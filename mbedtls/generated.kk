// Copyright (c) 2020, the Koka-Community authors. All rights reserved. 
// Use of this source code is governed by a
// MIT-style license that can be found in the LICENSE file.

// AUTO GENERATED FILE, DO NOT EDIT.
// 
// Generated by `ffigen`.

import std/core/cextern
import std/num/int32
import std/num/int64
import std/num/float64

extern import
  c { vcpkg="mbedtls" }

// \brief       PEM context setup
// 
// \param ctx   context to be initialized
pub extern external/mbedtls-pem-init(^ctx1: c-pointer<mbedtls-pem-context-c>): ()
  c inline "(void)mbedtls_pem_init((struct mbedtls_pem_context*)#1)"

// \brief       Read a buffer for PEM information and store the resulting
// data into the specified context buffers.
// 
// \param ctx       context to use
// \param header    header string to seek and expect
// \param footer    footer string to seek and expect
// \param data      source data to look in (must be nul-terminated)
// \param pwd       password for decryption (can be NULL)
// \param pwdlen    length of password
// \param use_len   destination for total length used from data buffer. It is
// set after header is correctly read, so unless you get
// MBEDTLS_ERR_PEM_BAD_INPUT_DATA or
// MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT, use_len is
// the length to skip.
// 
// \note            Attempts to check password correctness by verifying if
// the decrypted text starts with an ASN.1 sequence of
// appropriate length
// 
// \note            \c mbedtls_pem_free must be called on PEM context before
// the PEM context can be reused in another call to
// \c mbedtls_pem_read_buffer
// 
// \return          0 on success, or a specific PEM error code
pub extern external/mbedtls-pem-read-buffer(^ctx1: c-pointer<mbedtls-pem-context-c>, ^header: c-pointer<int>, ^footer: c-pointer<int>, ^data: c-pointer<int>, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^use-len: c-pointer<int>): int32
  c inline "(int)mbedtls_pem_read_buffer((struct mbedtls_pem_context*)#1, (char*)#2, (char*)#3, (unsigned char*)#4, (unsigned char*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/mbedtls-pem-read-buffer(^ctx1: c-pointer<mbedtls-pem-context-c>, ^header: c-pointer<int>, ^footer: c-pointer<int>, ^data: c-pointer<int>, ^pwd: c-pointer<int>, ^pwdlen: int, ^use-len: c-pointer<int>): <> int
  external/mbedtls-pem-read-buffer(ctx1, header, footer, data, pwd, pwdlen.ssize_t, use-len).int

// \brief       PEM context memory freeing
// 
// \param ctx   context to be freed
pub extern external/mbedtls-pem-free(^ctx1: c-pointer<mbedtls-pem-context-c>): ()
  c inline "(void)mbedtls_pem_free((struct mbedtls_pem_context*)#1)"

// \brief           Write a buffer of PEM information from a DER encoded
// buffer.
// 
// \param header    The header string to write.
// \param footer    The footer string to write.
// \param der_data  The DER data to encode.
// \param der_len   The length of the DER data \p der_data in Bytes.
// \param buf       The buffer to write to.
// \param buf_len   The length of the output buffer \p buf in Bytes.
// \param olen      The address at which to store the total length written
// or required (if \p buf_len is not enough).
// 
// \note            You may pass \c NULL for \p buf and \c 0 for \p buf_len
// to request the length of the resulting PEM buffer in
// `*olen`.
// 
// \note            This function may be called with overlapping \p der_data
// and \p buf buffers.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL if \p buf isn't large
// enough to hold the PEM buffer. In  this case, `*olen` holds
// the required minimum size of \p buf.
// \return          Another PEM or BASE64 error code on other kinds of failure.
pub extern external/mbedtls-pem-write-buffer(^header: c-pointer<int>, ^footer: c-pointer<int>, ^der-data: c-pointer<int>, ^der-len: ssize_t, ^buf: c-pointer<int>, ^buf-len: ssize_t, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_pem_write_buffer((char*)#1, (char*)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/mbedtls-pem-write-buffer(^header: c-pointer<int>, ^footer: c-pointer<int>, ^der-data: c-pointer<int>, ^der-len: int, ^buf: c-pointer<int>, ^buf-len: int, ^olen: c-pointer<int>): <> int
  external/mbedtls-pem-write-buffer(header, footer, der-data, der-len.ssize_t, buf, buf-len.ssize_t, olen).int

// \brief Translate an Mbed TLS error code into a string representation.
// The result is truncated if necessary and always includes a
// terminating null byte.
// 
// \param errnum    error code
// \param buffer    buffer to place representation in
// \param buflen    length of the buffer
pub extern external/mbedtls-strerror(^errnum: int32, ^buffer: c-pointer<int>, ^buflen: ssize_t): ()
  c inline "(void)mbedtls_strerror((int)#1, (char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-strerror(^errnum: int, ^buffer: c-pointer<int>, ^buflen: int): <> ()
  external/mbedtls-strerror(errnum.int32, buffer, buflen.ssize_t)

// \brief Translate the high-level part of an Mbed TLS error code into a string
// representation.
// 
// This function returns a const pointer to an un-modifiable string. The caller
// must not try to modify the string. It is intended to be used mostly for
// logging purposes.
// 
// \param error_code    error code
// 
// \return The string representation of the error code, or \c NULL if the error
// code is unknown.
pub extern external/mbedtls-high-level-strerr(^error-code: int32): c-pointer<int>
  c inline "(intptr_t)mbedtls_high_level_strerr((int)#1)"

pub inline fun ffi/mbedtls-high-level-strerr(^error-code: int): <> c-pointer<int>
  external/mbedtls-high-level-strerr(error-code.int32)

// \brief Translate the low-level part of an Mbed TLS error code into a string
// representation.
// 
// This function returns a const pointer to an un-modifiable string. The caller
// must not try to modify the string. It is intended to be used mostly for
// logging purposes.
// 
// \param error_code    error code
// 
// \return The string representation of the error code, or \c NULL if the error
// code is unknown.
pub extern external/mbedtls-low-level-strerr(^error-code: int32): c-pointer<int>
  c inline "(intptr_t)mbedtls_low_level_strerr((int)#1)"

pub inline fun ffi/mbedtls-low-level-strerr(^error-code: int): <> c-pointer<int>
  external/mbedtls-low-level-strerr(error-code.int32)

// \brief   Get time in milliseconds.
// 
// \return Monotonically-increasing current time in milliseconds.
// 
// \note Define MBEDTLS_PLATFORM_MS_TIME_ALT to be able to provide an
// alternative implementation
// 
// \warning This function returns a monotonically-increasing time value from a
// start time that will differ from platform to platform, and possibly
// from run to run of the process.
pub extern external/mbedtls-ms-time(): int64
  c inline "(mbedtls_ms_time_t)mbedtls_ms_time()"

pub inline fun ffi/mbedtls-ms-time(): <> int
  external/mbedtls-ms-time().int

// \brief       Securely zeroize a buffer
// 
// The function is meant to wipe the data contained in a buffer so
// that it can no longer be recovered even if the program memory
// is later compromised. Call this function on sensitive data
// stored on the stack before returning from a function, and on
// sensitive data stored on the heap before freeing the heap
// object.
// 
// It is extremely difficult to guarantee that calls to
// mbedtls_platform_zeroize() are not removed by aggressive
// compiler optimizations in a portable way. For this reason, Mbed
// TLS provides the configuration option
// MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure
// mbedtls_platform_zeroize() to use a suitable implementation for
// their platform and needs
// 
// \param buf   Buffer to be zeroized
// \param len   Length of the buffer in bytes
pub extern external/mbedtls-platform-zeroize(^buf: c-pointer<()>, ^len: ssize_t): ()
  c inline "(void)mbedtls_platform_zeroize((void*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-platform-zeroize(^buf: c-pointer<()>, ^len: int): <> ()
  external/mbedtls-platform-zeroize(buf, len.ssize_t)

// \brief      Platform-specific implementation of gmtime_r()
// 
// The function is a thread-safe abstraction that behaves
// similarly to the gmtime_r() function from Unix/POSIX.
// 
// Mbed TLS will try to identify the underlying platform and
// make use of an appropriate underlying implementation (e.g.
// gmtime_r() for POSIX and gmtime_s() for Windows). If this is
// not possible, then gmtime() will be used. In this case, calls
// from the library to gmtime() will be guarded by the mutex
// mbedtls_threading_gmtime_mutex if MBEDTLS_THREADING_C is
// enabled. It is recommended that calls from outside the library
// are also guarded by this mutex.
// 
// If MBEDTLS_PLATFORM_GMTIME_R_ALT is defined, then Mbed TLS will
// unconditionally use the alternative implementation for
// mbedtls_platform_gmtime_r() supplied by the user at compile time.
// 
// \param tt     Pointer to an object containing time (in seconds) since the
// epoch to be converted
// \param tm_buf Pointer to an object where the results will be stored
// 
// \return      Pointer to an object of type struct tm on success, otherwise
// NULL
pub extern external/mbedtls-platform-gmtime-r(^tt: c-pointer<int>, ^tm-buf: c-pointer<tm-c>): c-pointer<tm-c>
  c inline "(intptr_t)mbedtls_platform_gmtime_r((mbedtls_time_t*)#1, (struct tm*)#2)"

// \brief           Initialize an MPI context.
// 
// This makes the MPI ready to be set or freed,
// but does not define a value for the MPI.
// 
// \param X         The MPI context to initialize. This must not be \c NULL.
pub extern external/mbedtls-mpi-init(^x: c-pointer<mbedtls-mpi-c>): ()
  c inline "(void)mbedtls_mpi_init((struct mbedtls_mpi*)#1)"

// \brief          This function frees the components of an MPI context.
// 
// \param X        The MPI context to be cleared. This may be \c NULL,
// in which case this function is a no-op. If it is
// not \c NULL, it must point to an initialized MPI.
pub extern external/mbedtls-mpi-free(^x: c-pointer<mbedtls-mpi-c>): ()
  c inline "(void)mbedtls_mpi_free((struct mbedtls_mpi*)#1)"

// \brief          Enlarge an MPI to the specified number of limbs.
// 
// \note           This function does nothing if the MPI is
// already large enough.
// 
// \param X        The MPI to grow. It must be initialized.
// \param nblimbs  The target number of limbs.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-grow(^x: c-pointer<mbedtls-mpi-c>, ^nblimbs: ssize_t): int32
  c inline "(int)mbedtls_mpi_grow((struct mbedtls_mpi*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-mpi-grow(^x: c-pointer<mbedtls-mpi-c>, ^nblimbs: int): <> int
  external/mbedtls-mpi-grow(x, nblimbs.ssize_t).int

// \brief          This function resizes an MPI downwards, keeping at least the
// specified number of limbs.
// 
// If \c X is smaller than \c nblimbs, it is resized up
// instead.
// 
// \param X        The MPI to shrink. This must point to an initialized MPI.
// \param nblimbs  The minimum number of limbs to keep.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed
// (this can only happen when resizing up).
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-shrink(^x: c-pointer<mbedtls-mpi-c>, ^nblimbs: ssize_t): int32
  c inline "(int)mbedtls_mpi_shrink((struct mbedtls_mpi*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-mpi-shrink(^x: c-pointer<mbedtls-mpi-c>, ^nblimbs: int): <> int
  external/mbedtls-mpi-shrink(x, nblimbs.ssize_t).int

// \brief          Make a copy of an MPI.
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param Y        The source MPI. This must point to an initialized MPI.
// 
// \note           The limb-buffer in the destination MPI is enlarged
// if necessary to hold the value in the source MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-copy(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_copy((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2)"

pub inline fun ffi/mbedtls-mpi-copy(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-copy(x, y).int

// \brief          Swap the contents of two MPIs.
// 
// \param X        The first MPI. It must be initialized.
// \param Y        The second MPI. It must be initialized.
pub extern external/mbedtls-mpi-swap(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): ()
  c inline "(void)mbedtls_mpi_swap((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2)"

// \brief          Perform a safe conditional copy of MPI which doesn't
// reveal whether the condition was true or not.
// 
// \param X        The MPI to conditionally assign to. This must point
// to an initialized MPI.
// \param Y        The MPI to be assigned from. This must point to an
// initialized MPI.
// \param assign   The condition deciding whether to perform the
// assignment or not. Must be either 0 or 1:
// * \c 1: Perform the assignment `X = Y`.
// * \c 0: Keep the original value of \p X.
// 
// \note           This function is equivalent to
// `if( assign ) mbedtls_mpi_copy( X, Y );`
// except that it avoids leaking any information about whether
// the assignment was done or not (the above code may leak
// information through branch prediction and/or memory access
// patterns analysis).
// 
// \warning        If \p assign is neither 0 nor 1, the result of this function
// is indeterminate, and the resulting value in \p X might be
// neither its original value nor the value in \p Y.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-safe-cond-assign(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>, ^assign: int8): int32
  c inline "(int)mbedtls_mpi_safe_cond_assign((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (unsigned char)#3)"

pub inline fun ffi/mbedtls-mpi-safe-cond-assign(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>, ^assign: int): <> int
  external/mbedtls-mpi-safe-cond-assign(x, y, assign.int8).int

// \brief          Perform a safe conditional swap which doesn't
// reveal whether the condition was true or not.
// 
// \param X        The first MPI. This must be initialized.
// \param Y        The second MPI. This must be initialized.
// \param swap     The condition deciding whether to perform
// the swap or not. Must be either 0 or 1:
// * \c 1: Swap the values of \p X and \p Y.
// * \c 0: Keep the original values of \p X and \p Y.
// 
// \note           This function is equivalent to
// if( swap ) mbedtls_mpi_swap( X, Y );
// except that it avoids leaking any information about whether
// the swap was done or not (the above code may leak
// information through branch prediction and/or memory access
// patterns analysis).
// 
// \warning        If \p swap is neither 0 nor 1, the result of this function
// is indeterminate, and both \p X and \p Y might end up with
// values different to either of the original ones.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-safe-cond-swap(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>, ^swap: int8): int32
  c inline "(int)mbedtls_mpi_safe_cond_swap((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (unsigned char)#3)"

pub inline fun ffi/mbedtls-mpi-safe-cond-swap(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>, ^swap: int): <> int
  external/mbedtls-mpi-safe-cond-swap(x, y, swap.int8).int

// \brief          Store integer value in MPI.
// 
// \param X        The MPI to set. This must be initialized.
// \param z        The value to use.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-lset(^x: c-pointer<mbedtls-mpi-c>, ^z: int64): int32
  c inline "(int)mbedtls_mpi_lset((struct mbedtls_mpi*)#1, (mbedtls_mpi_sint)#2)"

pub inline fun ffi/mbedtls-mpi-lset(^x: c-pointer<mbedtls-mpi-c>, ^z: int): <> int
  external/mbedtls-mpi-lset(x, z.int64).int

// \brief          Get a specific bit from an MPI.
// 
// \param X        The MPI to query. This must be initialized.
// \param pos      Zero-based index of the bit to query.
// 
// \return         \c 0 or \c 1 on success, depending on whether bit \c pos
// of \c X is unset or set.
// \return         A negative error code on failure.
pub extern external/mbedtls-mpi-get-bit(^x: c-pointer<mbedtls-mpi-c>, ^pos: ssize_t): int32
  c inline "(int)mbedtls_mpi_get_bit((struct mbedtls_mpi*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-mpi-get-bit(^x: c-pointer<mbedtls-mpi-c>, ^pos: int): <> int
  external/mbedtls-mpi-get-bit(x, pos.ssize_t).int

// \brief          Modify a specific bit in an MPI.
// 
// \note           This function will grow the target MPI if necessary to set a
// bit to \c 1 in a not yet existing limb. It will not grow if
// the bit should be set to \c 0.
// 
// \param X        The MPI to modify. This must be initialized.
// \param pos      Zero-based index of the bit to modify.
// \param val      The desired value of bit \c pos: \c 0 or \c 1.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-set-bit(^x: c-pointer<mbedtls-mpi-c>, ^pos: ssize_t, ^val: int8): int32
  c inline "(int)mbedtls_mpi_set_bit((struct mbedtls_mpi*)#1, (size_t)#2, (unsigned char)#3)"

pub inline fun ffi/mbedtls-mpi-set-bit(^x: c-pointer<mbedtls-mpi-c>, ^pos: int, ^val: int): <> int
  external/mbedtls-mpi-set-bit(x, pos.ssize_t, val.int8).int

// \brief          Return the number of bits of value \c 0 before the
// least significant bit of value \c 1.
// 
// \note           This is the same as the zero-based index of
// the least significant bit of value \c 1.
// 
// \param X        The MPI to query.
// 
// \return         The number of bits of value \c 0 before the least significant
// bit of value \c 1 in \p X.
pub extern external/mbedtls-mpi-lsb(^x: c-pointer<mbedtls-mpi-c>): ssize_t
  c inline "(size_t)mbedtls_mpi_lsb((struct mbedtls_mpi*)#1)"

pub inline fun ffi/mbedtls-mpi-lsb(^x: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-lsb(x).int

// \brief          Return the number of bits up to and including the most
// significant bit of value \c 1.
// 
// * \note         This is same as the one-based index of the most
// significant bit of value \c 1.
// 
// \param X        The MPI to query. This must point to an initialized MPI.
// 
// \return         The number of bits up to and including the most
// significant bit of value \c 1.
pub extern external/mbedtls-mpi-bitlen(^x: c-pointer<mbedtls-mpi-c>): ssize_t
  c inline "(size_t)mbedtls_mpi_bitlen((struct mbedtls_mpi*)#1)"

pub inline fun ffi/mbedtls-mpi-bitlen(^x: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-bitlen(x).int

// \brief          Return the total size of an MPI value in bytes.
// 
// \param X        The MPI to use. This must point to an initialized MPI.
// 
// \note           The value returned by this function may be less than
// the number of bytes used to store \p X internally.
// This happens if and only if there are trailing bytes
// of value zero.
// 
// \return         The least number of bytes capable of storing
// the absolute value of \p X.
pub extern external/mbedtls-mpi-size(^x: c-pointer<mbedtls-mpi-c>): ssize_t
  c inline "(size_t)mbedtls_mpi_size((struct mbedtls_mpi*)#1)"

pub inline fun ffi/mbedtls-mpi-size(^x: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-size(x).int

// \brief          Import an MPI from an ASCII string.
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param radix    The numeric base of the input string.
// \param s        Null-terminated string buffer.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-mpi-read-string(^x: c-pointer<mbedtls-mpi-c>, ^radix: int32, ^s: c-pointer<int>): int32
  c inline "(int)mbedtls_mpi_read_string((struct mbedtls_mpi*)#1, (int)#2, (char*)#3)"

pub inline fun ffi/mbedtls-mpi-read-string(^x: c-pointer<mbedtls-mpi-c>, ^radix: int, ^s: c-pointer<int>): <> int
  external/mbedtls-mpi-read-string(x, radix.int32, s).int

// \brief          Export an MPI to an ASCII string.
// 
// \param X        The source MPI. This must point to an initialized MPI.
// \param radix    The numeric base of the output string.
// \param buf      The buffer to write the string to. This must be writable
// buffer of length \p buflen Bytes.
// \param buflen   The available size in Bytes of \p buf.
// \param olen     The address at which to store the length of the string
// written, including the  final \c NULL byte. This must
// not be \c NULL.
// 
// \note           You can call this function with `buflen == 0` to obtain the
// minimum required buffer size in `*olen`.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \p buf
// is too small to hold the value of \p X in the desired base.
// In this case, `*olen` is nonetheless updated to contain the
// size of \p buf required for a successful call.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-write-string(^x: c-pointer<mbedtls-mpi-c>, ^radix: int32, ^buf: c-pointer<int>, ^buflen: ssize_t, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_mpi_write_string((struct mbedtls_mpi*)#1, (int)#2, (char*)#3, (size_t)#4, (size_t*)#5)"

pub inline fun ffi/mbedtls-mpi-write-string(^x: c-pointer<mbedtls-mpi-c>, ^radix: int, ^buf: c-pointer<int>, ^buflen: int, ^olen: c-pointer<int>): <> int
  external/mbedtls-mpi-write-string(x, radix.int32, buf, buflen.ssize_t, olen).int

// \brief          Read an MPI from a line in an opened file.
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param radix    The numeric base of the string representation used
// in the source line.
// \param fin      The input file handle to use. This must not be \c NULL.
// 
// \note           On success, this function advances the file stream
// to the end of the current line or to EOF.
// 
// The function returns \c 0 on an empty line.
// 
// Leading whitespaces are ignored, as is a
// '0x' prefix for radix \c 16.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the file read buffer
// is too small.
// \return         Another negative error code on failure.
pub extern external/mbedtls-mpi-read-file(^x: c-pointer<mbedtls-mpi-c>, ^radix: int32, ^fin: c-pointer<--sfile-c>): int32
  c inline "(int)mbedtls_mpi_read_file((struct mbedtls_mpi*)#1, (int)#2, (FILE*)#3)"

pub inline fun ffi/mbedtls-mpi-read-file(^x: c-pointer<mbedtls-mpi-c>, ^radix: int, ^fin: c-pointer<--sfile-c>): <> int
  external/mbedtls-mpi-read-file(x, radix.int32, fin).int

// \brief          Export an MPI into an opened file.
// 
// \param p        A string prefix to emit prior to the MPI data.
// For example, this might be a label, or "0x" when
// printing in base \c 16. This may be \c NULL if no prefix
// is needed.
// \param X        The source MPI. This must point to an initialized MPI.
// \param radix    The numeric base to be used in the emitted string.
// \param fout     The output file handle. This may be \c NULL, in which case
// the output is written to \c stdout.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-mpi-write-file(^p: c-pointer<int>, ^x: c-pointer<mbedtls-mpi-c>, ^radix: int32, ^fout: c-pointer<--sfile-c>): int32
  c inline "(int)mbedtls_mpi_write_file((char*)#1, (struct mbedtls_mpi*)#2, (int)#3, (FILE*)#4)"

pub inline fun ffi/mbedtls-mpi-write-file(^p: c-pointer<int>, ^x: c-pointer<mbedtls-mpi-c>, ^radix: int, ^fout: c-pointer<--sfile-c>): <> int
  external/mbedtls-mpi-write-file(p, x, radix.int32, fout).int

// \brief          Import an MPI from unsigned big endian binary data.
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param buf      The input buffer. This must be a readable buffer of length
// \p buflen Bytes.
// \param buflen   The length of the input buffer \p buf in Bytes.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-read-binary(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_mpi_read_binary((struct mbedtls_mpi*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-mpi-read-binary(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-mpi-read-binary(x, buf, buflen.ssize_t).int

// \brief          Import X from unsigned binary data, little endian
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param buf      The input buffer. This must be a readable buffer of length
// \p buflen Bytes.
// \param buflen   The length of the input buffer \p buf in Bytes.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-read-binary-le(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_mpi_read_binary_le((struct mbedtls_mpi*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-mpi-read-binary-le(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-mpi-read-binary-le(x, buf, buflen.ssize_t).int

// \brief          Export X into unsigned binary data, big endian.
// Always fills the whole buffer, which will start with zeros
// if the number is smaller.
// 
// \param X        The source MPI. This must point to an initialized MPI.
// \param buf      The output buffer. This must be a writable buffer of length
// \p buflen Bytes.
// \param buflen   The size of the output buffer \p buf in Bytes.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \p buf isn't
// large enough to hold the value of \p X.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-write-binary(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_mpi_write_binary((struct mbedtls_mpi*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-mpi-write-binary(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-mpi-write-binary(x, buf, buflen.ssize_t).int

// \brief          Export X into unsigned binary data, little endian.
// Always fills the whole buffer, which will end with zeros
// if the number is smaller.
// 
// \param X        The source MPI. This must point to an initialized MPI.
// \param buf      The output buffer. This must be a writable buffer of length
// \p buflen Bytes.
// \param buflen   The size of the output buffer \p buf in Bytes.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \p buf isn't
// large enough to hold the value of \p X.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-write-binary-le(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_mpi_write_binary_le((struct mbedtls_mpi*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-mpi-write-binary-le(^x: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-mpi-write-binary-le(x, buf, buflen.ssize_t).int

// \brief          Perform a left-shift on an MPI: X <<= count
// 
// \param X        The MPI to shift. This must point to an initialized MPI.
// The MPI pointed by \p X may be resized to fit
// the resulting number.
// \param count    The number of bits to shift by.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-shift-l(^x: c-pointer<mbedtls-mpi-c>, ^count: ssize_t): int32
  c inline "(int)mbedtls_mpi_shift_l((struct mbedtls_mpi*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-mpi-shift-l(^x: c-pointer<mbedtls-mpi-c>, ^count: int): <> int
  external/mbedtls-mpi-shift-l(x, count.ssize_t).int

// \brief          Perform a right-shift on an MPI: X >>= count
// 
// \param X        The MPI to shift. This must point to an initialized MPI.
// \param count    The number of bits to shift by.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-shift-r(^x: c-pointer<mbedtls-mpi-c>, ^count: ssize_t): int32
  c inline "(int)mbedtls_mpi_shift_r((struct mbedtls_mpi*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-mpi-shift-r(^x: c-pointer<mbedtls-mpi-c>, ^count: int): <> int
  external/mbedtls-mpi-shift-r(x, count.ssize_t).int

// \brief          Compare the absolute values of two MPIs.
// 
// \param X        The left-hand MPI. This must point to an initialized MPI.
// \param Y        The right-hand MPI. This must point to an initialized MPI.
// 
// \return         \c 1 if `|X|` is greater than `|Y|`.
// \return         \c -1 if `|X|` is lesser than `|Y|`.
// \return         \c 0 if `|X|` is equal to `|Y|`.
pub extern external/mbedtls-mpi-cmp-abs(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_cmp_abs((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2)"

pub inline fun ffi/mbedtls-mpi-cmp-abs(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-cmp-abs(x, y).int

// \brief          Compare two MPIs.
// 
// \param X        The left-hand MPI. This must point to an initialized MPI.
// \param Y        The right-hand MPI. This must point to an initialized MPI.
// 
// \return         \c 1 if \p X is greater than \p Y.
// \return         \c -1 if \p X is lesser than \p Y.
// \return         \c 0 if \p X is equal to \p Y.
pub extern external/mbedtls-mpi-cmp-mpi(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_cmp_mpi((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2)"

pub inline fun ffi/mbedtls-mpi-cmp-mpi(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-cmp-mpi(x, y).int

// \brief          Check if an MPI is less than the other in constant time.
// 
// \param X        The left-hand MPI. This must point to an initialized MPI
// with the same allocated length as Y.
// \param Y        The right-hand MPI. This must point to an initialized MPI
// with the same allocated length as X.
// \param ret      The result of the comparison:
// \c 1 if \p X is less than \p Y.
// \c 0 if \p X is greater than or equal to \p Y.
// 
// \return         0 on success.
// \return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of
// the two input MPIs is not the same.
pub extern external/mbedtls-mpi-lt-mpi-ct(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>, ^ret: c-pointer<int>): int32
  c inline "(int)mbedtls_mpi_lt_mpi_ct((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (unsigned int*)#3)"

pub inline fun ffi/mbedtls-mpi-lt-mpi-ct(^x: c-pointer<mbedtls-mpi-c>, ^y: c-pointer<mbedtls-mpi-c>, ^ret: c-pointer<int>): <> int
  external/mbedtls-mpi-lt-mpi-ct(x, y, ret).int

// \brief          Compare an MPI with an integer.
// 
// \param X        The left-hand MPI. This must point to an initialized MPI.
// \param z        The integer value to compare \p X to.
// 
// \return         \c 1 if \p X is greater than \p z.
// \return         \c -1 if \p X is lesser than \p z.
// \return         \c 0 if \p X is equal to \p z.
pub extern external/mbedtls-mpi-cmp-int(^x: c-pointer<mbedtls-mpi-c>, ^z: int64): int32
  c inline "(int)mbedtls_mpi_cmp_int((struct mbedtls_mpi*)#1, (mbedtls_mpi_sint)#2)"

pub inline fun ffi/mbedtls-mpi-cmp-int(^x: c-pointer<mbedtls-mpi-c>, ^z: int): <> int
  external/mbedtls-mpi-cmp-int(x, z.int64).int

// \brief          Perform an unsigned addition of MPIs: X = |A| + |B|
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The first summand. This must point to an initialized MPI.
// \param B        The second summand. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-add-abs(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_add_abs((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-add-abs(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-add-abs(x, a, b).int

// \brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The minuend. This must point to an initialized MPI.
// \param B        The subtrahend. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \p B is greater than \p A.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-sub-abs(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_sub_abs((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-sub-abs(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-sub-abs(x, a, b).int

// \brief          Perform a signed addition of MPIs: X = A + B
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The first summand. This must point to an initialized MPI.
// \param B        The second summand. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-add-mpi(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_add_mpi((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-add-mpi(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-add-mpi(x, a, b).int

// \brief          Perform a signed subtraction of MPIs: X = A - B
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The minuend. This must point to an initialized MPI.
// \param B        The subtrahend. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-sub-mpi(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_sub_mpi((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-sub-mpi(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-sub-mpi(x, a, b).int

// \brief          Perform a signed addition of an MPI and an integer: X = A + b
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The first summand. This must point to an initialized MPI.
// \param b        The second summand.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-add-int(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int64): int32
  c inline "(int)mbedtls_mpi_add_int((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (mbedtls_mpi_sint)#3)"

pub inline fun ffi/mbedtls-mpi-add-int(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int): <> int
  external/mbedtls-mpi-add-int(x, a, b.int64).int

// \brief          Perform a signed subtraction of an MPI and an integer:
// X = A - b
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The minuend. This must point to an initialized MPI.
// \param b        The subtrahend.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-sub-int(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int64): int32
  c inline "(int)mbedtls_mpi_sub_int((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (mbedtls_mpi_sint)#3)"

pub inline fun ffi/mbedtls-mpi-sub-int(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int): <> int
  external/mbedtls-mpi-sub-int(x, a, b.int64).int

// \brief          Perform a multiplication of two MPIs: X = A * B
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The first factor. This must point to an initialized MPI.
// \param B        The second factor. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-mul-mpi(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_mul_mpi((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-mul-mpi(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-mul-mpi(x, a, b).int

// \brief          Perform a multiplication of an MPI with an unsigned integer:
// X = A * b
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The first factor. This must point to an initialized MPI.
// \param b        The second factor.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-mul-int(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int64): int32
  c inline "(int)mbedtls_mpi_mul_int((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (mbedtls_mpi_uint)#3)"

pub inline fun ffi/mbedtls-mpi-mul-int(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int): <> int
  external/mbedtls-mpi-mul-int(x, a, b.int64).int

// \brief          Perform a division with remainder of two MPIs:
// A = Q * B + R
// 
// \param Q        The destination MPI for the quotient.
// This may be \c NULL if the value of the
// quotient is not needed. This must not alias A or B.
// \param R        The destination MPI for the remainder value.
// This may be \c NULL if the value of the
// remainder is not needed. This must not alias A or B.
// \param A        The dividend. This must point to an initialized MPI.
// \param B        The divisor. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p B equals zero.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-div-mpi(^q: c-pointer<mbedtls-mpi-c>, ^r: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_div_mpi((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4)"

pub inline fun ffi/mbedtls-mpi-div-mpi(^q: c-pointer<mbedtls-mpi-c>, ^r: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-div-mpi(q, r, a, b).int

// \brief          Perform a division with remainder of an MPI by an integer:
// A = Q * b + R
// 
// \param Q        The destination MPI for the quotient.
// This may be \c NULL if the value of the
// quotient is not needed.  This must not alias A.
// \param R        The destination MPI for the remainder value.
// This may be \c NULL if the value of the
// remainder is not needed.  This must not alias A.
// \param A        The dividend. This must point to an initialized MPi.
// \param b        The divisor.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p b equals zero.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-div-int(^q: c-pointer<mbedtls-mpi-c>, ^r: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int64): int32
  c inline "(int)mbedtls_mpi_div_int((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (mbedtls_mpi_sint)#4)"

pub inline fun ffi/mbedtls-mpi-div-int(^q: c-pointer<mbedtls-mpi-c>, ^r: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int): <> int
  external/mbedtls-mpi-div-int(q, r, a, b.int64).int

// \brief          Perform a modular reduction. R = A mod B
// 
// \param R        The destination MPI for the residue value.
// This must point to an initialized MPI.
// \param A        The MPI to compute the residue of.
// This must point to an initialized MPI.
// \param B        The base of the modular reduction.
// This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p B equals zero.
// \return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \p B is negative.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-mod-mpi(^r: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_mod_mpi((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-mod-mpi(^r: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-mod-mpi(r, a, b).int

// \brief          Perform a modular reduction with respect to an integer.
// r = A mod b
// 
// \param r        The address at which to store the residue.
// This must not be \c NULL.
// \param A        The MPI to compute the residue of.
// This must point to an initialized MPi.
// \param b        The integer base of the modular reduction.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \p b equals zero.
// \return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \p b is negative.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-mod-int(^r: c-pointer<int>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int64): int32
  c inline "(int)mbedtls_mpi_mod_int((mbedtls_mpi_uint*)#1, (struct mbedtls_mpi*)#2, (mbedtls_mpi_sint)#3)"

pub inline fun ffi/mbedtls-mpi-mod-int(^r: c-pointer<int>, ^a: c-pointer<mbedtls-mpi-c>, ^b: int): <> int
  external/mbedtls-mpi-mod-int(r, a, b.int64).int

// \brief          Perform a sliding-window exponentiation: X = A^E mod N
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// This must not alias E or N.
// \param A        The base of the exponentiation.
// This must point to an initialized MPI.
// \param E        The exponent MPI. This must point to an initialized MPI.
// \param N        The base for the modular reduction. This must point to an
// initialized MPI.
// \param prec_RR  A helper MPI depending solely on \p N which can be used to
// speed-up multiple modular exponentiations for the same value
// of \p N. This may be \c NULL. If it is not \c NULL, it must
// point to an initialized MPI. If it hasn't been used after
// the call to mbedtls_mpi_init(), this function will compute
// the helper value and store it in \p prec_RR for reuse on
// subsequent calls to this function. Otherwise, the function
// will assume that \p prec_RR holds the helper value set by a
// previous call to mbedtls_mpi_exp_mod(), and reuse it.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \c N is negative or
// even, or if \c E is negative.
// \return         Another negative error code on different kinds of failures.
pub extern external/mbedtls-mpi-exp-mod(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^e: c-pointer<mbedtls-mpi-c>, ^n: c-pointer<mbedtls-mpi-c>, ^prec-rr: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_exp_mod((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (struct mbedtls_mpi*)#5)"

pub inline fun ffi/mbedtls-mpi-exp-mod(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^e: c-pointer<mbedtls-mpi-c>, ^n: c-pointer<mbedtls-mpi-c>, ^prec-rr: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-exp-mod(x, a, e, n, prec-rr).int

// \brief          Fill an MPI with a number of random bytes.
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param size     The number of random bytes to generate.
// \param f_rng    The RNG function to use. This must not be \c NULL.
// \param p_rng    The RNG parameter to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context argument.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on failure.
// 
// \note           The bytes obtained from the RNG are interpreted
// as a big-endian representation of an MPI; this can
// be relevant in applications like deterministic ECDSA.
pub extern external/mbedtls-mpi-fill-random(^x: c-pointer<mbedtls-mpi-c>, ^size: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_mpi_fill_random((struct mbedtls_mpi*)#1, (size_t)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-mpi-fill-random(^x: c-pointer<mbedtls-mpi-c>, ^size: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-mpi-fill-random(x, size.ssize_t, f-rng, p-rng).int

// Generate a random number uniformly in a range.
// 
// This function generates a random number between \p min inclusive and
// \p N exclusive.
// 
// The procedure complies with RFC 6979 ยง3.3 (deterministic ECDSA)
// when the RNG is a suitably parametrized instance of HMAC_DRBG
// and \p min is \c 1.
// 
// \note           There are `N - min` possible outputs. The lower bound
// \p min can be reached, but the upper bound \p N cannot.
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param min      The minimum value to return.
// It must be nonnegative.
// \param N        The upper bound of the range, exclusive.
// In other words, this is one plus the maximum value to return.
// \p N must be strictly larger than \p min.
// \param f_rng    The RNG function to use. This must not be \c NULL.
// \param p_rng    The RNG parameter to be passed to \p f_rng.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \p min or \p N is invalid
// or if they are incompatible.
// \return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if the implementation was
// unable to find a suitable value within a limited number
// of attempts. This has a negligible probability if \p N
// is significantly larger than \p min, which is the case
// for all usual cryptographic applications.
// \return         Another negative error code on failure.
pub extern external/mbedtls-mpi-random(^x: c-pointer<mbedtls-mpi-c>, ^min: int64, ^n: c-pointer<mbedtls-mpi-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_mpi_random((struct mbedtls_mpi*)#1, (mbedtls_mpi_sint)#2, (struct mbedtls_mpi*)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-mpi-random(^x: c-pointer<mbedtls-mpi-c>, ^min: int, ^n: c-pointer<mbedtls-mpi-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-mpi-random(x, min.int64, n, f-rng, p-rng).int

// \brief          Compute the greatest common divisor: G = gcd(A, B)
// 
// \param G        The destination MPI. This must point to an initialized MPI.
// \param A        The first operand. This must point to an initialized MPI.
// \param B        The second operand. This must point to an initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         Another negative error code on different kinds of failure.
pub extern external/mbedtls-mpi-gcd(^g: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_gcd((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-gcd(^g: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^b: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-gcd(g, a, b).int

// \brief          Compute the modular inverse: X = A^-1 mod N
// 
// \param X        The destination MPI. This must point to an initialized MPI.
// \param A        The MPI to calculate the modular inverse of. This must point
// to an initialized MPI.
// \param N        The base of the modular inversion. This must point to an
// initialized MPI.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \p N is less than
// or equal to one.
// \return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \p A has no modular
// inverse with respect to \p N.
pub extern external/mbedtls-mpi-inv-mod(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^n: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_mpi_inv_mod((struct mbedtls_mpi*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-mpi-inv-mod(^x: c-pointer<mbedtls-mpi-c>, ^a: c-pointer<mbedtls-mpi-c>, ^n: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-mpi-inv-mod(x, a, n).int

// \brief          Miller-Rabin primality test.
// 
// \warning        If \p X is potentially generated by an adversary, for example
// when validating cryptographic parameters that you didn't
// generate yourself and that are supposed to be prime, then
// \p rounds should be at least the half of the security
// strength of the cryptographic algorithm. On the other hand,
// if \p X is chosen uniformly or non-adversarially (as is the
// case when mbedtls_mpi_gen_prime calls this function), then
// \p rounds can be much lower.
// 
// \param X        The MPI to check for primality.
// This must point to an initialized MPI.
// \param rounds   The number of bases to perform the Miller-Rabin primality
// test for. The probability of returning 0 on a composite is
// at most 2<sup>-2*\p rounds </sup>.
// \param f_rng    The RNG function to use. This must not be \c NULL.
// \param p_rng    The RNG parameter to be passed to \p f_rng.
// This may be \c NULL if \p f_rng doesn't use
// a context parameter.
// 
// \return         \c 0 if successful, i.e. \p X is probably prime.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \p X is not prime.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-mpi-is-prime-ext(^x: c-pointer<mbedtls-mpi-c>, ^rounds: int32, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_mpi_is_prime_ext((struct mbedtls_mpi*)#1, (int)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-mpi-is-prime-ext(^x: c-pointer<mbedtls-mpi-c>, ^rounds: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-mpi-is-prime-ext(x, rounds.int32, f-rng, p-rng).int

// \brief          Generate a prime number.
// 
// \param X        The destination MPI to store the generated prime in.
// This must point to an initialized MPi.
// \param nbits    The required size of the destination MPI in bits.
// This must be between \c 3 and #MBEDTLS_MPI_MAX_BITS.
// \param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t.
// \param f_rng    The RNG function to use. This must not be \c NULL.
// \param p_rng    The RNG parameter to be passed to \p f_rng.
// This may be \c NULL if \p f_rng doesn't use
// a context parameter.
// 
// \return         \c 0 if successful, in which case \p X holds a
// probably prime number.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.
// \return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between
// \c 3 and #MBEDTLS_MPI_MAX_BITS.
pub extern external/mbedtls-mpi-gen-prime(^x: c-pointer<mbedtls-mpi-c>, ^nbits: ssize_t, ^flags: int32, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_mpi_gen_prime((struct mbedtls_mpi*)#1, (size_t)#2, (int)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-mpi-gen-prime(^x: c-pointer<mbedtls-mpi-c>, ^nbits: int, ^flags: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-mpi-gen-prime(x, nbits.ssize_t, flags.int32, f-rng, p-rng).int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
pub extern external/mbedtls-mpi-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_mpi_self_test((int)#1)"

pub inline fun ffi/mbedtls-mpi-self-test(^verbose: int): <> int
  external/mbedtls-mpi-self-test(verbose.int32).int

// \brief       Get the length of an ASN.1 element.
// Updates the pointer to immediately behind the length.
// 
// \param p     On entry, \c *p points to the first byte of the length,
// i.e. immediately after the tag.
// On successful completion, \c *p points to the first byte
// after the length, i.e. the first byte of the content.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param len   On successful completion, \c *len contains the length
// read from the ASN.1 input.
// 
// \return      0 if successful.
// \return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element
// would end beyond \p end.
// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable.
pub extern external/mbedtls-asn1-get-len(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^len: c-pointer<int>): int32
  c inline "(int)mbedtls_asn1_get_len((unsigned char**)#1, (unsigned char*)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-asn1-get-len(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^len: c-pointer<int>): <> int
  external/mbedtls-asn1-get-len(p, end, len).int

// \brief       Get the tag and length of the element.
// Check for the requested tag.
// Updates the pointer to immediately behind the tag and length.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// after the length, i.e. the first byte of the content.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param len   On successful completion, \c *len contains the length
// read from the ASN.1 input.
// \param tag   The expected tag.
// 
// \return      0 if successful.
// \return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start
// with the requested tag.
// \return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element
// would end beyond \p end.
// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable.
pub extern external/mbedtls-asn1-get-tag(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^len: c-pointer<int>, ^tag: int32): int32
  c inline "(int)mbedtls_asn1_get_tag((unsigned char**)#1, (unsigned char*)#2, (size_t*)#3, (int)#4)"

pub inline fun ffi/mbedtls-asn1-get-tag(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^len: c-pointer<int>, ^tag: int): <> int
  external/mbedtls-asn1-get-tag(p, end, len, tag.int32).int

// \brief       Retrieve a boolean ASN.1 tag and its value.
// Updates the pointer to immediately behind the full tag.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// beyond the ASN.1 element.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param val   On success, the parsed value (\c 0 or \c 1).
// 
// \return      0 if successful.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 BOOLEAN.
pub extern external/mbedtls-asn1-get-bool(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^val: c-pointer<int>): int32
  c inline "(int)mbedtls_asn1_get_bool((unsigned char**)#1, (unsigned char*)#2, (int*)#3)"

pub inline fun ffi/mbedtls-asn1-get-bool(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^val: c-pointer<int>): <> int
  external/mbedtls-asn1-get-bool(p, end, val).int

// \brief       Retrieve an integer ASN.1 tag and its value.
// Updates the pointer to immediately behind the full tag.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// beyond the ASN.1 element.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param val   On success, the parsed value.
// 
// \return      0 if successful.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 INTEGER.
// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does
// not fit in an \c int.
pub extern external/mbedtls-asn1-get-int(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^val: c-pointer<int>): int32
  c inline "(int)mbedtls_asn1_get_int((unsigned char**)#1, (unsigned char*)#2, (int*)#3)"

pub inline fun ffi/mbedtls-asn1-get-int(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^val: c-pointer<int>): <> int
  external/mbedtls-asn1-get-int(p, end, val).int

// \brief       Retrieve an enumerated ASN.1 tag and its value.
// Updates the pointer to immediately behind the full tag.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// beyond the ASN.1 element.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param val   On success, the parsed value.
// 
// \return      0 if successful.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 ENUMERATED.
// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does
// not fit in an \c int.
pub extern external/mbedtls-asn1-get-enum(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^val: c-pointer<int>): int32
  c inline "(int)mbedtls_asn1_get_enum((unsigned char**)#1, (unsigned char*)#2, (int*)#3)"

pub inline fun ffi/mbedtls-asn1-get-enum(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^val: c-pointer<int>): <> int
  external/mbedtls-asn1-get-enum(p, end, val).int

// \brief       Retrieve a bitstring ASN.1 tag and its value.
// Updates the pointer to immediately behind the full tag.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p is equal to \p end.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param bs    On success, ::mbedtls_asn1_bitstring information about
// the parsed value.
// 
// \return      0 if successful.
// \return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains
// extra data after a valid BIT STRING.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 BIT STRING.
pub extern external/mbedtls-asn1-get-bitstring(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^bs: c-pointer<mbedtls-asn1-bitstring-c>): int32
  c inline "(int)mbedtls_asn1_get_bitstring((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_asn1_bitstring*)#3)"

pub inline fun ffi/mbedtls-asn1-get-bitstring(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^bs: c-pointer<mbedtls-asn1-bitstring-c>): <> int
  external/mbedtls-asn1-get-bitstring(p, end, bs).int

// \brief       Retrieve a bitstring ASN.1 tag without unused bits and its
// value.
// Updates the pointer to the beginning of the bit/octet string.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// of the content of the BIT STRING.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param len   On success, \c *len is the length of the content in bytes.
// 
// \return      0 if successful.
// \return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with
// a valid BIT STRING with a nonzero number of unused bits.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 BIT STRING.
pub extern external/mbedtls-asn1-get-bitstring-null(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^len: c-pointer<int>): int32
  c inline "(int)mbedtls_asn1_get_bitstring_null((unsigned char**)#1, (unsigned char*)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-asn1-get-bitstring-null(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^len: c-pointer<int>): <> int
  external/mbedtls-asn1-get-bitstring-null(p, end, len).int

// \brief       Parses and splits an ASN.1 "SEQUENCE OF <tag>".
// Updates the pointer to immediately behind the full sequence tag.
// 
// This function allocates memory for the sequence elements. You can free
// the allocated memory with mbedtls_asn1_sequence_free().
// 
// \note        On error, this function may return a partial list in \p cur.
// You must set `cur->next = NULL` before calling this function!
// Otherwise it is impossible to distinguish a previously non-null
// pointer from a pointer to an object allocated by this function.
// 
// \note        If the sequence is empty, this function does not modify
// \c *cur. If the sequence is valid and non-empty, this
// function sets `cur->buf.tag` to \p tag. This allows
// callers to distinguish between an empty sequence and
// a one-element sequence.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p is equal to \p end.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param cur   A ::mbedtls_asn1_sequence which this function fills.
// When this function returns, \c *cur is the head of a linked
// list. Each node in this list is allocated with
// mbedtls_calloc() apart from \p cur itself, and should
// therefore be freed with mbedtls_free().
// The list describes the content of the sequence.
// The head of the list (i.e. \c *cur itself) describes the
// first element, `*cur->next` describes the second element, etc.
// For each element, `buf.tag == tag`, `buf.len` is the length
// of the content of the content of the element, and `buf.p`
// points to the first byte of the content (i.e. immediately
// past the length of the element).
// Note that list elements may be allocated even on error.
// \param tag   Each element of the sequence must have this tag.
// 
// \return      0 if successful.
// \return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains
// extra data after a valid SEQUENCE OF \p tag.
// \return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with
// an ASN.1 SEQUENCE in which an element has a tag that
// is different from \p tag.
// \return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 SEQUENCE.
pub extern external/mbedtls-asn1-get-sequence-of(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^cur: c-pointer<mbedtls-asn1-sequence-c>, ^tag: int32): int32
  c inline "(int)mbedtls_asn1_get_sequence_of((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_asn1_sequence*)#3, (int)#4)"

pub inline fun ffi/mbedtls-asn1-get-sequence-of(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^cur: c-pointer<mbedtls-asn1-sequence-c>, ^tag: int): <> int
  external/mbedtls-asn1-get-sequence-of(p, end, cur, tag.int32).int

// \brief          Free a heap-allocated linked list presentation of
// an ASN.1 sequence, including the first element.
// 
// There are two common ways to manage the memory used for the representation
// of a parsed ASN.1 sequence:
// - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc().
// Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of().
// When you have finished processing the sequence,
// call mbedtls_asn1_sequence_free() on `head`.
// - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,
// for example on the stack. Make sure that `head->next == NULL`.
// Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of().
// When you have finished processing the sequence,
// call mbedtls_asn1_sequence_free() on `head->cur`,
// then free `head` itself in the appropriate manner.
// 
// \param seq      The address of the first sequence component. This may
// be \c NULL, in which case this functions returns
// immediately.
pub extern external/mbedtls-asn1-sequence-free(^seq: c-pointer<mbedtls-asn1-sequence-c>): ()
  c inline "(void)mbedtls_asn1_sequence_free((struct mbedtls_asn1_sequence*)#1)"

// \brief                Traverse an ASN.1 SEQUENCE container and
// call a callback for each entry.
// 
// This function checks that the input is a SEQUENCE of elements that
// each have a "must" tag, and calls a callback function on the elements
// that have a "may" tag.
// 
// For example, to validate that the input is a SEQUENCE of `tag1` and call
// `cb` on each element, use
// ```
// mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);
// ```
// 
// To validate that the input is a SEQUENCE of ANY and call `cb` on
// each element, use
// ```
// mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);
// ```
// 
// To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}
// and call `cb` on each element that is an OCTET STRING, use
// ```
// mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);
// ```
// 
// The callback is called on the elements with a "may" tag from left to
// right. If the input is not a valid SEQUENCE of elements with a "must" tag,
// the callback is called on the elements up to the leftmost point where
// the input is invalid.
// 
// \warning              This function is still experimental and may change
// at any time.
// 
// \param p              The address of the pointer to the beginning of
// the ASN.1 SEQUENCE header. This is updated to
// point to the end of the ASN.1 SEQUENCE container
// on a successful invocation.
// \param end            The end of the ASN.1 SEQUENCE container.
// \param tag_must_mask  A mask to be applied to the ASN.1 tags found within
// the SEQUENCE before comparing to \p tag_must_val.
// \param tag_must_val   The required value of each ASN.1 tag found in the
// SEQUENCE, after masking with \p tag_must_mask.
// Mismatching tags lead to an error.
// For example, a value of \c 0 for both \p tag_must_mask
// and \p tag_must_val means that every tag is allowed,
// while a value of \c 0xFF for \p tag_must_mask means
// that \p tag_must_val is the only allowed tag.
// \param tag_may_mask   A mask to be applied to the ASN.1 tags found within
// the SEQUENCE before comparing to \p tag_may_val.
// \param tag_may_val    The desired value of each ASN.1 tag found in the
// SEQUENCE, after masking with \p tag_may_mask.
// Mismatching tags will be silently ignored.
// For example, a value of \c 0 for \p tag_may_mask and
// \p tag_may_val means that any tag will be considered,
// while a value of \c 0xFF for \p tag_may_mask means
// that all tags with value different from \p tag_may_val
// will be ignored.
// \param cb             The callback to trigger for each component
// in the ASN.1 SEQUENCE that matches \p tag_may_val.
// The callback function is called with the following
// parameters:
// - \p ctx.
// - The tag of the current element.
// - A pointer to the start of the current element's
// content inside the input.
// - The length of the content of the current element.
// If the callback returns a non-zero value,
// the function stops immediately,
// forwarding the callback's return value.
// \param ctx            The context to be passed to the callback \p cb.
// 
// \return               \c 0 if successful the entire ASN.1 SEQUENCE
// was traversed without parsing or callback errors.
// \return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input
// contains extra data after a valid SEQUENCE
// of elements with an accepted tag.
// \return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts
// with an ASN.1 SEQUENCE in which an element has a tag
// that is not accepted.
// \return               An ASN.1 error code if the input does not start with
// a valid ASN.1 SEQUENCE.
// \return               A non-zero error code forwarded from the callback
// \p cb in case the latter returns a non-zero value.
pub extern external/mbedtls-asn1-traverse-sequence-of(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^tag-must-mask: int8, ^tag-must-val: int8, ^tag-may-mask: int8, ^tag-may-val: int8, ^cb: c-pointer<intptr_t>, ^ctx1: c-pointer<()>): int32
  c inline "(int)mbedtls_asn1_traverse_sequence_of((unsigned char**)#1, (unsigned char*)#2, (unsigned char)#3, (unsigned char)#4, (unsigned char)#5, (unsigned char)#6, (int (*)(void*, int, unsigned char*, size_t))#7, (void*)#8)"

pub inline fun ffi/mbedtls-asn1-traverse-sequence-of(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^tag-must-mask: int, ^tag-must-val: int, ^tag-may-mask: int, ^tag-may-val: int, ^cb: c-pointer<intptr_t>, ^ctx1: c-pointer<()>): <> int
  external/mbedtls-asn1-traverse-sequence-of(p, end, tag-must-mask.int8, tag-must-val.int8, tag-may-mask.int8, tag-may-val.int8, cb, ctx1).int

// \brief       Retrieve an integer ASN.1 tag and its value.
// Updates the pointer to immediately behind the full tag.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// beyond the ASN.1 element.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param X     On success, the parsed value.
// 
// \return      0 if successful.
// \return      An ASN.1 error code if the input does not start with
// a valid ASN.1 INTEGER.
// \return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does
// not fit in an \c int.
// \return      An MPI error code if the parsed value is too large.
pub extern external/mbedtls-asn1-get-mpi(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^x: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_asn1_get_mpi((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-asn1-get-mpi(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^x: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-asn1-get-mpi(p, end, x).int

// \brief       Retrieve an AlgorithmIdentifier ASN.1 sequence.
// Updates the pointer to immediately behind the full
// AlgorithmIdentifier.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// beyond the AlgorithmIdentifier element.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param alg   The buffer to receive the OID.
// \param params The buffer to receive the parameters.
// This is zeroized if there are no parameters.
// 
// \return      0 if successful or a specific ASN.1 or MPI error code.
pub extern external/mbedtls-asn1-get-alg(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^alg: c-pointer<mbedtls-asn1-buf-c>, ^params: c-pointer<mbedtls-asn1-buf-c>): int32
  c inline "(int)mbedtls_asn1_get_alg((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_asn1_buf*)#3, (struct mbedtls_asn1_buf*)#4)"

pub inline fun ffi/mbedtls-asn1-get-alg(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^alg: c-pointer<mbedtls-asn1-buf-c>, ^params: c-pointer<mbedtls-asn1-buf-c>): <> int
  external/mbedtls-asn1-get-alg(p, end, alg, params).int

// \brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no
// params.
// Updates the pointer to immediately behind the full
// AlgorithmIdentifier.
// 
// \param p     On entry, \c *p points to the start of the ASN.1 element.
// On successful completion, \c *p points to the first byte
// beyond the AlgorithmIdentifier element.
// On error, the value of \c *p is undefined.
// \param end   End of data.
// \param alg   The buffer to receive the OID.
// 
// \return      0 if successful or a specific ASN.1 or MPI error code.
pub extern external/mbedtls-asn1-get-alg-null(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^alg: c-pointer<mbedtls-asn1-buf-c>): int32
  c inline "(int)mbedtls_asn1_get_alg_null((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_asn1_buf*)#3)"

pub inline fun ffi/mbedtls-asn1-get-alg-null(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^alg: c-pointer<mbedtls-asn1-buf-c>): <> int
  external/mbedtls-asn1-get-alg-null(p, end, alg).int

// \brief       Find a specific named_data entry in a sequence or list based on
// the OID.
// 
// \param list  The list to seek through
// \param oid   The OID to look for
// \param len   Size of the OID
// 
// \return      NULL if not found, or a pointer to the existing entry.
pub extern external/mbedtls-asn1-find-named-data(^list: c-pointer<mbedtls-asn1-named-data-c>, ^oid: c-pointer<int>, ^len: ssize_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)mbedtls_asn1_find_named_data((struct mbedtls_asn1_named_data*)#1, (char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-asn1-find-named-data(^list: c-pointer<mbedtls-asn1-named-data-c>, ^oid: c-pointer<int>, ^len: int): <> c-pointer<mbedtls-asn1-named-data-c>
  external/mbedtls-asn1-find-named-data(list, oid, len.ssize_t)

// \brief       Free a mbedtls_asn1_named_data entry
// 
// \deprecated  This function is deprecated and will be removed in a
// future version of the library.
// Please use mbedtls_asn1_free_named_data_list()
// or mbedtls_asn1_free_named_data_list_shallow().
// 
// \param entry The named data entry to free.
// This function calls mbedtls_free() on
// `entry->oid.p` and `entry->val.p`.
pub extern external/mbedtls-asn1-free-named-data(^entry: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "(void)mbedtls_asn1_free_named_data((struct mbedtls_asn1_named_data*)#1)"

// \brief       Free all entries in a mbedtls_asn1_named_data list.
// 
// \param head  Pointer to the head of the list of named data entries to free.
// This function calls mbedtls_free() on
// `entry->oid.p` and `entry->val.p` and then on `entry`
// for each list entry, and sets \c *head to \c NULL.
pub extern external/mbedtls-asn1-free-named-data-list(^head: c-pointer<c-pointer<mbedtls-asn1-named-data-c>>): ()
  c inline "(void)mbedtls_asn1_free_named_data_list((struct mbedtls_asn1_named_data**)#1)"

// \brief       Free all shallow entries in a mbedtls_asn1_named_data list,
// but do not free internal pointer targets.
// 
// \param name  Head of the list of named data entries to free.
// This function calls mbedtls_free() on each list element.
pub extern external/mbedtls-asn1-free-named-data-list-shallow(^name: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "(void)mbedtls_asn1_free_named_data_list_shallow((struct mbedtls_asn1_named_data*)#1)"

// \brief           This function returns the message-digest information
// associated with the given digest type.
// 
// \param md_type   The type of digest to search for.
// 
// \return          The message-digest information associated with \p md_type.
// \return          NULL if the associated message-digest information is not found.
pub extern external/mbedtls-md-info-from-type(^md-type: int32): c-pointer<mbedtls-md-info-t-c>
  c inline "(intptr_t)mbedtls_md_info_from_type((int32_t)#1)"

pub inline fun ffi/mbedtls-md-info-from-type(^md-type: mbedtls-md-type-t): <exn> c-pointer<mbedtls-md-info-t-c>
  external/mbedtls-md-info-from-type(md-type.mbedtls-md-type-t/int)

// \brief           This function initializes a message-digest context without
// binding it to a particular message-digest algorithm.
// 
// This function should always be called first. It prepares the
// context for mbedtls_md_setup() for binding it to a
// message-digest algorithm.
pub extern external/mbedtls-md-init(^ctx1: c-pointer<mbedtls-md-context-t-c>): ()
  c inline "(void)mbedtls_md_init((struct mbedtls_md_context_t*)#1)"

// \brief           This function clears the internal structure of \p ctx and
// frees any embedded internal structure, but does not free
// \p ctx itself.
// 
// If you have called mbedtls_md_setup() on \p ctx, you must
// call mbedtls_md_free() when you are no longer using the
// context.
// Calling this function if you have previously
// called mbedtls_md_init() and nothing else is optional.
// You must not call this function if you have not called
// mbedtls_md_init().
pub extern external/mbedtls-md-free(^ctx1: c-pointer<mbedtls-md-context-t-c>): ()
  c inline "(void)mbedtls_md_free((struct mbedtls_md_context_t*)#1)"

// \brief           This function selects the message digest algorithm to use,
// and allocates internal structures.
// 
// It should be called after mbedtls_md_init() or
// mbedtls_md_free(). Makes it necessary to call
// mbedtls_md_free() later.
// 
// \param ctx       The context to set up.
// \param md_info   The information structure of the message-digest algorithm
// to use.
// \param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),
// or non-zero: HMAC is used with this context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
// \return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure.
pub extern external/mbedtls-md-setup(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^md-info: c-pointer<mbedtls-md-info-t-c>, ^hmac: int32): int32
  c inline "(int)mbedtls_md_setup((struct mbedtls_md_context_t*)#1, (struct mbedtls_md_info_t*)#2, (int)#3)"

pub inline fun ffi/mbedtls-md-setup(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^md-info: c-pointer<mbedtls-md-info-t-c>, ^hmac: int): <> int
  external/mbedtls-md-setup(ctx1, md-info, hmac.int32).int

// \brief           This function clones the state of a message-digest
// context.
// 
// \note            You must call mbedtls_md_setup() on \c dst before calling
// this function.
// 
// \note            The two contexts must have the same type,
// for example, both are SHA-256.
// 
// \warning         This function clones the message-digest state, not the
// HMAC state.
// 
// \param dst       The destination context.
// \param src       The context to be cloned.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure.
// \return          #MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE if both contexts are
// not using the same engine. This can be avoided by moving
// the call to psa_crypto_init() before the first call to
// mbedtls_md_setup().
pub extern external/mbedtls-md-clone(^dst: c-pointer<mbedtls-md-context-t-c>, ^src: c-pointer<mbedtls-md-context-t-c>): int32
  c inline "(int)mbedtls_md_clone((struct mbedtls_md_context_t*)#1, (struct mbedtls_md_context_t*)#2)"

pub inline fun ffi/mbedtls-md-clone(^dst: c-pointer<mbedtls-md-context-t-c>, ^src: c-pointer<mbedtls-md-context-t-c>): <> int
  external/mbedtls-md-clone(dst, src).int

// \brief           This function extracts the message-digest size from the
// message-digest information structure.
// 
// \param md_info   The information structure of the message-digest algorithm
// to use.
// 
// \return          The size of the message-digest output in Bytes.
pub extern external/mbedtls-md-get-size(^md-info: c-pointer<mbedtls-md-info-t-c>): int8
  c inline "(unsigned char)mbedtls_md_get_size((struct mbedtls_md_info_t*)#1)"

pub inline fun ffi/mbedtls-md-get-size(^md-info: c-pointer<mbedtls-md-info-t-c>): <> int
  external/mbedtls-md-get-size(md-info).int

// \brief           This function extracts the message-digest type from the
// message-digest information structure.
// 
// \param md_info   The information structure of the message-digest algorithm
// to use.
// 
// \return          The type of the message digest.
pub extern external/mbedtls-md-get-type(^md-info: c-pointer<mbedtls-md-info-t-c>): int32
  c inline "(int32_t)mbedtls_md_get_type((struct mbedtls_md_info_t*)#1)"

pub inline fun ffi/mbedtls-md-get-type(^md-info: c-pointer<mbedtls-md-info-t-c>): <exn> mbedtls-md-type-t
  external/mbedtls-md-get-type(md-info).int/mbedtls-md-type-t

// \brief           This function starts a message-digest computation.
// 
// You must call this function after setting up the context
// with mbedtls_md_setup(), and before passing data with
// mbedtls_md_update().
// 
// \param ctx       The generic message-digest context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-starts(^ctx1: c-pointer<mbedtls-md-context-t-c>): int32
  c inline "(int)mbedtls_md_starts((struct mbedtls_md_context_t*)#1)"

pub inline fun ffi/mbedtls-md-starts(^ctx1: c-pointer<mbedtls-md-context-t-c>): <> int
  external/mbedtls-md-starts(ctx1).int

// \brief           This function feeds an input buffer into an ongoing
// message-digest computation.
// 
// You must call mbedtls_md_starts() before calling this
// function. You may call this function multiple times.
// Afterwards, call mbedtls_md_finish().
// 
// \param ctx       The generic message-digest context.
// \param input     The buffer holding the input data.
// \param ilen      The length of the input data.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-update(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_md_update((struct mbedtls_md_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-md-update(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-md-update(ctx1, input, ilen.ssize_t).int

// \brief           This function finishes the digest operation,
// and writes the result to the output buffer.
// 
// Call this function after a call to mbedtls_md_starts(),
// followed by any number of calls to mbedtls_md_update().
// Afterwards, you may either clear the context with
// mbedtls_md_free(), or call mbedtls_md_starts() to reuse
// the context for another digest operation with the same
// algorithm.
// 
// \param ctx       The generic message-digest context.
// \param output    The buffer for the generic message-digest checksum result.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-finish(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md_finish((struct mbedtls_md_context_t*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-md-finish(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^output: c-pointer<int>): <> int
  external/mbedtls-md-finish(ctx1, output).int

// \brief          This function calculates the message-digest of a buffer,
// with respect to a configurable message-digest algorithm
// in a single call.
// 
// The result is calculated as
// Output = message_digest(input buffer).
// 
// \param md_info  The information structure of the message-digest algorithm
// to use.
// \param input    The buffer holding the data.
// \param ilen     The length of the input data.
// \param output   The generic message-digest checksum result.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md(^md-info: c-pointer<mbedtls-md-info-t-c>, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md((struct mbedtls_md_info_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4)"

pub inline fun ffi/mbedtls-md(^md-info: c-pointer<mbedtls-md-info-t-c>, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>): <> int
  external/mbedtls-md(md-info, input, ilen.ssize_t, output).int

// \brief           This function returns the list of digests supported by the
// generic digest module.
// 
// \note            The list starts with the strongest available hashes.
// 
// \return          A statically allocated array of digests. Each element
// in the returned list is an integer belonging to the
// message-digest enumeration #mbedtls_md_type_t.
// The last entry is 0.
pub extern external/mbedtls-md-list(): c-pointer<int>
  c inline "(intptr_t)mbedtls_md_list()"

// \brief           This function returns the message-digest information
// associated with the given digest name.
// 
// \param md_name   The name of the digest to search for.
// 
// \return          The message-digest information associated with \p md_name.
// \return          NULL if the associated message-digest information is not found.
pub extern external/mbedtls-md-info-from-string(^md-name: c-pointer<int>): c-pointer<mbedtls-md-info-t-c>
  c inline "(intptr_t)mbedtls_md_info_from_string((char*)#1)"

// \brief           This function returns the name of the message digest for
// the message-digest information structure given.
// 
// \param md_info   The information structure of the message-digest algorithm
// to use.
// 
// \return          The name of the message digest.
pub extern external/mbedtls-md-get-name(^md-info: c-pointer<mbedtls-md-info-t-c>): c-pointer<int>
  c inline "(intptr_t)mbedtls_md_get_name((struct mbedtls_md_info_t*)#1)"

// \brief           This function returns the message-digest information
// from the given context.
// 
// \param ctx       The context from which to extract the information.
// This must be initialized (or \c NULL).
// 
// \return          The message-digest information associated with \p ctx.
// \return          \c NULL if \p ctx is \c NULL.
pub extern external/mbedtls-md-info-from-ctx(^ctx1: c-pointer<mbedtls-md-context-t-c>): c-pointer<mbedtls-md-info-t-c>
  c inline "(intptr_t)mbedtls_md_info_from_ctx((struct mbedtls_md_context_t*)#1)"

// \brief          This function calculates the message-digest checksum
// result of the contents of the provided file.
// 
// The result is calculated as
// Output = message_digest(file contents).
// 
// \param md_info  The information structure of the message-digest algorithm
// to use.
// \param path     The input file name.
// \param output   The generic message-digest checksum result.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_MD_FILE_IO_ERROR on an I/O error accessing
// the file pointed by \p path.
// \return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \p md_info was NULL.
pub extern external/mbedtls-md-file(^md-info: c-pointer<mbedtls-md-info-t-c>, ^path: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md_file((struct mbedtls_md_info_t*)#1, (char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-md-file(^md-info: c-pointer<mbedtls-md-info-t-c>, ^path: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-md-file(md-info, path, output).int

// \brief           This function sets the HMAC key and prepares to
// authenticate a new message.
// 
// Call this function after mbedtls_md_setup(), to use
// the MD context for an HMAC calculation, then call
// mbedtls_md_hmac_update() to provide the input data, and
// mbedtls_md_hmac_finish() to get the HMAC value.
// 
// \param ctx       The message digest context containing an embedded HMAC
// context.
// \param key       The HMAC secret key.
// \param keylen    The length of the HMAC key in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-hmac-starts(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^key: c-pointer<int>, ^keylen: ssize_t): int32
  c inline "(int)mbedtls_md_hmac_starts((struct mbedtls_md_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-md-hmac-starts(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^key: c-pointer<int>, ^keylen: int): <> int
  external/mbedtls-md-hmac-starts(ctx1, key, keylen.ssize_t).int

// \brief           This function feeds an input buffer into an ongoing HMAC
// computation.
// 
// Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()
// before calling this function.
// You may call this function multiple times to pass the
// input piecewise.
// Afterwards, call mbedtls_md_hmac_finish().
// 
// \param ctx       The message digest context containing an embedded HMAC
// context.
// \param input     The buffer holding the input data.
// \param ilen      The length of the input data.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-hmac-update(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_md_hmac_update((struct mbedtls_md_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-md-hmac-update(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-md-hmac-update(ctx1, input, ilen.ssize_t).int

// \brief           This function finishes the HMAC operation, and writes
// the result to the output buffer.
// 
// Call this function after mbedtls_md_hmac_starts() and
// mbedtls_md_hmac_update() to get the HMAC value. Afterwards
// you may either call mbedtls_md_free() to clear the context,
// or call mbedtls_md_hmac_reset() to reuse the context with
// the same HMAC key.
// 
// \param ctx       The message digest context containing an embedded HMAC
// context.
// \param output    The generic HMAC checksum result.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-hmac-finish(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md_hmac_finish((struct mbedtls_md_context_t*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-md-hmac-finish(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^output: c-pointer<int>): <> int
  external/mbedtls-md-hmac-finish(ctx1, output).int

// \brief           This function prepares to authenticate a new message with
// the same key as the previous HMAC operation.
// 
// You may call this function after mbedtls_md_hmac_finish().
// Afterwards call mbedtls_md_hmac_update() to pass the new
// input.
// 
// \param ctx       The message digest context containing an embedded HMAC
// context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-hmac-reset(^ctx1: c-pointer<mbedtls-md-context-t-c>): int32
  c inline "(int)mbedtls_md_hmac_reset((struct mbedtls_md_context_t*)#1)"

pub inline fun ffi/mbedtls-md-hmac-reset(^ctx1: c-pointer<mbedtls-md-context-t-c>): <> int
  external/mbedtls-md-hmac-reset(ctx1).int

// \brief          This function calculates the full generic HMAC
// on the input buffer with the provided key.
// 
// The function allocates the context, performs the
// calculation, and frees the context.
// 
// The HMAC result is calculated as
// output = generic HMAC(hmac key, input buffer).
// 
// \param md_info  The information structure of the message-digest algorithm
// to use.
// \param key      The HMAC secret key.
// \param keylen   The length of the HMAC secret key in Bytes.
// \param input    The buffer holding the input data.
// \param ilen     The length of the input data.
// \param output   The generic HMAC result.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification
// failure.
pub extern external/mbedtls-md-hmac(^md-info: c-pointer<mbedtls-md-info-t-c>, ^key: c-pointer<int>, ^keylen: ssize_t, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md_hmac((struct mbedtls_md_info_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-md-hmac(^md-info: c-pointer<mbedtls-md-info-t-c>, ^key: c-pointer<int>, ^keylen: int, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>): <> int
  external/mbedtls-md-hmac(md-info, key, keylen.ssize_t, input, ilen.ssize_t, output).int

// \brief          This function initializes an RSA context.
// 
// \note           This function initializes the padding and the hash
// identifier to respectively #MBEDTLS_RSA_PKCS_V15 and
// #MBEDTLS_MD_NONE. See mbedtls_rsa_set_padding() for more
// information about those parameters.
// 
// \param ctx      The RSA context to initialize. This must not be \c NULL.
pub extern external/mbedtls-rsa-init(^ctx1: c-pointer<mbedtls-rsa-context-c>): ()
  c inline "(void)mbedtls_rsa_init((struct mbedtls_rsa_context*)#1)"

// \brief          This function sets padding for an already initialized RSA
// context.
// 
// \note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP
// encryption scheme and the RSASSA-PSS signature scheme.
// 
// \note           The \p hash_id parameter is ignored when using
// #MBEDTLS_RSA_PKCS_V15 padding.
// 
// \note           The choice of padding mode is strictly enforced for private
// key operations, since there might be security concerns in
// mixing padding modes. For public key operations it is
// a default value, which can be overridden by calling specific
// \c mbedtls_rsa_rsaes_xxx or \c mbedtls_rsa_rsassa_xxx
// functions.
// 
// \note           The hash selected in \p hash_id is always used for OEAP
// encryption. For PSS signatures, it is always used for
// making signatures, but can be overridden for verifying them.
// If set to #MBEDTLS_MD_NONE, it is always overridden.
// 
// \param ctx      The initialized RSA context to be configured.
// \param padding  The padding mode to use. This must be either
// #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21.
// \param hash_id  The hash identifier for PSS or OAEP, if \p padding is
// #MBEDTLS_RSA_PKCS_V21. #MBEDTLS_MD_NONE is accepted by this
// function but may be not suitable for some operations.
// Ignored if \p padding is #MBEDTLS_RSA_PKCS_V15.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_RSA_INVALID_PADDING failure:
// \p padding or \p hash_id is invalid.
pub extern external/mbedtls-rsa-set-padding(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^padding: int32, ^hash-id: int32): int32
  c inline "(int)mbedtls_rsa_set_padding((struct mbedtls_rsa_context*)#1, (int)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-rsa-set-padding(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^padding: int, ^hash-id: mbedtls-md-type-t): <exn> int
  external/mbedtls-rsa-set-padding(ctx1, padding.int32, hash-id.mbedtls-md-type-t/int).int

// \brief          This function retrieves padding mode of initialized
// RSA context.
// 
// \param ctx      The initialized RSA context.
// 
// \return         RSA padding mode.
pub extern external/mbedtls-rsa-get-padding-mode(^ctx1: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_get_padding_mode((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-get-padding-mode(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-get-padding-mode(ctx1).int

// \brief          This function retrieves hash identifier of mbedtls_md_type_t
// type.
// 
// \param ctx      The initialized RSA context.
// 
// \return         Hash identifier of mbedtls_md_type_t type.
pub extern external/mbedtls-rsa-get-md-alg(^ctx1: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_get_md_alg((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-get-md-alg(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-get-md-alg(ctx1).int

// \brief          This function imports a set of core parameters into an
// RSA context.
// 
// \note           This function can be called multiple times for successive
// imports, if the parameters are not simultaneously present.
// 
// Any sequence of calls to this function should be followed
// by a call to mbedtls_rsa_complete(), which checks and
// completes the provided information to a ready-for-use
// public or private RSA key.
// 
// \note           See mbedtls_rsa_complete() for more information on which
// parameters are necessary to set up a private or public
// RSA key.
// 
// \note           The imported parameters are copied and need not be preserved
// for the lifetime of the RSA context being set up.
// 
// \param ctx      The initialized RSA context to store the parameters in.
// \param N        The RSA modulus. This may be \c NULL.
// \param P        The first prime factor of \p N. This may be \c NULL.
// \param Q        The second prime factor of \p N. This may be \c NULL.
// \param D        The private exponent. This may be \c NULL.
// \param E        The public exponent. This may be \c NULL.
// 
// \return         \c 0 on success.
// \return         A non-zero error code on failure.
pub extern external/mbedtls-rsa-import(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^e: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_rsa_import((struct mbedtls_rsa_context*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (struct mbedtls_mpi*)#5, (struct mbedtls_mpi*)#6)"

pub inline fun ffi/mbedtls-rsa-import(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^e: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-rsa-import(ctx1, n, p, q, d, e).int

// \brief          This function imports core RSA parameters, in raw big-endian
// binary format, into an RSA context.
// 
// \note           This function can be called multiple times for successive
// imports, if the parameters are not simultaneously present.
// 
// Any sequence of calls to this function should be followed
// by a call to mbedtls_rsa_complete(), which checks and
// completes the provided information to a ready-for-use
// public or private RSA key.
// 
// \note           See mbedtls_rsa_complete() for more information on which
// parameters are necessary to set up a private or public
// RSA key.
// 
// \note           The imported parameters are copied and need not be preserved
// for the lifetime of the RSA context being set up.
// 
// \param ctx      The initialized RSA context to store the parameters in.
// \param N        The RSA modulus. This may be \c NULL.
// \param N_len    The Byte length of \p N; it is ignored if \p N == NULL.
// \param P        The first prime factor of \p N. This may be \c NULL.
// \param P_len    The Byte length of \p P; it is ignored if \p P == NULL.
// \param Q        The second prime factor of \p N. This may be \c NULL.
// \param Q_len    The Byte length of \p Q; it is ignored if \p Q == NULL.
// \param D        The private exponent. This may be \c NULL.
// \param D_len    The Byte length of \p D; it is ignored if \p D == NULL.
// \param E        The public exponent. This may be \c NULL.
// \param E_len    The Byte length of \p E; it is ignored if \p E == NULL.
// 
// \return         \c 0 on success.
// \return         A non-zero error code on failure.
pub extern external/mbedtls-rsa-import-raw(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<int>, ^n-len: ssize_t, ^p: c-pointer<int>, ^p-len: ssize_t, ^q: c-pointer<int>, ^q-len: ssize_t, ^d: c-pointer<int>, ^d-len: ssize_t, ^e: c-pointer<int>, ^e-len: ssize_t): int32
  c inline "(int)mbedtls_rsa_import_raw((struct mbedtls_rsa_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (unsigned char*)#8, (size_t)#9, (unsigned char*)#10, (size_t)#11)"

pub inline fun ffi/mbedtls-rsa-import-raw(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<int>, ^n-len: int, ^p: c-pointer<int>, ^p-len: int, ^q: c-pointer<int>, ^q-len: int, ^d: c-pointer<int>, ^d-len: int, ^e: c-pointer<int>, ^e-len: int): <> int
  external/mbedtls-rsa-import-raw(ctx1, n, n-len.ssize_t, p, p-len.ssize_t, q, q-len.ssize_t, d, d-len.ssize_t, e, e-len.ssize_t).int

// \brief          This function completes an RSA context from
// a set of imported core parameters.
// 
// To setup an RSA public key, precisely \c N and \c E
// must have been imported.
// 
// To setup an RSA private key, sufficient information must
// be present for the other parameters to be derivable.
// 
// The default implementation supports the following:
// <ul><li>Derive \c P, \c Q from \c N, \c D, \c E.</li>
// <li>Derive \c N, \c D from \c P, \c Q, \c E.</li></ul>
// Alternative implementations need not support these.
// 
// If this function runs successfully, it guarantees that
// the RSA context can be used for RSA operations without
// the risk of failure or crash.
// 
// \warning        This function need not perform consistency checks
// for the imported parameters. In particular, parameters that
// are not needed by the implementation might be silently
// discarded and left unchecked. To check the consistency
// of the key material, see mbedtls_rsa_check_privkey().
// 
// \param ctx      The initialized RSA context holding imported parameters.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations
// failed.
pub extern external/mbedtls-rsa-complete(^ctx1: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_complete((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-complete(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-complete(ctx1).int

// \brief          This function exports the core parameters of an RSA key.
// 
// If this function runs successfully, the non-NULL buffers
// pointed to by \p N, \p P, \p Q, \p D, and \p E are fully
// written, with additional unused space filled leading by
// zero Bytes.
// 
// Possible reasons for returning
// #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>
// <li>An alternative RSA implementation is in use, which
// stores the key externally, and either cannot or should
// not export it into RAM.</li>
// <li>A SW or HW implementation might not support a certain
// deduction. For example, \p P, \p Q from \p N, \p D,
// and \p E if the former are not part of the
// implementation.</li></ul>
// 
// If the function fails due to an unsupported operation,
// the RSA context stays intact and remains usable.
// 
// \param ctx      The initialized RSA context.
// \param N        The MPI to hold the RSA modulus.
// This may be \c NULL if this field need not be exported.
// \param P        The MPI to hold the first prime factor of \p N.
// This may be \c NULL if this field need not be exported.
// \param Q        The MPI to hold the second prime factor of \p N.
// This may be \c NULL if this field need not be exported.
// \param D        The MPI to hold the private exponent.
// This may be \c NULL if this field need not be exported.
// \param E        The MPI to hold the public exponent.
// This may be \c NULL if this field need not be exported.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the
// requested parameters cannot be done due to missing
// functionality or because of security policies.
// \return         A non-zero return code on any other failure.
pub extern external/mbedtls-rsa-export(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^e: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_rsa_export((struct mbedtls_rsa_context*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (struct mbedtls_mpi*)#5, (struct mbedtls_mpi*)#6)"

pub inline fun ffi/mbedtls-rsa-export(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^e: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-rsa-export(ctx1, n, p, q, d, e).int

// \brief          This function exports core parameters of an RSA key
// in raw big-endian binary format.
// 
// If this function runs successfully, the non-NULL buffers
// pointed to by \p N, \p P, \p Q, \p D, and \p E are fully
// written, with additional unused space filled leading by
// zero Bytes.
// 
// Possible reasons for returning
// #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>
// <li>An alternative RSA implementation is in use, which
// stores the key externally, and either cannot or should
// not export it into RAM.</li>
// <li>A SW or HW implementation might not support a certain
// deduction. For example, \p P, \p Q from \p N, \p D,
// and \p E if the former are not part of the
// implementation.</li></ul>
// If the function fails due to an unsupported operation,
// the RSA context stays intact and remains usable.
// 
// \note           The length parameters are ignored if the corresponding
// buffer pointers are NULL.
// 
// \param ctx      The initialized RSA context.
// \param N        The Byte array to store the RSA modulus,
// or \c NULL if this field need not be exported.
// \param N_len    The size of the buffer for the modulus.
// \param P        The Byte array to hold the first prime factor of \p N,
// or \c NULL if this field need not be exported.
// \param P_len    The size of the buffer for the first prime factor.
// \param Q        The Byte array to hold the second prime factor of \p N,
// or \c NULL if this field need not be exported.
// \param Q_len    The size of the buffer for the second prime factor.
// \param D        The Byte array to hold the private exponent,
// or \c NULL if this field need not be exported.
// \param D_len    The size of the buffer for the private exponent.
// \param E        The Byte array to hold the public exponent,
// or \c NULL if this field need not be exported.
// \param E_len    The size of the buffer for the public exponent.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the
// requested parameters cannot be done due to missing
// functionality or because of security policies.
// \return         A non-zero return code on any other failure.
pub extern external/mbedtls-rsa-export-raw(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<int>, ^n-len: ssize_t, ^p: c-pointer<int>, ^p-len: ssize_t, ^q: c-pointer<int>, ^q-len: ssize_t, ^d: c-pointer<int>, ^d-len: ssize_t, ^e: c-pointer<int>, ^e-len: ssize_t): int32
  c inline "(int)mbedtls_rsa_export_raw((struct mbedtls_rsa_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (unsigned char*)#8, (size_t)#9, (unsigned char*)#10, (size_t)#11)"

pub inline fun ffi/mbedtls-rsa-export-raw(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^n: c-pointer<int>, ^n-len: int, ^p: c-pointer<int>, ^p-len: int, ^q: c-pointer<int>, ^q-len: int, ^d: c-pointer<int>, ^d-len: int, ^e: c-pointer<int>, ^e-len: int): <> int
  external/mbedtls-rsa-export-raw(ctx1, n, n-len.ssize_t, p, p-len.ssize_t, q, q-len.ssize_t, d, d-len.ssize_t, e, e-len.ssize_t).int

// \brief          This function exports CRT parameters of a private RSA key.
// 
// \note           Alternative RSA implementations not using CRT-parameters
// internally can implement this function based on
// mbedtls_rsa_deduce_opt().
// 
// \param ctx      The initialized RSA context.
// \param DP       The MPI to hold \c D modulo `P-1`,
// or \c NULL if it need not be exported.
// \param DQ       The MPI to hold \c D modulo `Q-1`,
// or \c NULL if it need not be exported.
// \param QP       The MPI to hold modular inverse of \c Q modulo \c P,
// or \c NULL if it need not be exported.
// 
// \return         \c 0 on success.
// \return         A non-zero error code on failure.
pub extern external/mbedtls-rsa-export-crt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^dp: c-pointer<mbedtls-mpi-c>, ^dq: c-pointer<mbedtls-mpi-c>, ^qp: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_rsa_export_crt((struct mbedtls_rsa_context*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4)"

pub inline fun ffi/mbedtls-rsa-export-crt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^dp: c-pointer<mbedtls-mpi-c>, ^dq: c-pointer<mbedtls-mpi-c>, ^qp: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-rsa-export-crt(ctx1, dp, dq, qp).int

// \brief          This function retrieves the length of the RSA modulus in bits.
// 
// \param ctx      The initialized RSA context.
// 
// \return         The length of the RSA modulus in bits.
pub extern external/mbedtls-rsa-get-bitlen(^ctx1: c-pointer<mbedtls-rsa-context-c>): ssize_t
  c inline "(size_t)mbedtls_rsa_get_bitlen((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-get-bitlen(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-get-bitlen(ctx1).int

// \brief          This function retrieves the length of RSA modulus in Bytes.
// 
// \param ctx      The initialized RSA context.
// 
// \return         The length of the RSA modulus in Bytes.
pub extern external/mbedtls-rsa-get-len(^ctx1: c-pointer<mbedtls-rsa-context-c>): ssize_t
  c inline "(size_t)mbedtls_rsa_get_len((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-get-len(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-get-len(ctx1).int

// \brief          This function generates an RSA keypair.
// 
// \note           mbedtls_rsa_init() must be called before this function,
// to set up the RSA context.
// 
// \param ctx      The initialized RSA context used to hold the key.
// \param f_rng    The RNG function to be used for key generation.
// This is mandatory and must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng.
// This may be \c NULL if \p f_rng doesn't need a context.
// \param nbits    The size of the public key in bits.
// \param exponent The public exponent to use. For example, \c 65537.
// This must be odd and greater than \c 1.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-gen-key(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^nbits: int32, ^exponent: int32): int32
  c inline "(int)mbedtls_rsa_gen_key((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (unsigned int)#4, (int)#5)"

pub inline fun ffi/mbedtls-rsa-gen-key(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^nbits: int, ^exponent: int): <> int
  external/mbedtls-rsa-gen-key(ctx1, f-rng, p-rng, nbits.int32, exponent.int32).int

// \brief          This function checks if a context contains at least an RSA
// public key.
// 
// If the function runs successfully, it is guaranteed that
// enough information is present to perform an RSA public key
// operation using mbedtls_rsa_public().
// 
// \param ctx      The initialized RSA context to check.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-check-pubkey(^ctx1: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_check_pubkey((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-check-pubkey(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-check-pubkey(ctx1).int

// \brief      This function checks if a context contains an RSA private key
// and perform basic consistency checks.
// 
// \note       The consistency checks performed by this function not only
// ensure that mbedtls_rsa_private() can be called successfully
// on the given context, but that the various parameters are
// mutually consistent with high probability, in the sense that
// mbedtls_rsa_public() and mbedtls_rsa_private() are inverses.
// 
// \warning    This function should catch accidental misconfigurations
// like swapping of parameters, but it cannot establish full
// trust in neither the quality nor the consistency of the key
// material that was used to setup the given RSA context:
// <ul><li>Consistency: Imported parameters that are irrelevant
// for the implementation might be silently dropped. If dropped,
// the current function does not have access to them,
// and therefore cannot check them. See mbedtls_rsa_complete().
// If you want to check the consistency of the entire
// content of a PKCS1-encoded RSA private key, for example, you
// should use mbedtls_rsa_validate_params() before setting
// up the RSA context.
// Additionally, if the implementation performs empirical checks,
// these checks substantiate but do not guarantee consistency.</li>
// <li>Quality: This function is not expected to perform
// extended quality assessments like checking that the prime
// factors are safe. Additionally, it is the responsibility of the
// user to ensure the trustworthiness of the source of his RSA
// parameters, which goes beyond what is effectively checkable
// by the library.</li></ul>
// 
// \param ctx  The initialized RSA context to check.
// 
// \return     \c 0 on success.
// \return     An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-check-privkey(^ctx1: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_check_privkey((struct mbedtls_rsa_context*)#1)"

pub inline fun ffi/mbedtls-rsa-check-privkey(^ctx1: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-check-privkey(ctx1).int

// \brief          This function checks a public-private RSA key pair.
// 
// It checks each of the contexts, and makes sure they match.
// 
// \param pub      The initialized RSA context holding the public key.
// \param prv      The initialized RSA context holding the private key.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-check-pub-priv(^pub: c-pointer<mbedtls-rsa-context-c>, ^prv: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_check_pub_priv((struct mbedtls_rsa_context*)#1, (struct mbedtls_rsa_context*)#2)"

pub inline fun ffi/mbedtls-rsa-check-pub-priv(^pub: c-pointer<mbedtls-rsa-context-c>, ^prv: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-check-pub-priv(pub, prv).int

// \brief          This function performs an RSA public key operation.
// 
// \param ctx      The initialized RSA context to use.
// \param input    The input buffer. This must be a readable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// \param output   The output buffer. This must be a writable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \note           This function does not handle message padding.
// 
// \note           Make sure to set \p input[0] = 0 or ensure that
// input is smaller than \c N.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-public(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_public((struct mbedtls_rsa_context*)#1, (unsigned char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-rsa-public(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-rsa-public(ctx1, input, output).int

// \brief          This function performs an RSA private key operation.
// 
// \note           Blinding is used if and only if a PRNG is provided.
// 
// \note           If blinding is used, both the base of exponentiation
// and the exponent are blinded, providing protection
// against some side-channel attacks.
// 
// \warning        It is deprecated and a security risk to not provide
// a PRNG here and thereby prevent the use of blinding.
// Future versions of the library may enforce the presence
// of a PRNG.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function, used for blinding. It is mandatory.
// \param p_rng    The RNG context to pass to \p f_rng. This may be \c NULL
// if \p f_rng doesn't need a context.
// \param input    The input buffer. This must be a readable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// \param output   The output buffer. This must be a writable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-private(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_private((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (unsigned char*)#4, (unsigned char*)#5)"

pub inline fun ffi/mbedtls-rsa-private(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-rsa-private(ctx1, f-rng, p-rng, input, output).int

// \brief          This function adds the message padding, then performs an RSA
// operation.
// 
// It is the generic wrapper for performing a PKCS#1 encryption
// operation.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG to use. It is used for padding generation
// and it is mandatory.
// \param p_rng    The RNG context to be passed to \p f_rng. May be
// \c NULL if \p f_rng doesn't need a context argument.
// \param ilen     The length of the plaintext in Bytes.
// \param input    The input data to encrypt. This must be a readable
// buffer of size \p ilen Bytes. It may be \c NULL if
// `ilen == 0`.
// \param output   The output buffer. This must be a writable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-pkcs1-encrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^ilen: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_pkcs1_encrypt((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (size_t)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-rsa-pkcs1-encrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^ilen: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-rsa-pkcs1-encrypt(ctx1, f-rng, p-rng, ilen.ssize_t, input, output).int

// \brief          This function performs a PKCS#1 v1.5 encryption operation
// (RSAES-PKCS1-v1_5-ENCRYPT).
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function to use. It is mandatory and used for
// padding generation.
// \param p_rng    The RNG context to be passed to \p f_rng. This may
// be \c NULL if \p f_rng doesn't need a context argument.
// \param ilen     The length of the plaintext in Bytes.
// \param input    The input data to encrypt. This must be a readable
// buffer of size \p ilen Bytes. It may be \c NULL if
// `ilen == 0`.
// \param output   The output buffer. This must be a writable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsaes-pkcs1-v15-encrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^ilen: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsaes_pkcs1_v15_encrypt((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (size_t)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-rsa-rsaes-pkcs1-v15-encrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^ilen: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-rsa-rsaes-pkcs1-v15-encrypt(ctx1, f-rng, p-rng, ilen.ssize_t, input, output).int

// \brief            This function performs a PKCS#1 v2.1 OAEP encryption
// operation (RSAES-OAEP-ENCRYPT).
// 
// \note             The output buffer must be as large as the size
// of ctx->N. For example, 128 Bytes if RSA-1024 is used.
// 
// \param ctx        The initialized RSA context to use.
// \param f_rng      The RNG function to use. This is needed for padding
// generation and is mandatory.
// \param p_rng      The RNG context to be passed to \p f_rng. This may
// be \c NULL if \p f_rng doesn't need a context argument.
// \param label      The buffer holding the custom label to use.
// This must be a readable buffer of length \p label_len
// Bytes. It may be \c NULL if \p label_len is \c 0.
// \param label_len  The length of the label in Bytes.
// \param ilen       The length of the plaintext buffer \p input in Bytes.
// \param input      The input data to encrypt. This must be a readable
// buffer of size \p ilen Bytes. It may be \c NULL if
// `ilen == 0`.
// \param output     The output buffer. This must be a writable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return           \c 0 on success.
// \return           An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsaes-oaep-encrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^label: c-pointer<int>, ^label-len: ssize_t, ^ilen: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsaes_oaep_encrypt((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (unsigned char*)#4, (size_t)#5, (size_t)#6, (unsigned char*)#7, (unsigned char*)#8)"

pub inline fun ffi/mbedtls-rsa-rsaes-oaep-encrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^label: c-pointer<int>, ^label-len: int, ^ilen: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-rsa-rsaes-oaep-encrypt(ctx1, f-rng, p-rng, label, label-len.ssize_t, ilen.ssize_t, input, output).int

// \brief          This function performs an RSA operation, then removes the
// message padding.
// 
// It is the generic wrapper for performing a PKCS#1 decryption
// operation.
// 
// \warning        When \p ctx->padding is set to #MBEDTLS_RSA_PKCS_V15,
// mbedtls_rsa_rsaes_pkcs1_v15_decrypt() is called, which is an
// inherently dangerous function (CWE-242).
// 
// \note           The output buffer length \c output_max_len should be
// as large as the size \p ctx->len of \p ctx->N (for example,
// 128 Bytes if RSA-1024 is used) to be able to hold an
// arbitrary decrypted message. If it is not large enough to
// hold the decryption of the particular ciphertext provided,
// the function returns \c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function. This is used for blinding and is
// mandatory; see mbedtls_rsa_private() for more.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context.
// \param olen     The address at which to store the length of
// the plaintext. This must not be \c NULL.
// \param input    The ciphertext buffer. This must be a readable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// \param output   The buffer used to hold the plaintext. This must
// be a writable buffer of length \p output_max_len Bytes.
// \param output_max_len The length in Bytes of the output buffer \p output.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-pkcs1-decrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^olen: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>, ^output-max-len: ssize_t): int32
  c inline "(int)mbedtls_rsa_pkcs1_decrypt((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (size_t*)#4, (unsigned char*)#5, (unsigned char*)#6, (size_t)#7)"

pub inline fun ffi/mbedtls-rsa-pkcs1-decrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^olen: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>, ^output-max-len: int): <> int
  external/mbedtls-rsa-pkcs1-decrypt(ctx1, f-rng, p-rng, olen, input, output, output-max-len.ssize_t).int

// \brief          This function performs a PKCS#1 v1.5 decryption
// operation (RSAES-PKCS1-v1_5-DECRYPT).
// 
// \warning        This is an inherently dangerous function (CWE-242). Unless
// it is used in a side channel free and safe way (eg.
// implementing the TLS protocol as per 7.4.7.1 of RFC 5246),
// the calling code is vulnerable.
// 
// \note           The output buffer length \c output_max_len should be
// as large as the size \p ctx->len of \p ctx->N, for example,
// 128 Bytes if RSA-1024 is used, to be able to hold an
// arbitrary decrypted message. If it is not large enough to
// hold the decryption of the particular ciphertext provided,
// the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function. This is used for blinding and is
// mandatory; see mbedtls_rsa_private() for more.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context.
// \param olen     The address at which to store the length of
// the plaintext. This must not be \c NULL.
// \param input    The ciphertext buffer. This must be a readable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// \param output   The buffer used to hold the plaintext. This must
// be a writable buffer of length \p output_max_len Bytes.
// \param output_max_len The length in Bytes of the output buffer \p output.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsaes-pkcs1-v15-decrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^olen: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>, ^output-max-len: ssize_t): int32
  c inline "(int)mbedtls_rsa_rsaes_pkcs1_v15_decrypt((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (size_t*)#4, (unsigned char*)#5, (unsigned char*)#6, (size_t)#7)"

pub inline fun ffi/mbedtls-rsa-rsaes-pkcs1-v15-decrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^olen: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>, ^output-max-len: int): <> int
  external/mbedtls-rsa-rsaes-pkcs1-v15-decrypt(ctx1, f-rng, p-rng, olen, input, output, output-max-len.ssize_t).int

// \brief            This function performs a PKCS#1 v2.1 OAEP decryption
// operation (RSAES-OAEP-DECRYPT).
// 
// \note             The output buffer length \c output_max_len should be
// as large as the size \p ctx->len of \p ctx->N, for
// example, 128 Bytes if RSA-1024 is used, to be able to
// hold an arbitrary decrypted message. If it is not
// large enough to hold the decryption of the particular
// ciphertext provided, the function returns
// #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.
// 
// \param ctx        The initialized RSA context to use.
// \param f_rng      The RNG function. This is used for blinding and is
// mandatory.
// \param p_rng      The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context.
// \param label      The buffer holding the custom label to use.
// This must be a readable buffer of length \p label_len
// Bytes. It may be \c NULL if \p label_len is \c 0.
// \param label_len  The length of the label in Bytes.
// \param olen       The address at which to store the length of
// the plaintext. This must not be \c NULL.
// \param input      The ciphertext buffer. This must be a readable buffer
// of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// \param output     The buffer used to hold the plaintext. This must
// be a writable buffer of length \p output_max_len Bytes.
// \param output_max_len The length in Bytes of the output buffer \p output.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsaes-oaep-decrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^label: c-pointer<int>, ^label-len: ssize_t, ^olen: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>, ^output-max-len: ssize_t): int32
  c inline "(int)mbedtls_rsa_rsaes_oaep_decrypt((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (unsigned char*)#4, (size_t)#5, (size_t*)#6, (unsigned char*)#7, (unsigned char*)#8, (size_t)#9)"

pub inline fun ffi/mbedtls-rsa-rsaes-oaep-decrypt(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^label: c-pointer<int>, ^label-len: int, ^olen: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>, ^output-max-len: int): <> int
  external/mbedtls-rsa-rsaes-oaep-decrypt(ctx1, f-rng, p-rng, label, label-len.ssize_t, olen, input, output, output-max-len.ssize_t).int

// \brief          This function performs a private RSA operation to sign
// a message digest using PKCS#1.
// 
// It is the generic wrapper for performing a PKCS#1
// signature.
// 
// \note           The \p sig buffer must be as large as the size
// of \p ctx->N. For example, 128 Bytes if RSA-1024 is used.
// 
// \note           For PKCS#1 v2.1 encoding, see comments on
// mbedtls_rsa_rsassa_pss_sign() for details on
// \p md_alg and \p hash_id.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function to use. This is mandatory and
// must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
// if \p f_rng doesn't need a context argument.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param sig      The buffer to hold the signature. This must be a writable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus. A buffer length of
// #MBEDTLS_MPI_MAX_SIZE is always safe.
// 
// \return         \c 0 if the signing operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-pkcs1-sign(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_pkcs1_sign((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (int32_t)#4, (unsigned int)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-rsa-pkcs1-sign(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-pkcs1-sign(ctx1, f-rng, p-rng, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, sig).int

// \brief          This function performs a PKCS#1 v1.5 signature
// operation (RSASSA-PKCS1-v1_5-SIGN).
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function. This is used for blinding and is
// mandatory; see mbedtls_rsa_private() for more.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
// if \p f_rng doesn't need a context argument.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param sig      The buffer to hold the signature. This must be a writable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus. A buffer length of
// #MBEDTLS_MPI_MAX_SIZE is always safe.
// 
// \return         \c 0 if the signing operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsassa-pkcs1-v15-sign(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsassa_pkcs1_v15_sign((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (int32_t)#4, (unsigned int)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-rsa-rsassa-pkcs1-v15-sign(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-rsassa-pkcs1-v15-sign(ctx1, f-rng, p-rng, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, sig).int

// \brief          This function performs a PKCS#1 v2.1 PSS signature
// operation (RSASSA-PSS-SIGN).
// 
// \note           The \c hash_id set in \p ctx by calling
// mbedtls_rsa_set_padding() selects the hash used for the
// encoding operation and for the mask generation function
// (MGF1). For more details on the encoding operation and the
// mask generation function, consult <em>RFC-3447: Public-Key
// Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography
// Specifications</em>.
// 
// \note           This function enforces that the provided salt length complies
// with FIPS 186-4 ยง5.5 (e) and RFC 8017 (PKCS#1 v2.2) ยง9.1.1
// step 3. The constraint is that the hash length plus the salt
// length plus 2 bytes must be at most the key length. If this
// constraint is not met, this function returns
// #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function. It is mandatory and must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
// if \p f_rng doesn't need a context argument.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param saltlen  The length of the salt that should be used.
// If passed #MBEDTLS_RSA_SALT_LEN_ANY, the function will use
// the largest possible salt length up to the hash length,
// which is the largest permitted by some standards including
// FIPS 186-4 ยง5.5.
// \param sig      The buffer to hold the signature. This must be a writable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus. A buffer length of
// #MBEDTLS_MPI_MAX_SIZE is always safe.
// 
// \return         \c 0 if the signing operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsassa-pss-sign-ext(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^saltlen: int32, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsassa_pss_sign_ext((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (int32_t)#4, (unsigned int)#5, (unsigned char*)#6, (int)#7, (unsigned char*)#8)"

pub inline fun ffi/mbedtls-rsa-rsassa-pss-sign-ext(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^saltlen: int, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-rsassa-pss-sign-ext(ctx1, f-rng, p-rng, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, saltlen.int32, sig).int

// \brief          This function performs a PKCS#1 v2.1 PSS signature
// operation (RSASSA-PSS-SIGN).
// 
// \note           The \c hash_id set in \p ctx by calling
// mbedtls_rsa_set_padding() selects the hash used for the
// encoding operation and for the mask generation function
// (MGF1). For more details on the encoding operation and the
// mask generation function, consult <em>RFC-3447: Public-Key
// Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography
// Specifications</em>.
// 
// \note           This function always uses the maximum possible salt size,
// up to the length of the payload hash. This choice of salt
// size complies with FIPS 186-4 ยง5.5 (e) and RFC 8017 (PKCS#1
// v2.2) ยง9.1.1 step 3. Furthermore this function enforces a
// minimum salt size which is the hash size minus 2 bytes. If
// this minimum size is too large given the key size (the salt
// size, plus the hash size, plus 2 bytes must be no more than
// the key size in bytes), this function returns
// #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.
// 
// \param ctx      The initialized RSA context to use.
// \param f_rng    The RNG function. It is mandatory and must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
// if \p f_rng doesn't need a context argument.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param sig      The buffer to hold the signature. This must be a writable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus. A buffer length of
// #MBEDTLS_MPI_MAX_SIZE is always safe.
// 
// \return         \c 0 if the signing operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsassa-pss-sign(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsassa_pss_sign((struct mbedtls_rsa_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (int32_t)#4, (unsigned int)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-rsa-rsassa-pss-sign(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-rsassa-pss-sign(ctx1, f-rng, p-rng, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, sig).int

// \brief          This function performs a public RSA operation and checks
// the message digest.
// 
// This is the generic wrapper for performing a PKCS#1
// verification.
// 
// \note           For PKCS#1 v2.1 encoding, see comments on
// mbedtls_rsa_rsassa_pss_verify() about \c md_alg and
// \c hash_id.
// 
// \param ctx      The initialized RSA public key context to use.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param sig      The buffer holding the signature. This must be a readable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 if the verify operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-pkcs1-verify(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_pkcs1_verify((struct mbedtls_rsa_context*)#1, (int32_t)#2, (unsigned int)#3, (unsigned char*)#4, (unsigned char*)#5)"

pub inline fun ffi/mbedtls-rsa-pkcs1-verify(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-pkcs1-verify(ctx1, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, sig).int

// \brief          This function performs a PKCS#1 v1.5 verification
// operation (RSASSA-PKCS1-v1_5-VERIFY).
// 
// \param ctx      The initialized RSA public key context to use.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param sig      The buffer holding the signature. This must be a readable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 if the verify operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsassa-pkcs1-v15-verify(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsassa_pkcs1_v15_verify((struct mbedtls_rsa_context*)#1, (int32_t)#2, (unsigned int)#3, (unsigned char*)#4, (unsigned char*)#5)"

pub inline fun ffi/mbedtls-rsa-rsassa-pkcs1-v15-verify(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-rsassa-pkcs1-v15-verify(ctx1, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, sig).int

// \brief          This function performs a PKCS#1 v2.1 PSS verification
// operation (RSASSA-PSS-VERIFY).
// 
// \note           The \c hash_id set in \p ctx by calling
// mbedtls_rsa_set_padding() selects the hash used for the
// encoding operation and for the mask generation function
// (MGF1). For more details on the encoding operation and the
// mask generation function, consult <em>RFC-3447: Public-Key
// Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography
// Specifications</em>. If the \c hash_id set in \p ctx by
// mbedtls_rsa_set_padding() is #MBEDTLS_MD_NONE, the \p md_alg
// parameter is used.
// 
// \param ctx      The initialized RSA public key context to use.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param sig      The buffer holding the signature. This must be a readable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 if the verify operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsassa-pss-verify(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsassa_pss_verify((struct mbedtls_rsa_context*)#1, (int32_t)#2, (unsigned int)#3, (unsigned char*)#4, (unsigned char*)#5)"

pub inline fun ffi/mbedtls-rsa-rsassa-pss-verify(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-rsassa-pss-verify(ctx1, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, sig).int

// \brief          This function performs a PKCS#1 v2.1 PSS verification
// operation (RSASSA-PSS-VERIFY).
// 
// \note           The \p sig buffer must be as large as the size
// of \p ctx->N. For example, 128 Bytes if RSA-1024 is used.
// 
// \note           The \c hash_id set in \p ctx by mbedtls_rsa_set_padding() is
// ignored.
// 
// \param ctx      The initialized RSA public key context to use.
// \param md_alg   The message-digest algorithm used to hash the original data.
// Use #MBEDTLS_MD_NONE for signing raw data.
// \param hashlen  The length of the message digest or raw data in Bytes.
// If \p md_alg is not #MBEDTLS_MD_NONE, this must match the
// output length of the corresponding hash algorithm.
// \param hash     The buffer holding the message digest or raw data.
// This must be a readable buffer of at least \p hashlen Bytes.
// \param mgf1_hash_id      The message digest algorithm used for the
// verification operation and the mask generation
// function (MGF1). For more details on the encoding
// operation and the mask generation function, consult
// <em>RFC-3447: Public-Key Cryptography Standards
// (PKCS) #1 v2.1: RSA Cryptography
// Specifications</em>.
// \param expected_salt_len The length of the salt used in padding. Use
// #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.
// \param sig      The buffer holding the signature. This must be a readable
// buffer of length \c ctx->len Bytes. For example, \c 256 Bytes
// for an 2048-bit RSA modulus.
// 
// \return         \c 0 if the verify operation was successful.
// \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.
pub extern external/mbedtls-rsa-rsassa-pss-verify-ext(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: int32, ^hashlen: int32, ^hash: c-pointer<int>, ^mgf1-hash-id: int32, ^expected-salt-len: int32, ^sig: c-pointer<int>): int32
  c inline "(int)mbedtls_rsa_rsassa_pss_verify_ext((struct mbedtls_rsa_context*)#1, (int32_t)#2, (unsigned int)#3, (unsigned char*)#4, (int32_t)#5, (int)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-rsa-rsassa-pss-verify-ext(^ctx1: c-pointer<mbedtls-rsa-context-c>, ^md-alg: mbedtls-md-type-t, ^hashlen: int, ^hash: c-pointer<int>, ^mgf1-hash-id: mbedtls-md-type-t, ^expected-salt-len: int, ^sig: c-pointer<int>): <exn> int
  external/mbedtls-rsa-rsassa-pss-verify-ext(ctx1, md-alg.mbedtls-md-type-t/int, hashlen.int32, hash, mgf1-hash-id.mbedtls-md-type-t/int, expected-salt-len.int32, sig).int

// \brief          This function copies the components of an RSA context.
// 
// \param dst      The destination context. This must be initialized.
// \param src      The source context. This must be initialized.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure.
pub extern external/mbedtls-rsa-copy(^dst: c-pointer<mbedtls-rsa-context-c>, ^src: c-pointer<mbedtls-rsa-context-c>): int32
  c inline "(int)mbedtls_rsa_copy((struct mbedtls_rsa_context*)#1, (struct mbedtls_rsa_context*)#2)"

pub inline fun ffi/mbedtls-rsa-copy(^dst: c-pointer<mbedtls-rsa-context-c>, ^src: c-pointer<mbedtls-rsa-context-c>): <> int
  external/mbedtls-rsa-copy(dst, src).int

// \brief          This function frees the components of an RSA key.
// 
// \param ctx      The RSA context to free. May be \c NULL, in which case
// this function is a no-op. If it is not \c NULL, it must
// point to an initialized RSA context.
pub extern external/mbedtls-rsa-free(^ctx1: c-pointer<mbedtls-rsa-context-c>): ()
  c inline "(void)mbedtls_rsa_free((struct mbedtls_rsa_context*)#1)"

// \brief          The RSA checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-rsa-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_rsa_self_test((int)#1)"

pub inline fun ffi/mbedtls-rsa-self-test(^verbose: int): <> int
  external/mbedtls-rsa-self-test(verbose.int32).int

pub extern external/mbedtls-ecp-get-type(^grp: c-pointer<mbedtls-ecp-group-c>): int32
  c inline "(int32_t)mbedtls_ecp_get_type((struct mbedtls_ecp_group*)#1)"

pub inline fun ffi/mbedtls-ecp-get-type(^grp: c-pointer<mbedtls-ecp-group-c>): <exn> mbedtls-ecp-curve-type
  external/mbedtls-ecp-get-type(grp).int/mbedtls-ecp-curve-type

// \brief           This function retrieves the information defined in
// mbedtls_ecp_curve_info() for all supported curves.
// 
// \note            This function returns information about all curves
// supported by the library. Some curves may not be
// supported for all algorithms. Call mbedtls_ecdh_can_do()
// or mbedtls_ecdsa_can_do() to check if a curve is
// supported for ECDH or ECDSA.
// 
// \return          A statically allocated array. The last entry is 0.
pub extern external/mbedtls-ecp-curve-list(): c-pointer<mbedtls-ecp-curve-info-c>
  c inline "(intptr_t)mbedtls_ecp_curve_list()"

// \brief           This function retrieves the list of internal group
// identifiers of all supported curves in the order of
// preference.
// 
// \note            This function returns information about all curves
// supported by the library. Some curves may not be
// supported for all algorithms. Call mbedtls_ecdh_can_do()
// or mbedtls_ecdsa_can_do() to check if a curve is
// supported for ECDH or ECDSA.
// 
// \return          A statically allocated array,
// terminated with MBEDTLS_ECP_DP_NONE.
pub extern external/mbedtls-ecp-grp-id-list(): c-pointer<mbedtls-ecp-group-id>
  c inline "(intptr_t)mbedtls_ecp_grp_id_list()"

// \brief           This function retrieves curve information from an internal
// group identifier.
// 
// \param grp_id    An \c MBEDTLS_ECP_DP_XXX value.
// 
// \return          The associated curve information on success.
// \return          NULL on failure.
pub extern external/mbedtls-ecp-curve-info-from-grp-id(^grp-id: int32): c-pointer<mbedtls-ecp-curve-info-c>
  c inline "(intptr_t)mbedtls_ecp_curve_info_from_grp_id((int32_t)#1)"

pub inline fun ffi/mbedtls-ecp-curve-info-from-grp-id(^grp-id: mbedtls-ecp-group-id): <exn> c-pointer<mbedtls-ecp-curve-info-c>
  external/mbedtls-ecp-curve-info-from-grp-id(grp-id.mbedtls-ecp-group-id/int)

// \brief           This function retrieves curve information from a TLS
// NamedCurve value.
// 
// \param tls_id    An \c MBEDTLS_ECP_DP_XXX value.
// 
// \return          The associated curve information on success.
// \return          NULL on failure.
pub extern external/mbedtls-ecp-curve-info-from-tls-id(^tls-id: int16): c-pointer<mbedtls-ecp-curve-info-c>
  c inline "(intptr_t)mbedtls_ecp_curve_info_from_tls_id((int16_t)#1)"

pub inline fun ffi/mbedtls-ecp-curve-info-from-tls-id(^tls-id: int): <> c-pointer<mbedtls-ecp-curve-info-c>
  external/mbedtls-ecp-curve-info-from-tls-id(tls-id.int16)

// \brief           This function retrieves curve information from a
// human-readable name.
// 
// \param name      The human-readable name.
// 
// \return          The associated curve information on success.
// \return          NULL on failure.
pub extern external/mbedtls-ecp-curve-info-from-name(^name: c-pointer<int>): c-pointer<mbedtls-ecp-curve-info-c>
  c inline "(intptr_t)mbedtls_ecp_curve_info_from_name((char*)#1)"

// \brief           This function initializes a point as zero.
// 
// \param pt        The point to initialize.
pub extern external/mbedtls-ecp-point-init(^pt: c-pointer<mbedtls-ecp-point-c>): ()
  c inline "(void)mbedtls_ecp_point_init((struct mbedtls_ecp_point*)#1)"

// \brief           This function initializes an ECP group context
// without loading any domain parameters.
// 
// \note            After this function is called, domain parameters
// for various ECP groups can be loaded through the
// mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()
// functions.
pub extern external/mbedtls-ecp-group-init(^grp: c-pointer<mbedtls-ecp-group-c>): ()
  c inline "(void)mbedtls_ecp_group_init((struct mbedtls_ecp_group*)#1)"

// \brief           This function initializes a key pair as an invalid one.
// 
// \param key       The key pair to initialize.
pub extern external/mbedtls-ecp-keypair-init(^key: c-pointer<mbedtls-ecp-keypair-c>): ()
  c inline "(void)mbedtls_ecp_keypair_init((struct mbedtls_ecp_keypair*)#1)"

// \brief           This function frees the components of a point.
// 
// \param pt        The point to free.
pub extern external/mbedtls-ecp-point-free(^pt: c-pointer<mbedtls-ecp-point-c>): ()
  c inline "(void)mbedtls_ecp_point_free((struct mbedtls_ecp_point*)#1)"

// \brief           This function frees the components of an ECP group.
// 
// \param grp       The group to free. This may be \c NULL, in which
// case this function returns immediately. If it is not
// \c NULL, it must point to an initialized ECP group.
pub extern external/mbedtls-ecp-group-free(^grp: c-pointer<mbedtls-ecp-group-c>): ()
  c inline "(void)mbedtls_ecp_group_free((struct mbedtls_ecp_group*)#1)"

// \brief           This function frees the components of a key pair.
// 
// \param key       The key pair to free. This may be \c NULL, in which
// case this function returns immediately. If it is not
// \c NULL, it must point to an initialized ECP key pair.
pub extern external/mbedtls-ecp-keypair-free(^key: c-pointer<mbedtls-ecp-keypair-c>): ()
  c inline "(void)mbedtls_ecp_keypair_free((struct mbedtls_ecp_keypair*)#1)"

// \brief           This function copies the contents of point \p Q into
// point \p P.
// 
// \param P         The destination point. This must be initialized.
// \param Q         The source point. This must be initialized.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          Another negative error code for other kinds of failure.
pub extern external/mbedtls-ecp-copy(^p: c-pointer<mbedtls-ecp-point-c>, ^q: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_copy((struct mbedtls_ecp_point*)#1, (struct mbedtls_ecp_point*)#2)"

pub inline fun ffi/mbedtls-ecp-copy(^p: c-pointer<mbedtls-ecp-point-c>, ^q: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-copy(p, q).int

// \brief           This function copies the contents of group \p src into
// group \p dst.
// 
// \param dst       The destination group. This must be initialized.
// \param src       The source group. This must be initialized.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-group-copy(^dst: c-pointer<mbedtls-ecp-group-c>, ^src: c-pointer<mbedtls-ecp-group-c>): int32
  c inline "(int)mbedtls_ecp_group_copy((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_group*)#2)"

pub inline fun ffi/mbedtls-ecp-group-copy(^dst: c-pointer<mbedtls-ecp-group-c>, ^src: c-pointer<mbedtls-ecp-group-c>): <> int
  external/mbedtls-ecp-group-copy(dst, src).int

// \brief           This function sets a point to the point at infinity.
// 
// \param pt        The point to set. This must be initialized.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-set-zero(^pt: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_set_zero((struct mbedtls_ecp_point*)#1)"

pub inline fun ffi/mbedtls-ecp-set-zero(^pt: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-set-zero(pt).int

// \brief           This function checks if a point is the point at infinity.
// 
// \param pt        The point to test. This must be initialized.
// 
// \return          \c 1 if the point is zero.
// \return          \c 0 if the point is non-zero.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecp-is-zero(^pt: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_is_zero((struct mbedtls_ecp_point*)#1)"

pub inline fun ffi/mbedtls-ecp-is-zero(^pt: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-is-zero(pt).int

// \brief           This function compares two points.
// 
// \note            This assumes that the points are normalized. Otherwise,
// they may compare as "not equal" even if they are.
// 
// \param P         The first point to compare. This must be initialized.
// \param Q         The second point to compare. This must be initialized.
// 
// \return          \c 0 if the points are equal.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal.
pub extern external/mbedtls-ecp-point-cmp(^p: c-pointer<mbedtls-ecp-point-c>, ^q: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_point_cmp((struct mbedtls_ecp_point*)#1, (struct mbedtls_ecp_point*)#2)"

pub inline fun ffi/mbedtls-ecp-point-cmp(^p: c-pointer<mbedtls-ecp-point-c>, ^q: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-point-cmp(p, q).int

// \brief           This function imports a non-zero point from two ASCII
// strings.
// 
// \param P         The destination point. This must be initialized.
// \param radix     The numeric base of the input.
// \param x         The first affine coordinate, as a null-terminated string.
// \param y         The second affine coordinate, as a null-terminated string.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_MPI_XXX error code on failure.
pub extern external/mbedtls-ecp-point-read-string(^p: c-pointer<mbedtls-ecp-point-c>, ^radix: int32, ^x: c-pointer<int>, ^y: c-pointer<int>): int32
  c inline "(int)mbedtls_ecp_point_read_string((struct mbedtls_ecp_point*)#1, (int)#2, (char*)#3, (char*)#4)"

pub inline fun ffi/mbedtls-ecp-point-read-string(^p: c-pointer<mbedtls-ecp-point-c>, ^radix: int, ^x: c-pointer<int>, ^y: c-pointer<int>): <> int
  external/mbedtls-ecp-point-read-string(p, radix.int32, x, y).int

// \brief           This function exports a point into unsigned binary data.
// 
// \param grp       The group to which the point should belong.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param P         The point to export. This must be initialized.
// \param format    The point format. This must be either
// #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
// (For groups without these formats, this parameter is
// ignored. But it still has to be either of the above
// values.)
// \param olen      The address at which to store the length of
// the output in Bytes. This must not be \c NULL.
// \param buf       The output buffer. This must be a writable buffer
// of length \p buflen Bytes.
// \param buflen    The length of the output buffer \p buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer
// is too small to hold the point.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format
// or the export for the given group is not implemented.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-point-write-binary(^grp: c-pointer<mbedtls-ecp-group-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^format: int32, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_ecp_point_write_binary((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (int)#3, (size_t*)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-ecp-point-write-binary(^grp: c-pointer<mbedtls-ecp-group-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^format: int, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-ecp-point-write-binary(grp, p, format.int32, olen, buf, buflen.ssize_t).int

// \brief           This function imports a point from unsigned binary data.
// 
// \note            This function does not check that the point actually
// belongs to the given group, see mbedtls_ecp_check_pubkey()
// for that.
// 
// \note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for
// limitations.
// 
// \param grp       The group to which the point should belong.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param P         The destination context to import the point to.
// This must be initialized.
// \param buf       The input buffer. This must be a readable buffer
// of length \p ilen Bytes.
// \param ilen      The length of the input buffer \p buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the
// given group is not implemented.
pub extern external/mbedtls-ecp-point-read-binary(^grp: c-pointer<mbedtls-ecp-group-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^buf: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_ecp_point_read_binary((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ecp-point-read-binary(^grp: c-pointer<mbedtls-ecp-group-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^buf: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-ecp-point-read-binary(grp, p, buf, ilen.ssize_t).int

// \brief           This function imports a point from a TLS ECPoint record.
// 
// \note            On function return, \p *buf is updated to point immediately
// after the ECPoint record.
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param pt        The destination point.
// \param buf       The address of the pointer to the start of the input buffer.
// \param len       The length of the buffer.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_MPI_XXX error code on initialization
// failure.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
pub extern external/mbedtls-ecp-tls-read-point(^grp: c-pointer<mbedtls-ecp-group-c>, ^pt: c-pointer<mbedtls-ecp-point-c>, ^buf: c-pointer<c-pointer<int>>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ecp_tls_read_point((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (unsigned char**)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ecp-tls-read-point(^grp: c-pointer<mbedtls-ecp-group-c>, ^pt: c-pointer<mbedtls-ecp-point-c>, ^buf: c-pointer<c-pointer<int>>, ^len: int): <> int
  external/mbedtls-ecp-tls-read-point(grp, pt, buf, len.ssize_t).int

// \brief           This function exports a point as a TLS ECPoint record
// defined in RFC 4492, Section 5.4.
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param pt        The point to be exported. This must be initialized.
// \param format    The point format to use. This must be either
// #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
// \param olen      The address at which to store the length in Bytes
// of the data written.
// \param buf       The target buffer. This must be a writable buffer of
// length \p blen Bytes.
// \param blen      The length of the target buffer \p buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.
// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer
// is too small to hold the exported point.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-tls-write-point(^grp: c-pointer<mbedtls-ecp-group-c>, ^pt: c-pointer<mbedtls-ecp-point-c>, ^format: int32, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: ssize_t): int32
  c inline "(int)mbedtls_ecp_tls_write_point((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (int)#3, (size_t*)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-ecp-tls-write-point(^grp: c-pointer<mbedtls-ecp-group-c>, ^pt: c-pointer<mbedtls-ecp-point-c>, ^format: int, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: int): <> int
  external/mbedtls-ecp-tls-write-point(grp, pt, format.int32, olen, buf, blen.ssize_t).int

// \brief           This function sets up an ECP group context
// from a standardized set of domain parameters.
// 
// \note            The index should be a value of the NamedCurve enum,
// as defined in <em>RFC-4492: Elliptic Curve Cryptography
// (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,
// usually in the form of an \c MBEDTLS_ECP_DP_XXX macro.
// 
// \param grp       The group context to setup. This must be initialized.
// \param id        The identifier of the domain parameter set to load.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p id doesn't
// correspond to a known group.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-group-load(^grp: c-pointer<mbedtls-ecp-group-c>, ^id: int32): int32
  c inline "(int)mbedtls_ecp_group_load((struct mbedtls_ecp_group*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-ecp-group-load(^grp: c-pointer<mbedtls-ecp-group-c>, ^id: mbedtls-ecp-group-id): <exn> int
  external/mbedtls-ecp-group-load(grp, id.mbedtls-ecp-group-id/int).int

// \brief           This function sets up an ECP group context from a TLS
// ECParameters record as defined in RFC 4492, Section 5.4.
// 
// \note            The read pointer \p buf is updated to point right after
// the ECParameters record on exit.
// 
// \param grp       The group context to setup. This must be initialized.
// \param buf       The address of the pointer to the start of the input buffer.
// \param len       The length of the input buffer \c *buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not
// recognized.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-tls-read-group(^grp: c-pointer<mbedtls-ecp-group-c>, ^buf: c-pointer<c-pointer<int>>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ecp_tls_read_group((struct mbedtls_ecp_group*)#1, (unsigned char**)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ecp-tls-read-group(^grp: c-pointer<mbedtls-ecp-group-c>, ^buf: c-pointer<c-pointer<int>>, ^len: int): <> int
  external/mbedtls-ecp-tls-read-group(grp, buf, len.ssize_t).int

// \brief           This function extracts an elliptic curve group ID from a
// TLS ECParameters record as defined in RFC 4492, Section 5.4.
// 
// \note            The read pointer \p buf is updated to point right after
// the ECParameters record on exit.
// 
// \param grp       The address at which to store the group id.
// This must not be \c NULL.
// \param buf       The address of the pointer to the start of the input buffer.
// \param len       The length of the input buffer \c *buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not
// recognized.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-tls-read-group-id(^grp: c-pointer<mbedtls-ecp-group-id>, ^buf: c-pointer<c-pointer<int>>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ecp_tls_read_group_id((int32_t*)#1, (unsigned char**)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ecp-tls-read-group-id(^grp: c-pointer<mbedtls-ecp-group-id>, ^buf: c-pointer<c-pointer<int>>, ^len: int): <> int
  external/mbedtls-ecp-tls-read-group-id(grp, buf, len.ssize_t).int

// \brief           This function exports an elliptic curve as a TLS
// ECParameters record as defined in RFC 4492, Section 5.4.
// 
// \param grp       The ECP group to be exported.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param olen      The address at which to store the number of Bytes written.
// This must not be \c NULL.
// \param buf       The buffer to write to. This must be a writable buffer
// of length \p blen Bytes.
// \param blen      The length of the output buffer \p buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output
// buffer is too small to hold the exported group.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-tls-write-group(^grp: c-pointer<mbedtls-ecp-group-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: ssize_t): int32
  c inline "(int)mbedtls_ecp_tls_write_group((struct mbedtls_ecp_group*)#1, (size_t*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ecp-tls-write-group(^grp: c-pointer<mbedtls-ecp-group-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: int): <> int
  external/mbedtls-ecp-tls-write-group(grp, olen, buf, blen.ssize_t).int

// \brief           This function performs a scalar multiplication of a point
// by an integer: \p R = \p m * \p P.
// 
// It is not thread-safe to use same group in multiple threads.
// 
// \note            To prevent timing attacks, this function
// executes the exact same sequence of base-field
// operations for any valid \p m. It avoids any if-branch or
// array index depending on the value of \p m. It also uses
// \p f_rng to randomize some intermediate results.
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param R         The point in which to store the result of the calculation.
// This must be initialized.
// \param m         The integer by which to multiply. This must be initialized.
// \param P         The point to multiply. This must be initialized.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
// NULL if \p f_rng doesn't need a context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m is not a valid private
// key, or \p P is not a valid public key.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-mul(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_mul((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_ecp_point*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecp-mul(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecp-mul(grp, r, m, p, f-rng, p-rng).int

// \brief           This function performs multiplication of a point by
// an integer: \p R = \p m * \p P in a restartable way.
// 
// \see             mbedtls_ecp_mul()
// 
// \note            This function does the same as \c mbedtls_ecp_mul(), but
// it can return early and restart according to the limit set
// with \c mbedtls_ecp_set_max_ops() to reduce blocking.
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param R         The point in which to store the result of the calculation.
// This must be initialized.
// \param m         The integer by which to multiply. This must be initialized.
// \param P         The point to multiply. This must be initialized.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
// NULL if \p f_rng doesn't need a context.
// \param rs_ctx    The restart context (NULL disables restart).
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m is not a valid private
// key, or \p P is not a valid public key.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-mul-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecp-restart-ctx>): int32
  c inline "(int)mbedtls_ecp_mul_restartable((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_ecp_point*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6, (mbedtls_ecp_restart_ctx*)#7)"

pub inline fun ffi/mbedtls-ecp-mul-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecp-restart-ctx>): <> int
  external/mbedtls-ecp-mul-restartable(grp, r, m, p, f-rng, p-rng, rs-ctx).int

// \brief           This function performs multiplication and addition of two
// points by integers: \p R = \p m * \p P + \p n * \p Q
// 
// It is not thread-safe to use same group in multiple threads.
// 
// \note            In contrast to mbedtls_ecp_mul(), this function does not
// guarantee a constant execution flow and timing.
// 
// \note            This function is only defined for short Weierstrass curves.
// It may not be included in builds without any short
// Weierstrass curve.
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param R         The point in which to store the result of the calculation.
// This must be initialized.
// \param m         The integer by which to multiply \p P.
// This must be initialized.
// \param P         The point to multiply by \p m. This must be initialized.
// \param n         The integer by which to multiply \p Q.
// This must be initialized.
// \param Q         The point to be multiplied by \p n.
// This must be initialized.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m or \p n are not
// valid private keys, or \p P or \p Q are not valid public
// keys.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p grp does not
// designate a short Weierstrass curve.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-muladd(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^n: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_muladd((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_ecp_point*)#4, (struct mbedtls_mpi*)#5, (struct mbedtls_ecp_point*)#6)"

pub inline fun ffi/mbedtls-ecp-muladd(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^n: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-muladd(grp, r, m, p, n, q).int

// \brief           This function performs multiplication and addition of two
// points by integers: \p R = \p m * \p P + \p n * \p Q in a
// restartable way.
// 
// \see             \c mbedtls_ecp_muladd()
// 
// \note            This function works the same as \c mbedtls_ecp_muladd(),
// but it can return early and restart according to the limit
// set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
// 
// \note            This function is only defined for short Weierstrass curves.
// It may not be included in builds without any short
// Weierstrass curve.
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param R         The point in which to store the result of the calculation.
// This must be initialized.
// \param m         The integer by which to multiply \p P.
// This must be initialized.
// \param P         The point to multiply by \p m. This must be initialized.
// \param n         The integer by which to multiply \p Q.
// This must be initialized.
// \param Q         The point to be multiplied by \p n.
// This must be initialized.
// \param rs_ctx    The restart context (NULL disables restart).
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m or \p n are not
// valid private keys, or \p P or \p Q are not valid public
// keys.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p grp does not
// designate a short Weierstrass curve.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-muladd-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^n: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^rs-ctx: c-pointer<mbedtls-ecp-restart-ctx>): int32
  c inline "(int)mbedtls_ecp_muladd_restartable((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_ecp_point*)#4, (struct mbedtls_mpi*)#5, (struct mbedtls_ecp_point*)#6, (mbedtls_ecp_restart_ctx*)#7)"

pub inline fun ffi/mbedtls-ecp-muladd-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-ecp-point-c>, ^m: c-pointer<mbedtls-mpi-c>, ^p: c-pointer<mbedtls-ecp-point-c>, ^n: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^rs-ctx: c-pointer<mbedtls-ecp-restart-ctx>): <> int
  external/mbedtls-ecp-muladd-restartable(grp, r, m, p, n, q, rs-ctx).int

// \brief           This function checks that a point is a valid public key
// on this curve.
// 
// It only checks that the point is non-zero, has
// valid coordinates and lies on the curve. It does not verify
// that it is indeed a multiple of \c G. This additional
// check is computationally more expensive, is not required
// by standards, and should not be necessary if the group
// used has a small cofactor. In particular, it is useless for
// the NIST groups which all have a cofactor of 1.
// 
// \note            This function uses bare components rather than an
// ::mbedtls_ecp_keypair structure, to ease use with other
// structures, such as ::mbedtls_ecdh_context or
// ::mbedtls_ecdsa_context.
// 
// \param grp       The ECP group the point should belong to.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param pt        The point to check. This must be initialized.
// 
// \return          \c 0 if the point is a valid public key.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not
// a valid public key for the given curve.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-check-pubkey(^grp: c-pointer<mbedtls-ecp-group-c>, ^pt: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_check_pubkey((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2)"

pub inline fun ffi/mbedtls-ecp-check-pubkey(^grp: c-pointer<mbedtls-ecp-group-c>, ^pt: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-check-pubkey(grp, pt).int

// \brief           This function checks that an \c mbedtls_mpi is a
// valid private key for this curve.
// 
// \note            This function uses bare components rather than an
// ::mbedtls_ecp_keypair structure to ease use with other
// structures, such as ::mbedtls_ecdh_context or
// ::mbedtls_ecdsa_context.
// 
// \param grp       The ECP group the private key should belong to.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param d         The integer to check. This must be initialized.
// 
// \return          \c 0 if the point is a valid private key.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid
// private key for the given curve.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-check-privkey(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_ecp_check_privkey((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2)"

pub inline fun ffi/mbedtls-ecp-check-privkey(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-ecp-check-privkey(grp, d).int

// \brief           This function generates a private key.
// 
// \param grp       The ECP group to generate a private key for.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param d         The destination MPI (secret part). This must be initialized.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG parameter to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
// on failure.
pub extern external/mbedtls-ecp-gen-privkey(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_gen_privkey((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-ecp-gen-privkey(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecp-gen-privkey(grp, d, f-rng, p-rng).int

// \brief           This function generates a keypair with a configurable base
// point.
// 
// \note            This function uses bare components rather than an
// ::mbedtls_ecp_keypair structure to ease use with other
// structures, such as ::mbedtls_ecdh_context or
// ::mbedtls_ecdsa_context.
// 
// \param grp       The ECP group to generate a key pair for.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param G         The base point to use. This must be initialized
// and belong to \p grp. It replaces the default base
// point \c grp->G used by mbedtls_ecp_gen_keypair().
// \param d         The destination MPI (secret part).
// This must be initialized.
// \param Q         The destination point (public part).
// This must be initialized.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may
// be \c NULL if \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
// on failure.
pub extern external/mbedtls-ecp-gen-keypair-base(^grp: c-pointer<mbedtls-ecp-group-c>, ^g: c-pointer<mbedtls-ecp-point-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_gen_keypair_base((struct mbedtls_ecp_group*)#1, (struct mbedtls_ecp_point*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_ecp_point*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecp-gen-keypair-base(^grp: c-pointer<mbedtls-ecp-group-c>, ^g: c-pointer<mbedtls-ecp-point-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecp-gen-keypair-base(grp, g, d, q, f-rng, p-rng).int

// \brief           This function generates an ECP keypair.
// 
// \note            This function uses bare components rather than an
// ::mbedtls_ecp_keypair structure to ease use with other
// structures, such as ::mbedtls_ecdh_context or
// ::mbedtls_ecdsa_context.
// 
// \param grp       The ECP group to generate a key pair for.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param d         The destination MPI (secret part).
// This must be initialized.
// \param Q         The destination point (public part).
// This must be initialized.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may
// be \c NULL if \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
// on failure.
pub extern external/mbedtls-ecp-gen-keypair(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_gen_keypair((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_ecp_point*)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-ecp-gen-keypair(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecp-gen-keypair(grp, d, q, f-rng, p-rng).int

// \brief           This function generates an ECP key.
// 
// \param grp_id    The ECP group identifier.
// \param key       The destination key. This must be initialized.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may
// be \c NULL if \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
// on failure.
pub extern external/mbedtls-ecp-gen-key(^grp-id: int32, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_gen_key((int32_t)#1, (struct mbedtls_ecp_keypair*)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-ecp-gen-key(^grp-id: mbedtls-ecp-group-id, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <exn> int
  external/mbedtls-ecp-gen-key(grp-id.mbedtls-ecp-group-id/int, key, f-rng, p-rng).int

// \brief          Set the public key in a key pair object.
// 
// \note            This function does not check that the point actually
// belongs to the given group. Call mbedtls_ecp_check_pubkey()
// on \p Q before calling this function to check that.
// 
// \note            This function does not check that the public key matches
// the private key that is already in \p key, if any.
// To check the consistency of the resulting key pair object,
// call mbedtls_ecp_check_pub_priv() after setting both
// the public key and the private key.
// 
// \param grp_id    The ECP group identifier.
// \param key       The key pair object. It must be initialized.
// If its group has already been set, it must match \p grp_id.
// If its group has not been set, it will be set to \p grp_id.
// If the public key has already been set, it is overwritten.
// \param Q         The public key to copy. This must be a point on the
// curve indicated by \p grp_id.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if \p key does not
// match \p grp_id.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for
// the group is not implemented.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-set-public-key(^grp-id: int32, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^q: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_set_public_key((int32_t)#1, (struct mbedtls_ecp_keypair*)#2, (struct mbedtls_ecp_point*)#3)"

pub inline fun ffi/mbedtls-ecp-set-public-key(^grp-id: mbedtls-ecp-group-id, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^q: c-pointer<mbedtls-ecp-point-c>): <exn> int
  external/mbedtls-ecp-set-public-key(grp-id.mbedtls-ecp-group-id/int, key, q).int

// \brief           This function reads an elliptic curve private key.
// 
// \note            This function does not set the public key in the
// key pair object. Without a public key, the key pair object
// cannot be used with operations that require the public key.
// Call mbedtls_ecp_keypair_calc_public() to set the public
// key from the private key. Alternatively, you can call
// mbedtls_ecp_set_public_key() to set the public key part,
// and then optionally mbedtls_ecp_check_pub_priv() to check
// that the private and public parts are consistent.
// 
// \note            If a public key has already been set in the key pair
// object, this function does not check that it is consistent
// with the private key. Call mbedtls_ecp_check_pub_priv()
// after setting both the public key and the private key
// to make that check.
// 
// \param grp_id    The ECP group identifier.
// \param key       The destination key.
// \param buf       The buffer containing the binary representation of the
// key. (Big endian integer for Weierstrass curves, byte
// string for Montgomery curves.)
// \param buflen    The length of the buffer in bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is
// invalid.
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for
// the group is not implemented.
// \return          Another negative error code on different kinds of failure.
pub extern external/mbedtls-ecp-read-key(^grp-id: int32, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_ecp_read_key((int32_t)#1, (struct mbedtls_ecp_keypair*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ecp-read-key(^grp-id: mbedtls-ecp-group-id, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^buf: c-pointer<int>, ^buflen: int): <exn> int
  external/mbedtls-ecp-read-key(grp-id.mbedtls-ecp-group-id/int, key, buf, buflen.ssize_t).int

// \brief           This function exports an elliptic curve private key.
// 
// \deprecated      Note that although this function accepts an output
// buffer that is smaller or larger than the key, most key
// import interfaces require the output to have exactly
// key's nominal length. It is generally simplest to
// pass the key's nominal length as \c buflen, after
// checking that the output buffer is large enough.
// See the description of the \p buflen parameter for
// how to calculate the nominal length.
// To avoid this difficulty, use mbedtls_ecp_write_key_ext()
// instead.
// mbedtls_ecp_write_key() is deprecated and will be
// removed in a future version of the library.
// 
// \note            If the private key was not set in \p key,
// the output is unspecified. Future versions
// may return an error in that case.
// 
// \param key       The private key.
// \param buf       The output buffer for containing the binary representation
// of the key.
// For Weierstrass curves, this is the big-endian
// representation, padded with null bytes at the beginning
// to reach \p buflen bytes.
// For Montgomery curves, this is the standard byte string
// representation (which is little-endian), padded with
// null bytes at the end to reach \p buflen bytes.
// \param buflen    The total length of the buffer in bytes.
// The length of the output is
// (`grp->nbits` + 7) / 8 bytes
// where `grp->nbits` is the private key size in bits.
// For Weierstrass keys, if the output buffer is smaller,
// leading zeros are trimmed to fit if possible. For
// Montgomery keys, the output buffer must always be large
// enough for the nominal length.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL or
// #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the \p key
// representation is larger than the available space in \p buf.
// \return          Another negative error code on different kinds of failure.
pub extern external/mbedtls-ecp-write-key(^key: c-pointer<mbedtls-ecp-keypair-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_ecp_write_key((struct mbedtls_ecp_keypair*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ecp-write-key(^key: c-pointer<mbedtls-ecp-keypair-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-ecp-write-key(key, buf, buflen.ssize_t).int

// \brief           This function exports an elliptic curve private key.
// 
// \param key       The private key.
// \param olen      On success, the length of the private key.
// This is always (`grp->nbits` + 7) / 8 bytes
// where `grp->nbits` is the private key size in bits.
// \param buf       The output buffer for containing the binary representation
// of the key.
// \param buflen    The total length of the buffer in bytes.
// #MBEDTLS_ECP_MAX_BYTES is always sufficient.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \p key
// representation is larger than the available space in \p buf.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if no private key is
// set in \p key.
// \return          Another negative error code on different kinds of failure.
pub extern external/mbedtls-ecp-write-key-ext(^key: c-pointer<mbedtls-ecp-keypair-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_ecp_write_key_ext((struct mbedtls_ecp_keypair*)#1, (size_t*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ecp-write-key-ext(^key: c-pointer<mbedtls-ecp-keypair-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-ecp-write-key-ext(key, olen, buf, buflen.ssize_t).int

// \brief           This function exports an elliptic curve public key.
// 
// \note            If the public key was not set in \p key,
// the output is unspecified. Future versions
// may return an error in that case.
// 
// \param key       The public key.
// \param format    The point format. This must be either
// #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
// (For groups without these formats, this parameter is
// ignored. But it still has to be either of the above
// values.)
// \param olen      The address at which to store the length of
// the output in Bytes. This must not be \c NULL.
// \param buf       The output buffer. This must be a writable buffer
// of length \p buflen Bytes.
// \param buflen    The length of the output buffer \p buf in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer
// is too small to hold the point.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format
// or the export for the given group is not implemented.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-write-public-key(^key: c-pointer<mbedtls-ecp-keypair-c>, ^format: int32, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_ecp_write_public_key((struct mbedtls_ecp_keypair*)#1, (int)#2, (size_t*)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ecp-write-public-key(^key: c-pointer<mbedtls-ecp-keypair-c>, ^format: int, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-ecp-write-public-key(key, format.int32, olen, buf, buflen.ssize_t).int

// \brief           This function checks that the keypair objects
// \p pub and \p prv have the same group and the
// same public point, and that the private key in
// \p prv is consistent with the public key.
// 
// \param pub       The keypair structure holding the public key. This
// must be initialized. If it contains a private key, that
// part is ignored.
// \param prv       The keypair structure holding the full keypair.
// This must be initialized.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
// NULL if \p f_rng doesn't need a context.
// 
// \return          \c 0 on success, meaning that the keys are valid and match.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match.
// \return          An \c MBEDTLS_ERR_ECP_XXX or an \c MBEDTLS_ERR_MPI_XXX
// error code on calculation failure.
pub extern external/mbedtls-ecp-check-pub-priv(^pub: c-pointer<mbedtls-ecp-keypair-c>, ^prv: c-pointer<mbedtls-ecp-keypair-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_check_pub_priv((struct mbedtls_ecp_keypair*)#1, (struct mbedtls_ecp_keypair*)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-ecp-check-pub-priv(^pub: c-pointer<mbedtls-ecp-keypair-c>, ^prv: c-pointer<mbedtls-ecp-keypair-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecp-check-pub-priv(pub, prv, f-rng, p-rng).int

// \brief          Calculate the public key from a private key in a key pair.
// 
// \param key       A keypair structure. It must have a private key set.
// If the public key is set, it will be overwritten.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be \c
// NULL if \p f_rng doesn't need a context.
// 
// \return          \c 0 on success. The key pair object can be used for
// operations that require the public key.
// \return          An \c MBEDTLS_ERR_ECP_XXX or an \c MBEDTLS_ERR_MPI_XXX
// error code on calculation failure.
pub extern external/mbedtls-ecp-keypair-calc-public(^key: c-pointer<mbedtls-ecp-keypair-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecp_keypair_calc_public((struct mbedtls_ecp_keypair*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3)"

pub inline fun ffi/mbedtls-ecp-keypair-calc-public(^key: c-pointer<mbedtls-ecp-keypair-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecp-keypair-calc-public(key, f-rng, p-rng).int

// \brief          Query the group that a key pair belongs to.
// 
// \param key       The key pair to query.
// 
// \return          The group ID for the group registered in the key pair
// object.
// This is \c MBEDTLS_ECP_DP_NONE if no group has been set
// in the key pair object.
pub extern external/mbedtls-ecp-keypair-get-group-id(^key: c-pointer<mbedtls-ecp-keypair-c>): int32
  c inline "(int32_t)mbedtls_ecp_keypair_get_group_id((struct mbedtls_ecp_keypair*)#1)"

pub inline fun ffi/mbedtls-ecp-keypair-get-group-id(^key: c-pointer<mbedtls-ecp-keypair-c>): <exn> mbedtls-ecp-group-id
  external/mbedtls-ecp-keypair-get-group-id(key).int/mbedtls-ecp-group-id

// \brief           This function exports generic key-pair parameters.
// 
// Each of the output parameters can be a null pointer
// if you do not need that parameter.
// 
// \note            If the private key or the public key was not set in \p key,
// the corresponding output is unspecified. Future versions
// may return an error in that case.
// 
// \param key       The key pair to export from.
// \param grp       Slot for exported ECP group.
// It must either be null or point to an initialized ECP group.
// \param d         Slot for the exported secret value.
// It must either be null or point to an initialized mpi.
// \param Q         Slot for the exported public value.
// It must either be null or point to an initialized ECP point.
// 
// \return          \c 0 on success,
// \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
// \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if key id doesn't
// correspond to a known group.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-ecp-export(^key: c-pointer<mbedtls-ecp-keypair-c>, ^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>): int32
  c inline "(int)mbedtls_ecp_export((struct mbedtls_ecp_keypair*)#1, (struct mbedtls_ecp_group*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_ecp_point*)#4)"

pub inline fun ffi/mbedtls-ecp-export(^key: c-pointer<mbedtls-ecp-keypair-c>, ^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>): <> int
  external/mbedtls-ecp-export(key, grp, d, q).int

// \brief          The ECP checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-ecp-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_ecp_self_test((int)#1)"

pub inline fun ffi/mbedtls-ecp-self-test(^verbose: int): <> int
  external/mbedtls-ecp-self-test(verbose.int32).int

// \brief          This function checks whether a given group can be used
// for ECDSA.
// 
// \param gid      The ECP group ID to check.
// 
// \return         \c 1 if the group can be used, \c 0 otherwise
pub extern external/mbedtls-ecdsa-can-do(^gid: int32): int32
  c inline "(int)mbedtls_ecdsa_can_do((int32_t)#1)"

pub inline fun ffi/mbedtls-ecdsa-can-do(^gid: mbedtls-ecp-group-id): <exn> int
  external/mbedtls-ecdsa-can-do(gid.mbedtls-ecp-group-id/int).int

// \brief           This function computes the ECDSA signature of a
// previously-hashed message.
// 
// \note            The deterministic version implemented in
// mbedtls_ecdsa_sign_det_ext() is usually preferred.
// 
// \note            If the bitlength of the message hash is larger than the
// bitlength of the group order, then the hash is truncated
// as defined in <em>Standards for Efficient Cryptography Group
// (SECG): SEC1 Elliptic Curve Cryptography</em>, section
// 4.1.3, step 5.
// 
// \see             ecp.h
// 
// \param grp       The context for the elliptic curve to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param r         The MPI context in which to store the first part
// the signature. This must be initialized.
// \param s         The MPI context in which to store the second part
// the signature. This must be initialized.
// \param d         The private signing key. This must be initialized.
// \param buf       The content to be signed. This is usually the hash of
// the original data to be signed. This must be a readable
// buffer of length \p blen Bytes. It may be \c NULL if
// \p blen is zero.
// \param blen      The length of \p buf in Bytes.
// \param f_rng     The RNG function. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context parameter.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX
// or \c MBEDTLS_MPI_XXX error code on failure.
pub extern external/mbedtls-ecdsa-sign(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdsa_sign((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (unsigned char*)#5, (size_t)#6, (int (*)(void*, unsigned char*, size_t))#7, (void*)#8)"

pub inline fun ffi/mbedtls-ecdsa-sign(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecdsa-sign(grp, r, s, d, buf, blen.ssize_t, f-rng, p-rng).int

// \brief           This function computes the ECDSA signature of a
// previously-hashed message, deterministic version.
// 
// For more information, see <em>RFC-6979: Deterministic
// Usage of the Digital Signature Algorithm (DSA) and Elliptic
// Curve Digital Signature Algorithm (ECDSA)</em>.
// 
// \note            If the bitlength of the message hash is larger than the
// bitlength of the group order, then the hash is truncated as
// defined in <em>Standards for Efficient Cryptography Group
// (SECG): SEC1 Elliptic Curve Cryptography</em>, section
// 4.1.3, step 5.
// 
// \see             ecp.h
// 
// \param grp           The context for the elliptic curve to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param r             The MPI context in which to store the first part
// the signature. This must be initialized.
// \param s             The MPI context in which to store the second part
// the signature. This must be initialized.
// \param d             The private signing key. This must be initialized
// and setup, for example through mbedtls_ecp_gen_privkey().
// \param buf           The hashed content to be signed. This must be a readable
// buffer of length \p blen Bytes. It may be \c NULL if
// \p blen is zero.
// \param blen          The length of \p buf in Bytes.
// \param md_alg        The hash algorithm used to hash the original data.
// \param f_rng_blind   The RNG function used for blinding. This must not be
// \c NULL.
// \param p_rng_blind   The RNG context to be passed to \p f_rng_blind. This
// may be \c NULL if \p f_rng_blind doesn't need a context
// parameter.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
// error code on failure.
pub extern external/mbedtls-ecdsa-sign-det-ext(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: ssize_t, ^md-alg: int32, ^f-rng-blind: c-pointer<intptr_t>, ^p-rng-blind: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdsa_sign_det_ext((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (unsigned char*)#5, (size_t)#6, (int32_t)#7, (int (*)(void*, unsigned char*, size_t))#8, (void*)#9)"

pub inline fun ffi/mbedtls-ecdsa-sign-det-ext(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: int, ^md-alg: mbedtls-md-type-t, ^f-rng-blind: c-pointer<intptr_t>, ^p-rng-blind: c-pointer<()>): <exn> int
  external/mbedtls-ecdsa-sign-det-ext(grp, r, s, d, buf, blen.ssize_t, md-alg.mbedtls-md-type-t/int, f-rng-blind, p-rng-blind).int

// \brief               This function computes the ECDSA signature of a
// previously-hashed message, in a restartable way.
// 
// \note                The deterministic version implemented in
// mbedtls_ecdsa_sign_det_restartable() is usually
// preferred.
// 
// \note                This function is like \c mbedtls_ecdsa_sign() but
// it can return early and restart according to the
// limit set with \c mbedtls_ecp_set_max_ops() to
// reduce blocking.
// 
// \note                If the bitlength of the message hash is larger
// than the bitlength of the group order, then the
// hash is truncated as defined in <em>Standards for
// Efficient Cryptography Group (SECG): SEC1 Elliptic
// Curve Cryptography</em>, section 4.1.3, step 5.
// 
// \see                 ecp.h
// 
// \param grp           The context for the elliptic curve to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param r             The MPI context in which to store the first part
// the signature. This must be initialized.
// \param s             The MPI context in which to store the second part
// the signature. This must be initialized.
// \param d             The private signing key. This must be initialized
// and setup, for example through
// mbedtls_ecp_gen_privkey().
// \param buf           The hashed content to be signed. This must be a readable
// buffer of length \p blen Bytes. It may be \c NULL if
// \p blen is zero.
// \param blen          The length of \p buf in Bytes.
// \param f_rng         The RNG function. This must not be \c NULL.
// \param p_rng         The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context parameter.
// \param f_rng_blind   The RNG function used for blinding. This must not be
// \c NULL.
// \param p_rng_blind   The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context parameter.
// \param rs_ctx        The restart context to use. This may be \c NULL
// to disable restarting. If it is not \c NULL, it
// must point to an initialized restart context.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c
// mbedtls_ecp_set_max_ops().
// \return              Another \c MBEDTLS_ERR_ECP_XXX, \c
// MBEDTLS_ERR_MPI_XXX or \c MBEDTLS_ERR_ASN1_XXX
// error code on failure.
pub extern external/mbedtls-ecdsa-sign-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^f-rng-blind: c-pointer<intptr_t>, ^p-rng-blind: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): int32
  c inline "(int)mbedtls_ecdsa_sign_restartable((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (unsigned char*)#5, (size_t)#6, (int (*)(void*, unsigned char*, size_t))#7, (void*)#8, (int (*)(void*, unsigned char*, size_t))#9, (void*)#10, (mbedtls_ecdsa_restart_ctx*)#11)"

pub inline fun ffi/mbedtls-ecdsa-sign-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^f-rng-blind: c-pointer<intptr_t>, ^p-rng-blind: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): <> int
  external/mbedtls-ecdsa-sign-restartable(grp, r, s, d, buf, blen.ssize_t, f-rng, p-rng, f-rng-blind, p-rng-blind, rs-ctx).int

// \brief               This function computes the ECDSA signature of a
// previously-hashed message, in a restartable way.
// 
// \note                This function is like \c
// mbedtls_ecdsa_sign_det_ext() but it can return
// early and restart according to the limit set with
// \c mbedtls_ecp_set_max_ops() to reduce blocking.
// 
// \note                If the bitlength of the message hash is larger
// than the bitlength of the group order, then the
// hash is truncated as defined in <em>Standards for
// Efficient Cryptography Group (SECG): SEC1 Elliptic
// Curve Cryptography</em>, section 4.1.3, step 5.
// 
// \see                 ecp.h
// 
// \param grp           The context for the elliptic curve to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param r             The MPI context in which to store the first part
// the signature. This must be initialized.
// \param s             The MPI context in which to store the second part
// the signature. This must be initialized.
// \param d             The private signing key. This must be initialized
// and setup, for example through
// mbedtls_ecp_gen_privkey().
// \param buf           The hashed content to be signed. This must be a readable
// buffer of length \p blen Bytes. It may be \c NULL if
// \p blen is zero.
// \param blen          The length of \p buf in Bytes.
// \param md_alg        The hash algorithm used to hash the original data.
// \param f_rng_blind   The RNG function used for blinding. This must not be
// \c NULL.
// \param p_rng_blind   The RNG context to be passed to \p f_rng_blind. This may be
// \c NULL if \p f_rng_blind doesn't need a context parameter.
// \param rs_ctx        The restart context to use. This may be \c NULL
// to disable restarting. If it is not \c NULL, it
// must point to an initialized restart context.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c
// mbedtls_ecp_set_max_ops().
// \return              Another \c MBEDTLS_ERR_ECP_XXX, \c
// MBEDTLS_ERR_MPI_XXX or \c MBEDTLS_ERR_ASN1_XXX
// error code on failure.
pub extern external/mbedtls-ecdsa-sign-det-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: ssize_t, ^md-alg: int32, ^f-rng-blind: c-pointer<intptr_t>, ^p-rng-blind: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): int32
  c inline "(int)mbedtls_ecdsa_sign_det_restartable((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3, (struct mbedtls_mpi*)#4, (unsigned char*)#5, (size_t)#6, (int32_t)#7, (int (*)(void*, unsigned char*, size_t))#8, (void*)#9, (mbedtls_ecdsa_restart_ctx*)#10)"

pub inline fun ffi/mbedtls-ecdsa-sign-det-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^d: c-pointer<mbedtls-mpi-c>, ^buf: c-pointer<int>, ^blen: int, ^md-alg: mbedtls-md-type-t, ^f-rng-blind: c-pointer<intptr_t>, ^p-rng-blind: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): <exn> int
  external/mbedtls-ecdsa-sign-det-restartable(grp, r, s, d, buf, blen.ssize_t, md-alg.mbedtls-md-type-t/int, f-rng-blind, p-rng-blind, rs-ctx).int

// \brief           This function verifies the ECDSA signature of a
// previously-hashed message.
// 
// \note            If the bitlength of the message hash is larger than the
// bitlength of the group order, then the hash is truncated as
// defined in <em>Standards for Efficient Cryptography Group
// (SECG): SEC1 Elliptic Curve Cryptography</em>, section
// 4.1.4, step 3.
// 
// \see             ecp.h
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param buf       The hashed content that was signed. This must be a readable
// buffer of length \p blen Bytes. It may be \c NULL if
// \p blen is zero.
// \param blen      The length of \p buf in Bytes.
// \param Q         The public key to use for verification. This must be
// initialized and setup.
// \param r         The first integer of the signature.
// This must be initialized.
// \param s         The second integer of the signature.
// This must be initialized.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
// error code on failure.
pub extern external/mbedtls-ecdsa-verify(^grp: c-pointer<mbedtls-ecp-group-c>, ^buf: c-pointer<int>, ^blen: ssize_t, ^q: c-pointer<mbedtls-ecp-point-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_ecdsa_verify((struct mbedtls_ecp_group*)#1, (unsigned char*)#2, (size_t)#3, (struct mbedtls_ecp_point*)#4, (struct mbedtls_mpi*)#5, (struct mbedtls_mpi*)#6)"

pub inline fun ffi/mbedtls-ecdsa-verify(^grp: c-pointer<mbedtls-ecp-group-c>, ^buf: c-pointer<int>, ^blen: int, ^q: c-pointer<mbedtls-ecp-point-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-ecdsa-verify(grp, buf, blen.ssize_t, q, r, s).int

// \brief           This function verifies the ECDSA signature of a
// previously-hashed message, in a restartable manner
// 
// \note            If the bitlength of the message hash is larger than the
// bitlength of the group order, then the hash is truncated as
// defined in <em>Standards for Efficient Cryptography Group
// (SECG): SEC1 Elliptic Curve Cryptography</em>, section
// 4.1.4, step 3.
// 
// \see             ecp.h
// 
// \param grp       The ECP group to use.
// This must be initialized and have group parameters
// set, for example through mbedtls_ecp_group_load().
// \param buf       The hashed content that was signed. This must be a readable
// buffer of length \p blen Bytes. It may be \c NULL if
// \p blen is zero.
// \param blen      The length of \p buf in Bytes.
// \param Q         The public key to use for verification. This must be
// initialized and setup.
// \param r         The first integer of the signature.
// This must be initialized.
// \param s         The second integer of the signature.
// This must be initialized.
// \param rs_ctx    The restart context to use. This may be \c NULL to disable
// restarting. If it is not \c NULL, it must point to an
// initialized restart context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX
// error code on failure.
pub extern external/mbedtls-ecdsa-verify-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^buf: c-pointer<int>, ^blen: ssize_t, ^q: c-pointer<mbedtls-ecp-point-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): int32
  c inline "(int)mbedtls_ecdsa_verify_restartable((struct mbedtls_ecp_group*)#1, (unsigned char*)#2, (size_t)#3, (struct mbedtls_ecp_point*)#4, (struct mbedtls_mpi*)#5, (struct mbedtls_mpi*)#6, (mbedtls_ecdsa_restart_ctx*)#7)"

pub inline fun ffi/mbedtls-ecdsa-verify-restartable(^grp: c-pointer<mbedtls-ecp-group-c>, ^buf: c-pointer<int>, ^blen: int, ^q: c-pointer<mbedtls-ecp-point-c>, ^r: c-pointer<mbedtls-mpi-c>, ^s: c-pointer<mbedtls-mpi-c>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): <> int
  external/mbedtls-ecdsa-verify-restartable(grp, buf, blen.ssize_t, q, r, s, rs-ctx).int

// \brief           This function computes the ECDSA signature and writes it
// to a buffer, serialized as defined in <em>RFC-4492:
// Elliptic Curve Cryptography (ECC) Cipher Suites for
// Transport Layer Security (TLS)</em>.
// 
// \warning         It is not thread-safe to use the same context in
// multiple threads.
// 
// \note            The deterministic version is used if
// #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more
// information, see <em>RFC-6979: Deterministic Usage
// of the Digital Signature Algorithm (DSA) and Elliptic
// Curve Digital Signature Algorithm (ECDSA)</em>.
// 
// \note            If the bitlength of the message hash is larger than the
// bitlength of the group order, then the hash is truncated as
// defined in <em>Standards for Efficient Cryptography Group
// (SECG): SEC1 Elliptic Curve Cryptography</em>, section
// 4.1.3, step 5.
// 
// \see             ecp.h
// 
// \param ctx       The ECDSA context to use. This must be initialized
// and have a group and private key bound to it, for example
// via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().
// \param md_alg    The message digest that was used to hash the message.
// \param hash      The message hash to be signed. This must be a readable
// buffer of length \p hlen Bytes.
// \param hlen      The length of the hash \p hash in Bytes.
// \param sig       The buffer to which to write the signature. This must be a
// writable buffer of length at least twice as large as the
// size of the curve used, plus 9. For example, 73 Bytes if
// a 256-bit curve is used. A buffer length of
// #MBEDTLS_ECDSA_MAX_LEN is always safe.
// \param sig_size  The size of the \p sig buffer in bytes.
// \param slen      The address at which to store the actual length of
// the signature written. Must not be \c NULL.
// \param f_rng     The RNG function. This must not be \c NULL if
// #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,
// it is used only for blinding and may be set to \c NULL, but
// doing so is DEPRECATED.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng is \c NULL or doesn't use a context.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX, \c MBEDTLS_ERR_MPI_XXX or
// \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-ecdsa-write-signature(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hlen: ssize_t, ^sig: c-pointer<int>, ^sig-size: ssize_t, ^slen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdsa_write_signature((mbedtls_ecdsa_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (size_t*)#7, (int (*)(void*, unsigned char*, size_t))#8, (void*)#9)"

pub inline fun ffi/mbedtls-ecdsa-write-signature(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hlen: int, ^sig: c-pointer<int>, ^sig-size: int, ^slen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <exn> int
  external/mbedtls-ecdsa-write-signature(ctx1, md-alg.mbedtls-md-type-t/int, hash, hlen.ssize_t, sig, sig-size.ssize_t, slen, f-rng, p-rng).int

// \brief           This function computes the ECDSA signature and writes it
// to a buffer, in a restartable way.
// 
// \see             \c mbedtls_ecdsa_write_signature()
// 
// \note            This function is like \c mbedtls_ecdsa_write_signature()
// but it can return early and restart according to the limit
// set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
// 
// \param ctx       The ECDSA context to use. This must be initialized
// and have a group and private key bound to it, for example
// via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().
// \param md_alg    The message digest that was used to hash the message.
// \param hash      The message hash to be signed. This must be a readable
// buffer of length \p hlen Bytes.
// \param hlen      The length of the hash \p hash in Bytes.
// \param sig       The buffer to which to write the signature. This must be a
// writable buffer of length at least twice as large as the
// size of the curve used, plus 9. For example, 73 Bytes if
// a 256-bit curve is used. A buffer length of
// #MBEDTLS_ECDSA_MAX_LEN is always safe.
// \param sig_size  The size of the \p sig buffer in bytes.
// \param slen      The address at which to store the actual length of
// the signature written. Must not be \c NULL.
// \param f_rng     The RNG function. This must not be \c NULL if
// #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,
// it is unused and may be set to \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng is \c NULL or doesn't use a context.
// \param rs_ctx    The restart context to use. This may be \c NULL to disable
// restarting. If it is not \c NULL, it must point to an
// initialized restart context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another \c MBEDTLS_ERR_ECP_XXX, \c MBEDTLS_ERR_MPI_XXX or
// \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-ecdsa-write-signature-restartable(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hlen: ssize_t, ^sig: c-pointer<int>, ^sig-size: ssize_t, ^slen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): int32
  c inline "(int)mbedtls_ecdsa_write_signature_restartable((mbedtls_ecdsa_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (size_t*)#7, (int (*)(void*, unsigned char*, size_t))#8, (void*)#9, (mbedtls_ecdsa_restart_ctx*)#10)"

pub inline fun ffi/mbedtls-ecdsa-write-signature-restartable(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hlen: int, ^sig: c-pointer<int>, ^sig-size: int, ^slen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): <exn> int
  external/mbedtls-ecdsa-write-signature-restartable(ctx1, md-alg.mbedtls-md-type-t/int, hash, hlen.ssize_t, sig, sig-size.ssize_t, slen, f-rng, p-rng, rs-ctx).int

// \brief           This function reads and verifies an ECDSA signature.
// 
// \note            If the bitlength of the message hash is larger than the
// bitlength of the group order, then the hash is truncated as
// defined in <em>Standards for Efficient Cryptography Group
// (SECG): SEC1 Elliptic Curve Cryptography</em>, section
// 4.1.4, step 3.
// 
// \see             ecp.h
// 
// \param ctx       The ECDSA context to use. This must be initialized
// and have a group and public key bound to it.
// \param hash      The message hash that was signed. This must be a readable
// buffer of length \p hlen Bytes.
// \param hlen      The size of the hash \p hash.
// \param sig       The signature to read and verify. This must be a readable
// buffer of length \p slen Bytes.
// \param slen      The size of \p sig in Bytes.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.
// \return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid
// signature in \p sig, but its length is less than \p siglen.
// \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_ERR_MPI_XXX
// error code on failure for any other reason.
pub extern external/mbedtls-ecdsa-read-signature(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^hash: c-pointer<int>, ^hlen: ssize_t, ^sig: c-pointer<int>, ^slen: ssize_t): int32
  c inline "(int)mbedtls_ecdsa_read_signature((mbedtls_ecdsa_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ecdsa-read-signature(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^hash: c-pointer<int>, ^hlen: int, ^sig: c-pointer<int>, ^slen: int): <> int
  external/mbedtls-ecdsa-read-signature(ctx1, hash, hlen.ssize_t, sig, slen.ssize_t).int

// \brief           This function reads and verifies an ECDSA signature,
// in a restartable way.
// 
// \see             \c mbedtls_ecdsa_read_signature()
// 
// \note            This function is like \c mbedtls_ecdsa_read_signature()
// but it can return early and restart according to the limit
// set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
// 
// \param ctx       The ECDSA context to use. This must be initialized
// and have a group and public key bound to it.
// \param hash      The message hash that was signed. This must be a readable
// buffer of length \p hlen Bytes.
// \param hlen      The size of the hash \p hash.
// \param sig       The signature to read and verify. This must be a readable
// buffer of length \p slen Bytes.
// \param slen      The size of \p sig in Bytes.
// \param rs_ctx    The restart context to use. This may be \c NULL to disable
// restarting. If it is not \c NULL, it must point to an
// initialized restart context.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.
// \return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid
// signature in \p sig, but its length is less than \p siglen.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_ERR_MPI_XXX
// error code on failure for any other reason.
pub extern external/mbedtls-ecdsa-read-signature-restartable(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^hash: c-pointer<int>, ^hlen: ssize_t, ^sig: c-pointer<int>, ^slen: ssize_t, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): int32
  c inline "(int)mbedtls_ecdsa_read_signature_restartable((mbedtls_ecdsa_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (mbedtls_ecdsa_restart_ctx*)#6)"

pub inline fun ffi/mbedtls-ecdsa-read-signature-restartable(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^hash: c-pointer<int>, ^hlen: int, ^sig: c-pointer<int>, ^slen: int, ^rs-ctx: c-pointer<mbedtls-ecdsa-restart-ctx>): <> int
  external/mbedtls-ecdsa-read-signature-restartable(ctx1, hash, hlen.ssize_t, sig, slen.ssize_t, rs-ctx).int

// \brief          This function generates an ECDSA keypair on the given curve.
// 
// \see            ecp.h
// 
// \param ctx      The ECDSA context to store the keypair in.
// This must be initialized.
// \param gid      The elliptic curve to use. One of the various
// \c MBEDTLS_ECP_DP_XXX macros depending on configuration.
// \param f_rng    The RNG function to use. This must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context argument.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_ECP_XXX code on failure.
pub extern external/mbedtls-ecdsa-genkey(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^gid: int32, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdsa_genkey((mbedtls_ecdsa_context*)#1, (int32_t)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-ecdsa-genkey(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^gid: mbedtls-ecp-group-id, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <exn> int
  external/mbedtls-ecdsa-genkey(ctx1, gid.mbedtls-ecp-group-id/int, f-rng, p-rng).int

// \brief           This function sets up an ECDSA context from an EC key pair.
// 
// \see             ecp.h
// 
// \param ctx       The ECDSA context to setup. This must be initialized.
// \param key       The EC key to use. This must be initialized and hold
// a private-public key pair or a public key. In the former
// case, the ECDSA context may be used for signature creation
// and verification after this call. In the latter case, it
// may be used for signature verification.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX code on failure.
pub extern external/mbedtls-ecdsa-from-keypair(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^key: c-pointer<mbedtls-ecp-keypair-c>): int32
  c inline "(int)mbedtls_ecdsa_from_keypair((mbedtls_ecdsa_context*)#1, (struct mbedtls_ecp_keypair*)#2)"

pub inline fun ffi/mbedtls-ecdsa-from-keypair(^ctx1: c-pointer<mbedtls-ecp-keypair-c>, ^key: c-pointer<mbedtls-ecp-keypair-c>): <> int
  external/mbedtls-ecdsa-from-keypair(ctx1, key).int

// \brief           This function initializes an ECDSA context.
// 
// \param ctx       The ECDSA context to initialize.
// This must not be \c NULL.
pub extern external/mbedtls-ecdsa-init(^ctx1: c-pointer<mbedtls-ecp-keypair-c>): ()
  c inline "(void)mbedtls_ecdsa_init((mbedtls_ecdsa_context*)#1)"

// \brief           This function frees an ECDSA context.
// 
// \param ctx       The ECDSA context to free. This may be \c NULL,
// in which case this function does nothing. If it
// is not \c NULL, it must be initialized.
pub extern external/mbedtls-ecdsa-free(^ctx1: c-pointer<mbedtls-ecp-keypair-c>): ()
  c inline "(void)mbedtls_ecdsa_free((mbedtls_ecdsa_context*)#1)"

// \brief Library initialization.
// 
// Applications must call this function before calling any other
// function in this module.
// 
// Applications may call this function more than once. Once a call
// succeeds, subsequent calls are guaranteed to succeed.
// 
// If the application calls other functions before calling psa_crypto_init(),
// the behavior is undefined. Implementations are encouraged to either perform
// the operation as if the library had been initialized or to return
// #PSA_ERROR_BAD_STATE or some other applicable error. In particular,
// implementations should not return a success status if the lack of
// initialization may have security implications, for example due to improper
// seeding of the random number generator.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
pub extern external/psa-crypto-init(): int32
  c inline "(psa_status_t)psa_crypto_init()"

pub inline fun ffi/psa-crypto-init(): <> int
  external/psa-crypto-init().int

// Return an initial value for a key attributes structure.
pub extern external/psa-key-attributes-init(): psa-key-attributes-s
  c inline "(psa_key_attributes_t)psa_key_attributes_init()"

pub inline fun ffi/psa-key-attributes-init(): <> psa-key-attributes-s-c
  external/psa-key-attributes-init()

// Declare a key as persistent and set its key identifier.
// 
// If the attribute structure currently declares the key as volatile (which
// is the default content of an attribute structure), this function sets
// the lifetime attribute to #PSA_KEY_LIFETIME_PERSISTENT.
// 
// This function does not access storage, it merely stores the given
// value in the structure.
// The persistent key will be written to storage when the attribute
// structure is passed to a key creation function such as
// psa_import_key(), psa_generate_key(), psa_generate_key_ext(),
// psa_key_derivation_output_key(), psa_key_derivation_output_key_ext()
// or psa_copy_key().
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate each of its arguments exactly once.
// 
// \param[out] attributes  The attribute structure to write to.
// \param key              The persistent identifier for the key.
pub extern external/psa-set-key-id(^attributes: c-pointer<psa-key-attributes-s-c>, ^key: int32): ()
  c inline "(void)psa_set_key_id((psa_key_attributes_t*)#1, (mbedtls_svc_key_id_t)#2)"

pub inline fun ffi/psa-set-key-id(^attributes: c-pointer<psa-key-attributes-s-c>, ^key: int): <> ()
  external/psa-set-key-id(attributes, key.int32)

// Set the location of a persistent key.
// 
// To make a key persistent, you must give it a persistent key identifier
// with psa_set_key_id(). By default, a key that has a persistent identifier
// is stored in the default storage area identifier by
// #PSA_KEY_LIFETIME_PERSISTENT. Call this function to choose a storage
// area, or to explicitly declare the key as volatile.
// 
// This function does not access storage, it merely stores the given
// value in the structure.
// The persistent key will be written to storage when the attribute
// structure is passed to a key creation function such as
// psa_import_key(), psa_generate_key(), psa_generate_key_ext(),
// psa_key_derivation_output_key(), psa_key_derivation_output_key_ext()
// or psa_copy_key().
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate each of its arguments exactly once.
// 
// \param[out] attributes       The attribute structure to write to.
// \param lifetime              The lifetime for the key.
// If this is #PSA_KEY_LIFETIME_VOLATILE, the
// key will be volatile, and the key identifier
// attribute is reset to 0.
pub extern external/psa-set-key-lifetime(^attributes: c-pointer<psa-key-attributes-s-c>, ^lifetime: int32): ()
  c inline "(void)psa_set_key_lifetime((psa_key_attributes_t*)#1, (psa_key_lifetime_t)#2)"

pub inline fun ffi/psa-set-key-lifetime(^attributes: c-pointer<psa-key-attributes-s-c>, ^lifetime: int): <> ()
  external/psa-set-key-lifetime(attributes, lifetime.int32)

// Retrieve the key identifier from key attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate its argument exactly once.
// 
// \param[in] attributes        The key attribute structure to query.
// 
// \return The persistent identifier stored in the attribute structure.
// This value is unspecified if the attribute structure declares
// the key as volatile.
pub extern external/psa-get-key-id(^attributes: c-pointer<psa-key-attributes-s-c>): int32
  c inline "(mbedtls_svc_key_id_t)psa_get_key_id((psa_key_attributes_t*)#1)"

pub inline fun ffi/psa-get-key-id(^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-id(attributes).int

// Retrieve the lifetime from key attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate its argument exactly once.
// 
// \param[in] attributes        The key attribute structure to query.
// 
// \return The lifetime value stored in the attribute structure.
pub extern external/psa-get-key-lifetime(^attributes: c-pointer<psa-key-attributes-s-c>): int32
  c inline "(psa_key_lifetime_t)psa_get_key_lifetime((psa_key_attributes_t*)#1)"

pub inline fun ffi/psa-get-key-lifetime(^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-lifetime(attributes).int

// Declare usage flags for a key.
// 
// Usage flags are part of a key's usage policy. They encode what
// kind of operations are permitted on the key. For more details,
// refer to the documentation of the type #psa_key_usage_t.
// 
// This function overwrites any usage flags
// previously set in \p attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate each of its arguments exactly once.
// 
// \param[out] attributes       The attribute structure to write to.
// \param usage_flags           The usage flags to write.
pub extern external/psa-set-key-usage-flags(^attributes: c-pointer<psa-key-attributes-s-c>, ^usage-flags: int32): ()
  c inline "(void)psa_set_key_usage_flags((psa_key_attributes_t*)#1, (psa_key_usage_t)#2)"

pub inline fun ffi/psa-set-key-usage-flags(^attributes: c-pointer<psa-key-attributes-s-c>, ^usage-flags: int): <> ()
  external/psa-set-key-usage-flags(attributes, usage-flags.int32)

// Retrieve the usage flags from key attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate its argument exactly once.
// 
// \param[in] attributes        The key attribute structure to query.
// 
// \return The usage flags stored in the attribute structure.
pub extern external/psa-get-key-usage-flags(^attributes: c-pointer<psa-key-attributes-s-c>): int32
  c inline "(psa_key_usage_t)psa_get_key_usage_flags((psa_key_attributes_t*)#1)"

pub inline fun ffi/psa-get-key-usage-flags(^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-usage-flags(attributes).int

// Declare the permitted algorithm policy for a key.
// 
// The permitted algorithm policy of a key encodes which algorithm or
// algorithms are permitted to be used with this key. The following
// algorithm policies are supported:
// - 0 does not allow any cryptographic operation with the key. The key
// may be used for non-cryptographic actions such as exporting (if
// permitted by the usage flags).
// - An algorithm value permits this particular algorithm.
// - An algorithm wildcard built from #PSA_ALG_ANY_HASH allows the specified
// signature scheme with any hash algorithm.
// - An algorithm built from #PSA_ALG_AT_LEAST_THIS_LENGTH_MAC allows
// any MAC algorithm from the same base class (e.g. CMAC) which
// generates/verifies a MAC length greater than or equal to the length
// encoded in the wildcard algorithm.
// - An algorithm built from #PSA_ALG_AEAD_WITH_AT_LEAST_THIS_LENGTH_TAG
// allows any AEAD algorithm from the same base class (e.g. CCM) which
// generates/verifies a tag length greater than or equal to the length
// encoded in the wildcard algorithm.
// 
// This function overwrites any algorithm policy
// previously set in \p attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate each of its arguments exactly once.
// 
// \param[out] attributes       The attribute structure to write to.
// \param alg                   The permitted algorithm policy to write.
pub extern external/psa-set-key-algorithm(^attributes: c-pointer<psa-key-attributes-s-c>, ^alg: int32): ()
  c inline "(void)psa_set_key_algorithm((psa_key_attributes_t*)#1, (psa_algorithm_t)#2)"

pub inline fun ffi/psa-set-key-algorithm(^attributes: c-pointer<psa-key-attributes-s-c>, ^alg: int): <> ()
  external/psa-set-key-algorithm(attributes, alg.int32)

// Retrieve the algorithm policy from key attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate its argument exactly once.
// 
// \param[in] attributes        The key attribute structure to query.
// 
// \return The algorithm stored in the attribute structure.
pub extern external/psa-get-key-algorithm(^attributes: c-pointer<psa-key-attributes-s-c>): int32
  c inline "(psa_algorithm_t)psa_get_key_algorithm((psa_key_attributes_t*)#1)"

pub inline fun ffi/psa-get-key-algorithm(^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-algorithm(attributes).int

// Declare the type of a key.
// 
// This function overwrites any key type
// previously set in \p attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate each of its arguments exactly once.
// 
// \param[out] attributes       The attribute structure to write to.
// \param type                  The key type to write.
// If this is 0, the key type in \p attributes
// becomes unspecified.
pub extern external/psa-set-key-type(^attributes: c-pointer<psa-key-attributes-s-c>, ^type1: int16): ()
  c inline "(void)psa_set_key_type((psa_key_attributes_t*)#1, (psa_key_type_t)#2)"

pub inline fun ffi/psa-set-key-type(^attributes: c-pointer<psa-key-attributes-s-c>, ^type1: int): <> ()
  external/psa-set-key-type(attributes, type1.int16)

// Declare the size of a key.
// 
// This function overwrites any key size previously set in \p attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate each of its arguments exactly once.
// 
// \param[out] attributes       The attribute structure to write to.
// \param bits                  The key size in bits.
// If this is 0, the key size in \p attributes
// becomes unspecified. Keys of size 0 are
// not supported.
pub extern external/psa-set-key-bits(^attributes: c-pointer<psa-key-attributes-s-c>, ^bits: ssize_t): ()
  c inline "(void)psa_set_key_bits((psa_key_attributes_t*)#1, (size_t)#2)"

pub inline fun ffi/psa-set-key-bits(^attributes: c-pointer<psa-key-attributes-s-c>, ^bits: int): <> ()
  external/psa-set-key-bits(attributes, bits.ssize_t)

// Retrieve the key type from key attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate its argument exactly once.
// 
// \param[in] attributes        The key attribute structure to query.
// 
// \return The key type stored in the attribute structure.
pub extern external/psa-get-key-type(^attributes: c-pointer<psa-key-attributes-s-c>): int16
  c inline "(psa_key_type_t)psa_get_key_type((psa_key_attributes_t*)#1)"

pub inline fun ffi/psa-get-key-type(^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-type(attributes).int

// Retrieve the key size from key attributes.
// 
// This function may be declared as `static` (i.e. without external
// linkage). This function may be provided as a function-like macro,
// but in this case it must evaluate its argument exactly once.
// 
// \param[in] attributes        The key attribute structure to query.
// 
// \return The key size stored in the attribute structure, in bits.
pub extern external/psa-get-key-bits(^attributes: c-pointer<psa-key-attributes-s-c>): ssize_t
  c inline "(size_t)psa_get_key_bits((psa_key_attributes_t*)#1)"

pub inline fun ffi/psa-get-key-bits(^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-bits(attributes).int

// Retrieve the attributes of a key.
// 
// This function first resets the attribute structure as with
// psa_reset_key_attributes(). It then copies the attributes of
// the given key into the given attribute structure.
// 
// \note This function may allocate memory or other resources.
// Once you have called this function on an attribute structure,
// you must call psa_reset_key_attributes() to free these resources.
// 
// \param[in] key               Identifier of the key to query.
// \param[in,out] attributes    On success, the attributes of the key.
// On failure, equivalent to a
// freshly-initialized structure.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-get-key-attributes(^key: int32, ^attributes: c-pointer<psa-key-attributes-s-c>): int32
  c inline "(psa_status_t)psa_get_key_attributes((mbedtls_svc_key_id_t)#1, (psa_key_attributes_t*)#2)"

pub inline fun ffi/psa-get-key-attributes(^key: int, ^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/psa-get-key-attributes(key.int32, attributes).int

// Reset a key attribute structure to a freshly initialized state.
// 
// You must initialize the attribute structure as described in the
// documentation of the type #psa_key_attributes_t before calling this
// function. Once the structure has been initialized, you may call this
// function at any time.
// 
// This function frees any auxiliary resources that the structure
// may contain.
// 
// \param[in,out] attributes    The attribute structure to reset.
pub extern external/psa-reset-key-attributes(^attributes: c-pointer<psa-key-attributes-s-c>): ()
  c inline "(void)psa_reset_key_attributes((psa_key_attributes_t*)#1)"

// Remove non-essential copies of key material from memory.
// 
// If the key identifier designates a volatile key, this functions does not do
// anything and returns successfully.
// 
// If the key identifier designates a persistent key, then this function will
// free all resources associated with the key in volatile memory. The key
// data in persistent storage is not affected and the key can still be used.
// 
// \param key Identifier of the key to purge.
// 
// \retval #PSA_SUCCESS
// The key material will have been removed from memory if it is not
// currently required.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not a valid key identifier.
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-purge-key(^key: int32): int32
  c inline "(psa_status_t)psa_purge_key((mbedtls_svc_key_id_t)#1)"

pub inline fun ffi/psa-purge-key(^key: int): <> int
  external/psa-purge-key(key.int32).int

// Make a copy of a key.
// 
// Copy key material from one location to another.
// 
// This function is primarily useful to copy a key from one location
// to another, since it populates a key using the material from
// another key which may have a different lifetime.
// 
// This function may be used to share a key with a different party,
// subject to implementation-defined restrictions on key sharing.
// 
// The policy on the source key must have the usage flag
// #PSA_KEY_USAGE_COPY set.
// This flag is sufficient to permit the copy if the key has the lifetime
// #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT.
// Some secure elements do not provide a way to copy a key without
// making it extractable from the secure element. If a key is located
// in such a secure element, then the key must have both usage flags
// #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make
// a copy of the key outside the secure element.
// 
// The resulting key may only be used in a way that conforms to
// both the policy of the original key and the policy specified in
// the \p attributes parameter:
// - The usage flags on the resulting key are the bitwise-and of the
// usage flags on the source policy and the usage flags in \p attributes.
// - If both allow the same algorithm or wildcard-based
// algorithm policy, the resulting key has the same algorithm policy.
// - If either of the policies allows an algorithm and the other policy
// allows a wildcard-based algorithm policy that includes this algorithm,
// the resulting key allows the same algorithm.
// - If the policies do not allow any algorithm in common, this function
// fails with the status #PSA_ERROR_INVALID_ARGUMENT.
// 
// The effect of this function on implementation-defined attributes is
// implementation-defined.
// 
// \param source_key        The key to copy. It must allow the usage
// #PSA_KEY_USAGE_COPY. If a private or secret key is
// being copied outside of a secure element it must
// also allow #PSA_KEY_USAGE_EXPORT.
// \param[in] attributes    The attributes for the new key.
// They are used as follows:
// - The key type and size may be 0. If either is
// nonzero, it must match the corresponding
// attribute of the source key.
// - The key location (the lifetime and, for
// persistent keys, the key identifier) is
// used directly.
// - The policy constraints (usage flags and
// algorithm policy) are combined from
// the source key and \p attributes so that
// both sets of restrictions apply, as
// described in the documentation of this function.
// \param[out] target_key   On success, an identifier for the newly created
// key. For persistent keys, this is the key
// identifier defined in \p attributes.
// \c 0 on failure.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE
// \p source_key is invalid.
// \retval #PSA_ERROR_ALREADY_EXISTS
// This is an attempt to create a persistent key, and there is
// already a persistent key with the given identifier.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The lifetime or identifier in \p attributes are invalid, or
// the policy constraints on the source and specified in
// \p attributes are incompatible, or
// \p attributes specifies a key type or key size
// which does not match the attributes of the source key.
// \retval #PSA_ERROR_NOT_PERMITTED
// The source key does not have the #PSA_KEY_USAGE_COPY usage flag, or
// the source key is not exportable and its lifetime does not
// allow copying it to the target's lifetime.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-copy-key(^source-key: int32, ^attributes: c-pointer<psa-key-attributes-s-c>, ^target-key: c-pointer<int>): int32
  c inline "(psa_status_t)psa_copy_key((mbedtls_svc_key_id_t)#1, (psa_key_attributes_t*)#2, (mbedtls_svc_key_id_t*)#3)"

pub inline fun ffi/psa-copy-key(^source-key: int, ^attributes: c-pointer<psa-key-attributes-s-c>, ^target-key: c-pointer<int>): <> int
  external/psa-copy-key(source-key.int32, attributes, target-key).int

// \brief Destroy a key.
// 
// This function destroys a key from both volatile
// memory and, if applicable, non-volatile storage. Implementations shall
// make a best effort to ensure that the key material cannot be recovered.
// 
// This function also erases any metadata such as policies and frees
// resources associated with the key.
// 
// If a key is currently in use in a multipart operation, then destroying the
// key will cause the multipart operation to fail.
// 
// \warning    We can only guarantee that the the key material will
// eventually be wiped from memory. With threading enabled
// and during concurrent execution, copies of the key material may
// still exist until all threads have finished using the key.
// 
// \param key  Identifier of the key to erase. If this is \c 0, do nothing and
// return #PSA_SUCCESS.
// 
// \retval #PSA_SUCCESS
// \p key was a valid identifier and the key material that it
// referred to has been erased. Alternatively, \p key is \c 0.
// \retval #PSA_ERROR_NOT_PERMITTED
// The key cannot be erased because it is
// read-only, either due to a policy or due to physical restrictions.
// \retval #PSA_ERROR_INVALID_HANDLE
// \p key is not a valid identifier nor \c 0.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE
// There was a failure in communication with the cryptoprocessor.
// The key material may still be present in the cryptoprocessor.
// \retval #PSA_ERROR_DATA_INVALID
// This error is typically a result of either storage corruption on a
// cleartext storage backend, or an attempt to read data that was
// written by an incompatible version of the library.
// \retval #PSA_ERROR_STORAGE_FAILURE
// The storage is corrupted. Implementations shall make a best effort
// to erase key material even in this stage, however applications
// should be aware that it may be impossible to guarantee that the
// key material is not recoverable in such cases.
// \retval #PSA_ERROR_CORRUPTION_DETECTED
// An unexpected condition which is not a storage corruption or
// a communication failure occurred. The cryptoprocessor may have
// been compromised.
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-destroy-key(^key: int32): int32
  c inline "(psa_status_t)psa_destroy_key((mbedtls_svc_key_id_t)#1)"

pub inline fun ffi/psa-destroy-key(^key: int): <> int
  external/psa-destroy-key(key.int32).int

// \brief Import a key in binary format.
// 
// This function supports any output from psa_export_key(). Refer to the
// documentation of psa_export_public_key() for the format of public keys
// and to the documentation of psa_export_key() for the format for
// other key types.
// 
// The key data determines the key size. The attributes may optionally
// specify a key size; in this case it must match the size determined
// from the key data. A key size of 0 in \p attributes indicates that
// the key size is solely determined by the key data.
// 
// Implementations must reject an attempt to import a key of size 0.
// 
// This specification supports a single format for each key type.
// Implementations may support other formats as long as the standard
// format is supported. Implementations that support other formats
// should ensure that the formats are clearly unambiguous so as to
// minimize the risk that an invalid input is accidentally interpreted
// according to a different format.
// 
// \param[in] attributes    The attributes for the new key.
// The key size is always determined from the
// \p data buffer.
// If the key size in \p attributes is nonzero,
// it must be equal to the size from \p data.
// \param[out] key          On success, an identifier to the newly created key.
// For persistent keys, this is the key identifier
// defined in \p attributes.
// \c 0 on failure.
// \param[in] data    Buffer containing the key data. The content of this
// buffer is interpreted according to the type declared
// in \p attributes.
// All implementations must support at least the format
// described in the documentation
// of psa_export_key() or psa_export_public_key() for
// the chosen type. Implementations may allow other
// formats, but should be conservative: implementations
// should err on the side of rejecting content if it
// may be erroneous (e.g. wrong type or truncated data).
// \param data_length Size of the \p data buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// If the key is persistent, the key material and the key's metadata
// have been saved to persistent storage.
// \retval #PSA_ERROR_ALREADY_EXISTS
// This is an attempt to create a persistent key, and there is
// already a persistent key with the given identifier.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The key type or key size is not supported, either by the
// implementation in general or in this particular persistent location.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The key attributes, as a whole, are invalid, or
// the key data is not correctly formatted, or
// the size in \p attributes is nonzero and does not match the size
// of the key data.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-import-key(^attributes: c-pointer<psa-key-attributes-s-c>, ^data: c-pointer<int>, ^data-length: ssize_t, ^key: c-pointer<int>): int32
  c inline "(psa_status_t)psa_import_key((psa_key_attributes_t*)#1, (uint8_t*)#2, (size_t)#3, (mbedtls_svc_key_id_t*)#4)"

pub inline fun ffi/psa-import-key(^attributes: c-pointer<psa-key-attributes-s-c>, ^data: c-pointer<int>, ^data-length: int, ^key: c-pointer<int>): <> int
  external/psa-import-key(attributes, data, data-length.ssize_t, key).int

// \brief Export a key in binary format.
// 
// The output of this function can be passed to psa_import_key() to
// create an equivalent object.
// 
// If the implementation of psa_import_key() supports other formats
// beyond the format specified here, the output from psa_export_key()
// must use the representation specified here, not the original
// representation.
// 
// For standard key types, the output format is as follows:
// 
// - For symmetric keys (including MAC keys), the format is the
// raw bytes of the key.
// - For DES, the key data consists of 8 bytes. The parity bits must be
// correct.
// - For Triple-DES, the format is the concatenation of the
// two or three DES keys.
// - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format
// is the non-encrypted DER encoding of the representation defined by
// PKCS\#1 (RFC 8017) as `RSAPrivateKey`, version 0.
// ```
// RSAPrivateKey ::= SEQUENCE {
// version             INTEGER,  -- must be 0
// modulus             INTEGER,  -- n
// publicExponent      INTEGER,  -- e
// privateExponent     INTEGER,  -- d
// prime1              INTEGER,  -- p
// prime2              INTEGER,  -- q
// exponent1           INTEGER,  -- d mod (p-1)
// exponent2           INTEGER,  -- d mod (q-1)
// coefficient         INTEGER,  -- (inverse of q) mod p
// }
// ```
// - For elliptic curve key pairs (key types for which
// #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is
// a representation of the private value as a `ceiling(m/8)`-byte string
// where `m` is the bit size associated with the curve, i.e. the bit size
// of the order of the curve's coordinate field. This byte string is
// in little-endian order for Montgomery curves (curve types
// `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass
// curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`
// and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`).
// For Weierstrass curves, this is the content of the `privateKey` field of
// the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,
// the format is defined by RFC 7748, and output is masked according to ยง5.
// For twisted Edwards curves, the private key is as defined by RFC 8032
// (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).
// - For Diffie-Hellman key exchange key pairs (key types for which
// #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the
// format is the representation of the private key `x` as a big-endian byte
// string. The length of the byte string is the private key size in bytes
// (leading zeroes are not stripped).
// - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is
// true), the format is the same as for psa_export_public_key().
// 
// The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set.
// 
// \param key               Identifier of the key to export. It must allow the
// usage #PSA_KEY_USAGE_EXPORT, unless it is a public
// key.
// \param[out] data         Buffer where the key data is to be written.
// \param data_size         Size of the \p data buffer in bytes.
// \param[out] data_length  On success, the number of bytes
// that make up the key data.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED
// The key does not have the #PSA_KEY_USAGE_EXPORT flag.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p data buffer is too small. You can determine a
// sufficient buffer size by calling
// #PSA_EXPORT_KEY_OUTPUT_SIZE(\c type, \c bits)
// where \c type is the key type
// and \c bits is the key size in bits.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-export-key(^key: int32, ^data: c-pointer<int>, ^data-size: ssize_t, ^data-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_export_key((mbedtls_svc_key_id_t)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-export-key(^key: int, ^data: c-pointer<int>, ^data-size: int, ^data-length: c-pointer<int>): <> int
  external/psa-export-key(key.int32, data, data-size.ssize_t, data-length).int

// \brief Export a public key or the public part of a key pair in binary format.
// 
// The output of this function can be passed to psa_import_key() to
// create an object that is equivalent to the public key.
// 
// This specification supports a single format for each key type.
// Implementations may support other formats as long as the standard
// format is supported. Implementations that support other formats
// should ensure that the formats are clearly unambiguous so as to
// minimize the risk that an invalid input is accidentally interpreted
// according to a different format.
// 
// For standard key types, the output format is as follows:
// - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of
// the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`.
// ```
// RSAPublicKey ::= SEQUENCE {
// modulus            INTEGER,    -- n
// publicExponent     INTEGER  }  -- e
// ```
// - For elliptic curve keys on a twisted Edwards curve (key types for which
// #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY
// returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined
// by RFC 8032
// (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).
// - For other elliptic curve public keys (key types for which
// #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed
// representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint.
// Let `m` be the bit size associated with the curve, i.e. the bit size of
// `q` for a curve over `F_q`. The representation consists of:
// - The byte 0x04;
// - `x_P` as a `ceiling(m/8)`-byte string, big-endian;
// - `y_P` as a `ceiling(m/8)`-byte string, big-endian.
// - For Diffie-Hellman key exchange public keys (key types for which
// #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),
// the format is the representation of the public key `y = g^x mod p` as a
// big-endian byte string. The length of the byte string is the length of the
// base prime `p` in bytes.
// 
// Exporting a public key object or the public part of a key pair is
// always permitted, regardless of the key's usage flags.
// 
// \param key               Identifier of the key to export.
// \param[out] data         Buffer where the key data is to be written.
// \param data_size         Size of the \p data buffer in bytes.
// \param[out] data_length  On success, the number of bytes
// that make up the key data.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The key is neither a public key nor a key pair.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p data buffer is too small. You can determine a
// sufficient buffer size by calling
// #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\c type), \c bits)
// where \c type is the key type
// and \c bits is the key size in bits.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-export-public-key(^key: int32, ^data: c-pointer<int>, ^data-size: ssize_t, ^data-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_export_public_key((mbedtls_svc_key_id_t)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-export-public-key(^key: int, ^data: c-pointer<int>, ^data-size: int, ^data-length: c-pointer<int>): <> int
  external/psa-export-public-key(key.int32, data, data-size.ssize_t, data-length).int

// Calculate the hash (digest) of a message.
// 
// \note To verify the hash of a message against an
// expected value, use psa_hash_compare() instead.
// 
// \param alg               The hash algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_HASH(\p alg) is true).
// \param[in] input         Buffer containing the message to hash.
// \param input_length      Size of the \p input buffer in bytes.
// \param[out] hash         Buffer where the hash is to be written.
// \param hash_size         Size of the \p hash buffer in bytes.
// \param[out] hash_length  On success, the number of bytes
// that make up the hash value. This is always
// #PSA_HASH_LENGTH(\p alg).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a hash algorithm.
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// \p hash_size is too small
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-compute(^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^hash: c-pointer<int>, ^hash-size: ssize_t, ^hash-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_hash_compute((psa_algorithm_t)#1, (uint8_t*)#2, (size_t)#3, (uint8_t*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/psa-hash-compute(^alg: int, ^input: c-pointer<int>, ^input-length: int, ^hash: c-pointer<int>, ^hash-size: int, ^hash-length: c-pointer<int>): <> int
  external/psa-hash-compute(alg.int32, input, input-length.ssize_t, hash, hash-size.ssize_t, hash-length).int

// Calculate the hash (digest) of a message and compare it with a
// reference value.
// 
// \param alg               The hash algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_HASH(\p alg) is true).
// \param[in] input         Buffer containing the message to hash.
// \param input_length      Size of the \p input buffer in bytes.
// \param[out] hash         Buffer containing the expected hash value.
// \param hash_length       Size of the \p hash buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The expected hash is identical to the actual hash of the input.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The hash of the message was calculated successfully, but it
// differs from the expected hash.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a hash algorithm.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p input_length or \p hash_length do not match the hash size for \p alg
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-compare(^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^hash: c-pointer<int>, ^hash-length: ssize_t): int32
  c inline "(psa_status_t)psa_hash_compare((psa_algorithm_t)#1, (uint8_t*)#2, (size_t)#3, (uint8_t*)#4, (size_t)#5)"

pub inline fun ffi/psa-hash-compare(^alg: int, ^input: c-pointer<int>, ^input-length: int, ^hash: c-pointer<int>, ^hash-length: int): <> int
  external/psa-hash-compare(alg.int32, input, input-length.ssize_t, hash, hash-length.ssize_t).int

// Return an initial value for a hash operation object.
pub extern external/psa-hash-operation-init(): psa-hash-operation-s
  c inline "(psa_hash_operation_t)psa_hash_operation_init()"

pub inline fun ffi/psa-hash-operation-init(): <> psa-hash-operation-s-c
  external/psa-hash-operation-init()

// Set up a multipart hash operation.
// 
// The sequence of operations to calculate a hash (message digest)
// is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT.
// -# Call psa_hash_setup() to specify the algorithm.
// -# Call psa_hash_update() zero, one or more times, passing a fragment
// of the message each time. The hash that is calculated is the hash
// of the concatenation of these messages in order.
// -# To calculate the hash, call psa_hash_finish().
// To compare the hash with an expected value, call psa_hash_verify().
// 
// If an error occurs at any step after a call to psa_hash_setup(), the
// operation will need to be reset by a call to psa_hash_abort(). The
// application may call psa_hash_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_hash_setup(), the application must
// eventually terminate the operation. The following events terminate an
// operation:
// - A successful call to psa_hash_finish() or psa_hash_verify().
// - A call to psa_hash_abort().
// 
// \param[in,out] operation The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_hash_operation_t and not yet in use.
// \param alg               The hash algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_HASH(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not a supported hash algorithm.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p alg is not a hash algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-setup(^operation: c-pointer<psa-hash-operation-s-c>, ^alg: int32): int32
  c inline "(psa_status_t)psa_hash_setup((psa_hash_operation_t*)#1, (psa_algorithm_t)#2)"

pub inline fun ffi/psa-hash-setup(^operation: c-pointer<psa-hash-operation-s-c>, ^alg: int): <> int
  external/psa-hash-setup(operation, alg.int32).int

// Add a message fragment to a multipart hash operation.
// 
// The application must call psa_hash_setup() before calling this function.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_hash_abort().
// 
// \param[in,out] operation Active hash operation.
// \param[in] input         Buffer containing the message fragment to hash.
// \param input_length      Size of the \p input buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-update(^operation: c-pointer<psa-hash-operation-s-c>, ^input: c-pointer<int>, ^input-length: ssize_t): int32
  c inline "(psa_status_t)psa_hash_update((psa_hash_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-hash-update(^operation: c-pointer<psa-hash-operation-s-c>, ^input: c-pointer<int>, ^input-length: int): <> int
  external/psa-hash-update(operation, input, input-length.ssize_t).int

// Finish the calculation of the hash of a message.
// 
// The application must call psa_hash_setup() before calling this function.
// This function calculates the hash of the message formed by concatenating
// the inputs passed to preceding calls to psa_hash_update().
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_hash_abort().
// 
// \warning Applications should not call this function if they expect
// a specific value for the hash. Call psa_hash_verify() instead.
// Beware that comparing integrity or authenticity data such as
// hash values with a function such as \c memcmp is risky
// because the time taken by the comparison may leak information
// about the hashed data which could allow an attacker to guess
// a valid hash and thereby bypass security controls.
// 
// \param[in,out] operation     Active hash operation.
// \param[out] hash             Buffer where the hash is to be written.
// \param hash_size             Size of the \p hash buffer in bytes.
// \param[out] hash_length      On success, the number of bytes
// that make up the hash value. This is always
// #PSA_HASH_LENGTH(\c alg) where \c alg is the
// hash algorithm that is calculated.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p hash buffer is too small. You can determine a
// sufficient buffer size by calling #PSA_HASH_LENGTH(\c alg)
// where \c alg is the hash algorithm that is calculated.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-finish(^operation: c-pointer<psa-hash-operation-s-c>, ^hash: c-pointer<int>, ^hash-size: ssize_t, ^hash-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_hash_finish((psa_hash_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-hash-finish(^operation: c-pointer<psa-hash-operation-s-c>, ^hash: c-pointer<int>, ^hash-size: int, ^hash-length: c-pointer<int>): <> int
  external/psa-hash-finish(operation, hash, hash-size.ssize_t, hash-length).int

// Finish the calculation of the hash of a message and compare it with
// an expected value.
// 
// The application must call psa_hash_setup() before calling this function.
// This function calculates the hash of the message formed by concatenating
// the inputs passed to preceding calls to psa_hash_update(). It then
// compares the calculated hash with the expected hash passed as a
// parameter to this function.
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_hash_abort().
// 
// \note Implementations shall make the best effort to ensure that the
// comparison between the actual hash and the expected hash is performed
// in constant time.
// 
// \param[in,out] operation     Active hash operation.
// \param[in] hash              Buffer containing the expected hash value.
// \param hash_length           Size of the \p hash buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The expected hash is identical to the actual hash of the message.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The hash of the message was calculated successfully, but it
// differs from the expected hash.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-verify(^operation: c-pointer<psa-hash-operation-s-c>, ^hash: c-pointer<int>, ^hash-length: ssize_t): int32
  c inline "(psa_status_t)psa_hash_verify((psa_hash_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-hash-verify(^operation: c-pointer<psa-hash-operation-s-c>, ^hash: c-pointer<int>, ^hash-length: int): <> int
  external/psa-hash-verify(operation, hash, hash-length.ssize_t).int

// Abort a hash operation.
// 
// Aborting an operation frees all associated resources except for the
// \p operation structure itself. Once aborted, the operation object
// can be reused for another operation by calling
// psa_hash_setup() again.
// 
// You may call this function any time after the operation object has
// been initialized by one of the methods described in #psa_hash_operation_t.
// 
// In particular, calling psa_hash_abort() after the operation has been
// terminated by a call to psa_hash_abort(), psa_hash_finish() or
// psa_hash_verify() is safe and has no effect.
// 
// \param[in,out] operation     Initialized hash operation.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-abort(^operation: c-pointer<psa-hash-operation-s-c>): int32
  c inline "(psa_status_t)psa_hash_abort((psa_hash_operation_t*)#1)"

pub inline fun ffi/psa-hash-abort(^operation: c-pointer<psa-hash-operation-s-c>): <> int
  external/psa-hash-abort(operation).int

// Clone a hash operation.
// 
// This function copies the state of an ongoing hash operation to
// a new operation object. In other words, this function is equivalent
// to calling psa_hash_setup() on \p target_operation with the same
// algorithm that \p source_operation was set up for, then
// psa_hash_update() on \p target_operation with the same input that
// that was passed to \p source_operation. After this function returns, the
// two objects are independent, i.e. subsequent calls involving one of
// the objects do not affect the other object.
// 
// \param[in] source_operation      The active hash operation to clone.
// \param[in,out] target_operation  The operation object to set up.
// It must be initialized but not active.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The \p source_operation state is not valid (it must be active), or
// the \p target_operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-hash-clone(^source-operation: c-pointer<psa-hash-operation-s-c>, ^target-operation: c-pointer<psa-hash-operation-s-c>): int32
  c inline "(psa_status_t)psa_hash_clone((psa_hash_operation_t*)#1, (psa_hash_operation_t*)#2)"

pub inline fun ffi/psa-hash-clone(^source-operation: c-pointer<psa-hash-operation-s-c>, ^target-operation: c-pointer<psa-hash-operation-s-c>): <> int
  external/psa-hash-clone(source-operation, target-operation).int

// Calculate the MAC (message authentication code) of a message.
// 
// \note To verify the MAC of a message against an
// expected value, use psa_mac_verify() instead.
// Beware that comparing integrity or authenticity data such as
// MAC values with a function such as \c memcmp is risky
// because the time taken by the comparison may leak information
// about the MAC value which could allow an attacker to guess
// a valid MAC and thereby bypass security controls.
// 
// \param key               Identifier of the key to use for the operation. It
// must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.
// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_MAC(\p alg) is true).
// \param[in] input         Buffer containing the input message.
// \param input_length      Size of the \p input buffer in bytes.
// \param[out] mac          Buffer where the MAC value is to be written.
// \param mac_size          Size of the \p mac buffer in bytes.
// \param[out] mac_length   On success, the number of bytes
// that make up the MAC value.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a MAC algorithm.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// \p mac_size is too small
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE
// The key could not be retrieved from storage.
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-compute(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^mac: c-pointer<int>, ^mac-size: ssize_t, ^mac-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_mac_compute((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-mac-compute(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^mac: c-pointer<int>, ^mac-size: int, ^mac-length: c-pointer<int>): <> int
  external/psa-mac-compute(key.int32, alg.int32, input, input-length.ssize_t, mac, mac-size.ssize_t, mac-length).int

// Calculate the MAC of a message and compare it with a reference value.
// 
// \param key               Identifier of the key to use for the operation. It
// must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE.
// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_MAC(\p alg) is true).
// \param[in] input         Buffer containing the input message.
// \param input_length      Size of the \p input buffer in bytes.
// \param[out] mac          Buffer containing the expected MAC value.
// \param mac_length        Size of the \p mac buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The expected MAC is identical to the actual MAC of the input.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The MAC of the message was calculated successfully, but it
// differs from the expected value.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a MAC algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE
// The key could not be retrieved from storage.
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-verify(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^mac: c-pointer<int>, ^mac-length: ssize_t): int32
  c inline "(psa_status_t)psa_mac_verify((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6)"

pub inline fun ffi/psa-mac-verify(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^mac: c-pointer<int>, ^mac-length: int): <> int
  external/psa-mac-verify(key.int32, alg.int32, input, input-length.ssize_t, mac, mac-length.ssize_t).int

// Set up a multipart MAC calculation operation.
// 
// This function sets up the calculation of the MAC
// (message authentication code) of a byte string.
// To verify the MAC of a message against an
// expected value, use psa_mac_verify_setup() instead.
// 
// The sequence of operations to calculate a MAC is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.
// -# Call psa_mac_sign_setup() to specify the algorithm and key.
// -# Call psa_mac_update() zero, one or more times, passing a fragment
// of the message each time. The MAC that is calculated is the MAC
// of the concatenation of these messages in order.
// -# At the end of the message, call psa_mac_sign_finish() to finish
// calculating the MAC value and retrieve it.
// 
// If an error occurs at any step after a call to psa_mac_sign_setup(), the
// operation will need to be reset by a call to psa_mac_abort(). The
// application may call psa_mac_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_mac_sign_setup(), the application must
// eventually terminate the operation through one of the following methods:
// - A successful call to psa_mac_sign_finish().
// - A call to psa_mac_abort().
// 
// \param[in,out] operation The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_mac_operation_t and not yet in use.
// \param key               Identifier of the key to use for the operation. It
// must remain valid until the operation terminates.
// It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.
// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_MAC(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a MAC algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE
// The key could not be retrieved from storage.
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-sign-setup(^operation: c-pointer<psa-mac-operation-s-c>, ^key: int32, ^alg: int32): int32
  c inline "(psa_status_t)psa_mac_sign_setup((psa_mac_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3)"

pub inline fun ffi/psa-mac-sign-setup(^operation: c-pointer<psa-mac-operation-s-c>, ^key: int, ^alg: int): <> int
  external/psa-mac-sign-setup(operation, key.int32, alg.int32).int

// Set up a multipart MAC verification operation.
// 
// This function sets up the verification of the MAC
// (message authentication code) of a byte string against an expected value.
// 
// The sequence of operations to verify a MAC is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.
// -# Call psa_mac_verify_setup() to specify the algorithm and key.
// -# Call psa_mac_update() zero, one or more times, passing a fragment
// of the message each time. The MAC that is calculated is the MAC
// of the concatenation of these messages in order.
// -# At the end of the message, call psa_mac_verify_finish() to finish
// calculating the actual MAC of the message and verify it against
// the expected value.
// 
// If an error occurs at any step after a call to psa_mac_verify_setup(), the
// operation will need to be reset by a call to psa_mac_abort(). The
// application may call psa_mac_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_mac_verify_setup(), the application must
// eventually terminate the operation through one of the following methods:
// - A successful call to psa_mac_verify_finish().
// - A call to psa_mac_abort().
// 
// \param[in,out] operation The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_mac_operation_t and not yet in use.
// \param key               Identifier of the key to use for the operation. It
// must remain valid until the operation terminates.
// It must allow the usage
// PSA_KEY_USAGE_VERIFY_MESSAGE.
// \param alg               The MAC algorithm to compute (\c PSA_ALG_XXX value
// such that #PSA_ALG_IS_MAC(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \c key is not compatible with \c alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \c alg is not supported or is not a MAC algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE
// The key could not be retrieved from storage.
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-verify-setup(^operation: c-pointer<psa-mac-operation-s-c>, ^key: int32, ^alg: int32): int32
  c inline "(psa_status_t)psa_mac_verify_setup((psa_mac_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3)"

pub inline fun ffi/psa-mac-verify-setup(^operation: c-pointer<psa-mac-operation-s-c>, ^key: int, ^alg: int): <> int
  external/psa-mac-verify-setup(operation, key.int32, alg.int32).int

// Add a message fragment to a multipart MAC operation.
// 
// The application must call psa_mac_sign_setup() or psa_mac_verify_setup()
// before calling this function.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_mac_abort().
// 
// \param[in,out] operation Active MAC operation.
// \param[in] input         Buffer containing the message fragment to add to
// the MAC calculation.
// \param input_length      Size of the \p input buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-update(^operation: c-pointer<psa-mac-operation-s-c>, ^input: c-pointer<int>, ^input-length: ssize_t): int32
  c inline "(psa_status_t)psa_mac_update((psa_mac_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-mac-update(^operation: c-pointer<psa-mac-operation-s-c>, ^input: c-pointer<int>, ^input-length: int): <> int
  external/psa-mac-update(operation, input, input-length.ssize_t).int

// Finish the calculation of the MAC of a message.
// 
// The application must call psa_mac_sign_setup() before calling this function.
// This function calculates the MAC of the message formed by concatenating
// the inputs passed to preceding calls to psa_mac_update().
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_mac_abort().
// 
// \warning Applications should not call this function if they expect
// a specific value for the MAC. Call psa_mac_verify_finish() instead.
// Beware that comparing integrity or authenticity data such as
// MAC values with a function such as \c memcmp is risky
// because the time taken by the comparison may leak information
// about the MAC value which could allow an attacker to guess
// a valid MAC and thereby bypass security controls.
// 
// \param[in,out] operation Active MAC operation.
// \param[out] mac          Buffer where the MAC value is to be written.
// \param mac_size          Size of the \p mac buffer in bytes.
// \param[out] mac_length   On success, the number of bytes
// that make up the MAC value. This is always
// #PSA_MAC_LENGTH(\c key_type, \c key_bits, \c alg)
// where \c key_type and \c key_bits are the type and
// bit-size respectively of the key and \c alg is the
// MAC algorithm that is calculated.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p mac buffer is too small. You can determine a
// sufficient buffer size by calling PSA_MAC_LENGTH().
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be an active mac sign
// operation), or the library has not been previously initialized
// by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-sign-finish(^operation: c-pointer<psa-mac-operation-s-c>, ^mac: c-pointer<int>, ^mac-size: ssize_t, ^mac-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_mac_sign_finish((psa_mac_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-mac-sign-finish(^operation: c-pointer<psa-mac-operation-s-c>, ^mac: c-pointer<int>, ^mac-size: int, ^mac-length: c-pointer<int>): <> int
  external/psa-mac-sign-finish(operation, mac, mac-size.ssize_t, mac-length).int

// Finish the calculation of the MAC of a message and compare it with
// an expected value.
// 
// The application must call psa_mac_verify_setup() before calling this function.
// This function calculates the MAC of the message formed by concatenating
// the inputs passed to preceding calls to psa_mac_update(). It then
// compares the calculated MAC with the expected MAC passed as a
// parameter to this function.
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_mac_abort().
// 
// \note Implementations shall make the best effort to ensure that the
// comparison between the actual MAC and the expected MAC is performed
// in constant time.
// 
// \param[in,out] operation Active MAC operation.
// \param[in] mac           Buffer containing the expected MAC value.
// \param mac_length        Size of the \p mac buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The expected MAC is identical to the actual MAC of the message.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The MAC of the message was calculated successfully, but it
// differs from the expected MAC.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be an active mac verify
// operation), or the library has not been previously initialized
// by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-verify-finish(^operation: c-pointer<psa-mac-operation-s-c>, ^mac: c-pointer<int>, ^mac-length: ssize_t): int32
  c inline "(psa_status_t)psa_mac_verify_finish((psa_mac_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-mac-verify-finish(^operation: c-pointer<psa-mac-operation-s-c>, ^mac: c-pointer<int>, ^mac-length: int): <> int
  external/psa-mac-verify-finish(operation, mac, mac-length.ssize_t).int

// Abort a MAC operation.
// 
// Aborting an operation frees all associated resources except for the
// \p operation structure itself. Once aborted, the operation object
// can be reused for another operation by calling
// psa_mac_sign_setup() or psa_mac_verify_setup() again.
// 
// You may call this function any time after the operation object has
// been initialized by one of the methods described in #psa_mac_operation_t.
// 
// In particular, calling psa_mac_abort() after the operation has been
// terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or
// psa_mac_verify_finish() is safe and has no effect.
// 
// \param[in,out] operation Initialized MAC operation.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-mac-abort(^operation: c-pointer<psa-mac-operation-s-c>): int32
  c inline "(psa_status_t)psa_mac_abort((psa_mac_operation_t*)#1)"

pub inline fun ffi/psa-mac-abort(^operation: c-pointer<psa-mac-operation-s-c>): <> int
  external/psa-mac-abort(operation).int

// Encrypt a message using a symmetric cipher.
// 
// This function encrypts a message with a random IV (initialization
// vector). Use the multipart operation interface with a
// #psa_cipher_operation_t object to provide other forms of IV.
// 
// \param key                   Identifier of the key to use for the operation.
// It must allow the usage #PSA_KEY_USAGE_ENCRYPT.
// \param alg                   The cipher algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_CIPHER(\p alg) is true).
// \param[in] input             Buffer containing the message to encrypt.
// \param input_length          Size of the \p input buffer in bytes.
// \param[out] output           Buffer where the output is to be written.
// The output contains the IV followed by
// the ciphertext proper.
// \param output_size           Size of the \p output buffer in bytes.
// \param[out] output_length    On success, the number of bytes
// that make up the output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a cipher algorithm.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-encrypt(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_cipher_encrypt((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-cipher-encrypt(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-cipher-encrypt(key.int32, alg.int32, input, input-length.ssize_t, output, output-size.ssize_t, output-length).int

// Decrypt a message using a symmetric cipher.
// 
// This function decrypts a message encrypted with a symmetric cipher.
// 
// \param key                   Identifier of the key to use for the operation.
// It must remain valid until the operation
// terminates. It must allow the usage
// #PSA_KEY_USAGE_DECRYPT.
// \param alg                   The cipher algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_CIPHER(\p alg) is true).
// \param[in] input             Buffer containing the message to decrypt.
// This consists of the IV followed by the
// ciphertext proper.
// \param input_length          Size of the \p input buffer in bytes.
// \param[out] output           Buffer where the plaintext is to be written.
// \param output_size           Size of the \p output buffer in bytes.
// \param[out] output_length    On success, the number of bytes
// that make up the output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a cipher algorithm.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-decrypt(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_cipher_decrypt((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-cipher-decrypt(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-cipher-decrypt(key.int32, alg.int32, input, input-length.ssize_t, output, output-size.ssize_t, output-length).int

// Set the key for a multipart symmetric encryption operation.
// 
// The sequence of operations to encrypt a message with a symmetric cipher
// is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_cipher_operation_t, e.g.
// #PSA_CIPHER_OPERATION_INIT.
// -# Call psa_cipher_encrypt_setup() to specify the algorithm and key.
// -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to
// generate or set the IV (initialization vector). You should use
// psa_cipher_generate_iv() unless the protocol you are implementing
// requires a specific IV value.
// -# Call psa_cipher_update() zero, one or more times, passing a fragment
// of the message each time.
// -# Call psa_cipher_finish().
// 
// If an error occurs at any step after a call to psa_cipher_encrypt_setup(),
// the operation will need to be reset by a call to psa_cipher_abort(). The
// application may call psa_cipher_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_cipher_encrypt_setup(), the application must
// eventually terminate the operation. The following events terminate an
// operation:
// - A successful call to psa_cipher_finish().
// - A call to psa_cipher_abort().
// 
// \param[in,out] operation     The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_cipher_operation_t and not yet in use.
// \param key                   Identifier of the key to use for the operation.
// It must remain valid until the operation
// terminates. It must allow the usage
// #PSA_KEY_USAGE_ENCRYPT.
// \param alg                   The cipher algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_CIPHER(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a cipher algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-encrypt-setup(^operation: c-pointer<psa-cipher-operation-s-c>, ^key: int32, ^alg: int32): int32
  c inline "(psa_status_t)psa_cipher_encrypt_setup((psa_cipher_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3)"

pub inline fun ffi/psa-cipher-encrypt-setup(^operation: c-pointer<psa-cipher-operation-s-c>, ^key: int, ^alg: int): <> int
  external/psa-cipher-encrypt-setup(operation, key.int32, alg.int32).int

// Set the key for a multipart symmetric decryption operation.
// 
// The sequence of operations to decrypt a message with a symmetric cipher
// is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_cipher_operation_t, e.g.
// #PSA_CIPHER_OPERATION_INIT.
// -# Call psa_cipher_decrypt_setup() to specify the algorithm and key.
// -# Call psa_cipher_set_iv() with the IV (initialization vector) for the
// decryption. If the IV is prepended to the ciphertext, you can call
// psa_cipher_update() on a buffer containing the IV followed by the
// beginning of the message.
// -# Call psa_cipher_update() zero, one or more times, passing a fragment
// of the message each time.
// -# Call psa_cipher_finish().
// 
// If an error occurs at any step after a call to psa_cipher_decrypt_setup(),
// the operation will need to be reset by a call to psa_cipher_abort(). The
// application may call psa_cipher_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_cipher_decrypt_setup(), the application must
// eventually terminate the operation. The following events terminate an
// operation:
// - A successful call to psa_cipher_finish().
// - A call to psa_cipher_abort().
// 
// \param[in,out] operation     The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_cipher_operation_t and not yet in use.
// \param key                   Identifier of the key to use for the operation.
// It must remain valid until the operation
// terminates. It must allow the usage
// #PSA_KEY_USAGE_DECRYPT.
// \param alg                   The cipher algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_CIPHER(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not a cipher algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-decrypt-setup(^operation: c-pointer<psa-cipher-operation-s-c>, ^key: int32, ^alg: int32): int32
  c inline "(psa_status_t)psa_cipher_decrypt_setup((psa_cipher_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3)"

pub inline fun ffi/psa-cipher-decrypt-setup(^operation: c-pointer<psa-cipher-operation-s-c>, ^key: int, ^alg: int): <> int
  external/psa-cipher-decrypt-setup(operation, key.int32, alg.int32).int

// Generate an IV for a symmetric encryption operation.
// 
// This function generates a random IV (initialization vector), nonce
// or initial counter value for the encryption operation as appropriate
// for the chosen algorithm, key type and key size.
// 
// The application must call psa_cipher_encrypt_setup() before
// calling this function.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_cipher_abort().
// 
// \param[in,out] operation     Active cipher operation.
// \param[out] iv               Buffer where the generated IV is to be written.
// \param iv_size               Size of the \p iv buffer in bytes.
// \param[out] iv_length        On success, the number of bytes of the
// generated IV.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p iv buffer is too small.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, with no IV set),
// or the library has not been previously initialized
// by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-generate-iv(^operation: c-pointer<psa-cipher-operation-s-c>, ^iv: c-pointer<int>, ^iv-size: ssize_t, ^iv-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_cipher_generate_iv((psa_cipher_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-cipher-generate-iv(^operation: c-pointer<psa-cipher-operation-s-c>, ^iv: c-pointer<int>, ^iv-size: int, ^iv-length: c-pointer<int>): <> int
  external/psa-cipher-generate-iv(operation, iv, iv-size.ssize_t, iv-length).int

// Set the IV for a symmetric encryption or decryption operation.
// 
// This function sets the IV (initialization vector), nonce
// or initial counter value for the encryption or decryption operation.
// 
// The application must call psa_cipher_encrypt_setup() before
// calling this function.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_cipher_abort().
// 
// \note When encrypting, applications should use psa_cipher_generate_iv()
// instead of this function, unless implementing a protocol that requires
// a non-random IV.
// 
// \param[in,out] operation     Active cipher operation.
// \param[in] iv                Buffer containing the IV to use.
// \param iv_length             Size of the IV in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The size of \p iv is not acceptable for the chosen algorithm,
// or the chosen algorithm does not use an IV.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be an active cipher
// encrypt operation, with no IV set), or the library has not been
// previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-set-iv(^operation: c-pointer<psa-cipher-operation-s-c>, ^iv: c-pointer<int>, ^iv-length: ssize_t): int32
  c inline "(psa_status_t)psa_cipher_set_iv((psa_cipher_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-cipher-set-iv(^operation: c-pointer<psa-cipher-operation-s-c>, ^iv: c-pointer<int>, ^iv-length: int): <> int
  external/psa-cipher-set-iv(operation, iv, iv-length.ssize_t).int

// Encrypt or decrypt a message fragment in an active cipher operation.
// 
// Before calling this function, you must:
// 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup().
// The choice of setup function determines whether this function
// encrypts or decrypts its input.
// 2. If the algorithm requires an IV, call psa_cipher_generate_iv()
// (recommended when encrypting) or psa_cipher_set_iv().
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_cipher_abort().
// 
// \param[in,out] operation     Active cipher operation.
// \param[in] input             Buffer containing the message fragment to
// encrypt or decrypt.
// \param input_length          Size of the \p input buffer in bytes.
// \param[out] output           Buffer where the output is to be written.
// \param output_size           Size of the \p output buffer in bytes.
// \param[out] output_length    On success, the number of bytes
// that make up the returned output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p output buffer is too small.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, with an IV set
// if required for the algorithm), or the library has not been
// previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-update(^operation: c-pointer<psa-cipher-operation-s-c>, ^input: c-pointer<int>, ^input-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_cipher_update((psa_cipher_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (uint8_t*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/psa-cipher-update(^operation: c-pointer<psa-cipher-operation-s-c>, ^input: c-pointer<int>, ^input-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-cipher-update(operation, input, input-length.ssize_t, output, output-size.ssize_t, output-length).int

// Finish encrypting or decrypting a message in a cipher operation.
// 
// The application must call psa_cipher_encrypt_setup() or
// psa_cipher_decrypt_setup() before calling this function. The choice
// of setup function determines whether this function encrypts or
// decrypts its input.
// 
// This function finishes the encryption or decryption of the message
// formed by concatenating the inputs passed to preceding calls to
// psa_cipher_update().
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_cipher_abort().
// 
// \param[in,out] operation     Active cipher operation.
// \param[out] output           Buffer where the output is to be written.
// \param output_size           Size of the \p output buffer in bytes.
// \param[out] output_length    On success, the number of bytes
// that make up the returned output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The total input size passed to this operation is not valid for
// this particular algorithm. For example, the algorithm is a based
// on block cipher and requires a whole number of blocks, but the
// total input size is not a multiple of the block size.
// \retval #PSA_ERROR_INVALID_PADDING
// This is a decryption operation for an algorithm that includes
// padding, and the ciphertext does not contain valid padding.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p output buffer is too small.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, with an IV set
// if required for the algorithm), or the library has not been
// previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-finish(^operation: c-pointer<psa-cipher-operation-s-c>, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_cipher_finish((psa_cipher_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-cipher-finish(^operation: c-pointer<psa-cipher-operation-s-c>, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-cipher-finish(operation, output, output-size.ssize_t, output-length).int

// Abort a cipher operation.
// 
// Aborting an operation frees all associated resources except for the
// \p operation structure itself. Once aborted, the operation object
// can be reused for another operation by calling
// psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again.
// 
// You may call this function any time after the operation object has
// been initialized as described in #psa_cipher_operation_t.
// 
// In particular, calling psa_cipher_abort() after the operation has been
// terminated by a call to psa_cipher_abort() or psa_cipher_finish()
// is safe and has no effect.
// 
// \param[in,out] operation     Initialized cipher operation.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-cipher-abort(^operation: c-pointer<psa-cipher-operation-s-c>): int32
  c inline "(psa_status_t)psa_cipher_abort((psa_cipher_operation_t*)#1)"

pub inline fun ffi/psa-cipher-abort(^operation: c-pointer<psa-cipher-operation-s-c>): <> int
  external/psa-cipher-abort(operation).int

// Process an authenticated encryption operation.
// 
// \param key                     Identifier of the key to use for the
// operation. It must allow the usage
// #PSA_KEY_USAGE_ENCRYPT.
// \param alg                     The AEAD algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_AEAD(\p alg) is true).
// \param[in] nonce               Nonce or IV to use.
// \param nonce_length            Size of the \p nonce buffer in bytes.
// \param[in] additional_data     Additional data that will be authenticated
// but not encrypted.
// \param additional_data_length  Size of \p additional_data in bytes.
// \param[in] plaintext           Data that will be authenticated and
// encrypted.
// \param plaintext_length        Size of \p plaintext in bytes.
// \param[out] ciphertext         Output buffer for the authenticated and
// encrypted data. The additional data is not
// part of this output. For algorithms where the
// encrypted data and the authentication tag
// are defined as separate outputs, the
// authentication tag is appended to the
// encrypted data.
// \param ciphertext_size         Size of the \p ciphertext buffer in bytes.
// This must be appropriate for the selected
// algorithm and key:
// - A sufficient output size is
// #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\c key_type,
// \p alg, \p plaintext_length) where
// \c key_type is the type of \p key.
// - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p
// plaintext_length) evaluates to the maximum
// ciphertext size of any supported AEAD
// encryption.
// \param[out] ciphertext_length  On success, the size of the output
// in the \p ciphertext buffer.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not an AEAD algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// \p ciphertext_size is too small.
// #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\c key_type, \p alg,
// \p plaintext_length) or
// #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p plaintext_length) can be used to
// determine the required buffer size.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-encrypt(^key: int32, ^alg: int32, ^nonce: c-pointer<int>, ^nonce-length: ssize_t, ^additional-data: c-pointer<int>, ^additional-data-length: ssize_t, ^plaintext: c-pointer<int>, ^plaintext-length: ssize_t, ^ciphertext: c-pointer<int>, ^ciphertext-size: ssize_t, ^ciphertext-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_aead_encrypt((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (uint8_t*)#7, (size_t)#8, (uint8_t*)#9, (size_t)#10, (size_t*)#11)"

pub inline fun ffi/psa-aead-encrypt(^key: int, ^alg: int, ^nonce: c-pointer<int>, ^nonce-length: int, ^additional-data: c-pointer<int>, ^additional-data-length: int, ^plaintext: c-pointer<int>, ^plaintext-length: int, ^ciphertext: c-pointer<int>, ^ciphertext-size: int, ^ciphertext-length: c-pointer<int>): <> int
  external/psa-aead-encrypt(key.int32, alg.int32, nonce, nonce-length.ssize_t, additional-data, additional-data-length.ssize_t, plaintext, plaintext-length.ssize_t, ciphertext, ciphertext-size.ssize_t, ciphertext-length).int

// Process an authenticated decryption operation.
// 
// \param key                     Identifier of the key to use for the
// operation. It must allow the usage
// #PSA_KEY_USAGE_DECRYPT.
// \param alg                     The AEAD algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_AEAD(\p alg) is true).
// \param[in] nonce               Nonce or IV to use.
// \param nonce_length            Size of the \p nonce buffer in bytes.
// \param[in] additional_data     Additional data that has been authenticated
// but not encrypted.
// \param additional_data_length  Size of \p additional_data in bytes.
// \param[in] ciphertext          Data that has been authenticated and
// encrypted. For algorithms where the
// encrypted data and the authentication tag
// are defined as separate inputs, the buffer
// must contain the encrypted data followed
// by the authentication tag.
// \param ciphertext_length       Size of \p ciphertext in bytes.
// \param[out] plaintext          Output buffer for the decrypted data.
// \param plaintext_size          Size of the \p plaintext buffer in bytes.
// This must be appropriate for the selected
// algorithm and key:
// - A sufficient output size is
// #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\c key_type,
// \p alg, \p ciphertext_length) where
// \c key_type is the type of \p key.
// - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p
// ciphertext_length) evaluates to the maximum
// plaintext size of any supported AEAD
// decryption.
// \param[out] plaintext_length   On success, the size of the output
// in the \p plaintext buffer.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The ciphertext is not authentic.
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not an AEAD algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// \p plaintext_size is too small.
// #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\c key_type, \p alg,
// \p ciphertext_length) or
// #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p ciphertext_length) can be used
// to determine the required buffer size.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-decrypt(^key: int32, ^alg: int32, ^nonce: c-pointer<int>, ^nonce-length: ssize_t, ^additional-data: c-pointer<int>, ^additional-data-length: ssize_t, ^ciphertext: c-pointer<int>, ^ciphertext-length: ssize_t, ^plaintext: c-pointer<int>, ^plaintext-size: ssize_t, ^plaintext-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_aead_decrypt((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (uint8_t*)#7, (size_t)#8, (uint8_t*)#9, (size_t)#10, (size_t*)#11)"

pub inline fun ffi/psa-aead-decrypt(^key: int, ^alg: int, ^nonce: c-pointer<int>, ^nonce-length: int, ^additional-data: c-pointer<int>, ^additional-data-length: int, ^ciphertext: c-pointer<int>, ^ciphertext-length: int, ^plaintext: c-pointer<int>, ^plaintext-size: int, ^plaintext-length: c-pointer<int>): <> int
  external/psa-aead-decrypt(key.int32, alg.int32, nonce, nonce-length.ssize_t, additional-data, additional-data-length.ssize_t, ciphertext, ciphertext-length.ssize_t, plaintext, plaintext-size.ssize_t, plaintext-length).int

// Set the key for a multipart authenticated encryption operation.
// 
// The sequence of operations to encrypt a message with authentication
// is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_aead_operation_t, e.g.
// #PSA_AEAD_OPERATION_INIT.
// -# Call psa_aead_encrypt_setup() to specify the algorithm and key.
// -# If needed, call psa_aead_set_lengths() to specify the length of the
// inputs to the subsequent calls to psa_aead_update_ad() and
// psa_aead_update(). See the documentation of psa_aead_set_lengths()
// for details.
// -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to
// generate or set the nonce. You should use
// psa_aead_generate_nonce() unless the protocol you are implementing
// requires a specific nonce value.
// -# Call psa_aead_update_ad() zero, one or more times, passing a fragment
// of the non-encrypted additional authenticated data each time.
// -# Call psa_aead_update() zero, one or more times, passing a fragment
// of the message to encrypt each time.
// -# Call psa_aead_finish().
// 
// If an error occurs at any step after a call to psa_aead_encrypt_setup(),
// the operation will need to be reset by a call to psa_aead_abort(). The
// application may call psa_aead_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_aead_encrypt_setup(), the application must
// eventually terminate the operation. The following events terminate an
// operation:
// - A successful call to psa_aead_finish().
// - A call to psa_aead_abort().
// 
// \param[in,out] operation     The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_aead_operation_t and not yet in use.
// \param key                   Identifier of the key to use for the operation.
// It must remain valid until the operation
// terminates. It must allow the usage
// #PSA_KEY_USAGE_ENCRYPT.
// \param alg                   The AEAD algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_AEAD(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not an AEAD algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-encrypt-setup(^operation: c-pointer<psa-aead-operation-s-c>, ^key: int32, ^alg: int32): int32
  c inline "(psa_status_t)psa_aead_encrypt_setup((psa_aead_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3)"

pub inline fun ffi/psa-aead-encrypt-setup(^operation: c-pointer<psa-aead-operation-s-c>, ^key: int, ^alg: int): <> int
  external/psa-aead-encrypt-setup(operation, key.int32, alg.int32).int

// Set the key for a multipart authenticated decryption operation.
// 
// The sequence of operations to decrypt a message with authentication
// is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_aead_operation_t, e.g.
// #PSA_AEAD_OPERATION_INIT.
// -# Call psa_aead_decrypt_setup() to specify the algorithm and key.
// -# If needed, call psa_aead_set_lengths() to specify the length of the
// inputs to the subsequent calls to psa_aead_update_ad() and
// psa_aead_update(). See the documentation of psa_aead_set_lengths()
// for details.
// -# Call psa_aead_set_nonce() with the nonce for the decryption.
// -# Call psa_aead_update_ad() zero, one or more times, passing a fragment
// of the non-encrypted additional authenticated data each time.
// -# Call psa_aead_update() zero, one or more times, passing a fragment
// of the ciphertext to decrypt each time.
// -# Call psa_aead_verify().
// 
// If an error occurs at any step after a call to psa_aead_decrypt_setup(),
// the operation will need to be reset by a call to psa_aead_abort(). The
// application may call psa_aead_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_aead_decrypt_setup(), the application must
// eventually terminate the operation. The following events terminate an
// operation:
// - A successful call to psa_aead_verify().
// - A call to psa_aead_abort().
// 
// \param[in,out] operation     The operation object to set up. It must have
// been initialized as per the documentation for
// #psa_aead_operation_t and not yet in use.
// \param key                   Identifier of the key to use for the operation.
// It must remain valid until the operation
// terminates. It must allow the usage
// #PSA_KEY_USAGE_DECRYPT.
// \param alg                   The AEAD algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_AEAD(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not compatible with \p alg.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not supported or is not an AEAD algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or the
// library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-decrypt-setup(^operation: c-pointer<psa-aead-operation-s-c>, ^key: int32, ^alg: int32): int32
  c inline "(psa_status_t)psa_aead_decrypt_setup((psa_aead_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3)"

pub inline fun ffi/psa-aead-decrypt-setup(^operation: c-pointer<psa-aead-operation-s-c>, ^key: int, ^alg: int): <> int
  external/psa-aead-decrypt-setup(operation, key.int32, alg.int32).int

// Generate a random nonce for an authenticated encryption operation.
// 
// This function generates a random nonce for the authenticated encryption
// operation with an appropriate size for the chosen algorithm, key type
// and key size.
// 
// The application must call psa_aead_encrypt_setup() before
// calling this function.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \param[in,out] operation     Active AEAD operation.
// \param[out] nonce            Buffer where the generated nonce is to be
// written.
// \param nonce_size            Size of the \p nonce buffer in bytes.
// \param[out] nonce_length     On success, the number of bytes of the
// generated nonce.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p nonce buffer is too small.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be an active aead encrypt
// operation, with no nonce set), or the library has not been
// previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-generate-nonce(^operation: c-pointer<psa-aead-operation-s-c>, ^nonce: c-pointer<int>, ^nonce-size: ssize_t, ^nonce-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_aead_generate_nonce((psa_aead_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-aead-generate-nonce(^operation: c-pointer<psa-aead-operation-s-c>, ^nonce: c-pointer<int>, ^nonce-size: int, ^nonce-length: c-pointer<int>): <> int
  external/psa-aead-generate-nonce(operation, nonce, nonce-size.ssize_t, nonce-length).int

// Set the nonce for an authenticated encryption or decryption operation.
// 
// This function sets the nonce for the authenticated
// encryption or decryption operation.
// 
// The application must call psa_aead_encrypt_setup() or
// psa_aead_decrypt_setup() before calling this function.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \note When encrypting, applications should use psa_aead_generate_nonce()
// instead of this function, unless implementing a protocol that requires
// a non-random IV.
// 
// \param[in,out] operation     Active AEAD operation.
// \param[in] nonce             Buffer containing the nonce to use.
// \param nonce_length          Size of the nonce in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The size of \p nonce is not acceptable for the chosen algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, with no nonce
// set), or the library has not been previously initialized
// by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-set-nonce(^operation: c-pointer<psa-aead-operation-s-c>, ^nonce: c-pointer<int>, ^nonce-length: ssize_t): int32
  c inline "(psa_status_t)psa_aead_set_nonce((psa_aead_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-aead-set-nonce(^operation: c-pointer<psa-aead-operation-s-c>, ^nonce: c-pointer<int>, ^nonce-length: int): <> int
  external/psa-aead-set-nonce(operation, nonce, nonce-length.ssize_t).int

// Declare the lengths of the message and additional data for AEAD.
// 
// The application must call this function before calling
// psa_aead_update_ad() or psa_aead_update() if the algorithm for
// the operation requires it. If the algorithm does not require it,
// calling this function is optional, but if this function is called
// then the implementation must enforce the lengths.
// 
// You may call this function before or after setting the nonce with
// psa_aead_set_nonce() or psa_aead_generate_nonce().
// 
// - For #PSA_ALG_CCM, calling this function is required.
// - For the other AEAD algorithms defined in this specification, calling
// this function is not required.
// - For vendor-defined algorithm, refer to the vendor documentation.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \param[in,out] operation     Active AEAD operation.
// \param ad_length             Size of the non-encrypted additional
// authenticated data in bytes.
// \param plaintext_length      Size of the plaintext to encrypt in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// At least one of the lengths is not acceptable for the chosen
// algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, and
// psa_aead_update_ad() and psa_aead_update() must not have been
// called yet), or the library has not been previously initialized
// by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-set-lengths(^operation: c-pointer<psa-aead-operation-s-c>, ^ad-length: ssize_t, ^plaintext-length: ssize_t): int32
  c inline "(psa_status_t)psa_aead_set_lengths((psa_aead_operation_t*)#1, (size_t)#2, (size_t)#3)"

pub inline fun ffi/psa-aead-set-lengths(^operation: c-pointer<psa-aead-operation-s-c>, ^ad-length: int, ^plaintext-length: int): <> int
  external/psa-aead-set-lengths(operation, ad-length.ssize_t, plaintext-length.ssize_t).int

// Pass additional data to an active AEAD operation.
// 
// Additional data is authenticated, but not encrypted.
// 
// You may call this function multiple times to pass successive fragments
// of the additional data. You may not call this function after passing
// data to encrypt or decrypt with psa_aead_update().
// 
// Before calling this function, you must:
// 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().
// 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,
// there is no guarantee that the input is valid. Therefore, until
// you have called psa_aead_verify() and it has returned #PSA_SUCCESS,
// treat the input as untrusted and prepare to undo any action that
// depends on the input if psa_aead_verify() returns an error status.
// 
// \param[in,out] operation     Active AEAD operation.
// \param[in] input             Buffer containing the fragment of
// additional data.
// \param input_length          Size of the \p input buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The total input length overflows the additional data length that
// was previously specified with psa_aead_set_lengths().
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, have a nonce
// set, have lengths set if required by the algorithm, and
// psa_aead_update() must not have been called yet), or the library
// has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-update-ad(^operation: c-pointer<psa-aead-operation-s-c>, ^input: c-pointer<int>, ^input-length: ssize_t): int32
  c inline "(psa_status_t)psa_aead_update_ad((psa_aead_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-aead-update-ad(^operation: c-pointer<psa-aead-operation-s-c>, ^input: c-pointer<int>, ^input-length: int): <> int
  external/psa-aead-update-ad(operation, input, input-length.ssize_t).int

// Encrypt or decrypt a message fragment in an active AEAD operation.
// 
// Before calling this function, you must:
// 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().
// The choice of setup function determines whether this function
// encrypts or decrypts its input.
// 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().
// 3. Call psa_aead_update_ad() to pass all the additional data.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,
// there is no guarantee that the input is valid. Therefore, until
// you have called psa_aead_verify() and it has returned #PSA_SUCCESS:
// - Do not use the output in any way other than storing it in a
// confidential location. If you take any action that depends
// on the tentative decrypted data, this action will need to be
// undone if the input turns out not to be valid. Furthermore,
// if an adversary can observe that this action took place
// (for example through timing), they may be able to use this
// fact as an oracle to decrypt any message encrypted with the
// same key.
// - In particular, do not copy the output anywhere but to a
// memory or storage space that you have exclusive access to.
// 
// This function does not require the input to be aligned to any
// particular block boundary. If the implementation can only process
// a whole block at a time, it must consume all the input provided, but
// it may delay the end of the corresponding output until a subsequent
// call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()
// provides sufficient input. The amount of data that can be delayed
// in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE.
// 
// \param[in,out] operation     Active AEAD operation.
// \param[in] input             Buffer containing the message fragment to
// encrypt or decrypt.
// \param input_length          Size of the \p input buffer in bytes.
// \param[out] output           Buffer where the output is to be written.
// \param output_size           Size of the \p output buffer in bytes.
// This must be appropriate for the selected
// algorithm and key:
// - A sufficient output size is
// #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c key_type,
// \c alg, \p input_length) where
// \c key_type is the type of key and \c alg is
// the algorithm that were used to set up the
// operation.
// - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p
// input_length) evaluates to the maximum
// output size of any supported AEAD
// algorithm.
// \param[out] output_length    On success, the number of bytes
// that make up the returned output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p output buffer is too small.
// #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c key_type, \c alg, \p input_length) or
// #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p input_length) can be used to
// determine the required buffer size.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The total length of input to psa_aead_update_ad() so far is
// less than the additional data length that was previously
// specified with psa_aead_set_lengths(), or
// the total input length overflows the plaintext length that
// was previously specified with psa_aead_set_lengths().
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, have a nonce
// set, and have lengths set if required by the algorithm), or the
// library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-update(^operation: c-pointer<psa-aead-operation-s-c>, ^input: c-pointer<int>, ^input-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_aead_update((psa_aead_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (uint8_t*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/psa-aead-update(^operation: c-pointer<psa-aead-operation-s-c>, ^input: c-pointer<int>, ^input-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-aead-update(operation, input, input-length.ssize_t, output, output-size.ssize_t, output-length).int

// Finish encrypting a message in an AEAD operation.
// 
// The operation must have been set up with psa_aead_encrypt_setup().
// 
// This function finishes the authentication of the additional data
// formed by concatenating the inputs passed to preceding calls to
// psa_aead_update_ad() with the plaintext formed by concatenating the
// inputs passed to preceding calls to psa_aead_update().
// 
// This function has two output buffers:
// - \p ciphertext contains trailing ciphertext that was buffered from
// preceding calls to psa_aead_update().
// - \p tag contains the authentication tag.
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \param[in,out] operation     Active AEAD operation.
// \param[out] ciphertext       Buffer where the last part of the ciphertext
// is to be written.
// \param ciphertext_size       Size of the \p ciphertext buffer in bytes.
// This must be appropriate for the selected
// algorithm and key:
// - A sufficient output size is
// #PSA_AEAD_FINISH_OUTPUT_SIZE(\c key_type,
// \c alg) where \c key_type is the type of key
// and \c alg is the algorithm that were used to
// set up the operation.
// - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to
// the maximum output size of any supported AEAD
// algorithm.
// \param[out] ciphertext_length On success, the number of bytes of
// returned ciphertext.
// \param[out] tag              Buffer where the authentication tag is
// to be written.
// \param tag_size              Size of the \p tag buffer in bytes.
// This must be appropriate for the selected
// algorithm and key:
// - The exact tag size is #PSA_AEAD_TAG_LENGTH(\c
// key_type, \c key_bits, \c alg) where
// \c key_type and \c key_bits are the type and
// bit-size of the key, and \c alg is the
// algorithm that were used in the call to
// psa_aead_encrypt_setup().
// - #PSA_AEAD_TAG_MAX_SIZE evaluates to the
// maximum tag size of any supported AEAD
// algorithm.
// \param[out] tag_length       On success, the number of bytes
// that make up the returned tag.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p ciphertext or \p tag buffer is too small.
// #PSA_AEAD_FINISH_OUTPUT_SIZE(\c key_type, \c alg) or
// #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the
// required \p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\c key_type,
// \c key_bits, \c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to
// determine the required \p tag buffer size.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The total length of input to psa_aead_update_ad() so far is
// less than the additional data length that was previously
// specified with psa_aead_set_lengths(), or
// the total length of input to psa_aead_update() so far is
// less than the plaintext length that was previously
// specified with psa_aead_set_lengths().
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be an active encryption
// operation with a nonce set), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-finish(^operation: c-pointer<psa-aead-operation-s-c>, ^ciphertext: c-pointer<int>, ^ciphertext-size: ssize_t, ^ciphertext-length: c-pointer<int>, ^tag: c-pointer<int>, ^tag-size: ssize_t, ^tag-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_aead_finish((psa_aead_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-aead-finish(^operation: c-pointer<psa-aead-operation-s-c>, ^ciphertext: c-pointer<int>, ^ciphertext-size: int, ^ciphertext-length: c-pointer<int>, ^tag: c-pointer<int>, ^tag-size: int, ^tag-length: c-pointer<int>): <> int
  external/psa-aead-finish(operation, ciphertext, ciphertext-size.ssize_t, ciphertext-length, tag, tag-size.ssize_t, tag-length).int

// Finish authenticating and decrypting a message in an AEAD operation.
// 
// The operation must have been set up with psa_aead_decrypt_setup().
// 
// This function finishes the authenticated decryption of the message
// components:
// 
// -  The additional data consisting of the concatenation of the inputs
// passed to preceding calls to psa_aead_update_ad().
// -  The ciphertext consisting of the concatenation of the inputs passed to
// preceding calls to psa_aead_update().
// -  The tag passed to this function call.
// 
// If the authentication tag is correct, this function outputs any remaining
// plaintext and reports success. If the authentication tag is not correct,
// this function returns #PSA_ERROR_INVALID_SIGNATURE.
// 
// When this function returns successfully, the operation becomes inactive.
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_aead_abort().
// 
// \note Implementations shall make the best effort to ensure that the
// comparison between the actual tag and the expected tag is performed
// in constant time.
// 
// \param[in,out] operation     Active AEAD operation.
// \param[out] plaintext        Buffer where the last part of the plaintext
// is to be written. This is the remaining data
// from previous calls to psa_aead_update()
// that could not be processed until the end
// of the input.
// \param plaintext_size        Size of the \p plaintext buffer in bytes.
// This must be appropriate for the selected algorithm and key:
// - A sufficient output size is
// #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c key_type,
// \c alg) where \c key_type is the type of key
// and \c alg is the algorithm that were used to
// set up the operation.
// - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to
// the maximum output size of any supported AEAD
// algorithm.
// \param[out] plaintext_length On success, the number of bytes of
// returned plaintext.
// \param[in] tag               Buffer containing the authentication tag.
// \param tag_length            Size of the \p tag buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The calculations were successful, but the authentication tag is
// not correct.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p plaintext buffer is too small.
// #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c key_type, \c alg) or
// #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the
// required buffer size.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The total length of input to psa_aead_update_ad() so far is
// less than the additional data length that was previously
// specified with psa_aead_set_lengths(), or
// the total length of input to psa_aead_update() so far is
// less than the plaintext length that was previously
// specified with psa_aead_set_lengths().
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be an active decryption
// operation with a nonce set), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-verify(^operation: c-pointer<psa-aead-operation-s-c>, ^plaintext: c-pointer<int>, ^plaintext-size: ssize_t, ^plaintext-length: c-pointer<int>, ^tag: c-pointer<int>, ^tag-length: ssize_t): int32
  c inline "(psa_status_t)psa_aead_verify((psa_aead_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4, (uint8_t*)#5, (size_t)#6)"

pub inline fun ffi/psa-aead-verify(^operation: c-pointer<psa-aead-operation-s-c>, ^plaintext: c-pointer<int>, ^plaintext-size: int, ^plaintext-length: c-pointer<int>, ^tag: c-pointer<int>, ^tag-length: int): <> int
  external/psa-aead-verify(operation, plaintext, plaintext-size.ssize_t, plaintext-length, tag, tag-length.ssize_t).int

// Abort an AEAD operation.
// 
// Aborting an operation frees all associated resources except for the
// \p operation structure itself. Once aborted, the operation object
// can be reused for another operation by calling
// psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again.
// 
// You may call this function any time after the operation object has
// been initialized as described in #psa_aead_operation_t.
// 
// In particular, calling psa_aead_abort() after the operation has been
// terminated by a call to psa_aead_abort(), psa_aead_finish() or
// psa_aead_verify() is safe and has no effect.
// 
// \param[in,out] operation     Initialized AEAD operation.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-aead-abort(^operation: c-pointer<psa-aead-operation-s-c>): int32
  c inline "(psa_status_t)psa_aead_abort((psa_aead_operation_t*)#1)"

pub inline fun ffi/psa-aead-abort(^operation: c-pointer<psa-aead-operation-s-c>): <> int
  external/psa-aead-abort(operation).int

// \brief Sign a message with a private key. For hash-and-sign algorithms,
// this includes the hashing step.
// 
// \note To perform a multi-part hash-and-sign signature algorithm, first use
// a multi-part hash operation and then pass the resulting hash to
// psa_sign_hash(). PSA_ALG_GET_HASH(\p alg) can be used to determine the
// hash algorithm to use.
// 
// \param[in]  key              Identifier of the key to use for the operation.
// It must be an asymmetric key pair. The key must
// allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE.
// \param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX
// value such that #PSA_ALG_IS_SIGN_MESSAGE(\p alg)
// is true), that is compatible with the type of
// \p key.
// \param[in]  input            The input message to sign.
// \param[in]  input_length     Size of the \p input buffer in bytes.
// \param[out] signature        Buffer where the signature is to be written.
// \param[in]  signature_size   Size of the \p signature buffer in bytes. This
// must be appropriate for the selected
// algorithm and key:
// - The required signature size is
// #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
// where \c key_type and \c key_bits are the type and
// bit-size respectively of key.
// - #PSA_SIGNATURE_MAX_SIZE evaluates to the
// maximum signature size of any supported
// signature algorithm.
// \param[out] signature_length On success, the number of bytes that make up
// the returned signature value.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED
// The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,
// or it does not permit the requested algorithm.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p signature buffer is too small. You can
// determine a sufficient buffer size by calling
// #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
// where \c key_type and \c key_bits are the type and bit-size
// respectively of \p key.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-sign-message(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^signature: c-pointer<int>, ^signature-size: ssize_t, ^signature-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_sign_message((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-sign-message(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^signature: c-pointer<int>, ^signature-size: int, ^signature-length: c-pointer<int>): <> int
  external/psa-sign-message(key.int32, alg.int32, input, input-length.ssize_t, signature, signature-size.ssize_t, signature-length).int

// \brief Verify the signature of a message with a public key, using
// a hash-and-sign verification algorithm.
// 
// \note To perform a multi-part hash-and-sign signature verification
// algorithm, first use a multi-part hash operation to hash the message
// and then pass the resulting hash to psa_verify_hash().
// PSA_ALG_GET_HASH(\p alg) can be used to determine the hash algorithm
// to use.
// 
// \param[in]  key              Identifier of the key to use for the operation.
// It must be a public key or an asymmetric key
// pair. The key must allow the usage
// #PSA_KEY_USAGE_VERIFY_MESSAGE.
// \param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX
// value such that #PSA_ALG_IS_SIGN_MESSAGE(\p alg)
// is true), that is compatible with the type of
// \p key.
// \param[in]  input            The message whose signature is to be verified.
// \param[in]  input_length     Size of the \p input buffer in bytes.
// \param[out] signature        Buffer containing the signature to verify.
// \param[in]  signature_length Size of the \p signature buffer in bytes.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED
// The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,
// or it does not permit the requested algorithm.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The calculation was performed successfully, but the passed signature
// is not a valid signature.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-verify-message(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^signature: c-pointer<int>, ^signature-length: ssize_t): int32
  c inline "(psa_status_t)psa_verify_message((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6)"

pub inline fun ffi/psa-verify-message(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^signature: c-pointer<int>, ^signature-length: int): <> int
  external/psa-verify-message(key.int32, alg.int32, input, input-length.ssize_t, signature, signature-length.ssize_t).int

// \brief Sign a hash or short message with a private key.
// 
// Note that to perform a hash-and-sign signature algorithm, you must
// first calculate the hash by calling psa_hash_setup(), psa_hash_update()
// and psa_hash_finish(), or alternatively by calling psa_hash_compute().
// Then pass the resulting hash as the \p hash
// parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\p alg)
// to determine the hash algorithm to use.
// 
// \param key                   Identifier of the key to use for the operation.
// It must be an asymmetric key pair. The key must
// allow the usage #PSA_KEY_USAGE_SIGN_HASH.
// \param alg                   A signature algorithm (PSA_ALG_XXX
// value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
// is true), that is compatible with
// the type of \p key.
// \param[in] hash              The hash or message to sign.
// \param hash_length           Size of the \p hash buffer in bytes.
// \param[out] signature        Buffer where the signature is to be written.
// \param signature_size        Size of the \p signature buffer in bytes.
// \param[out] signature_length On success, the number of bytes
// that make up the returned signature value.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p signature buffer is too small. You can
// determine a sufficient buffer size by calling
// #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
// where \c key_type and \c key_bits are the type and bit-size
// respectively of \p key.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-sign-hash(^key: int32, ^alg: int32, ^hash: c-pointer<int>, ^hash-length: ssize_t, ^signature: c-pointer<int>, ^signature-size: ssize_t, ^signature-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_sign_hash((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-sign-hash(^key: int, ^alg: int, ^hash: c-pointer<int>, ^hash-length: int, ^signature: c-pointer<int>, ^signature-size: int, ^signature-length: c-pointer<int>): <> int
  external/psa-sign-hash(key.int32, alg.int32, hash, hash-length.ssize_t, signature, signature-size.ssize_t, signature-length).int

// \brief Verify the signature of a hash or short message using a public key.
// 
// Note that to perform a hash-and-sign signature algorithm, you must
// first calculate the hash by calling psa_hash_setup(), psa_hash_update()
// and psa_hash_finish(), or alternatively by calling psa_hash_compute().
// Then pass the resulting hash as the \p hash
// parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\p alg)
// to determine the hash algorithm to use.
// 
// \param key               Identifier of the key to use for the operation. It
// must be a public key or an asymmetric key pair. The
// key must allow the usage
// #PSA_KEY_USAGE_VERIFY_HASH.
// \param alg               A signature algorithm (PSA_ALG_XXX
// value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
// is true), that is compatible with
// the type of \p key.
// \param[in] hash          The hash or message whose signature is to be
// verified.
// \param hash_length       Size of the \p hash buffer in bytes.
// \param[in] signature     Buffer containing the signature to verify.
// \param signature_length  Size of the \p signature buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The signature is valid.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The calculation was performed successfully, but the passed
// signature is not a valid signature.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-verify-hash(^key: int32, ^alg: int32, ^hash: c-pointer<int>, ^hash-length: ssize_t, ^signature: c-pointer<int>, ^signature-length: ssize_t): int32
  c inline "(psa_status_t)psa_verify_hash((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6)"

pub inline fun ffi/psa-verify-hash(^key: int, ^alg: int, ^hash: c-pointer<int>, ^hash-length: int, ^signature: c-pointer<int>, ^signature-length: int): <> int
  external/psa-verify-hash(key.int32, alg.int32, hash, hash-length.ssize_t, signature, signature-length.ssize_t).int

// \brief Encrypt a short message with a public key.
// 
// \param key                   Identifier of the key to use for the operation.
// It must be a public key or an asymmetric key
// pair. It must allow the usage
// #PSA_KEY_USAGE_ENCRYPT.
// \param alg                   An asymmetric encryption algorithm that is
// compatible with the type of \p key.
// \param[in] input             The message to encrypt.
// \param input_length          Size of the \p input buffer in bytes.
// \param[in] salt              A salt or label, if supported by the
// encryption algorithm.
// If the algorithm does not support a
// salt, pass \c NULL.
// If the algorithm supports an optional
// salt and you do not want to pass a salt,
// pass \c NULL.
// 
// - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is
// supported.
// \param salt_length           Size of the \p salt buffer in bytes.
// If \p salt is \c NULL, pass 0.
// \param[out] output           Buffer where the encrypted message is to
// be written.
// \param output_size           Size of the \p output buffer in bytes.
// \param[out] output_length    On success, the number of bytes
// that make up the returned output.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p output buffer is too small. You can
// determine a sufficient buffer size by calling
// #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
// where \c key_type and \c key_bits are the type and bit-size
// respectively of \p key.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-asymmetric-encrypt(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^salt: c-pointer<int>, ^salt-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_asymmetric_encrypt((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (uint8_t*)#7, (size_t)#8, (size_t*)#9)"

pub inline fun ffi/psa-asymmetric-encrypt(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^salt: c-pointer<int>, ^salt-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-asymmetric-encrypt(key.int32, alg.int32, input, input-length.ssize_t, salt, salt-length.ssize_t, output, output-size.ssize_t, output-length).int

// \brief Decrypt a short message with a private key.
// 
// \param key                   Identifier of the key to use for the operation.
// It must be an asymmetric key pair. It must
// allow the usage #PSA_KEY_USAGE_DECRYPT.
// \param alg                   An asymmetric encryption algorithm that is
// compatible with the type of \p key.
// \param[in] input             The message to decrypt.
// \param input_length          Size of the \p input buffer in bytes.
// \param[in] salt              A salt or label, if supported by the
// encryption algorithm.
// If the algorithm does not support a
// salt, pass \c NULL.
// If the algorithm supports an optional
// salt and you do not want to pass a salt,
// pass \c NULL.
// 
// - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is
// supported.
// \param salt_length           Size of the \p salt buffer in bytes.
// If \p salt is \c NULL, pass 0.
// \param[out] output           Buffer where the decrypted message is to
// be written.
// \param output_size           Size of the \c output buffer in bytes.
// \param[out] output_length    On success, the number of bytes
// that make up the returned output.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p output buffer is too small. You can
// determine a sufficient buffer size by calling
// #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
// where \c key_type and \c key_bits are the type and bit-size
// respectively of \p key.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_INVALID_PADDING \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-asymmetric-decrypt(^key: int32, ^alg: int32, ^input: c-pointer<int>, ^input-length: ssize_t, ^salt: c-pointer<int>, ^salt-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_asymmetric_decrypt((mbedtls_svc_key_id_t)#1, (psa_algorithm_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (uint8_t*)#7, (size_t)#8, (size_t*)#9)"

pub inline fun ffi/psa-asymmetric-decrypt(^key: int, ^alg: int, ^input: c-pointer<int>, ^input-length: int, ^salt: c-pointer<int>, ^salt-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-asymmetric-decrypt(key.int32, alg.int32, input, input-length.ssize_t, salt, salt-length.ssize_t, output, output-size.ssize_t, output-length).int

// Set up a key derivation operation.
// 
// A key derivation algorithm takes some inputs and uses them to generate
// a byte stream in a deterministic way.
// This byte stream can be used to produce keys and other
// cryptographic material.
// 
// To derive a key:
// -# Start with an initialized object of type #psa_key_derivation_operation_t.
// -# Call psa_key_derivation_setup() to select the algorithm.
// -# Provide the inputs for the key derivation by calling
// psa_key_derivation_input_bytes() or psa_key_derivation_input_key()
// as appropriate. Which inputs are needed, in what order, and whether
// they may be keys and if so of what type depends on the algorithm.
// -# Optionally set the operation's maximum capacity with
// psa_key_derivation_set_capacity(). You may do this before, in the middle
// of or after providing inputs. For some algorithms, this step is mandatory
// because the output depends on the maximum capacity.
// -# To derive a key, call psa_key_derivation_output_key() or
// psa_key_derivation_output_key_ext().
// To derive a byte string for a different purpose, call
// psa_key_derivation_output_bytes().
// Successive calls to these functions use successive output bytes
// calculated by the key derivation algorithm.
// -# Clean up the key derivation operation object with
// psa_key_derivation_abort().
// 
// If this function returns an error, the key derivation operation object is
// not changed.
// 
// If an error occurs at any step after a call to psa_key_derivation_setup(),
// the operation will need to be reset by a call to psa_key_derivation_abort().
// 
// Implementations must reject an attempt to derive a key of size 0.
// 
// \param[in,out] operation       The key derivation operation object
// to set up. It must
// have been initialized but not set up yet.
// \param alg                     The key derivation algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_KEY_DERIVATION(\p alg) is true).
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \c alg is not a key derivation algorithm.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \c alg is not supported or is not a key derivation algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be inactive), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-setup(^operation: c-pointer<psa-key-derivation-s-c>, ^alg: int32): int32
  c inline "(psa_status_t)psa_key_derivation_setup((psa_key_derivation_operation_t*)#1, (psa_algorithm_t)#2)"

pub inline fun ffi/psa-key-derivation-setup(^operation: c-pointer<psa-key-derivation-s-c>, ^alg: int): <> int
  external/psa-key-derivation-setup(operation, alg.int32).int

// Retrieve the current capacity of a key derivation operation.
// 
// The capacity of a key derivation is the maximum number of bytes that it can
// return. When you get *N* bytes of output from a key derivation operation,
// this reduces its capacity by *N*.
// 
// \param[in] operation     The operation to query.
// \param[out] capacity     On success, the capacity of the operation.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-get-capacity(^operation: c-pointer<psa-key-derivation-s-c>, ^capacity: c-pointer<int>): int32
  c inline "(psa_status_t)psa_key_derivation_get_capacity((psa_key_derivation_operation_t*)#1, (size_t*)#2)"

pub inline fun ffi/psa-key-derivation-get-capacity(^operation: c-pointer<psa-key-derivation-s-c>, ^capacity: c-pointer<int>): <> int
  external/psa-key-derivation-get-capacity(operation, capacity).int

// Set the maximum capacity of a key derivation operation.
// 
// The capacity of a key derivation operation is the maximum number of bytes
// that the key derivation operation can return from this point onwards.
// 
// \param[in,out] operation The key derivation operation object to modify.
// \param capacity          The new capacity of the operation.
// It must be less or equal to the operation's
// current capacity.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p capacity is larger than the operation's current capacity.
// In this case, the operation object remains valid and its capacity
// remains unchanged.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active), or the
// library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-set-capacity(^operation: c-pointer<psa-key-derivation-s-c>, ^capacity: ssize_t): int32
  c inline "(psa_status_t)psa_key_derivation_set_capacity((psa_key_derivation_operation_t*)#1, (size_t)#2)"

pub inline fun ffi/psa-key-derivation-set-capacity(^operation: c-pointer<psa-key-derivation-s-c>, ^capacity: int): <> int
  external/psa-key-derivation-set-capacity(operation, capacity.ssize_t).int

// Provide an input for key derivation or key agreement.
// 
// Which inputs are required and in what order depends on the algorithm.
// Refer to the documentation of each key derivation or key agreement
// algorithm for information.
// 
// This function passes direct inputs, which is usually correct for
// non-secret inputs. To pass a secret input, which should be in a key
// object, call psa_key_derivation_input_key() instead of this function.
// Refer to the documentation of individual step types
// (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)
// for more information.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_key_derivation_abort().
// 
// \param[in,out] operation       The key derivation operation object to use.
// It must have been set up with
// psa_key_derivation_setup() and must not
// have produced any output yet.
// \param step                    Which step the input data is for.
// \param[in] data                Input data to use.
// \param data_length             Size of the \p data buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \c step is not compatible with the operation's algorithm, or
// \c step does not allow direct inputs.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid for this input \p step, or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-input-bytes(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int16, ^data: c-pointer<int>, ^data-length: ssize_t): int32
  c inline "(psa_status_t)psa_key_derivation_input_bytes((psa_key_derivation_operation_t*)#1, (psa_key_derivation_step_t)#2, (uint8_t*)#3, (size_t)#4)"

pub inline fun ffi/psa-key-derivation-input-bytes(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int, ^data: c-pointer<int>, ^data-length: int): <> int
  external/psa-key-derivation-input-bytes(operation, step.int16, data, data-length.ssize_t).int

// Provide a numeric input for key derivation or key agreement.
// 
// Which inputs are required and in what order depends on the algorithm.
// However, when an algorithm requires a particular order, numeric inputs
// usually come first as they tend to be configuration parameters.
// Refer to the documentation of each key derivation or key agreement
// algorithm for information.
// 
// This function is used for inputs which are fixed-size non-negative
// integers.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_key_derivation_abort().
// 
// \param[in,out] operation       The key derivation operation object to use.
// It must have been set up with
// psa_key_derivation_setup() and must not
// have produced any output yet.
// \param step                    Which step the input data is for.
// \param[in] value               The value of the numeric input.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \c step is not compatible with the operation's algorithm, or
// \c step does not allow numeric inputs.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid for this input \p step, or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-input-integer(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int16, ^value: int64): int32
  c inline "(psa_status_t)psa_key_derivation_input_integer((psa_key_derivation_operation_t*)#1, (psa_key_derivation_step_t)#2, (int64_t)#3)"

pub inline fun ffi/psa-key-derivation-input-integer(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int, ^value: int): <> int
  external/psa-key-derivation-input-integer(operation, step.int16, value.int64).int

// Provide an input for key derivation in the form of a key.
// 
// Which inputs are required and in what order depends on the algorithm.
// Refer to the documentation of each key derivation or key agreement
// algorithm for information.
// 
// This function obtains input from a key object, which is usually correct for
// secret inputs or for non-secret personalization strings kept in the key
// store. To pass a non-secret parameter which is not in the key store,
// call psa_key_derivation_input_bytes() instead of this function.
// Refer to the documentation of individual step types
// (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)
// for more information.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_key_derivation_abort().
// 
// \param[in,out] operation       The key derivation operation object to use.
// It must have been set up with
// psa_key_derivation_setup() and must not
// have produced any output yet.
// \param step                    Which step the input data is for.
// \param key                     Identifier of the key. It must have an
// appropriate type for step and must allow the
// usage #PSA_KEY_USAGE_DERIVE or
// #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)
// and the algorithm used by the operation.
// 
// \note Once all inputs steps are completed, the operations will allow:
// - psa_key_derivation_output_bytes() if each input was either a direct input
// or  a key with #PSA_KEY_USAGE_DERIVE set;
// - psa_key_derivation_output_key() or psa_key_derivation_output_key_ext()
// if the input for step
// #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD
// was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was
// either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;
// - psa_key_derivation_verify_bytes() if each input was either a direct input
// or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;
// - psa_key_derivation_verify_key() under the same conditions as
// psa_key_derivation_verify_bytes().
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED
// The key allows neither #PSA_KEY_USAGE_DERIVE nor
// #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this
// algorithm.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \c step is not compatible with the operation's algorithm, or
// \c step does not allow key inputs of the given type
// or does not allow key inputs at all.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid for this input \p step, or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-input-key(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int16, ^key: int32): int32
  c inline "(psa_status_t)psa_key_derivation_input_key((psa_key_derivation_operation_t*)#1, (psa_key_derivation_step_t)#2, (mbedtls_svc_key_id_t)#3)"

pub inline fun ffi/psa-key-derivation-input-key(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int, ^key: int): <> int
  external/psa-key-derivation-input-key(operation, step.int16, key.int32).int

// Perform a key agreement and use the shared secret as input to a key
// derivation.
// 
// A key agreement algorithm takes two inputs: a private key \p private_key
// a public key \p peer_key.
// The result of this function is passed as input to a key derivation.
// The output of this key derivation can be extracted by reading from the
// resulting operation to produce keys and other cryptographic material.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_key_derivation_abort().
// 
// \param[in,out] operation       The key derivation operation object to use.
// It must have been set up with
// psa_key_derivation_setup() with a
// key agreement and derivation algorithm
// \c alg (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_KEY_AGREEMENT(\c alg) is true
// and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\c alg)
// is false).
// The operation must be ready for an
// input of the type given by \p step.
// \param step                    Which step the input data is for.
// \param private_key             Identifier of the private key to use. It must
// allow the usage #PSA_KEY_USAGE_DERIVE.
// \param[in] peer_key      Public key of the peer. The peer key must be in the
// same format that psa_import_key() accepts for the
// public key type corresponding to the type of
// private_key. That is, this function performs the
// equivalent of
// #psa_import_key(...,
// `peer_key`, `peer_key_length`) where
// with key attributes indicating the public key
// type corresponding to the type of `private_key`.
// For example, for EC keys, this means that peer_key
// is interpreted as a point on the curve that the
// private key is on. The standard formats for public
// keys are documented in the documentation of
// psa_export_public_key().
// \param peer_key_length         Size of \p peer_key in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \c private_key is not compatible with \c alg,
// or \p peer_key is not valid for \c alg or not compatible with
// \c private_key, or \c step does not allow an input resulting
// from a key agreement.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \c alg is not supported or is not a key derivation algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid for this key agreement \p step,
// or the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-key-agreement(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int16, ^private-key: int32, ^peer-key: c-pointer<int>, ^peer-key-length: ssize_t): int32
  c inline "(psa_status_t)psa_key_derivation_key_agreement((psa_key_derivation_operation_t*)#1, (psa_key_derivation_step_t)#2, (mbedtls_svc_key_id_t)#3, (uint8_t*)#4, (size_t)#5)"

pub inline fun ffi/psa-key-derivation-key-agreement(^operation: c-pointer<psa-key-derivation-s-c>, ^step: int, ^private-key: int, ^peer-key: c-pointer<int>, ^peer-key-length: int): <> int
  external/psa-key-derivation-key-agreement(operation, step.int16, private-key.int32, peer-key, peer-key-length.ssize_t).int

// Read some data from a key derivation operation.
// 
// This function calculates output bytes from a key derivation algorithm and
// return those bytes.
// If you view the key derivation's output as a stream of bytes, this
// function destructively reads the requested number of bytes from the
// stream.
// The operation's capacity decreases by the number of bytes read.
// 
// If this function returns an error status other than
// #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error
// state and must be aborted by calling psa_key_derivation_abort().
// 
// \param[in,out] operation The key derivation operation object to read from.
// \param[out] output       Buffer where the output will be written.
// \param output_length     Number of bytes to output.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED
// One of the inputs was a key whose policy didn't allow
// #PSA_KEY_USAGE_DERIVE.
// \retval #PSA_ERROR_INSUFFICIENT_DATA
// The operation's capacity was less than
// \p output_length bytes. Note that in this case,
// no output is written to the output buffer.
// The operation's capacity is set to 0, thus
// subsequent calls to this function will not
// succeed, even with a smaller output buffer.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active and completed
// all required input steps), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-output-bytes(^operation: c-pointer<psa-key-derivation-s-c>, ^output: c-pointer<int>, ^output-length: ssize_t): int32
  c inline "(psa_status_t)psa_key_derivation_output_bytes((psa_key_derivation_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-key-derivation-output-bytes(^operation: c-pointer<psa-key-derivation-s-c>, ^output: c-pointer<int>, ^output-length: int): <> int
  external/psa-key-derivation-output-bytes(operation, output, output-length.ssize_t).int

// Derive a key from an ongoing key derivation operation.
// 
// This function calculates output bytes from a key derivation algorithm
// and uses those bytes to generate a key deterministically.
// The key's location, usage policy, type and size are taken from
// \p attributes.
// 
// If you view the key derivation's output as a stream of bytes, this
// function destructively reads as many bytes as required from the
// stream.
// The operation's capacity decreases by the number of bytes read.
// 
// If this function returns an error status other than
// #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error
// state and must be aborted by calling psa_key_derivation_abort().
// 
// How much output is produced and consumed from the operation, and how
// the key is derived, depends on the key type and on the key size
// (denoted \c bits below):
// 
// - For key types for which the key is an arbitrary sequence of bytes
// of a given size, this function is functionally equivalent to
// calling #psa_key_derivation_output_bytes
// and passing the resulting output to #psa_import_key.
// However, this function has a security benefit:
// if the implementation provides an isolation boundary then
// the key material is not exposed outside the isolation boundary.
// As a consequence, for these key types, this function always consumes
// exactly (\c bits / 8) bytes from the operation.
// The following key types defined in this specification follow this scheme:
// 
// - #PSA_KEY_TYPE_AES;
// - #PSA_KEY_TYPE_ARIA;
// - #PSA_KEY_TYPE_CAMELLIA;
// - #PSA_KEY_TYPE_DERIVE;
// - #PSA_KEY_TYPE_HMAC;
// - #PSA_KEY_TYPE_PASSWORD_HASH.
// 
// - For ECC keys on a Montgomery elliptic curve
// (#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
// Montgomery curve), this function always draws a byte string whose
// length is determined by the curve, and sets the mandatory bits
// accordingly. That is:
// 
// - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte
// string and process it as specified in RFC 7748 &sect;5.
// - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte
// string and process it as specified in RFC 7748 &sect;5.
// 
// - For key types for which the key is represented by a single sequence of
// \c bits bits with constraints as to which bit sequences are acceptable,
// this function draws a byte string of length (\c bits / 8) bytes rounded
// up to the nearest whole number of bytes. If the resulting byte string
// is acceptable, it becomes the key, otherwise the drawn bytes are discarded.
// This process is repeated until an acceptable byte string is drawn.
// The byte string drawn from the operation is interpreted as specified
// for the output produced by psa_export_key().
// The following key types defined in this specification follow this scheme:
// 
// - #PSA_KEY_TYPE_DES.
// Force-set the parity bits, but discard forbidden weak keys.
// For 2-key and 3-key triple-DES, the three keys are generated
// successively (for example, for 3-key triple-DES,
// if the first 8 bytes specify a weak key and the next 8 bytes do not,
// discard the first 8 bytes, use the next 8 bytes as the first key,
// and continue reading output from the operation to derive the other
// two keys).
// - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\c group)
// where \c group designates any Diffie-Hellman group) and
// ECC keys on a Weierstrass elliptic curve
// (#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
// Weierstrass curve).
// For these key types, interpret the byte string as integer
// in big-endian order. Discard it if it is not in the range
// [0, *N* - 2] where *N* is the boundary of the private key domain
// (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,
// or the order of the curve's base point for ECC).
// Add 1 to the resulting integer and use this as the private key *x*.
// This method allows compliance to NIST standards, specifically
// the methods titled "key-pair generation by testing candidates"
// in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,
// in FIPS 186-4 &sect;B.1.2 for DSA, and
// in NIST SP 800-56A &sect;5.6.1.2.2 or
// FIPS 186-4 &sect;B.4.2 for elliptic curve keys.
// 
// - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,
// the way in which the operation output is consumed is
// implementation-defined.
// 
// In all cases, the data that is read is discarded from the operation.
// The operation's capacity is decreased by the number of bytes read.
// 
// For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,
// the input to that step must be provided with psa_key_derivation_input_key().
// Future versions of this specification may include additional restrictions
// on the derived key based on the attributes and strength of the secret key.
// 
// \note This function is equivalent to calling
// psa_key_derivation_output_key_ext()
// with the production parameters #PSA_KEY_PRODUCTION_PARAMETERS_INIT
// and `params_data_length == 0` (i.e. `params->data` is empty).
// 
// \param[in] attributes    The attributes for the new key.
// If the key type to be created is
// #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in
// the policy must be the same as in the current
// operation.
// \param[in,out] operation The key derivation operation object to read from.
// \param[out] key          On success, an identifier for the newly created
// key. For persistent keys, this is the key
// identifier defined in \p attributes.
// \c 0 on failure.
// 
// \retval #PSA_SUCCESS
// Success.
// If the key is persistent, the key material and the key's metadata
// have been saved to persistent storage.
// \retval #PSA_ERROR_ALREADY_EXISTS
// This is an attempt to create a persistent key, and there is
// already a persistent key with the given identifier.
// \retval #PSA_ERROR_INSUFFICIENT_DATA
// There was not enough data to create the desired key.
// Note that in this case, no output is written to the output buffer.
// The operation's capacity is set to 0, thus subsequent calls to
// this function will not succeed, even with a smaller output buffer.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The key type or key size is not supported, either by the
// implementation in general or in this particular location.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The provided key attributes are not valid for the operation.
// \retval #PSA_ERROR_NOT_PERMITTED
// The #PSA_KEY_DERIVATION_INPUT_SECRET or
// #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a
// key; or one of the inputs was a key whose policy didn't allow
// #PSA_KEY_USAGE_DERIVE.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active and completed
// all required input steps), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-output-key(^attributes: c-pointer<psa-key-attributes-s-c>, ^operation: c-pointer<psa-key-derivation-s-c>, ^key: c-pointer<int>): int32
  c inline "(psa_status_t)psa_key_derivation_output_key((psa_key_attributes_t*)#1, (psa_key_derivation_operation_t*)#2, (mbedtls_svc_key_id_t*)#3)"

pub inline fun ffi/psa-key-derivation-output-key(^attributes: c-pointer<psa-key-attributes-s-c>, ^operation: c-pointer<psa-key-derivation-s-c>, ^key: c-pointer<int>): <> int
  external/psa-key-derivation-output-key(attributes, operation, key).int

// Derive a key from an ongoing key derivation operation with custom
// production parameters.
// 
// See the description of psa_key_derivation_out_key() for the operation of
// this function with the default production parameters.
// Mbed TLS currently does not currently support any non-default production
// parameters.
// 
// \note This function is experimental and may change in future minor
// versions of Mbed TLS.
// 
// \param[in] attributes    The attributes for the new key.
// If the key type to be created is
// #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in
// the policy must be the same as in the current
// operation.
// \param[in,out] operation The key derivation operation object to read from.
// \param[in] params        Customization parameters for the key derivation.
// When this is #PSA_KEY_PRODUCTION_PARAMETERS_INIT
// with \p params_data_length = 0,
// this function is equivalent to
// psa_key_derivation_output_key().
// Mbed TLS currently only supports the default
// production parameters, i.e.
// #PSA_KEY_PRODUCTION_PARAMETERS_INIT,
// for all key types.
// \param params_data_length
// Length of `params->data` in bytes.
// \param[out] key          On success, an identifier for the newly created
// key. For persistent keys, this is the key
// identifier defined in \p attributes.
// \c 0 on failure.
// 
// \retval #PSA_SUCCESS
// Success.
// If the key is persistent, the key material and the key's metadata
// have been saved to persistent storage.
// \retval #PSA_ERROR_ALREADY_EXISTS
// This is an attempt to create a persistent key, and there is
// already a persistent key with the given identifier.
// \retval #PSA_ERROR_INSUFFICIENT_DATA
// There was not enough data to create the desired key.
// Note that in this case, no output is written to the output buffer.
// The operation's capacity is set to 0, thus subsequent calls to
// this function will not succeed, even with a smaller output buffer.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The key type or key size is not supported, either by the
// implementation in general or in this particular location.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The provided key attributes are not valid for the operation.
// \retval #PSA_ERROR_NOT_PERMITTED
// The #PSA_KEY_DERIVATION_INPUT_SECRET or
// #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a
// key; or one of the inputs was a key whose policy didn't allow
// #PSA_KEY_USAGE_DERIVE.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active and completed
// all required input steps), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-output-key-ext(^attributes: c-pointer<psa-key-attributes-s-c>, ^operation: c-pointer<psa-key-derivation-s-c>, ^params: c-pointer<psa-key-production-parameters-s-c>, ^params-data-length: ssize_t, ^key: c-pointer<int>): int32
  c inline "(psa_status_t)psa_key_derivation_output_key_ext((psa_key_attributes_t*)#1, (psa_key_derivation_operation_t*)#2, (psa_key_production_parameters_t*)#3, (size_t)#4, (mbedtls_svc_key_id_t*)#5)"

pub inline fun ffi/psa-key-derivation-output-key-ext(^attributes: c-pointer<psa-key-attributes-s-c>, ^operation: c-pointer<psa-key-derivation-s-c>, ^params: c-pointer<psa-key-production-parameters-s-c>, ^params-data-length: int, ^key: c-pointer<int>): <> int
  external/psa-key-derivation-output-key-ext(attributes, operation, params, params-data-length.ssize_t, key).int

// Compare output data from a key derivation operation to an expected value.
// 
// This function calculates output bytes from a key derivation algorithm and
// compares those bytes to an expected value in constant time.
// If you view the key derivation's output as a stream of bytes, this
// function destructively reads the expected number of bytes from the
// stream before comparing them.
// The operation's capacity decreases by the number of bytes read.
// 
// This is functionally equivalent to the following code:
// \code
// psa_key_derivation_output_bytes(operation, tmp, output_length);
// if (memcmp(output, tmp, output_length) != 0)
// return PSA_ERROR_INVALID_SIGNATURE;
// \endcode
// except (1) it works even if the key's policy does not allow outputting the
// bytes, and (2) the comparison will be done in constant time.
// 
// If this function returns an error status other than
// #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,
// the operation enters an error state and must be aborted by calling
// psa_key_derivation_abort().
// 
// \param[in,out] operation The key derivation operation object to read from.
// \param[in] expected_output Buffer containing the expected derivation output.
// \param output_length     Length of the expected output; this is also the
// number of bytes that will be read.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The output was read successfully, but it differs from the expected
// output.
// \retval #PSA_ERROR_NOT_PERMITTED
// One of the inputs was a key whose policy didn't allow
// #PSA_KEY_USAGE_VERIFY_DERIVATION.
// \retval #PSA_ERROR_INSUFFICIENT_DATA
// The operation's capacity was less than
// \p output_length bytes. Note that in this case,
// the operation's capacity is set to 0, thus
// subsequent calls to this function will not
// succeed, even with a smaller expected output.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active and completed
// all required input steps), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-verify-bytes(^operation: c-pointer<psa-key-derivation-s-c>, ^expected-output: c-pointer<int>, ^output-length: ssize_t): int32
  c inline "(psa_status_t)psa_key_derivation_verify_bytes((psa_key_derivation_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-key-derivation-verify-bytes(^operation: c-pointer<psa-key-derivation-s-c>, ^expected-output: c-pointer<int>, ^output-length: int): <> int
  external/psa-key-derivation-verify-bytes(operation, expected-output, output-length.ssize_t).int

// Compare output data from a key derivation operation to an expected value
// stored in a key object.
// 
// This function calculates output bytes from a key derivation algorithm and
// compares those bytes to an expected value, provided as key of type
// #PSA_KEY_TYPE_PASSWORD_HASH.
// If you view the key derivation's output as a stream of bytes, this
// function destructively reads the number of bytes corresponding to the
// length of the expected value from the stream before comparing them.
// The operation's capacity decreases by the number of bytes read.
// 
// This is functionally equivalent to exporting the key and calling
// psa_key_derivation_verify_bytes() on the result, except that it
// works even if the key cannot be exported.
// 
// If this function returns an error status other than
// #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,
// the operation enters an error state and must be aborted by calling
// psa_key_derivation_abort().
// 
// \param[in,out] operation The key derivation operation object to read from.
// \param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH
// containing the expected output. Its policy must
// include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag
// and the permitted algorithm must match the
// operation. The value of this key was likely
// computed by a previous call to
// psa_key_derivation_output_key() or
// psa_key_derivation_output_key_ext().
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The output was read successfully, but if differs from the expected
// output.
// \retval #PSA_ERROR_INVALID_HANDLE
// The key passed as the expected value does not exist.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The key passed as the expected value has an invalid type.
// \retval #PSA_ERROR_NOT_PERMITTED
// The key passed as the expected value does not allow this usage or
// this algorithm; or one of the inputs was a key whose policy didn't
// allow #PSA_KEY_USAGE_VERIFY_DERIVATION.
// \retval #PSA_ERROR_INSUFFICIENT_DATA
// The operation's capacity was less than
// the length of the expected value. In this case,
// the operation's capacity is set to 0, thus
// subsequent calls to this function will not
// succeed, even with a smaller expected output.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active and completed
// all required input steps), or the library has not been previously
// initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-verify-key(^operation: c-pointer<psa-key-derivation-s-c>, ^expected: int32): int32
  c inline "(psa_status_t)psa_key_derivation_verify_key((psa_key_derivation_operation_t*)#1, (psa_key_id_t)#2)"

pub inline fun ffi/psa-key-derivation-verify-key(^operation: c-pointer<psa-key-derivation-s-c>, ^expected: int): <> int
  external/psa-key-derivation-verify-key(operation, expected.int32).int

// Abort a key derivation operation.
// 
// Aborting an operation frees all associated resources except for the \c
// operation structure itself. Once aborted, the operation object can be reused
// for another operation by calling psa_key_derivation_setup() again.
// 
// This function may be called at any time after the operation
// object has been initialized as described in #psa_key_derivation_operation_t.
// 
// In particular, it is valid to call psa_key_derivation_abort() twice, or to
// call psa_key_derivation_abort() on an operation that has not been set up.
// 
// \param[in,out] operation    The operation to abort.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-key-derivation-abort(^operation: c-pointer<psa-key-derivation-s-c>): int32
  c inline "(psa_status_t)psa_key_derivation_abort((psa_key_derivation_operation_t*)#1)"

pub inline fun ffi/psa-key-derivation-abort(^operation: c-pointer<psa-key-derivation-s-c>): <> int
  external/psa-key-derivation-abort(operation).int

// Perform a key agreement and return the raw shared secret.
// 
// \warning The raw result of a key agreement algorithm such as finite-field
// Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should
// not be used directly as key material. It should instead be passed as
// input to a key derivation algorithm. To chain a key agreement with
// a key derivation, use psa_key_derivation_key_agreement() and other
// functions from the key derivation interface.
// 
// \param alg                     The key agreement algorithm to compute
// (\c PSA_ALG_XXX value such that
// #PSA_ALG_IS_RAW_KEY_AGREEMENT(\p alg)
// is true).
// \param private_key             Identifier of the private key to use. It must
// allow the usage #PSA_KEY_USAGE_DERIVE.
// \param[in] peer_key            Public key of the peer. It must be
// in the same format that psa_import_key()
// accepts. The standard formats for public
// keys are documented in the documentation
// of psa_export_public_key().
// \param peer_key_length         Size of \p peer_key in bytes.
// \param[out] output             Buffer where the decrypted message is to
// be written.
// \param output_size             Size of the \c output buffer in bytes.
// \param[out] output_length      On success, the number of bytes
// that make up the returned output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p alg is not a key agreement algorithm, or
// \p private_key is not compatible with \p alg,
// or \p peer_key is not valid for \p alg or not compatible with
// \p private_key.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// \p output_size is too small
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p alg is not a supported key agreement algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-raw-key-agreement(^alg: int32, ^private-key: int32, ^peer-key: c-pointer<int>, ^peer-key-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_raw_key_agreement((psa_algorithm_t)#1, (mbedtls_svc_key_id_t)#2, (uint8_t*)#3, (size_t)#4, (uint8_t*)#5, (size_t)#6, (size_t*)#7)"

pub inline fun ffi/psa-raw-key-agreement(^alg: int, ^private-key: int, ^peer-key: c-pointer<int>, ^peer-key-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-raw-key-agreement(alg.int32, private-key.int32, peer-key, peer-key-length.ssize_t, output, output-size.ssize_t, output-length).int

// \brief Generate random bytes.
// 
// \warning This function **can** fail! Callers MUST check the return status
// and MUST NOT use the content of the output buffer if the return
// status is not #PSA_SUCCESS.
// 
// \note    To generate a key, use psa_generate_key() instead.
// 
// \param[out] output       Output buffer for the generated data.
// \param output_size       Number of bytes to generate and output.
// 
// \retval #PSA_SUCCESS \emptydescription
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-generate-random(^output: c-pointer<int>, ^output-size: ssize_t): int32
  c inline "(psa_status_t)psa_generate_random((uint8_t*)#1, (size_t)#2)"

pub inline fun ffi/psa-generate-random(^output: c-pointer<int>, ^output-size: int): <> int
  external/psa-generate-random(output, output-size.ssize_t).int

// \brief Generate a key or key pair.
// 
// The key is generated randomly.
// Its location, usage policy, type and size are taken from \p attributes.
// 
// Implementations must reject an attempt to generate a key of size 0.
// 
// The following type-specific considerations apply:
// - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),
// the public exponent is 65537.
// The modulus is a product of two probabilistic primes
// between 2^{n-1} and 2^n where n is the bit size specified in the
// attributes.
// 
// \note This function is equivalent to calling psa_generate_key_ext()
// with the production parameters #PSA_KEY_PRODUCTION_PARAMETERS_INIT
// and `params_data_length == 0` (i.e. `params->data` is empty).
// 
// \param[in] attributes    The attributes for the new key.
// \param[out] key          On success, an identifier for the newly created
// key. For persistent keys, this is the key
// identifier defined in \p attributes.
// \c 0 on failure.
// 
// \retval #PSA_SUCCESS
// Success.
// If the key is persistent, the key material and the key's metadata
// have been saved to persistent storage.
// \retval #PSA_ERROR_ALREADY_EXISTS
// This is an attempt to create a persistent key, and there is
// already a persistent key with the given identifier.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-generate-key(^attributes: c-pointer<psa-key-attributes-s-c>, ^key: c-pointer<int>): int32
  c inline "(psa_status_t)psa_generate_key((psa_key_attributes_t*)#1, (mbedtls_svc_key_id_t*)#2)"

pub inline fun ffi/psa-generate-key(^attributes: c-pointer<psa-key-attributes-s-c>, ^key: c-pointer<int>): <> int
  external/psa-generate-key(attributes, key).int

// \brief Generate a key or key pair using custom production parameters.
// 
// See the description of psa_generate_key() for the operation of this
// function with the default production parameters. In addition, this function
// supports the following production customizations, described in more detail
// in the documentation of ::psa_key_production_parameters_t:
// 
// - RSA keys: generation with a custom public exponent.
// 
// \note This function is experimental and may change in future minor
// versions of Mbed TLS.
// 
// \param[in] attributes    The attributes for the new key.
// \param[in] params        Customization parameters for the key generation.
// When this is #PSA_KEY_PRODUCTION_PARAMETERS_INIT
// with \p params_data_length = 0,
// this function is equivalent to
// psa_generate_key().
// \param params_data_length
// Length of `params->data` in bytes.
// \param[out] key          On success, an identifier for the newly created
// key. For persistent keys, this is the key
// identifier defined in \p attributes.
// \c 0 on failure.
// 
// \retval #PSA_SUCCESS
// Success.
// If the key is persistent, the key material and the key's metadata
// have been saved to persistent storage.
// \retval #PSA_ERROR_ALREADY_EXISTS
// This is an attempt to create a persistent key, and there is
// already a persistent key with the given identifier.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-generate-key-ext(^attributes: c-pointer<psa-key-attributes-s-c>, ^params: c-pointer<psa-key-production-parameters-s-c>, ^params-data-length: ssize_t, ^key: c-pointer<int>): int32
  c inline "(psa_status_t)psa_generate_key_ext((psa_key_attributes_t*)#1, (psa_key_production_parameters_t*)#2, (size_t)#3, (mbedtls_svc_key_id_t*)#4)"

pub inline fun ffi/psa-generate-key-ext(^attributes: c-pointer<psa-key-attributes-s-c>, ^params: c-pointer<psa-key-production-parameters-s-c>, ^params-data-length: int, ^key: c-pointer<int>): <> int
  external/psa-generate-key-ext(attributes, params, params-data-length.ssize_t, key).int

// \brief                       Set the maximum number of ops allowed to be
// executed by an interruptible function in a
// single call.
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \note                        The time taken to execute a single op is
// implementation specific and depends on
// software, hardware, the algorithm, key type and
// curve chosen. Even within a single operation,
// successive ops can take differing amounts of
// time. The only guarantee is that lower values
// for \p max_ops means functions will block for a
// lesser maximum amount of time. The functions
// \c psa_sign_interruptible_get_num_ops() and
// \c psa_verify_interruptible_get_num_ops() are
// provided to help with tuning this value.
// 
// \note                        This value defaults to
// #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, which
// means the whole operation will be done in one
// go, regardless of the number of ops required.
// 
// \note                        If more ops are needed to complete a
// computation, #PSA_OPERATION_INCOMPLETE will be
// returned by the function performing the
// computation. It is then the caller's
// responsibility to either call again with the
// same operation context until it returns 0 or an
// error code; or to call the relevant abort
// function if the answer is no longer required.
// 
// \note                        The interpretation of \p max_ops is also
// implementation defined. On a hard real time
// system, this can indicate a hard deadline, as a
// real-time system needs a guarantee of not
// spending more than X time, however care must be
// taken in such an implementation to avoid the
// situation whereby calls just return, not being
// able to do any actual work within the allotted
// time.  On a non-real-time system, the
// implementation can be more relaxed, but again
// whether this number should be interpreted as as
// hard or soft limit or even whether a less than
// or equals as regards to ops executed in a
// single call is implementation defined.
// 
// \note                        For keys in local storage when no accelerator
// driver applies, please see also the
// documentation for \c mbedtls_ecp_set_max_ops(),
// which is the internal implementation in these
// cases.
// 
// \warning                     With implementations that interpret this number
// as a hard limit, setting this number too small
// may result in an infinite loop, whereby each
// call results in immediate return with no ops
// done (as there is not enough time to execute
// any), and thus no result will ever be achieved.
// 
// \note                        This only applies to functions whose
// documentation mentions they may return
// #PSA_OPERATION_INCOMPLETE.
// 
// \param max_ops               The maximum number of ops to be executed in a
// single call. This can be a number from 0 to
// #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, where 0
// is the least amount of work done per call.
pub extern external/psa-interruptible-set-max-ops(^max-ops: int32): ()
  c inline "(void)psa_interruptible_set_max_ops((int32_t)#1)"

pub inline fun ffi/psa-interruptible-set-max-ops(^max-ops: int): <> ()
  external/psa-interruptible-set-max-ops(max-ops.int32)

// \brief                       Get the maximum number of ops allowed to be
// executed by an interruptible function in a
// single call. This will return the last
// value set by
// \c psa_interruptible_set_max_ops() or
// #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED if
// that function has never been called.
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \return                      Maximum number of ops allowed to be
// executed by an interruptible function in a
// single call.
pub extern external/psa-interruptible-get-max-ops(): int32
  c inline "(int32_t)psa_interruptible_get_max_ops()"

pub inline fun ffi/psa-interruptible-get-max-ops(): <> int
  external/psa-interruptible-get-max-ops().int

// \brief                       Get the number of ops that a hash signing
// operation has taken so far. If the operation
// has completed, then this will represent the
// number of ops required for the entire
// operation. After initialization or calling
// \c psa_sign_hash_interruptible_abort() on
// the operation, a value of 0 will be returned.
// 
// \note                        This interface is guaranteed re-entrant and
// thus may be called from driver code.
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// This is a helper provided to help you tune the
// value passed to \c
// psa_interruptible_set_max_ops().
// 
// \param operation             The \c psa_sign_hash_interruptible_operation_t
// to use. This must be initialized first.
// 
// \return                      Number of ops that the operation has taken so
// far.
pub extern external/psa-sign-hash-get-num-ops(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>): int32
  c inline "(int32_t)psa_sign_hash_get_num_ops((psa_sign_hash_interruptible_operation_t*)#1)"

pub inline fun ffi/psa-sign-hash-get-num-ops(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>): <> int
  external/psa-sign-hash-get-num-ops(operation).int

// \brief                       Get the number of ops that a hash verification
// operation has taken so far. If the operation
// has completed, then this will represent the
// number of ops required for the entire
// operation. After initialization or calling \c
// psa_verify_hash_interruptible_abort() on the
// operation, a value of 0 will be returned.
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// This is a helper provided to help you tune the
// value passed to \c
// psa_interruptible_set_max_ops().
// 
// \param operation             The \c
// psa_verify_hash_interruptible_operation_t to
// use. This must be initialized first.
// 
// \return                      Number of ops that the operation has taken so
// far.
pub extern external/psa-verify-hash-get-num-ops(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>): int32
  c inline "(int32_t)psa_verify_hash_get_num_ops((psa_verify_hash_interruptible_operation_t*)#1)"

pub inline fun ffi/psa-verify-hash-get-num-ops(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>): <> int
  external/psa-verify-hash-get-num-ops(operation).int

// \brief                       Start signing a hash or short message with a
// private key, in an interruptible manner.
// 
// \see                         \c psa_sign_hash_complete()
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \note                        This function combined with \c
// psa_sign_hash_complete() is equivalent to
// \c psa_sign_hash() but
// \c psa_sign_hash_complete() can return early and
// resume according to the limit set with \c
// psa_interruptible_set_max_ops() to reduce the
// maximum time spent in a function call.
// 
// \note                        Users should call \c psa_sign_hash_complete()
// repeatedly on the same context after a
// successful call to this function until \c
// psa_sign_hash_complete() either returns 0 or an
// error. \c psa_sign_hash_complete() will return
// #PSA_OPERATION_INCOMPLETE if there is more work
// to do. Alternatively users can call
// \c psa_sign_hash_abort() at any point if they no
// longer want the result.
// 
// \note                        If this function returns an error status, the
// operation enters an error state and must be
// aborted by calling \c psa_sign_hash_abort().
// 
// \param[in, out] operation    The \c psa_sign_hash_interruptible_operation_t
// to use. This must be initialized first.
// 
// \param key                   Identifier of the key to use for the operation.
// It must be an asymmetric key pair. The key must
// allow the usage #PSA_KEY_USAGE_SIGN_HASH.
// \param alg                   A signature algorithm (\c PSA_ALG_XXX
// value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
// is true), that is compatible with
// the type of \p key.
// \param[in] hash              The hash or message to sign.
// \param hash_length           Size of the \p hash buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The operation started successfully - call \c psa_sign_hash_complete()
// with the same context to complete the operation
// 
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_NOT_PERMITTED
// The key does not have the #PSA_KEY_USAGE_SIGN_HASH flag, or it does
// not permit the requested algorithm.
// \retval #PSA_ERROR_BAD_STATE
// An operation has previously been started on this context, and is
// still in progress.
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-sign-hash-start(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>, ^key: int32, ^alg: int32, ^hash: c-pointer<int>, ^hash-length: ssize_t): int32
  c inline "(psa_status_t)psa_sign_hash_start((psa_sign_hash_interruptible_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3, (uint8_t*)#4, (size_t)#5)"

pub inline fun ffi/psa-sign-hash-start(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>, ^key: int, ^alg: int, ^hash: c-pointer<int>, ^hash-length: int): <> int
  external/psa-sign-hash-start(operation, key.int32, alg.int32, hash, hash-length.ssize_t).int

// \brief                       Continue and eventually complete the action of
// signing a hash or short message with a private
// key, in an interruptible manner.
// 
// \see                         \c psa_sign_hash_start()
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \note                        This function combined with \c
// psa_sign_hash_start() is equivalent to
// \c psa_sign_hash() but this function can return
// early and resume according to the limit set with
// \c psa_interruptible_set_max_ops() to reduce the
// maximum time spent in a function call.
// 
// \note                        Users should call this function on the same
// operation object repeatedly until it either
// returns 0 or an error. This function will return
// #PSA_OPERATION_INCOMPLETE if there is more work
// to do. Alternatively users can call
// \c psa_sign_hash_abort() at any point if they no
// longer want the result.
// 
// \note                        When this function returns successfully, the
// operation becomes inactive. If this function
// returns an error status, the operation enters an
// error state and must be aborted by calling
// \c psa_sign_hash_abort().
// 
// \param[in, out] operation    The \c psa_sign_hash_interruptible_operation_t
// to use. This must be initialized first, and have
// had \c psa_sign_hash_start() called with it
// first.
// 
// \param[out] signature        Buffer where the signature is to be written.
// \param signature_size        Size of the \p signature buffer in bytes. This
// must be appropriate for the selected
// algorithm and key:
// - The required signature size is
// #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c
// key_bits, \c alg) where \c key_type and \c
// key_bits are the type and bit-size
// respectively of key.
// - #PSA_SIGNATURE_MAX_SIZE evaluates to the
// maximum signature size of any supported
// signature algorithm.
// \param[out] signature_length On success, the number of bytes that make up
// the returned signature value.
// 
// \retval #PSA_SUCCESS
// Operation completed successfully
// 
// \retval #PSA_OPERATION_INCOMPLETE
// Operation was interrupted due to the setting of \c
// psa_interruptible_set_max_ops(). There is still work to be done.
// Call this function again with the same operation object.
// 
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p signature buffer is too small. You can
// determine a sufficient buffer size by calling
// #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \c alg)
// where \c key_type and \c key_bits are the type and bit-size
// respectively of \c key.
// 
// \retval #PSA_ERROR_BAD_STATE
// An operation was not previously started on this context via
// \c psa_sign_hash_start().
// 
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has either not been previously initialized by
// psa_crypto_init() or you did not previously call
// psa_sign_hash_start() with this operation object. It is
// implementation-dependent whether a failure to initialize results in
// this error code.
pub extern external/psa-sign-hash-complete(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>, ^signature: c-pointer<int>, ^signature-size: ssize_t, ^signature-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_sign_hash_complete((psa_sign_hash_interruptible_operation_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-sign-hash-complete(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>, ^signature: c-pointer<int>, ^signature-size: int, ^signature-length: c-pointer<int>): <> int
  external/psa-sign-hash-complete(operation, signature, signature-size.ssize_t, signature-length).int

// \brief                       Abort a sign hash operation.
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \note                        This function is the only function that clears
// the number of ops completed as part of the
// operation. Please ensure you copy this value via
// \c psa_sign_hash_get_num_ops() if required
// before calling.
// 
// \note                        Aborting an operation frees all associated
// resources except for the \p operation structure
// itself. Once aborted, the operation object can
// be reused for another operation by calling \c
// psa_sign_hash_start() again.
// 
// \note                        You may call this function any time after the
// operation object has been initialized. In
// particular, calling \c psa_sign_hash_abort()
// after the operation has already been terminated
// by a call to \c psa_sign_hash_abort() or
// psa_sign_hash_complete() is safe.
// 
// \param[in,out] operation     Initialized sign hash operation.
// 
// \retval #PSA_SUCCESS
// The operation was aborted successfully.
// 
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-sign-hash-abort(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>): int32
  c inline "(psa_status_t)psa_sign_hash_abort((psa_sign_hash_interruptible_operation_t*)#1)"

pub inline fun ffi/psa-sign-hash-abort(^operation: c-pointer<psa-sign-hash-interruptible-operation-s-c>): <> int
  external/psa-sign-hash-abort(operation).int

// \brief                       Start reading and verifying a hash or short
// message, in an interruptible manner.
// 
// \see                         \c psa_verify_hash_complete()
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \note                        This function combined with \c
// psa_verify_hash_complete() is equivalent to
// \c psa_verify_hash() but \c
// psa_verify_hash_complete() can return early and
// resume according to the limit set with \c
// psa_interruptible_set_max_ops() to reduce the
// maximum time spent in a function.
// 
// \note                        Users should call \c psa_verify_hash_complete()
// repeatedly on the same operation object after a
// successful call to this function until \c
// psa_verify_hash_complete() either returns 0 or
// an error. \c psa_verify_hash_complete() will
// return #PSA_OPERATION_INCOMPLETE if there is
// more work to do. Alternatively users can call
// \c psa_verify_hash_abort() at any point if they
// no longer want the result.
// 
// \note                        If this function returns an error status, the
// operation enters an error state and must be
// aborted by calling \c psa_verify_hash_abort().
// 
// \param[in, out] operation    The \c psa_verify_hash_interruptible_operation_t
// to use. This must be initialized first.
// 
// \param key                   Identifier of the key to use for the operation.
// The key must allow the usage
// #PSA_KEY_USAGE_VERIFY_HASH.
// \param alg                   A signature algorithm (\c PSA_ALG_XXX
// value such that #PSA_ALG_IS_SIGN_HASH(\p alg)
// is true), that is compatible with
// the type of \p key.
// \param[in] hash              The hash whose signature is to be verified.
// \param hash_length           Size of the \p hash buffer in bytes.
// \param[in] signature         Buffer containing the signature to verify.
// \param signature_length      Size of the \p signature buffer in bytes.
// 
// \retval #PSA_SUCCESS
// The operation started successfully - please call \c
// psa_verify_hash_complete() with the same context to complete the
// operation.
// 
// \retval #PSA_ERROR_BAD_STATE
// Another operation has already been started on this context, and is
// still in progress.
// 
// \retval #PSA_ERROR_NOT_PERMITTED
// The key does not have the #PSA_KEY_USAGE_VERIFY_HASH flag, or it does
// not permit the requested algorithm.
// 
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-verify-hash-start(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>, ^key: int32, ^alg: int32, ^hash: c-pointer<int>, ^hash-length: ssize_t, ^signature: c-pointer<int>, ^signature-length: ssize_t): int32
  c inline "(psa_status_t)psa_verify_hash_start((psa_verify_hash_interruptible_operation_t*)#1, (mbedtls_svc_key_id_t)#2, (psa_algorithm_t)#3, (uint8_t*)#4, (size_t)#5, (uint8_t*)#6, (size_t)#7)"

pub inline fun ffi/psa-verify-hash-start(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>, ^key: int, ^alg: int, ^hash: c-pointer<int>, ^hash-length: int, ^signature: c-pointer<int>, ^signature-length: int): <> int
  external/psa-verify-hash-start(operation, key.int32, alg.int32, hash, hash-length.ssize_t, signature, signature-length.ssize_t).int

// \brief                       Continue and eventually complete the action of
// reading and verifying a hash or short message
// signed with a private key, in an interruptible
// manner.
// 
// \see                         \c psa_verify_hash_start()
// 
// \warning                     This is a beta API, and thus subject to change
// at any point. It is not bound by the usual
// interface stability promises.
// 
// \note                        This function combined with \c
// psa_verify_hash_start() is equivalent to
// \c psa_verify_hash() but this function can
// return early and resume according to the limit
// set with \c psa_interruptible_set_max_ops() to
// reduce the maximum time spent in a function
// call.
// 
// \note                        Users should call this function on the same
// operation object repeatedly until it either
// returns 0 or an error. This function will return
// #PSA_OPERATION_INCOMPLETE if there is more work
// to do. Alternatively users can call
// \c psa_verify_hash_abort() at any point if they
// no longer want the result.
// 
// \note                        When this function returns successfully, the
// operation becomes inactive. If this function
// returns an error status, the operation enters an
// error state and must be aborted by calling
// \c psa_verify_hash_abort().
// 
// \param[in, out] operation    The \c psa_verify_hash_interruptible_operation_t
// to use. This must be initialized first, and have
// had \c psa_verify_hash_start() called with it
// first.
// 
// \retval #PSA_SUCCESS
// Operation completed successfully, and the passed signature is valid.
// 
// \retval #PSA_OPERATION_INCOMPLETE
// Operation was interrupted due to the setting of \c
// psa_interruptible_set_max_ops(). There is still work to be done.
// Call this function again with the same operation object.
// 
// \retval #PSA_ERROR_INVALID_HANDLE \emptydescription
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The calculation was performed successfully, but the passed
// signature is not a valid signature.
// \retval #PSA_ERROR_BAD_STATE
// An operation was not previously started on this context via
// \c psa_verify_hash_start().
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_INVALID_ARGUMENT \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has either not been previously initialized by
// psa_crypto_init() or you did not previously call
// psa_verify_hash_start() on this object. It is
// implementation-dependent whether a failure to initialize results in
// this error code.
pub extern external/psa-verify-hash-complete(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>): int32
  c inline "(psa_status_t)psa_verify_hash_complete((psa_verify_hash_interruptible_operation_t*)#1)"

pub inline fun ffi/psa-verify-hash-complete(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>): <> int
  external/psa-verify-hash-complete(operation).int

// \brief                     Abort a verify hash operation.
// 
// \warning                   This is a beta API, and thus subject to change at
// any point. It is not bound by the usual interface
// stability promises.
// 
// \note                      This function is the only function that clears the
// number of ops completed as part of the operation.
// Please ensure you copy this value via
// \c psa_verify_hash_get_num_ops() if required
// before calling.
// 
// \note                      Aborting an operation frees all associated
// resources except for the operation structure
// itself. Once aborted, the operation object can be
// reused for another operation by calling \c
// psa_verify_hash_start() again.
// 
// \note                      You may call this function any time after the
// operation object has been initialized.
// In particular, calling \c psa_verify_hash_abort()
// after the operation has already been terminated by
// a call to \c psa_verify_hash_abort() or
// psa_verify_hash_complete() is safe.
// 
// \param[in,out] operation   Initialized verify hash operation.
// 
// \retval #PSA_SUCCESS
// The operation was aborted successfully.
// 
// \retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-verify-hash-abort(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>): int32
  c inline "(psa_status_t)psa_verify_hash_abort((psa_verify_hash_interruptible_operation_t*)#1)"

pub inline fun ffi/psa-verify-hash-abort(^operation: c-pointer<psa-verify-hash-interruptible-operation-s-c>): <> int
  external/psa-verify-hash-abort(operation).int

// \brief          Initialize MD5 context
// 
// \param ctx      MD5 context to be initialized
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-init(^ctx1: c-pointer<mbedtls-md5-context-c>): ()
  c inline "(void)mbedtls_md5_init((struct mbedtls_md5_context*)#1)"

// \brief          Clear MD5 context
// 
// \param ctx      MD5 context to be cleared
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-free(^ctx1: c-pointer<mbedtls-md5-context-c>): ()
  c inline "(void)mbedtls_md5_free((struct mbedtls_md5_context*)#1)"

// \brief          Clone (the state of) an MD5 context
// 
// \param dst      The destination context
// \param src      The context to be cloned
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-clone(^dst: c-pointer<mbedtls-md5-context-c>, ^src: c-pointer<mbedtls-md5-context-c>): ()
  c inline "(void)mbedtls_md5_clone((struct mbedtls_md5_context*)#1, (struct mbedtls_md5_context*)#2)"

// \brief          MD5 context setup
// 
// \param ctx      context to be initialized
// 
// \return         0 if successful
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-starts(^ctx1: c-pointer<mbedtls-md5-context-c>): int32
  c inline "(int)mbedtls_md5_starts((struct mbedtls_md5_context*)#1)"

pub inline fun ffi/mbedtls-md5-starts(^ctx1: c-pointer<mbedtls-md5-context-c>): <> int
  external/mbedtls-md5-starts(ctx1).int

// \brief          MD5 process buffer
// 
// \param ctx      MD5 context
// \param input    buffer holding the data
// \param ilen     length of the input data
// 
// \return         0 if successful
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-update(^ctx1: c-pointer<mbedtls-md5-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_md5_update((struct mbedtls_md5_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-md5-update(^ctx1: c-pointer<mbedtls-md5-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-md5-update(ctx1, input, ilen.ssize_t).int

// \brief          MD5 final digest
// 
// \param ctx      MD5 context
// \param output   MD5 checksum result
// 
// \return         0 if successful
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-finish(^ctx1: c-pointer<mbedtls-md5-context-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md5_finish((struct mbedtls_md5_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-md5-finish(^ctx1: c-pointer<mbedtls-md5-context-c>, ^output: c-array<int>): <> int
  external/mbedtls-md5-finish(ctx1, output.cextern/carray/ptr).int

// \brief          MD5 process data block (internal use only)
// 
// \param ctx      MD5 context
// \param data     buffer holding one block of data
// 
// \return         0 if successful
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-internal-md5-process(^ctx1: c-pointer<mbedtls-md5-context-c>, ^data: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_md5_process((struct mbedtls_md5_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-internal-md5-process(^ctx1: c-pointer<mbedtls-md5-context-c>, ^data: c-array<int>): <> int
  external/mbedtls-internal-md5-process(ctx1, data.cextern/carray/ptr).int

// \brief          Output = MD5( input buffer )
// 
// \param input    buffer holding the data
// \param ilen     length of the input data
// \param output   MD5 checksum result
// 
// \return         0 if successful
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5(^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_md5((unsigned char*)#1, (size_t)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-md5(^input: c-pointer<int>, ^ilen: int, ^output: c-array<int>): <> int
  external/mbedtls-md5(input, ilen.ssize_t, output.cextern/carray/ptr).int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub extern external/mbedtls-md5-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_md5_self_test((int)#1)"

pub inline fun ffi/mbedtls-md5-self-test(^verbose: int): <> int
  external/mbedtls-md5-self-test(verbose.int32).int

// \brief          Initialize RIPEMD-160 context
// 
// \param ctx      RIPEMD-160 context to be initialized
pub extern external/mbedtls-ripemd160-init(^ctx1: c-pointer<mbedtls-ripemd160-context-c>): ()
  c inline "(void)mbedtls_ripemd160_init((struct mbedtls_ripemd160_context*)#1)"

// \brief          Clear RIPEMD-160 context
// 
// \param ctx      RIPEMD-160 context to be cleared
pub extern external/mbedtls-ripemd160-free(^ctx1: c-pointer<mbedtls-ripemd160-context-c>): ()
  c inline "(void)mbedtls_ripemd160_free((struct mbedtls_ripemd160_context*)#1)"

// \brief          Clone (the state of) a RIPEMD-160 context
// 
// \param dst      The destination context
// \param src      The context to be cloned
pub extern external/mbedtls-ripemd160-clone(^dst: c-pointer<mbedtls-ripemd160-context-c>, ^src: c-pointer<mbedtls-ripemd160-context-c>): ()
  c inline "(void)mbedtls_ripemd160_clone((struct mbedtls_ripemd160_context*)#1, (struct mbedtls_ripemd160_context*)#2)"

// \brief          RIPEMD-160 context setup
// 
// \param ctx      context to be initialized
// 
// \return         0 if successful
pub extern external/mbedtls-ripemd160-starts(^ctx1: c-pointer<mbedtls-ripemd160-context-c>): int32
  c inline "(int)mbedtls_ripemd160_starts((struct mbedtls_ripemd160_context*)#1)"

pub inline fun ffi/mbedtls-ripemd160-starts(^ctx1: c-pointer<mbedtls-ripemd160-context-c>): <> int
  external/mbedtls-ripemd160-starts(ctx1).int

// \brief          RIPEMD-160 process buffer
// 
// \param ctx      RIPEMD-160 context
// \param input    buffer holding the data
// \param ilen     length of the input data
// 
// \return         0 if successful
pub extern external/mbedtls-ripemd160-update(^ctx1: c-pointer<mbedtls-ripemd160-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_ripemd160_update((struct mbedtls_ripemd160_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ripemd160-update(^ctx1: c-pointer<mbedtls-ripemd160-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-ripemd160-update(ctx1, input, ilen.ssize_t).int

// \brief          RIPEMD-160 final digest
// 
// \param ctx      RIPEMD-160 context
// \param output   RIPEMD-160 checksum result
// 
// \return         0 if successful
pub extern external/mbedtls-ripemd160-finish(^ctx1: c-pointer<mbedtls-ripemd160-context-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_ripemd160_finish((struct mbedtls_ripemd160_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-ripemd160-finish(^ctx1: c-pointer<mbedtls-ripemd160-context-c>, ^output: c-array<int>): <> int
  external/mbedtls-ripemd160-finish(ctx1, output.cextern/carray/ptr).int

// \brief          RIPEMD-160 process data block (internal use only)
// 
// \param ctx      RIPEMD-160 context
// \param data     buffer holding one block of data
// 
// \return         0 if successful
pub extern external/mbedtls-internal-ripemd160-process(^ctx1: c-pointer<mbedtls-ripemd160-context-c>, ^data: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_ripemd160_process((struct mbedtls_ripemd160_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-internal-ripemd160-process(^ctx1: c-pointer<mbedtls-ripemd160-context-c>, ^data: c-array<int>): <> int
  external/mbedtls-internal-ripemd160-process(ctx1, data.cextern/carray/ptr).int

// \brief          Output = RIPEMD-160( input buffer )
// 
// \param input    buffer holding the data
// \param ilen     length of the input data
// \param output   RIPEMD-160 checksum result
// 
// \return         0 if successful
pub extern external/mbedtls-ripemd160(^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_ripemd160((unsigned char*)#1, (size_t)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-ripemd160(^input: c-pointer<int>, ^ilen: int, ^output: c-array<int>): <> int
  external/mbedtls-ripemd160(input, ilen.ssize_t, output.cextern/carray/ptr).int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
pub extern external/mbedtls-ripemd160-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_ripemd160_self_test((int)#1)"

pub inline fun ffi/mbedtls-ripemd160-self-test(^verbose: int): <> int
  external/mbedtls-ripemd160-self-test(verbose.int32).int

// \brief          This function initializes a SHA-1 context.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param ctx      The SHA-1 context to initialize.
// This must not be \c NULL.
pub extern external/mbedtls-sha1-init(^ctx1: c-pointer<mbedtls-sha1-context-c>): ()
  c inline "(void)mbedtls_sha1_init((struct mbedtls_sha1_context*)#1)"

// \brief          This function clears a SHA-1 context.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param ctx      The SHA-1 context to clear. This may be \c NULL,
// in which case this function does nothing. If it is
// not \c NULL, it must point to an initialized
// SHA-1 context.
pub extern external/mbedtls-sha1-free(^ctx1: c-pointer<mbedtls-sha1-context-c>): ()
  c inline "(void)mbedtls_sha1_free((struct mbedtls_sha1_context*)#1)"

// \brief          This function clones the state of a SHA-1 context.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param dst      The SHA-1 context to clone to. This must be initialized.
// \param src      The SHA-1 context to clone from. This must be initialized.
pub extern external/mbedtls-sha1-clone(^dst: c-pointer<mbedtls-sha1-context-c>, ^src: c-pointer<mbedtls-sha1-context-c>): ()
  c inline "(void)mbedtls_sha1_clone((struct mbedtls_sha1_context*)#1, (struct mbedtls_sha1_context*)#2)"

// \brief          This function starts a SHA-1 checksum calculation.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param ctx      The SHA-1 context to initialize. This must be initialized.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha1-starts(^ctx1: c-pointer<mbedtls-sha1-context-c>): int32
  c inline "(int)mbedtls_sha1_starts((struct mbedtls_sha1_context*)#1)"

pub inline fun ffi/mbedtls-sha1-starts(^ctx1: c-pointer<mbedtls-sha1-context-c>): <> int
  external/mbedtls-sha1-starts(ctx1).int

// \brief          This function feeds an input buffer into an ongoing SHA-1
// checksum calculation.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param ctx      The SHA-1 context. This must be initialized
// and have a hash operation started.
// \param input    The buffer holding the input data.
// This must be a readable buffer of length \p ilen Bytes.
// \param ilen     The length of the input data \p input in Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha1-update(^ctx1: c-pointer<mbedtls-sha1-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_sha1_update((struct mbedtls_sha1_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-sha1-update(^ctx1: c-pointer<mbedtls-sha1-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-sha1-update(ctx1, input, ilen.ssize_t).int

// \brief          This function finishes the SHA-1 operation, and writes
// the result to the output buffer.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param ctx      The SHA-1 context to use. This must be initialized and
// have a hash operation started.
// \param output   The SHA-1 checksum result. This must be a writable
// buffer of length \c 20 Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha1-finish(^ctx1: c-pointer<mbedtls-sha1-context-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_sha1_finish((struct mbedtls_sha1_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-sha1-finish(^ctx1: c-pointer<mbedtls-sha1-context-c>, ^output: c-array<int>): <> int
  external/mbedtls-sha1-finish(ctx1, output.cextern/carray/ptr).int

// \brief          SHA-1 process data block (internal use only).
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param ctx      The SHA-1 context to use. This must be initialized.
// \param data     The data block being processed. This must be a
// readable buffer of length \c 64 Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-internal-sha1-process(^ctx1: c-pointer<mbedtls-sha1-context-c>, ^data: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_sha1_process((struct mbedtls_sha1_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-internal-sha1-process(^ctx1: c-pointer<mbedtls-sha1-context-c>, ^data: c-array<int>): <> int
  external/mbedtls-internal-sha1-process(ctx1, data.cextern/carray/ptr).int

// \brief          This function calculates the SHA-1 checksum of a buffer.
// 
// The function allocates the context, performs the
// calculation, and frees the context.
// 
// The SHA-1 result is calculated as
// output = SHA-1(input buffer).
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \param input    The buffer holding the input data.
// This must be a readable buffer of length \p ilen Bytes.
// \param ilen     The length of the input data \p input in Bytes.
// \param output   The SHA-1 checksum result.
// This must be a writable buffer of length \c 20 Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha1(^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_sha1((unsigned char*)#1, (size_t)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-sha1(^input: c-pointer<int>, ^ilen: int, ^output: c-array<int>): <> int
  external/mbedtls-sha1(input, ilen.ssize_t, output.cextern/carray/ptr).int

// \brief          The SHA-1 checkup routine.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-sha1-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_sha1_self_test((int)#1)"

pub inline fun ffi/mbedtls-sha1-self-test(^verbose: int): <> int
  external/mbedtls-sha1-self-test(verbose.int32).int

// \brief          This function initializes a SHA-256 context.
// 
// \param ctx      The SHA-256 context to initialize. This must not be \c NULL.
pub extern external/mbedtls-sha256-init(^ctx1: c-pointer<mbedtls-sha256-context-c>): ()
  c inline "(void)mbedtls_sha256_init((struct mbedtls_sha256_context*)#1)"

// \brief          This function clears a SHA-256 context.
// 
// \param ctx      The SHA-256 context to clear. This may be \c NULL, in which
// case this function returns immediately. If it is not \c NULL,
// it must point to an initialized SHA-256 context.
pub extern external/mbedtls-sha256-free(^ctx1: c-pointer<mbedtls-sha256-context-c>): ()
  c inline "(void)mbedtls_sha256_free((struct mbedtls_sha256_context*)#1)"

// \brief          This function clones the state of a SHA-256 context.
// 
// \param dst      The destination context. This must be initialized.
// \param src      The context to clone. This must be initialized.
pub extern external/mbedtls-sha256-clone(^dst: c-pointer<mbedtls-sha256-context-c>, ^src: c-pointer<mbedtls-sha256-context-c>): ()
  c inline "(void)mbedtls_sha256_clone((struct mbedtls_sha256_context*)#1, (struct mbedtls_sha256_context*)#2)"

// \brief          This function starts a SHA-224 or SHA-256 checksum
// calculation.
// 
// \param ctx      The context to use. This must be initialized.
// \param is224    This determines which function to use. This must be
// either \c 0 for SHA-256, or \c 1 for SHA-224.
// 
// \note           is224 must be defined accordingly to the enabled
// MBEDTLS_SHA224_C/MBEDTLS_SHA256_C symbols otherwise the
// function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha256-starts(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^is224: int32): int32
  c inline "(int)mbedtls_sha256_starts((struct mbedtls_sha256_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-sha256-starts(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^is224: int): <> int
  external/mbedtls-sha256-starts(ctx1, is224.int32).int

// \brief          This function feeds an input buffer into an ongoing
// SHA-256 checksum calculation.
// 
// \param ctx      The SHA-256 context. This must be initialized
// and have a hash operation started.
// \param input    The buffer holding the data. This must be a readable
// buffer of length \p ilen Bytes.
// \param ilen     The length of the input data in Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha256-update(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_sha256_update((struct mbedtls_sha256_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-sha256-update(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-sha256-update(ctx1, input, ilen.ssize_t).int

// \brief          This function finishes the SHA-256 operation, and writes
// the result to the output buffer.
// 
// \param ctx      The SHA-256 context. This must be initialized
// and have a hash operation started.
// \param output   The SHA-224 or SHA-256 checksum result.
// This must be a writable buffer of length \c 32 bytes
// for SHA-256, \c 28 bytes for SHA-224.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha256-finish(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_sha256_finish((struct mbedtls_sha256_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-sha256-finish(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^output: c-pointer<int>): <> int
  external/mbedtls-sha256-finish(ctx1, output).int

// \brief          This function processes a single data block within
// the ongoing SHA-256 computation. This function is for
// internal use only.
// 
// \param ctx      The SHA-256 context. This must be initialized.
// \param data     The buffer holding one block of data. This must
// be a readable buffer of length \c 64 Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-internal-sha256-process(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^data: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_sha256_process((struct mbedtls_sha256_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-internal-sha256-process(^ctx1: c-pointer<mbedtls-sha256-context-c>, ^data: c-array<int>): <> int
  external/mbedtls-internal-sha256-process(ctx1, data.cextern/carray/ptr).int

// \brief          This function calculates the SHA-224 or SHA-256
// checksum of a buffer.
// 
// The function allocates the context, performs the
// calculation, and frees the context.
// 
// The SHA-256 result is calculated as
// output = SHA-256(input buffer).
// 
// \param input    The buffer holding the data. This must be a readable
// buffer of length \p ilen Bytes.
// \param ilen     The length of the input data in Bytes.
// \param output   The SHA-224 or SHA-256 checksum result.
// This must be a writable buffer of length \c 32 bytes
// for SHA-256, \c 28 bytes for SHA-224.
// \param is224    Determines which function to use. This must be
// either \c 0 for SHA-256, or \c 1 for SHA-224.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha256(^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^is224: int32): int32
  c inline "(int)mbedtls_sha256((unsigned char*)#1, (size_t)#2, (unsigned char*)#3, (int)#4)"

pub inline fun ffi/mbedtls-sha256(^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^is224: int): <> int
  external/mbedtls-sha256(input, ilen.ssize_t, output, is224.int32).int

// \brief          The SHA-224 checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-sha224-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_sha224_self_test((int)#1)"

pub inline fun ffi/mbedtls-sha224-self-test(^verbose: int): <> int
  external/mbedtls-sha224-self-test(verbose.int32).int

// \brief          The SHA-256 checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-sha256-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_sha256_self_test((int)#1)"

pub inline fun ffi/mbedtls-sha256-self-test(^verbose: int): <> int
  external/mbedtls-sha256-self-test(verbose.int32).int

// \brief          This function initializes a SHA-512 context.
// 
// \param ctx      The SHA-512 context to initialize. This must
// not be \c NULL.
pub extern external/mbedtls-sha512-init(^ctx1: c-pointer<mbedtls-sha512-context-c>): ()
  c inline "(void)mbedtls_sha512_init((struct mbedtls_sha512_context*)#1)"

// \brief          This function clears a SHA-512 context.
// 
// \param ctx      The SHA-512 context to clear. This may be \c NULL,
// in which case this function does nothing. If it
// is not \c NULL, it must point to an initialized
// SHA-512 context.
pub extern external/mbedtls-sha512-free(^ctx1: c-pointer<mbedtls-sha512-context-c>): ()
  c inline "(void)mbedtls_sha512_free((struct mbedtls_sha512_context*)#1)"

// \brief          This function clones the state of a SHA-512 context.
// 
// \param dst      The destination context. This must be initialized.
// \param src      The context to clone. This must be initialized.
pub extern external/mbedtls-sha512-clone(^dst: c-pointer<mbedtls-sha512-context-c>, ^src: c-pointer<mbedtls-sha512-context-c>): ()
  c inline "(void)mbedtls_sha512_clone((struct mbedtls_sha512_context*)#1, (struct mbedtls_sha512_context*)#2)"

// \brief          This function starts a SHA-384 or SHA-512 checksum
// calculation.
// 
// \param ctx      The SHA-512 context to use. This must be initialized.
// \param is384    Determines which function to use. This must be
// either \c 0 for SHA-512, or \c 1 for SHA-384.
// 
// \note           is384 must be defined accordingly to the enabled
// MBEDTLS_SHA384_C/MBEDTLS_SHA512_C symbols otherwise the
// function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha512-starts(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^is384: int32): int32
  c inline "(int)mbedtls_sha512_starts((struct mbedtls_sha512_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-sha512-starts(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^is384: int): <> int
  external/mbedtls-sha512-starts(ctx1, is384.int32).int

// \brief          This function feeds an input buffer into an ongoing
// SHA-512 checksum calculation.
// 
// \param ctx      The SHA-512 context. This must be initialized
// and have a hash operation started.
// \param input    The buffer holding the input data. This must
// be a readable buffer of length \p ilen Bytes.
// \param ilen     The length of the input data in Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha512-update(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_sha512_update((struct mbedtls_sha512_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-sha512-update(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-sha512-update(ctx1, input, ilen.ssize_t).int

// \brief          This function finishes the SHA-512 operation, and writes
// the result to the output buffer.
// 
// \param ctx      The SHA-512 context. This must be initialized
// and have a hash operation started.
// \param output   The SHA-384 or SHA-512 checksum result.
// This must be a writable buffer of length \c 64 bytes
// for SHA-512, \c 48 bytes for SHA-384.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha512-finish(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_sha512_finish((struct mbedtls_sha512_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-sha512-finish(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^output: c-pointer<int>): <> int
  external/mbedtls-sha512-finish(ctx1, output).int

// \brief          This function processes a single data block within
// the ongoing SHA-512 computation.
// This function is for internal use only.
// 
// \param ctx      The SHA-512 context. This must be initialized.
// \param data     The buffer holding one block of data. This
// must be a readable buffer of length \c 128 Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-internal-sha512-process(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^data: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_sha512_process((struct mbedtls_sha512_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-internal-sha512-process(^ctx1: c-pointer<mbedtls-sha512-context-c>, ^data: c-array<int>): <> int
  external/mbedtls-internal-sha512-process(ctx1, data.cextern/carray/ptr).int

// \brief          This function calculates the SHA-512 or SHA-384
// checksum of a buffer.
// 
// The function allocates the context, performs the
// calculation, and frees the context.
// 
// The SHA-512 result is calculated as
// output = SHA-512(input buffer).
// 
// \param input    The buffer holding the input data. This must be
// a readable buffer of length \p ilen Bytes.
// \param ilen     The length of the input data in Bytes.
// \param output   The SHA-384 or SHA-512 checksum result.
// This must be a writable buffer of length \c 64 bytes
// for SHA-512, \c 48 bytes for SHA-384.
// \param is384    Determines which function to use. This must be either
// \c 0 for SHA-512, or \c 1 for SHA-384.
// 
// \note           is384 must be defined accordingly with the supported
// symbols in the config file. If:
// - is384 is 0, but \c MBEDTLS_SHA384_C is not defined, or
// - is384 is 1, but \c MBEDTLS_SHA512_C is not defined
// then the function will return
// #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha512(^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^is384: int32): int32
  c inline "(int)mbedtls_sha512((unsigned char*)#1, (size_t)#2, (unsigned char*)#3, (int)#4)"

pub inline fun ffi/mbedtls-sha512(^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^is384: int): <> int
  external/mbedtls-sha512(input, ilen.ssize_t, output, is384.int32).int

// \brief          The SHA-384 checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-sha384-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_sha384_self_test((int)#1)"

pub inline fun ffi/mbedtls-sha384-self-test(^verbose: int): <> int
  external/mbedtls-sha384-self-test(verbose.int32).int

// \brief          The SHA-512 checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-sha512-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_sha512_self_test((int)#1)"

pub inline fun ffi/mbedtls-sha512-self-test(^verbose: int): <> int
  external/mbedtls-sha512-self-test(verbose.int32).int

// \brief          This function initializes a SHA-3 context.
// 
// \param ctx      The SHA-3 context to initialize. This must not be \c NULL.
pub extern external/mbedtls-sha3-init(^ctx1: c-pointer<mbedtls-sha3-context-c>): ()
  c inline "(void)mbedtls_sha3_init((mbedtls_sha3_context*)#1)"

// \brief          This function clears a SHA-3 context.
// 
// \param ctx      The SHA-3 context to clear. This may be \c NULL, in which
// case this function returns immediately. If it is not \c NULL,
// it must point to an initialized SHA-3 context.
pub extern external/mbedtls-sha3-free(^ctx1: c-pointer<mbedtls-sha3-context-c>): ()
  c inline "(void)mbedtls_sha3_free((mbedtls_sha3_context*)#1)"

// \brief          This function clones the state of a SHA-3 context.
// 
// \param dst      The destination context. This must be initialized.
// \param src      The context to clone. This must be initialized.
pub extern external/mbedtls-sha3-clone(^dst: c-pointer<mbedtls-sha3-context-c>, ^src: c-pointer<mbedtls-sha3-context-c>): ()
  c inline "(void)mbedtls_sha3_clone((mbedtls_sha3_context*)#1, (mbedtls_sha3_context*)#2)"

// \brief          This function starts a SHA-3 checksum
// calculation.
// 
// \param ctx      The context to use. This must be initialized.
// \param id       The id of the SHA-3 family.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha3-starts(^ctx1: c-pointer<mbedtls-sha3-context-c>, ^id: int32): int32
  c inline "(int)mbedtls_sha3_starts((mbedtls_sha3_context*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-sha3-starts(^ctx1: c-pointer<mbedtls-sha3-context-c>, ^id: mbedtls-sha3-id): <exn> int
  external/mbedtls-sha3-starts(ctx1, id.mbedtls-sha3-id/int).int

// \brief          This function feeds an input buffer into an ongoing
// SHA-3 checksum calculation.
// 
// \param ctx      The SHA-3 context. This must be initialized
// and have a hash operation started.
// \param input    The buffer holding the data. This must be a readable
// buffer of length \p ilen Bytes.
// \param ilen     The length of the input data in Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha3-update(^ctx1: c-pointer<mbedtls-sha3-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_sha3_update((mbedtls_sha3_context*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-sha3-update(^ctx1: c-pointer<mbedtls-sha3-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-sha3-update(ctx1, input, ilen.ssize_t).int

// \brief          This function finishes the SHA-3 operation, and writes
// the result to the output buffer.
// 
// \param ctx      The SHA-3 context. This must be initialized
// and have a hash operation started.
// \param output   The SHA-3 checksum result.
// This must be a writable buffer of length \c olen bytes.
// \param olen     Defines the length of output buffer (in bytes). For SHA-3 224, SHA-3 256,
// SHA-3 384 and SHA-3 512 \c olen must equal to 28, 32, 48 and 64,
// respectively.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha3-finish(^ctx1: c-pointer<mbedtls-sha3-context-c>, ^output: c-pointer<int>, ^olen: ssize_t): int32
  c inline "(int)mbedtls_sha3_finish((mbedtls_sha3_context*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-sha3-finish(^ctx1: c-pointer<mbedtls-sha3-context-c>, ^output: c-pointer<int>, ^olen: int): <> int
  external/mbedtls-sha3-finish(ctx1, output, olen.ssize_t).int

// \brief          This function calculates the SHA-3
// checksum of a buffer.
// 
// The function allocates the context, performs the
// calculation, and frees the context.
// 
// The SHA-3 result is calculated as
// output = SHA-3(id, input buffer, d).
// 
// \param id       The id of the SHA-3 family.
// \param input    The buffer holding the data. This must be a readable
// buffer of length \p ilen Bytes.
// \param ilen     The length of the input data in Bytes.
// \param output   The SHA-3 checksum result.
// This must be a writable buffer of length \c olen bytes.
// \param olen     Defines the length of output buffer (in bytes). For SHA-3 224, SHA-3 256,
// SHA-3 384 and SHA-3 512 \c olen must equal to 28, 32, 48 and 64,
// respectively.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-sha3(^id: int32, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^olen: ssize_t): int32
  c inline "(int)mbedtls_sha3((int32_t)#1, (uint8_t*)#2, (size_t)#3, (uint8_t*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-sha3(^id: mbedtls-sha3-id, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^olen: int): <exn> int
  external/mbedtls-sha3(id.mbedtls-sha3-id/int, input, ilen.ssize_t, output, olen.ssize_t).int

// \brief          Checkup routine for the algorithms implemented
// by this module: SHA3-224, SHA3-256, SHA3-384, SHA3-512.
// 
// \return         0 if successful, or 1 if the test failed.
pub extern external/mbedtls-sha3-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_sha3_self_test((int)#1)"

pub inline fun ffi/mbedtls-sha3-self-test(^verbose: int): <> int
  external/mbedtls-sha3-self-test(verbose.int32).int

// \brief This function retrieves the list of ciphers supported
// by the generic cipher module.
// 
// For any cipher identifier in the returned list, you can
// obtain the corresponding generic cipher information structure
// via mbedtls_cipher_info_from_type(), which can then be used
// to prepare a cipher context via mbedtls_cipher_setup().
// 
// 
// \return      A statically-allocated array of cipher identifiers
// of type cipher_type_t. The last entry is zero.
pub extern external/mbedtls-cipher-list(): c-pointer<int>
  c inline "(intptr_t)mbedtls_cipher_list()"

// \brief               This function retrieves the cipher-information
// structure associated with the given cipher name.
// 
// \param cipher_name   Name of the cipher to search for. This must not be
// \c NULL.
// 
// \return              The cipher information structure associated with the
// given \p cipher_name.
// \return              \c NULL if the associated cipher information is not found.
pub extern external/mbedtls-cipher-info-from-string(^cipher-name: c-pointer<int>): c-pointer<mbedtls-cipher-info-t-c>
  c inline "(intptr_t)mbedtls_cipher_info_from_string((char*)#1)"

// \brief               This function retrieves the cipher-information
// structure associated with the given cipher type.
// 
// \param cipher_type   Type of the cipher to search for.
// 
// \return              The cipher information structure associated with the
// given \p cipher_type.
// \return              \c NULL if the associated cipher information is not found.
pub extern external/mbedtls-cipher-info-from-type(^cipher-type: int32): c-pointer<mbedtls-cipher-info-t-c>
  c inline "(intptr_t)mbedtls_cipher_info_from_type((int32_t)#1)"

pub inline fun ffi/mbedtls-cipher-info-from-type(^cipher-type: mbedtls-cipher-type-t): <exn> c-pointer<mbedtls-cipher-info-t-c>
  external/mbedtls-cipher-info-from-type(cipher-type.mbedtls-cipher-type-t/int)

// \brief               This function retrieves the cipher-information
// structure associated with the given cipher ID,
// key size and mode.
// 
// \param cipher_id     The ID of the cipher to search for. For example,
// #MBEDTLS_CIPHER_ID_AES.
// \param key_bitlen    The length of the key in bits.
// \param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.
// 
// \return              The cipher information structure associated with the
// given \p cipher_id.
// \return              \c NULL if the associated cipher information is not found.
pub extern external/mbedtls-cipher-info-from-values(^cipher-id: int32, ^key-bitlen: int32, ^mode: int32): c-pointer<mbedtls-cipher-info-t-c>
  c inline "(intptr_t)mbedtls_cipher_info_from_values((int32_t)#1, (int)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-cipher-info-from-values(^cipher-id: mbedtls-cipher-id-t, ^key-bitlen: int, ^mode: mbedtls-cipher-mode-t): <exn> c-pointer<mbedtls-cipher-info-t-c>
  external/mbedtls-cipher-info-from-values(cipher-id.mbedtls-cipher-id-t/int, key-bitlen.int32, mode.mbedtls-cipher-mode-t/int)

// \brief               This function initializes a \p ctx as NONE.
// 
// \param ctx           The context to be initialized. This must not be \c NULL.
pub extern external/mbedtls-cipher-init(^ctx1: c-pointer<mbedtls-cipher-context-t-c>): ()
  c inline "(void)mbedtls_cipher_init((struct mbedtls_cipher_context_t*)#1)"

// \brief               This function frees and clears the cipher-specific
// context of \p ctx. Freeing \p ctx itself remains the
// responsibility of the caller.
// 
// \param ctx           The context to be freed. If this is \c NULL, the
// function has no effect, otherwise this must point to an
// initialized context.
pub extern external/mbedtls-cipher-free(^ctx1: c-pointer<mbedtls-cipher-context-t-c>): ()
  c inline "(void)mbedtls_cipher_free((struct mbedtls_cipher_context_t*)#1)"

// \brief               This function prepares a cipher context for
// use with the given cipher primitive.
// 
// \note                After calling this function, you should call
// mbedtls_cipher_setkey() and, if the mode uses padding,
// mbedtls_cipher_set_padding_mode(), then for each
// message to encrypt or decrypt with this key, either:
// - mbedtls_cipher_crypt() for one-shot processing with
// non-AEAD modes;
// - mbedtls_cipher_auth_encrypt_ext() or
// mbedtls_cipher_auth_decrypt_ext() for one-shot
// processing with AEAD modes or NIST_KW;
// - for multi-part processing, see the documentation of
// mbedtls_cipher_reset().
// 
// \param ctx           The context to prepare. This must be initialized by
// a call to mbedtls_cipher_init() first.
// \param cipher_info   The cipher to use.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the
// cipher-specific context fails.
pub extern external/mbedtls-cipher-setup(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^cipher-info: c-pointer<mbedtls-cipher-info-t-c>): int32
  c inline "(int)mbedtls_cipher_setup((struct mbedtls_cipher_context_t*)#1, (struct mbedtls_cipher_info_t*)#2)"

pub inline fun ffi/mbedtls-cipher-setup(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^cipher-info: c-pointer<mbedtls-cipher-info-t-c>): <> int
  external/mbedtls-cipher-setup(ctx1, cipher-info).int

// \brief               This function sets the key to use with the given context.
// 
// \param ctx           The generic cipher context. This must be initialized and
// bound to a cipher information structure.
// \param key           The key to use. This must be a readable buffer of at
// least \p key_bitlen Bits.
// \param key_bitlen    The key length to use, in Bits.
// \param operation     The operation that the key will be used for:
// #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-setkey(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^key: c-pointer<int>, ^key-bitlen: int32, ^operation: int32): int32
  c inline "(int)mbedtls_cipher_setkey((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (int)#3, (int32_t)#4)"

pub inline fun ffi/mbedtls-cipher-setkey(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^key: c-pointer<int>, ^key-bitlen: int, ^operation: mbedtls-operation-t): <exn> int
  external/mbedtls-cipher-setkey(ctx1, key, key-bitlen.int32, operation.mbedtls-operation-t/int).int

// \brief               This function sets the padding mode, for cipher modes
// that use padding.
// 
// 
// \param ctx           The generic cipher context. This must be initialized and
// bound to a cipher information structure.
// \param mode          The padding mode.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE
// if the selected padding mode is not supported.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode
// does not support padding.
pub extern external/mbedtls-cipher-set-padding-mode(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^mode: int32): int32
  c inline "(int)mbedtls_cipher_set_padding_mode((struct mbedtls_cipher_context_t*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-cipher-set-padding-mode(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^mode: mbedtls-cipher-padding-t): <exn> int
  external/mbedtls-cipher-set-padding-mode(ctx1, mode.mbedtls-cipher-padding-t/int).int

// \brief           This function sets the initialization vector (IV)
// or nonce.
// 
// \note            Some ciphers do not use IVs nor nonce. For these
// ciphers, this function has no effect.
// 
// \note            For #MBEDTLS_CIPHER_CHACHA20, the nonce length must
// be 12, and the initial counter value is 0.
// 
// \note            For #MBEDTLS_CIPHER_CHACHA20_POLY1305, the nonce length
// must be 12.
// 
// \param ctx       The generic cipher context. This must be initialized and
// bound to a cipher information structure.
// \param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This
// must be a readable buffer of at least \p iv_len Bytes.
// \param iv_len    The IV length for ciphers with variable-size IV.
// This parameter is discarded by ciphers with fixed-size IV.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
pub extern external/mbedtls-cipher-set-iv(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: ssize_t): int32
  c inline "(int)mbedtls_cipher_set_iv((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-cipher-set-iv(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: int): <> int
  external/mbedtls-cipher-set-iv(ctx1, iv, iv-len.ssize_t).int

// \brief         This function resets the cipher state.
// 
// \note          With non-AEAD ciphers, the order of calls for each message
// is as follows:
// 1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.
// 2. mbedtls_cipher_reset()
// 3. mbedtls_cipher_update() one or more times
// 4. mbedtls_cipher_finish()
// .
// This sequence can be repeated to encrypt or decrypt multiple
// messages with the same key.
// 
// \note          With AEAD ciphers, the order of calls for each message
// is as follows:
// 1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.
// 2. mbedtls_cipher_reset()
// 3. mbedtls_cipher_update_ad()
// 4. mbedtls_cipher_update() one or more times
// 5. mbedtls_cipher_finish()
// 6. mbedtls_cipher_check_tag() (for decryption) or
// mbedtls_cipher_write_tag() (for encryption).
// .
// This sequence can be repeated to encrypt or decrypt multiple
// messages with the same key.
// 
// \param ctx     The generic cipher context. This must be bound to a key.
// 
// \return        \c 0 on success.
// \return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
pub extern external/mbedtls-cipher-reset(^ctx1: c-pointer<mbedtls-cipher-context-t-c>): int32
  c inline "(int)mbedtls_cipher_reset((struct mbedtls_cipher_context_t*)#1)"

pub inline fun ffi/mbedtls-cipher-reset(^ctx1: c-pointer<mbedtls-cipher-context-t-c>): <> int
  external/mbedtls-cipher-reset(ctx1).int

// \brief               This function adds additional data for AEAD ciphers.
// Currently supported with GCM and ChaCha20+Poly1305.
// 
// \param ctx           The generic cipher context. This must be initialized.
// \param ad            The additional data to use. This must be a readable
// buffer of at least \p ad_len Bytes.
// \param ad_len        The length of \p ad in Bytes.
// 
// \return              \c 0 on success.
// \return              A specific error code on failure.
pub extern external/mbedtls-cipher-update-ad(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^ad: c-pointer<int>, ^ad-len: ssize_t): int32
  c inline "(int)mbedtls_cipher_update_ad((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-cipher-update-ad(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^ad: c-pointer<int>, ^ad-len: int): <> int
  external/mbedtls-cipher-update-ad(ctx1, ad, ad-len.ssize_t).int

// \brief               The generic cipher update function. It encrypts or
// decrypts using the given cipher context. Writes as
// many block-sized blocks of data as possible to output.
// Any data that cannot be written immediately is either
// added to the next block, or flushed when
// mbedtls_cipher_finish() is called.
// Exception: For MBEDTLS_MODE_ECB, expects a single block
// in size. For example, 16 Bytes for AES.
// 
// \param ctx           The generic cipher context. This must be initialized and
// bound to a key.
// \param input         The buffer holding the input data. This must be a
// readable buffer of at least \p ilen Bytes.
// \param ilen          The length of the input data.
// \param output        The buffer for the output data. This must be able to
// hold at least `ilen + block_size`. This must not be the
// same buffer as \p input.
// \param olen          The length of the output data, to be updated with the
// actual number of Bytes written. This must not be
// \c NULL.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an
// unsupported mode for a cipher.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-update(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_cipher_update((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t*)#5)"

pub inline fun ffi/mbedtls-cipher-update(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^olen: c-pointer<int>): <> int
  external/mbedtls-cipher-update(ctx1, input, ilen.ssize_t, output, olen).int

// \brief               The generic cipher finalization function. If data still
// needs to be flushed from an incomplete block, the data
// contained in it is padded to the size of
// the last block, and written to the \p output buffer.
// 
// \param ctx           The generic cipher context. This must be initialized and
// bound to a key.
// \param output        The buffer to write data to. This needs to be a writable
// buffer of at least block_size Bytes.
// \param olen          The length of the data written to the \p output buffer.
// This may not be \c NULL.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption
// expecting a full block but not receiving one.
// \return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding
// while decrypting.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-finish(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^output: c-pointer<int>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_cipher_finish((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-cipher-finish(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^output: c-pointer<int>, ^olen: c-pointer<int>): <> int
  external/mbedtls-cipher-finish(ctx1, output, olen).int

// \brief               This function writes a tag for AEAD ciphers.
// Currently supported with GCM and ChaCha20+Poly1305.
// This must be called after mbedtls_cipher_finish().
// 
// \param ctx           The generic cipher context. This must be initialized,
// bound to a key, and have just completed a cipher
// operation through mbedtls_cipher_finish() the tag for
// which should be written.
// \param tag           The buffer to write the tag to. This must be a writable
// buffer of at least \p tag_len Bytes.
// \param tag_len       The length of the tag to write.
// 
// \return              \c 0 on success.
// \return              A specific error code on failure.
pub extern external/mbedtls-cipher-write-tag(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_cipher_write_tag((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-cipher-write-tag(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-cipher-write-tag(ctx1, tag, tag-len.ssize_t).int

// \brief               This function checks the tag for AEAD ciphers.
// Currently supported with GCM and ChaCha20+Poly1305.
// This must be called after mbedtls_cipher_finish().
// 
// \param ctx           The generic cipher context. This must be initialized.
// \param tag           The buffer holding the tag. This must be a readable
// buffer of at least \p tag_len Bytes.
// \param tag_len       The length of the tag to check.
// 
// \return              \c 0 on success.
// \return              A specific error code on failure.
pub extern external/mbedtls-cipher-check-tag(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_cipher_check_tag((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-cipher-check-tag(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-cipher-check-tag(ctx1, tag, tag-len.ssize_t).int

// \brief               The generic all-in-one encryption/decryption function,
// for all ciphers except AEAD constructs.
// 
// \param ctx           The generic cipher context. This must be initialized.
// \param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.
// This must be a readable buffer of at least \p iv_len
// Bytes.
// \param iv_len        The IV length for ciphers with variable-size IV.
// This parameter is discarded by ciphers with fixed-size
// IV.
// \param input         The buffer holding the input data. This must be a
// readable buffer of at least \p ilen Bytes.
// \param ilen          The length of the input data in Bytes.
// \param output        The buffer for the output data. This must be able to
// hold at least `ilen + block_size`. This must not be the
// same buffer as \p input.
// \param olen          The length of the output data, to be updated with the
// actual number of Bytes written. This must not be
// \c NULL.
// 
// \note                Some ciphers do not use IVs nor nonce. For these
// ciphers, use \p iv = NULL and \p iv_len = 0.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption
// expecting a full block but not receiving one.
// \return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding
// while decrypting.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-crypt(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_cipher_crypt((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t*)#7)"

pub inline fun ffi/mbedtls-cipher-crypt(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: int, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^olen: c-pointer<int>): <> int
  external/mbedtls-cipher-crypt(ctx1, iv, iv-len.ssize_t, input, ilen.ssize_t, output, olen).int

// \brief               The authenticated encryption (AEAD/NIST_KW) function.
// 
// \note                For AEAD modes, the tag will be appended to the
// ciphertext, as recommended by RFC 5116.
// (NIST_KW doesn't have a separate tag.)
// 
// \param ctx           The generic cipher context. This must be initialized and
// bound to a key, with an AEAD algorithm or NIST_KW.
// \param iv            The nonce to use. This must be a readable buffer of
// at least \p iv_len Bytes and may be \c NULL if \p
// iv_len is \c 0.
// \param iv_len        The length of the nonce. For AEAD ciphers, this must
// satisfy the constraints imposed by the cipher used.
// For NIST_KW, this must be \c 0.
// \param ad            The additional data to authenticate. This must be a
// readable buffer of at least \p ad_len Bytes, and may
// be \c NULL is \p ad_len is \c 0.
// \param ad_len        The length of \p ad. For NIST_KW, this must be \c 0.
// \param input         The buffer holding the input data. This must be a
// readable buffer of at least \p ilen Bytes, and may be
// \c NULL if \p ilen is \c 0.
// \param ilen          The length of the input data.
// \param output        The buffer for the output data. This must be a
// writable buffer of at least \p output_len Bytes, and
// must not be \c NULL.
// \param output_len    The length of the \p output buffer in Bytes. For AEAD
// ciphers, this must be at least \p ilen + \p tag_len.
// For NIST_KW, this must be at least \p ilen + 8
// (rounded up to a multiple of 8 if KWP is used);
// \p ilen + 15 is always a safe value.
// \param olen          This will be filled with the actual number of Bytes
// written to the \p output buffer. This must point to a
// writable object of type \c size_t.
// \param tag_len       The desired length of the authentication tag. For AEAD
// ciphers, this must match the constraints imposed by
// the cipher used, and in particular must not be \c 0.
// For NIST_KW, this must be \c 0.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-auth-encrypt-ext(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^ad: c-pointer<int>, ^ad-len: ssize_t, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^output-len: ssize_t, ^olen: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_cipher_auth_encrypt_ext((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (unsigned char*)#8, (size_t)#9, (size_t*)#10, (size_t)#11)"

pub inline fun ffi/mbedtls-cipher-auth-encrypt-ext(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: int, ^ad: c-pointer<int>, ^ad-len: int, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^output-len: int, ^olen: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-cipher-auth-encrypt-ext(ctx1, iv, iv-len.ssize_t, ad, ad-len.ssize_t, input, ilen.ssize_t, output, output-len.ssize_t, olen, tag-len.ssize_t).int

// \brief               The authenticated encryption (AEAD/NIST_KW) function.
// 
// \note                If the data is not authentic, then the output buffer
// is zeroed out to prevent the unauthentic plaintext being
// used, making this interface safer.
// 
// \note                For AEAD modes, the tag must be appended to the
// ciphertext, as recommended by RFC 5116.
// (NIST_KW doesn't have a separate tag.)
// 
// \param ctx           The generic cipher context. This must be initialized and
// bound to a key, with an AEAD algorithm or NIST_KW.
// \param iv            The nonce to use. This must be a readable buffer of
// at least \p iv_len Bytes and may be \c NULL if \p
// iv_len is \c 0.
// \param iv_len        The length of the nonce. For AEAD ciphers, this must
// satisfy the constraints imposed by the cipher used.
// For NIST_KW, this must be \c 0.
// \param ad            The additional data to authenticate. This must be a
// readable buffer of at least \p ad_len Bytes, and may
// be \c NULL is \p ad_len is \c 0.
// \param ad_len        The length of \p ad. For NIST_KW, this must be \c 0.
// \param input         The buffer holding the input data. This must be a
// readable buffer of at least \p ilen Bytes, and may be
// \c NULL if \p ilen is \c 0.
// \param ilen          The length of the input data. For AEAD ciphers this
// must be at least \p tag_len. For NIST_KW this must be
// at least \c 8.
// \param output        The buffer for the output data. This must be a
// writable buffer of at least \p output_len Bytes, and
// may be \c NULL if \p output_len is \c 0.
// \param output_len    The length of the \p output buffer in Bytes. For AEAD
// ciphers, this must be at least \p ilen - \p tag_len.
// For NIST_KW, this must be at least \p ilen - 8.
// \param olen          This will be filled with the actual number of Bytes
// written to the \p output buffer. This must point to a
// writable object of type \c size_t.
// \param tag_len       The actual length of the authentication tag. For AEAD
// ciphers, this must match the constraints imposed by
// the cipher used, and in particular must not be \c 0.
// For NIST_KW, this must be \c 0.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on
// parameter-verification failure.
// \return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-auth-decrypt-ext(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^ad: c-pointer<int>, ^ad-len: ssize_t, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^output-len: ssize_t, ^olen: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_cipher_auth_decrypt_ext((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (unsigned char*)#8, (size_t)#9, (size_t*)#10, (size_t)#11)"

pub inline fun ffi/mbedtls-cipher-auth-decrypt-ext(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^iv: c-pointer<int>, ^iv-len: int, ^ad: c-pointer<int>, ^ad-len: int, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^output-len: int, ^olen: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-cipher-auth-decrypt-ext(ctx1, iv, iv-len.ssize_t, ad, ad-len.ssize_t, input, ilen.ssize_t, output, output-len.ssize_t, olen, tag-len.ssize_t).int

// \brief               This function starts a new CMAC computation
// by setting the CMAC key, and preparing to authenticate
// the input data.
// It must be called with an initialized cipher context.
// 
// Once this function has completed, data can be supplied
// to the CMAC computation by calling
// mbedtls_cipher_cmac_update().
// 
// To start a CMAC computation using the same key as a previous
// CMAC computation, use mbedtls_cipher_cmac_finish().
// 
// \note                When the CMAC implementation is supplied by an alternate
// implementation (through #MBEDTLS_CMAC_ALT), some ciphers
// may not be supported by that implementation, and thus
// return an error. Alternate implementations must support
// AES-128 and AES-256, and may support AES-192 and 3DES.
// 
// \param ctx           The cipher context used for the CMAC operation, initialized
// as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,
// MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,
// or MBEDTLS_CIPHER_DES_EDE3_ECB.
// \param key           The CMAC key.
// \param keybits       The length of the CMAC key in bits.
// Must be supported by the cipher.
// 
// \return              \c 0 on success.
// \return              A cipher-specific error code on failure.
pub extern external/mbedtls-cipher-cmac-starts(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^key: c-pointer<int>, ^keybits: ssize_t): int32
  c inline "(int)mbedtls_cipher_cmac_starts((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-cipher-cmac-starts(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-cipher-cmac-starts(ctx1, key, keybits.ssize_t).int

// \brief               This function feeds an input buffer into an ongoing CMAC
// computation.
// 
// The CMAC computation must have previously been started
// by calling mbedtls_cipher_cmac_starts() or
// mbedtls_cipher_cmac_reset().
// 
// Call this function as many times as needed to input the
// data to be authenticated.
// Once all of the required data has been input,
// call mbedtls_cipher_cmac_finish() to obtain the result
// of the CMAC operation.
// 
// \param ctx           The cipher context used for the CMAC operation.
// \param input         The buffer holding the input data.
// \param ilen          The length of the input data.
// 
// \return             \c 0 on success.
// \return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA
// if parameter verification fails.
pub extern external/mbedtls-cipher-cmac-update(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_cipher_cmac_update((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-cipher-cmac-update(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-cipher-cmac-update(ctx1, input, ilen.ssize_t).int

// \brief               This function finishes an ongoing CMAC operation, and
// writes the result to the output buffer.
// 
// It should be followed either by
// mbedtls_cipher_cmac_reset(), which starts another CMAC
// operation with the same key, or mbedtls_cipher_free(),
// which clears the cipher context.
// 
// \param ctx           The cipher context used for the CMAC operation.
// \param output        The output buffer for the CMAC checksum result.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA
// if parameter verification fails.
pub extern external/mbedtls-cipher-cmac-finish(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_cipher_cmac_finish((struct mbedtls_cipher_context_t*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-cipher-cmac-finish(^ctx1: c-pointer<mbedtls-cipher-context-t-c>, ^output: c-pointer<int>): <> int
  external/mbedtls-cipher-cmac-finish(ctx1, output).int

// \brief               This function starts a new CMAC operation with the same
// key as the previous one.
// 
// It should be called after finishing the previous CMAC
// operation with mbedtls_cipher_cmac_finish().
// After calling this function,
// call mbedtls_cipher_cmac_update() to supply the new
// CMAC operation with data.
// 
// \param ctx           The cipher context used for the CMAC operation.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA
// if parameter verification fails.
pub extern external/mbedtls-cipher-cmac-reset(^ctx1: c-pointer<mbedtls-cipher-context-t-c>): int32
  c inline "(int)mbedtls_cipher_cmac_reset((struct mbedtls_cipher_context_t*)#1)"

pub inline fun ffi/mbedtls-cipher-cmac-reset(^ctx1: c-pointer<mbedtls-cipher-context-t-c>): <> int
  external/mbedtls-cipher-cmac-reset(ctx1).int

// \brief               This function calculates the full generic CMAC
// on the input buffer with the provided key.
// 
// The function allocates the context, performs the
// calculation, and frees the context.
// 
// The CMAC result is calculated as
// output = generic CMAC(cmac key, input buffer).
// 
// \note                When the CMAC implementation is supplied by an alternate
// implementation (through #MBEDTLS_CMAC_ALT), some ciphers
// may not be supported by that implementation, and thus
// return an error. Alternate implementations must support
// AES-128 and AES-256, and may support AES-192 and 3DES.
// 
// \param cipher_info   The cipher information.
// \param key           The CMAC key.
// \param keylen        The length of the CMAC key in bits.
// \param input         The buffer holding the input data.
// \param ilen          The length of the input data.
// \param output        The buffer for the generic CMAC result.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA
// if parameter verification fails.
pub extern external/mbedtls-cipher-cmac(^cipher-info: c-pointer<mbedtls-cipher-info-t-c>, ^key: c-pointer<int>, ^keylen: ssize_t, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_cipher_cmac((struct mbedtls_cipher_info_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-cipher-cmac(^cipher-info: c-pointer<mbedtls-cipher-info-t-c>, ^key: c-pointer<int>, ^keylen: int, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>): <> int
  external/mbedtls-cipher-cmac(cipher-info, key, keylen.ssize_t, input, ilen.ssize_t, output).int

// \brief           This function implements the AES-CMAC-PRF-128 pseudorandom
// function, as defined in
// <em>RFC-4615: The Advanced Encryption Standard-Cipher-based
// Message Authentication Code-Pseudo-Random Function-128
// (AES-CMAC-PRF-128) Algorithm for the Internet Key
// Exchange Protocol (IKE).</em>
// 
// \param key       The key to use.
// \param key_len   The key length in Bytes.
// \param input     The buffer holding the input data.
// \param in_len    The length of the input data in Bytes.
// \param output    The buffer holding the generated 16 Bytes of
// pseudorandom output.
// 
// \return          \c 0 on success.
pub extern external/mbedtls-aes-cmac-prf-128(^key: c-pointer<int>, ^key-len: ssize_t, ^input: c-pointer<int>, ^in-len: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_cmac_prf_128((unsigned char*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5)"

pub inline fun ffi/mbedtls-aes-cmac-prf-128(^key: c-pointer<int>, ^key-len: int, ^input: c-pointer<int>, ^in-len: int, ^output: c-array<int>): <> int
  external/mbedtls-aes-cmac-prf-128(key, key-len.ssize_t, input, in-len.ssize_t, output.cextern/carray/ptr).int

// \brief          The CMAC checkup routine.
// 
// \note           In case the CMAC routines are provided by an alternative
// implementation (i.e. #MBEDTLS_CMAC_ALT is defined), the
// checkup routine will succeed even if the implementation does
// not support the less widely used AES-192 or 3DES primitives.
// The self-test requires at least AES-128 and AES-256 to be
// supported by the underlying implementation.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-cmac-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_cmac_self_test((int)#1)"

pub inline fun ffi/mbedtls-cmac-self-test(^verbose: int): <> int
  external/mbedtls-cmac-self-test(verbose.int32).int

// \brief           This function initializes the specified GCM context,
// to make references valid, and prepares the context
// for mbedtls_gcm_setkey() or mbedtls_gcm_free().
// 
// The function does not bind the GCM context to a particular
// cipher, nor set the key. For this purpose, use
// mbedtls_gcm_setkey().
// 
// \param ctx       The GCM context to initialize. This must not be \c NULL.
pub extern external/mbedtls-gcm-init(^ctx1: c-pointer<mbedtls-gcm-context-c>): ()
  c inline "(void)mbedtls_gcm_init((struct mbedtls_gcm_context*)#1)"

// \brief           This function associates a GCM context with a
// cipher algorithm and a key.
// 
// \param ctx       The GCM context. This must be initialized.
// \param cipher    The 128-bit block cipher to use.
// \param key       The encryption key. This must be a readable buffer of at
// least \p keybits bits.
// \param keybits   The key size in bits. Valid options are:
// <ul><li>128 bits</li>
// <li>192 bits</li>
// <li>256 bits</li></ul>
// 
// \return          \c 0 on success.
// \return          A cipher-specific error code on failure.
pub extern external/mbedtls-gcm-setkey(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^cipher: int32, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_gcm_setkey((struct mbedtls_gcm_context*)#1, (int32_t)#2, (unsigned char*)#3, (unsigned int)#4)"

pub inline fun ffi/mbedtls-gcm-setkey(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^cipher: mbedtls-cipher-id-t, ^key: c-pointer<int>, ^keybits: int): <exn> int
  external/mbedtls-gcm-setkey(ctx1, cipher.mbedtls-cipher-id-t/int, key, keybits.int32).int

// \brief           This function performs GCM encryption or decryption of a buffer.
// 
// \note            For encryption, the output buffer can be the same as the
// input buffer. For decryption, the output buffer cannot be
// the same as input buffer. If the buffers overlap, the output
// buffer must trail at least 8 Bytes behind the input buffer.
// 
// \warning         When this function performs a decryption, it outputs the
// authentication tag and does not verify that the data is
// authentic. You should use this function to perform encryption
// only. For decryption, use mbedtls_gcm_auth_decrypt() instead.
// 
// \param ctx       The GCM context to use for encryption or decryption. This
// must be initialized.
// \param mode      The operation to perform:
// - #MBEDTLS_GCM_ENCRYPT to perform authenticated encryption.
// The ciphertext is written to \p output and the
// authentication tag is written to \p tag.
// - #MBEDTLS_GCM_DECRYPT to perform decryption.
// The plaintext is written to \p output and the
// authentication tag is written to \p tag.
// Note that this mode is not recommended, because it does
// not verify the authenticity of the data. For this reason,
// you should use mbedtls_gcm_auth_decrypt() instead of
// calling this function in decryption mode.
// \param length    The length of the input data, which is equal to the length
// of the output data.
// \param iv        The initialization vector. This must be a readable buffer of
// at least \p iv_len Bytes.
// \param iv_len    The length of the IV.
// \param add       The buffer holding the additional data. This must be of at
// least that size in Bytes.
// \param add_len   The length of the additional data.
// \param input     The buffer holding the input data. If \p length is greater
// than zero, this must be a readable buffer of at least that
// size in Bytes.
// \param output    The buffer for holding the output data. If \p length is greater
// than zero, this must be a writable buffer of at least that
// size in Bytes.
// \param tag_len   The length of the tag to generate.
// \param tag       The buffer for holding the tag. This must be a writable
// buffer of at least \p tag_len Bytes.
// 
// \return          \c 0 if the encryption or decryption was performed
// successfully. Note that in #MBEDTLS_GCM_DECRYPT mode,
// this does not indicate that the data is authentic.
// \return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are
// not valid or a cipher-specific error code if the encryption
// or decryption failed.
pub extern external/mbedtls-gcm-crypt-and-tag(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^add: c-pointer<int>, ^add-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag-len: ssize_t, ^tag: c-pointer<int>): int32
  c inline "(int)mbedtls_gcm_crypt_and_tag((struct mbedtls_gcm_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (unsigned char*)#8, (unsigned char*)#9, (size_t)#10, (unsigned char*)#11)"

pub inline fun ffi/mbedtls-gcm-crypt-and-tag(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^mode: int, ^length: int, ^iv: c-pointer<int>, ^iv-len: int, ^add: c-pointer<int>, ^add-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag-len: int, ^tag: c-pointer<int>): <> int
  external/mbedtls-gcm-crypt-and-tag(ctx1, mode.int32, length.ssize_t, iv, iv-len.ssize_t, add, add-len.ssize_t, input, output, tag-len.ssize_t, tag).int

// \brief           This function performs a GCM authenticated decryption of a
// buffer.
// 
// \note            For decryption, the output buffer cannot be the same as
// input buffer. If the buffers overlap, the output buffer
// must trail at least 8 Bytes behind the input buffer.
// 
// \param ctx       The GCM context. This must be initialized.
// \param length    The length of the ciphertext to decrypt, which is also
// the length of the decrypted plaintext.
// \param iv        The initialization vector. This must be a readable buffer
// of at least \p iv_len Bytes.
// \param iv_len    The length of the IV.
// \param add       The buffer holding the additional data. This must be of at
// least that size in Bytes.
// \param add_len   The length of the additional data.
// \param tag       The buffer holding the tag to verify. This must be a
// readable buffer of at least \p tag_len Bytes.
// \param tag_len   The length of the tag to verify.
// \param input     The buffer holding the ciphertext. If \p length is greater
// than zero, this must be a readable buffer of at least that
// size.
// \param output    The buffer for holding the decrypted plaintext. If \p length
// is greater than zero, this must be a writable buffer of at
// least that size.
// 
// \return          \c 0 if successful and authenticated.
// \return          #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match.
// \return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are
// not valid or a cipher-specific error code if the decryption
// failed.
pub extern external/mbedtls-gcm-auth-decrypt(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^length: ssize_t, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^add: c-pointer<int>, ^add-len: ssize_t, ^tag: c-pointer<int>, ^tag-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_gcm_auth_decrypt((struct mbedtls_gcm_context*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (size_t)#8, (unsigned char*)#9, (unsigned char*)#10)"

pub inline fun ffi/mbedtls-gcm-auth-decrypt(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^length: int, ^iv: c-pointer<int>, ^iv-len: int, ^add: c-pointer<int>, ^add-len: int, ^tag: c-pointer<int>, ^tag-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-gcm-auth-decrypt(ctx1, length.ssize_t, iv, iv-len.ssize_t, add, add-len.ssize_t, tag, tag-len.ssize_t, input, output).int

// \brief           This function starts a GCM encryption or decryption
// operation.
// 
// \param ctx       The GCM context. This must be initialized.
// \param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or
// #MBEDTLS_GCM_DECRYPT.
// \param iv        The initialization vector. This must be a readable buffer of
// at least \p iv_len Bytes.
// \param iv_len    The length of the IV.
// 
// \return          \c 0 on success.
pub extern external/mbedtls-gcm-starts(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^mode: int32, ^iv: c-pointer<int>, ^iv-len: ssize_t): int32
  c inline "(int)mbedtls_gcm_starts((struct mbedtls_gcm_context*)#1, (int)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-gcm-starts(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^mode: int, ^iv: c-pointer<int>, ^iv-len: int): <> int
  external/mbedtls-gcm-starts(ctx1, mode.int32, iv, iv-len.ssize_t).int

// \brief           This function feeds an input buffer as associated data
// (authenticated but not encrypted data) in a GCM
// encryption or decryption operation.
// 
// Call this function after mbedtls_gcm_starts() to pass
// the associated data. If the associated data is empty,
// you do not need to call this function. You may not
// call this function after calling mbedtls_cipher_update().
// 
// \param ctx       The GCM context. This must have been started with
// mbedtls_gcm_starts() and must not have yet received
// any input with mbedtls_gcm_update().
// \param add       The buffer holding the additional data, or \c NULL
// if \p add_len is \c 0.
// \param add_len   The length of the additional data. If \c 0,
// \p add may be \c NULL.
// 
// \return          \c 0 on success.
pub extern external/mbedtls-gcm-update-ad(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^add: c-pointer<int>, ^add-len: ssize_t): int32
  c inline "(int)mbedtls_gcm_update_ad((struct mbedtls_gcm_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-gcm-update-ad(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^add: c-pointer<int>, ^add-len: int): <> int
  external/mbedtls-gcm-update-ad(ctx1, add, add-len.ssize_t).int

// \brief           This function feeds an input buffer into an ongoing GCM
// encryption or decryption operation.
// 
// You may call this function zero, one or more times
// to pass successive parts of the input: the plaintext to
// encrypt, or the ciphertext (not including the tag) to
// decrypt. After the last part of the input, call
// mbedtls_gcm_finish().
// 
// This function may produce output in one of the following
// ways:
// - Immediate output: the output length is always equal
// to the input length.
// - Buffered output: the output consists of a whole number
// of 16-byte blocks. If the total input length so far
// (not including associated data) is 16 \* *B* + *A*
// with *A* < 16 then the total output length is 16 \* *B*.
// 
// In particular:
// - It is always correct to call this function with
// \p output_size >= \p input_length + 15.
// - If \p input_length is a multiple of 16 for all the calls
// to this function during an operation, then it is
// correct to use \p output_size = \p input_length.
// 
// \note            For decryption, the output buffer cannot be the same as
// input buffer. If the buffers overlap, the output buffer
// must trail at least 8 Bytes behind the input buffer.
// 
// \param ctx           The GCM context. This must be initialized.
// \param input         The buffer holding the input data. If \p input_length
// is greater than zero, this must be a readable buffer
// of at least \p input_length bytes.
// \param input_length  The length of the input data in bytes.
// \param output        The buffer for the output data. If \p output_size
// is greater than zero, this must be a writable buffer of
// of at least \p output_size bytes.
// \param output_size   The size of the output buffer in bytes.
// See the function description regarding the output size.
// \param output_length On success, \p *output_length contains the actual
// length of the output written in \p output.
// On failure, the content of \p *output_length is
// unspecified.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure:
// total input length too long,
// unsupported input/output buffer overlap detected,
// or \p output_size too small.
pub extern external/mbedtls-gcm-update(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^input: c-pointer<int>, ^input-length: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(int)mbedtls_gcm_update((struct mbedtls_gcm_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/mbedtls-gcm-update(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^input: c-pointer<int>, ^input-length: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/mbedtls-gcm-update(ctx1, input, input-length.ssize_t, output, output-size.ssize_t, output-length).int

// \brief           This function finishes the GCM operation and generates
// the authentication tag.
// 
// It wraps up the GCM stream, and generates the
// tag. The tag can have a maximum length of 16 Bytes.
// 
// \param ctx       The GCM context. This must be initialized.
// \param tag       The buffer for holding the tag. This must be a writable
// buffer of at least \p tag_len Bytes.
// \param tag_len   The length of the tag to generate. This must be at least
// four.
// \param output    The buffer for the final output.
// If \p output_size is nonzero, this must be a writable
// buffer of at least \p output_size bytes.
// \param output_size  The size of the \p output buffer in bytes.
// This must be large enough for the output that
// mbedtls_gcm_update() has not produced. In particular:
// - If mbedtls_gcm_update() produces immediate output,
// or if the total input size is a multiple of \c 16,
// then mbedtls_gcm_finish() never produces any output,
// so \p output_size can be \c 0.
// - \p output_size never needs to be more than \c 15.
// \param output_length On success, \p *output_length contains the actual
// length of the output written in \p output.
// On failure, the content of \p *output_length is
// unspecified.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure:
// invalid value of \p tag_len,
// or \p output_size too small.
pub extern external/mbedtls-gcm-finish(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_gcm_finish((struct mbedtls_gcm_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-gcm-finish(^ctx1: c-pointer<mbedtls-gcm-context-c>, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-gcm-finish(ctx1, output, output-size.ssize_t, output-length, tag, tag-len.ssize_t).int

// \brief           This function clears a GCM context and the underlying
// cipher sub-context.
// 
// \param ctx       The GCM context to clear. If this is \c NULL, the call has
// no effect. Otherwise, this must be initialized.
pub extern external/mbedtls-gcm-free(^ctx1: c-pointer<mbedtls-gcm-context-c>): ()
  c inline "(void)mbedtls_gcm_free((struct mbedtls_gcm_context*)#1)"

// \brief          The GCM checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-gcm-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_gcm_self_test((int)#1)"

pub inline fun ffi/mbedtls-gcm-self-test(^verbose: int): <> int
  external/mbedtls-gcm-self-test(verbose.int32).int

// \brief           This function initializes the specified CCM context,
// to make references valid, and prepare the context
// for mbedtls_ccm_setkey() or mbedtls_ccm_free().
// 
// \param ctx       The CCM context to initialize. This must not be \c NULL.
pub extern external/mbedtls-ccm-init(^ctx1: c-pointer<mbedtls-ccm-context-c>): ()
  c inline "(void)mbedtls_ccm_init((struct mbedtls_ccm_context*)#1)"

// \brief           This function initializes the CCM context set in the
// \p ctx parameter and sets the encryption key.
// 
// \param ctx       The CCM context to initialize. This must be an initialized
// context.
// \param cipher    The 128-bit block cipher to use.
// \param key       The encryption key. This must not be \c NULL.
// \param keybits   The key size in bits. This must be acceptable by the cipher.
// 
// \return          \c 0 on success.
// \return          A CCM or cipher-specific error code on failure.
pub extern external/mbedtls-ccm-setkey(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^cipher: int32, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_ccm_setkey((struct mbedtls_ccm_context*)#1, (int32_t)#2, (unsigned char*)#3, (unsigned int)#4)"

pub inline fun ffi/mbedtls-ccm-setkey(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^cipher: mbedtls-cipher-id-t, ^key: c-pointer<int>, ^keybits: int): <exn> int
  external/mbedtls-ccm-setkey(ctx1, cipher.mbedtls-cipher-id-t/int, key, keybits.int32).int

// \brief   This function releases and clears the specified CCM context
// and underlying cipher sub-context.
// 
// \param ctx       The CCM context to clear. If this is \c NULL, the function
// has no effect. Otherwise, this must be initialized.
pub extern external/mbedtls-ccm-free(^ctx1: c-pointer<mbedtls-ccm-context-c>): ()
  c inline "(void)mbedtls_ccm_free((struct mbedtls_ccm_context*)#1)"

// \brief           This function encrypts a buffer using CCM.
// 
// \note            The tag is written to a separate buffer. To concatenate
// the \p tag with the \p output, as done in <em>RFC-3610:
// Counter with CBC-MAC (CCM)</em>, use
// \p tag = \p output + \p length, and make sure that the
// output buffer is at least \p length + \p tag_len wide.
// 
// \param ctx       The CCM context to use for encryption. This must be
// initialized and bound to a key.
// \param length    The length of the input data in Bytes.
// \param iv        The initialization vector (nonce). This must be a readable
// buffer of at least \p iv_len Bytes.
// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
// or 13. The length L of the message length field is
// 15 - \p iv_len.
// \param ad        The additional data field. If \p ad_len is greater than
// zero, \p ad must be a readable buffer of at least that
// length.
// \param ad_len    The length of additional data in Bytes.
// This must be less than `2^16 - 2^8`.
// \param input     The buffer holding the input data. If \p length is greater
// than zero, \p input must be a readable buffer of at least
// that length.
// \param output    The buffer holding the output data. If \p length is greater
// than zero, \p output must be a writable buffer of at least
// that length.
// \param tag       The buffer holding the authentication field. This must be a
// writable buffer of at least \p tag_len Bytes.
// \param tag_len   The length of the authentication field to generate in Bytes:
// 4, 6, 8, 10, 12, 14 or 16.
// 
// \return          \c 0 on success.
// \return          A CCM or cipher-specific error code on failure.
pub extern external/mbedtls-ccm-encrypt-and-tag(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: ssize_t, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^ad: c-pointer<int>, ^ad-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_encrypt_and_tag((struct mbedtls_ccm_context*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (unsigned char*)#8, (unsigned char*)#9, (size_t)#10)"

pub inline fun ffi/mbedtls-ccm-encrypt-and-tag(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: int, ^iv: c-pointer<int>, ^iv-len: int, ^ad: c-pointer<int>, ^ad-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-ccm-encrypt-and-tag(ctx1, length.ssize_t, iv, iv-len.ssize_t, ad, ad-len.ssize_t, input, output, tag, tag-len.ssize_t).int

// \brief           This function encrypts a buffer using CCM*.
// 
// \note            The tag is written to a separate buffer. To concatenate
// the \p tag with the \p output, as done in <em>RFC-3610:
// Counter with CBC-MAC (CCM)</em>, use
// \p tag = \p output + \p length, and make sure that the
// output buffer is at least \p length + \p tag_len wide.
// 
// \note            When using this function in a variable tag length context,
// the tag length has to be encoded into the \p iv passed to
// this function.
// 
// \param ctx       The CCM context to use for encryption. This must be
// initialized and bound to a key.
// \param length    The length of the input data in Bytes.
// For tag length = 0, input length is ignored.
// \param iv        The initialization vector (nonce). This must be a readable
// buffer of at least \p iv_len Bytes.
// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
// or 13. The length L of the message length field is
// 15 - \p iv_len.
// \param ad        The additional data field. This must be a readable buffer of
// at least \p ad_len Bytes.
// \param ad_len    The length of additional data in Bytes.
// This must be less than 2^16 - 2^8.
// \param input     The buffer holding the input data. If \p length is greater
// than zero, \p input must be a readable buffer of at least
// that length.
// \param output    The buffer holding the output data. If \p length is greater
// than zero, \p output must be a writable buffer of at least
// that length.
// \param tag       The buffer holding the authentication field. This must be a
// writable buffer of at least \p tag_len Bytes.
// \param tag_len   The length of the authentication field to generate in Bytes:
// 0, 4, 6, 8, 10, 12, 14 or 16.
// 
// \warning         Passing \c 0 as \p tag_len means that the message is no
// longer authenticated.
// 
// \return          \c 0 on success.
// \return          A CCM or cipher-specific error code on failure.
pub extern external/mbedtls-ccm-star-encrypt-and-tag(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: ssize_t, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^ad: c-pointer<int>, ^ad-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_star_encrypt_and_tag((struct mbedtls_ccm_context*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (unsigned char*)#8, (unsigned char*)#9, (size_t)#10)"

pub inline fun ffi/mbedtls-ccm-star-encrypt-and-tag(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: int, ^iv: c-pointer<int>, ^iv-len: int, ^ad: c-pointer<int>, ^ad-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-ccm-star-encrypt-and-tag(ctx1, length.ssize_t, iv, iv-len.ssize_t, ad, ad-len.ssize_t, input, output, tag, tag-len.ssize_t).int

// \brief           This function performs a CCM authenticated decryption of a
// buffer.
// 
// \param ctx       The CCM context to use for decryption. This must be
// initialized and bound to a key.
// \param length    The length of the input data in Bytes.
// \param iv        The initialization vector (nonce). This must be a readable
// buffer of at least \p iv_len Bytes.
// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
// or 13. The length L of the message length field is
// 15 - \p iv_len.
// \param ad        The additional data field. This must be a readable buffer
// of at least that \p ad_len Bytes..
// \param ad_len    The length of additional data in Bytes.
// This must be less than 2^16 - 2^8.
// \param input     The buffer holding the input data. If \p length is greater
// than zero, \p input must be a readable buffer of at least
// that length.
// \param output    The buffer holding the output data. If \p length is greater
// than zero, \p output must be a writable buffer of at least
// that length.
// \param tag       The buffer holding the authentication field. This must be a
// readable buffer of at least \p tag_len Bytes.
// \param tag_len   The length of the authentication field to generate in Bytes:
// 4, 6, 8, 10, 12, 14 or 16.
// 
// \return          \c 0 on success. This indicates that the message is authentic.
// \return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.
// \return          A cipher-specific error code on calculation failure.
pub extern external/mbedtls-ccm-auth-decrypt(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: ssize_t, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^ad: c-pointer<int>, ^ad-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_auth_decrypt((struct mbedtls_ccm_context*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (unsigned char*)#8, (unsigned char*)#9, (size_t)#10)"

pub inline fun ffi/mbedtls-ccm-auth-decrypt(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: int, ^iv: c-pointer<int>, ^iv-len: int, ^ad: c-pointer<int>, ^ad-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-ccm-auth-decrypt(ctx1, length.ssize_t, iv, iv-len.ssize_t, ad, ad-len.ssize_t, input, output, tag, tag-len.ssize_t).int

// \brief           This function performs a CCM* authenticated decryption of a
// buffer.
// 
// \note            When using this function in a variable tag length context,
// the tag length has to be decoded from \p iv and passed to
// this function as \p tag_len. (\p tag needs to be adjusted
// accordingly.)
// 
// \param ctx       The CCM context to use for decryption. This must be
// initialized and bound to a key.
// \param length    The length of the input data in Bytes.
// For tag length = 0, input length is ignored.
// \param iv        The initialization vector (nonce). This must be a readable
// buffer of at least \p iv_len Bytes.
// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
// or 13. The length L of the message length field is
// 15 - \p iv_len.
// \param ad        The additional data field. This must be a readable buffer of
// at least that \p ad_len Bytes.
// \param ad_len    The length of additional data in Bytes.
// This must be less than 2^16 - 2^8.
// \param input     The buffer holding the input data. If \p length is greater
// than zero, \p input must be a readable buffer of at least
// that length.
// \param output    The buffer holding the output data. If \p length is greater
// than zero, \p output must be a writable buffer of at least
// that length.
// \param tag       The buffer holding the authentication field. This must be a
// readable buffer of at least \p tag_len Bytes.
// \param tag_len   The length of the authentication field in Bytes.
// 0, 4, 6, 8, 10, 12, 14 or 16.
// 
// \warning         Passing \c 0 as \p tag_len means that the message is nos
// longer authenticated.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.
// \return          A cipher-specific error code on calculation failure.
pub extern external/mbedtls-ccm-star-auth-decrypt(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: ssize_t, ^iv: c-pointer<int>, ^iv-len: ssize_t, ^ad: c-pointer<int>, ^ad-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_star_auth_decrypt((struct mbedtls_ccm_context*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (unsigned char*)#8, (unsigned char*)#9, (size_t)#10)"

pub inline fun ffi/mbedtls-ccm-star-auth-decrypt(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^length: int, ^iv: c-pointer<int>, ^iv-len: int, ^ad: c-pointer<int>, ^ad-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-ccm-star-auth-decrypt(ctx1, length.ssize_t, iv, iv-len.ssize_t, ad, ad-len.ssize_t, input, output, tag, tag-len.ssize_t).int

// \brief           This function starts a CCM encryption or decryption
// operation.
// 
// This function and mbedtls_ccm_set_lengths() must be called
// before calling mbedtls_ccm_update_ad() or
// mbedtls_ccm_update(). This function can be called before
// or after mbedtls_ccm_set_lengths().
// 
// \note            This function is not implemented in Mbed TLS yet.
// 
// \param ctx       The CCM context. This must be initialized.
// \param mode      The operation to perform: #MBEDTLS_CCM_ENCRYPT or
// #MBEDTLS_CCM_DECRYPT or #MBEDTLS_CCM_STAR_ENCRYPT or
// #MBEDTLS_CCM_STAR_DECRYPT.
// \param iv        The initialization vector. This must be a readable buffer
// of at least \p iv_len Bytes.
// \param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,
// or 13. The length L of the message length field is
// 15 - \p iv_len.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
// \p ctx is in an invalid state,
// \p mode is invalid,
// \p iv_len is invalid (lower than \c 7 or greater than
// \c 13).
pub extern external/mbedtls-ccm-starts(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^mode: int32, ^iv: c-pointer<int>, ^iv-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_starts((struct mbedtls_ccm_context*)#1, (int)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ccm-starts(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^mode: int, ^iv: c-pointer<int>, ^iv-len: int): <> int
  external/mbedtls-ccm-starts(ctx1, mode.int32, iv, iv-len.ssize_t).int

// \brief           This function declares the lengths of the message
// and additional data for a CCM encryption or decryption
// operation.
// 
// This function and mbedtls_ccm_starts() must be called
// before calling mbedtls_ccm_update_ad() or
// mbedtls_ccm_update(). This function can be called before
// or after mbedtls_ccm_starts().
// 
// \note            This function is not implemented in Mbed TLS yet.
// 
// \param ctx       The CCM context. This must be initialized.
// \param total_ad_len   The total length of additional data in bytes.
// This must be less than `2^16 - 2^8`.
// \param plaintext_len  The length in bytes of the plaintext to encrypt or
// result of the decryption (thus not encompassing the
// additional data that are not encrypted).
// \param tag_len   The length of the tag to generate in Bytes:
// 4, 6, 8, 10, 12, 14 or 16.
// For CCM*, zero is also valid.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
// \p ctx is in an invalid state,
// \p total_ad_len is greater than \c 0xFF00.
pub extern external/mbedtls-ccm-set-lengths(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^total-ad-len: ssize_t, ^plaintext-len: ssize_t, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_set_lengths((struct mbedtls_ccm_context*)#1, (size_t)#2, (size_t)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ccm-set-lengths(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^total-ad-len: int, ^plaintext-len: int, ^tag-len: int): <> int
  external/mbedtls-ccm-set-lengths(ctx1, total-ad-len.ssize_t, plaintext-len.ssize_t, tag-len.ssize_t).int

// \brief           This function feeds an input buffer as associated data
// (authenticated but not encrypted data) in a CCM
// encryption or decryption operation.
// 
// You may call this function zero, one or more times
// to pass successive parts of the additional data. The
// lengths \p ad_len of the data parts should eventually add
// up exactly to the total length of additional data
// \c total_ad_len passed to mbedtls_ccm_set_lengths(). You
// may not call this function after calling
// mbedtls_ccm_update().
// 
// \note            This function is not implemented in Mbed TLS yet.
// 
// \param ctx       The CCM context. This must have been started with
// mbedtls_ccm_starts(), the lengths of the message and
// additional data must have been declared with
// mbedtls_ccm_set_lengths() and this must not have yet
// received any input with mbedtls_ccm_update().
// \param ad        The buffer holding the additional data, or \c NULL
// if \p ad_len is \c 0.
// \param ad_len    The length of the additional data. If \c 0,
// \p ad may be \c NULL.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
// \p ctx is in an invalid state,
// total input length too long.
pub extern external/mbedtls-ccm-update-ad(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^ad: c-pointer<int>, ^ad-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_update_ad((struct mbedtls_ccm_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ccm-update-ad(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^ad: c-pointer<int>, ^ad-len: int): <> int
  external/mbedtls-ccm-update-ad(ctx1, ad, ad-len.ssize_t).int

// \brief           This function feeds an input buffer into an ongoing CCM
// encryption or decryption operation.
// 
// You may call this function zero, one or more times
// to pass successive parts of the input: the plaintext to
// encrypt, or the ciphertext (not including the tag) to
// decrypt. After the last part of the input, call
// mbedtls_ccm_finish(). The lengths \p input_len of the
// data parts should eventually add up exactly to the
// plaintext length \c plaintext_len passed to
// mbedtls_ccm_set_lengths().
// 
// This function may produce output in one of the following
// ways:
// - Immediate output: the output length is always equal
// to the input length.
// - Buffered output: except for the last part of input data,
// the output consists of a whole number of 16-byte blocks.
// If the total input length so far (not including
// associated data) is 16 \* *B* + *A* with *A* < 16 then
// the total output length is 16 \* *B*.
// For the last part of input data, the output length is
// equal to the input length plus the number of bytes (*A*)
// buffered in the previous call to the function (if any).
// The function uses the plaintext length
// \c plaintext_len passed to mbedtls_ccm_set_lengths()
// to detect the last part of input data.
// 
// In particular:
// - It is always correct to call this function with
// \p output_size >= \p input_len + 15.
// - If \p input_len is a multiple of 16 for all the calls
// to this function during an operation (not necessary for
// the last one) then it is correct to use \p output_size
// =\p input_len.
// 
// \note            This function is not implemented in Mbed TLS yet.
// 
// \param ctx           The CCM context. This must have been started with
// mbedtls_ccm_starts() and the lengths of the message and
// additional data must have been declared with
// mbedtls_ccm_set_lengths().
// \param input         The buffer holding the input data. If \p input_len
// is greater than zero, this must be a readable buffer
// of at least \p input_len bytes.
// \param input_len     The length of the input data in bytes.
// \param output        The buffer for the output data. If \p output_size
// is greater than zero, this must be a writable buffer of
// at least \p output_size bytes.
// \param output_size   The size of the output buffer in bytes.
// See the function description regarding the output size.
// \param output_len    On success, \p *output_len contains the actual
// length of the output written in \p output.
// On failure, the content of \p *output_len is
// unspecified.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
// \p ctx is in an invalid state,
// total input length too long,
// or \p output_size too small.
pub extern external/mbedtls-ccm-update(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^input: c-pointer<int>, ^input-len: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-len: c-pointer<int>): int32
  c inline "(int)mbedtls_ccm_update((struct mbedtls_ccm_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/mbedtls-ccm-update(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^input: c-pointer<int>, ^input-len: int, ^output: c-pointer<int>, ^output-size: int, ^output-len: c-pointer<int>): <> int
  external/mbedtls-ccm-update(ctx1, input, input-len.ssize_t, output, output-size.ssize_t, output-len).int

// \brief           This function finishes the CCM operation and generates
// the authentication tag.
// 
// It wraps up the CCM stream, and generates the
// tag. The tag can have a maximum length of 16 Bytes.
// 
// \note            This function is not implemented in Mbed TLS yet.
// 
// \param ctx       The CCM context. This must have been started with
// mbedtls_ccm_starts() and the lengths of the message and
// additional data must have been declared with
// mbedtls_ccm_set_lengths().
// \param tag       The buffer for holding the tag. If \p tag_len is greater
// than zero, this must be a writable buffer of at least \p
// tag_len Bytes.
// \param tag_len   The length of the tag. Must match the tag length passed to
// mbedtls_ccm_set_lengths() function.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:
// \p ctx is in an invalid state,
// invalid value of \p tag_len,
// the total amount of additional data passed to
// mbedtls_ccm_update_ad() was lower than the total length of
// additional data \c total_ad_len passed to
// mbedtls_ccm_set_lengths(),
// the total amount of input data passed to
// mbedtls_ccm_update() was lower than the plaintext length
// \c plaintext_len passed to mbedtls_ccm_set_lengths().
pub extern external/mbedtls-ccm-finish(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^tag: c-pointer<int>, ^tag-len: ssize_t): int32
  c inline "(int)mbedtls_ccm_finish((struct mbedtls_ccm_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ccm-finish(^ctx1: c-pointer<mbedtls-ccm-context-c>, ^tag: c-pointer<int>, ^tag-len: int): <> int
  external/mbedtls-ccm-finish(ctx1, tag, tag-len.ssize_t).int

// \brief          The CCM checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-ccm-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_ccm_self_test((int)#1)"

pub inline fun ffi/mbedtls-ccm-self-test(^verbose: int): <> int
  external/mbedtls-ccm-self-test(verbose.int32).int

// \brief           This function initializes the specified Poly1305 context.
// 
// It must be the first API called before using
// the context.
// 
// It is usually followed by a call to
// \c mbedtls_poly1305_starts(), then one or more calls to
// \c mbedtls_poly1305_update(), then one call to
// \c mbedtls_poly1305_finish(), then finally
// \c mbedtls_poly1305_free().
// 
// \param ctx       The Poly1305 context to initialize. This must
// not be \c NULL.
pub extern external/mbedtls-poly1305-init(^ctx1: c-pointer<mbedtls-poly1305-context-c>): ()
  c inline "(void)mbedtls_poly1305_init((struct mbedtls_poly1305_context*)#1)"

// \brief           This function releases and clears the specified
// Poly1305 context.
// 
// \param ctx       The Poly1305 context to clear. This may be \c NULL, in which
// case this function is a no-op. If it is not \c NULL, it must
// point to an initialized Poly1305 context.
pub extern external/mbedtls-poly1305-free(^ctx1: c-pointer<mbedtls-poly1305-context-c>): ()
  c inline "(void)mbedtls_poly1305_free((struct mbedtls_poly1305_context*)#1)"

// \brief           This function sets the one-time authentication key.
// 
// \warning         The key must be unique and unpredictable for each
// invocation of Poly1305.
// 
// \param ctx       The Poly1305 context to which the key should be bound.
// This must be initialized.
// \param key       The buffer containing the \c 32 Byte (\c 256 Bit) key.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-poly1305-starts(^ctx1: c-pointer<mbedtls-poly1305-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_poly1305_starts((struct mbedtls_poly1305_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-poly1305-starts(^ctx1: c-pointer<mbedtls-poly1305-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-poly1305-starts(ctx1, key.cextern/carray/ptr).int

// \brief           This functions feeds an input buffer into an ongoing
// Poly1305 computation.
// 
// It is called between \c mbedtls_cipher_poly1305_starts() and
// \c mbedtls_cipher_poly1305_finish().
// It can be called repeatedly to process a stream of data.
// 
// \param ctx       The Poly1305 context to use for the Poly1305 operation.
// This must be initialized and bound to a key.
// \param ilen      The length of the input data in Bytes.
// Any value is accepted.
// \param input     The buffer holding the input data.
// This pointer can be \c NULL if `ilen == 0`.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-poly1305-update(^ctx1: c-pointer<mbedtls-poly1305-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_poly1305_update((struct mbedtls_poly1305_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-poly1305-update(^ctx1: c-pointer<mbedtls-poly1305-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-poly1305-update(ctx1, input, ilen.ssize_t).int

// \brief           This function generates the Poly1305 Message
// Authentication Code (MAC).
// 
// \param ctx       The Poly1305 context to use for the Poly1305 operation.
// This must be initialized and bound to a key.
// \param mac       The buffer to where the MAC is written. This must
// be a writable buffer of length \c 16 Bytes.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-poly1305-finish(^ctx1: c-pointer<mbedtls-poly1305-context-c>, ^mac: c-pointer<int>): int32
  c inline "(int)mbedtls_poly1305_finish((struct mbedtls_poly1305_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-poly1305-finish(^ctx1: c-pointer<mbedtls-poly1305-context-c>, ^mac: c-array<int>): <> int
  external/mbedtls-poly1305-finish(ctx1, mac.cextern/carray/ptr).int

// \brief           This function calculates the Poly1305 MAC of the input
// buffer with the provided key.
// 
// \warning         The key must be unique and unpredictable for each
// invocation of Poly1305.
// 
// \param key       The buffer containing the \c 32 Byte (\c 256 Bit) key.
// \param ilen      The length of the input data in Bytes.
// Any value is accepted.
// \param input     The buffer holding the input data.
// This pointer can be \c NULL if `ilen == 0`.
// \param mac       The buffer to where the MAC is written. This must be
// a writable buffer of length \c 16 Bytes.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-poly1305-mac(^key: c-pointer<int>, ^input: c-pointer<int>, ^ilen: ssize_t, ^mac: c-pointer<int>): int32
  c inline "(int)mbedtls_poly1305_mac((unsigned char*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4)"

pub inline fun ffi/mbedtls-poly1305-mac(^key: c-array<int>, ^input: c-pointer<int>, ^ilen: int, ^mac: c-array<int>): <> int
  external/mbedtls-poly1305-mac(key.cextern/carray/ptr, input, ilen.ssize_t, mac.cextern/carray/ptr).int

// \brief           The Poly1305 checkup routine.
// 
// \return          \c 0 on success.
// \return          \c 1 on failure.
pub extern external/mbedtls-poly1305-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_poly1305_self_test((int)#1)"

pub inline fun ffi/mbedtls-poly1305-self-test(^verbose: int): <> int
  external/mbedtls-poly1305-self-test(verbose.int32).int

// \brief           This function initializes the specified ChaCha20 context.
// 
// It must be the first API called before using
// the context.
// 
// It is usually followed by calls to
// \c mbedtls_chacha20_setkey() and
// \c mbedtls_chacha20_starts(), then one or more calls to
// to \c mbedtls_chacha20_update(), and finally to
// \c mbedtls_chacha20_free().
// 
// \param ctx       The ChaCha20 context to initialize.
// This must not be \c NULL.
pub extern external/mbedtls-chacha20-init(^ctx1: c-pointer<mbedtls-chacha20-context-c>): ()
  c inline "(void)mbedtls_chacha20_init((struct mbedtls_chacha20_context*)#1)"

// \brief           This function releases and clears the specified
// ChaCha20 context.
// 
// \param ctx       The ChaCha20 context to clear. This may be \c NULL,
// in which case this function is a no-op. If it is not
// \c NULL, it must point to an initialized context.
pub extern external/mbedtls-chacha20-free(^ctx1: c-pointer<mbedtls-chacha20-context-c>): ()
  c inline "(void)mbedtls_chacha20_free((struct mbedtls_chacha20_context*)#1)"

// \brief           This function sets the encryption/decryption key.
// 
// \note            After using this function, you must also call
// \c mbedtls_chacha20_starts() to set a nonce before you
// start encrypting/decrypting data with
// \c mbedtls_chacha_update().
// 
// \param ctx       The ChaCha20 context to which the key should be bound.
// It must be initialized.
// \param key       The encryption/decryption key. This must be \c 32 Bytes
// in length.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL.
pub extern external/mbedtls-chacha20-setkey(^ctx1: c-pointer<mbedtls-chacha20-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_chacha20_setkey((struct mbedtls_chacha20_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-chacha20-setkey(^ctx1: c-pointer<mbedtls-chacha20-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-chacha20-setkey(ctx1, key.cextern/carray/ptr).int

// \brief           This function sets the nonce and initial counter value.
// 
// \note            A ChaCha20 context can be re-used with the same key by
// calling this function to change the nonce.
// 
// \warning         You must never use the same nonce twice with the same key.
// This would void any confidentiality guarantees for the
// messages encrypted with the same nonce and key.
// 
// \param ctx       The ChaCha20 context to which the nonce should be bound.
// It must be initialized and bound to a key.
// \param nonce     The nonce. This must be \c 12 Bytes in size.
// \param counter   The initial counter value. This is usually \c 0.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is
// NULL.
pub extern external/mbedtls-chacha20-starts(^ctx1: c-pointer<mbedtls-chacha20-context-c>, ^nonce: c-pointer<int>, ^counter: int32): int32
  c inline "(int)mbedtls_chacha20_starts((struct mbedtls_chacha20_context*)#1, (unsigned char*)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-chacha20-starts(^ctx1: c-pointer<mbedtls-chacha20-context-c>, ^nonce: c-array<int>, ^counter: int): <> int
  external/mbedtls-chacha20-starts(ctx1, nonce.cextern/carray/ptr, counter.int32).int

// \brief           This function encrypts or decrypts data.
// 
// Since ChaCha20 is a stream cipher, the same operation is
// used for encrypting and decrypting data.
// 
// \note            The \p input and \p output pointers must either be equal or
// point to non-overlapping buffers.
// 
// \note            \c mbedtls_chacha20_setkey() and
// \c mbedtls_chacha20_starts() must be called at least once
// to setup the context before this function can be called.
// 
// \note            This function can be called multiple times in a row in
// order to encrypt of decrypt data piecewise with the same
// key and nonce.
// 
// \param ctx       The ChaCha20 context to use for encryption or decryption.
// It must be initialized and bound to a key and nonce.
// \param size      The length of the input data in Bytes.
// \param input     The buffer holding the input data.
// This pointer can be \c NULL if `size == 0`.
// \param output    The buffer holding the output data.
// This must be able to hold \p size Bytes.
// This pointer can be \c NULL if `size == 0`.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-chacha20-update(^ctx1: c-pointer<mbedtls-chacha20-context-c>, ^size: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_chacha20_update((struct mbedtls_chacha20_context*)#1, (size_t)#2, (unsigned char*)#3, (unsigned char*)#4)"

pub inline fun ffi/mbedtls-chacha20-update(^ctx1: c-pointer<mbedtls-chacha20-context-c>, ^size: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-chacha20-update(ctx1, size.ssize_t, input, output).int

// \brief           This function encrypts or decrypts data with ChaCha20 and
// the given key and nonce.
// 
// Since ChaCha20 is a stream cipher, the same operation is
// used for encrypting and decrypting data.
// 
// \warning         You must never use the same (key, nonce) pair more than
// once. This would void any confidentiality guarantees for
// the messages encrypted with the same nonce and key.
// 
// \note            The \p input and \p output pointers must either be equal or
// point to non-overlapping buffers.
// 
// \param key       The encryption/decryption key.
// This must be \c 32 Bytes in length.
// \param nonce     The nonce. This must be \c 12 Bytes in size.
// \param counter   The initial counter value. This is usually \c 0.
// \param size      The length of the input data in Bytes.
// \param input     The buffer holding the input data.
// This pointer can be \c NULL if `size == 0`.
// \param output    The buffer holding the output data.
// This must be able to hold \p size Bytes.
// This pointer can be \c NULL if `size == 0`.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-chacha20-crypt(^key: c-pointer<int>, ^nonce: c-pointer<int>, ^counter: int32, ^size: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_chacha20_crypt((unsigned char*)#1, (unsigned char*)#2, (int32_t)#3, (size_t)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-chacha20-crypt(^key: c-array<int>, ^nonce: c-array<int>, ^counter: int, ^size: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-chacha20-crypt(key.cextern/carray/ptr, nonce.cextern/carray/ptr, counter.int32, size.ssize_t, input, output).int

// \brief           The ChaCha20 checkup routine.
// 
// \return          \c 0 on success.
// \return          \c 1 on failure.
pub extern external/mbedtls-chacha20-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_chacha20_self_test((int)#1)"

pub inline fun ffi/mbedtls-chacha20-self-test(^verbose: int): <> int
  external/mbedtls-chacha20-self-test(verbose.int32).int

// \brief           This function initializes the specified ChaCha20-Poly1305 context.
// 
// It must be the first API called before using
// the context. It must be followed by a call to
// \c mbedtls_chachapoly_setkey() before any operation can be
// done, and to \c mbedtls_chachapoly_free() once all
// operations with that context have been finished.
// 
// In order to encrypt or decrypt full messages at once, for
// each message you should make a single call to
// \c mbedtls_chachapoly_crypt_and_tag() or
// \c mbedtls_chachapoly_auth_decrypt().
// 
// In order to encrypt messages piecewise, for each
// message you should make a call to
// \c mbedtls_chachapoly_starts(), then 0 or more calls to
// \c mbedtls_chachapoly_update_aad(), then 0 or more calls to
// \c mbedtls_chachapoly_update(), then one call to
// \c mbedtls_chachapoly_finish().
// 
// \warning         Decryption with the piecewise API is discouraged! Always
// use \c mbedtls_chachapoly_auth_decrypt() when possible!
// 
// If however this is not possible because the data is too
// large to fit in memory, you need to:
// 
// - call \c mbedtls_chachapoly_starts() and (if needed)
// \c mbedtls_chachapoly_update_aad() as above,
// - call \c mbedtls_chachapoly_update() multiple times and
// ensure its output (the plaintext) is NOT used in any other
// way than placing it in temporary storage at this point,
// - call \c mbedtls_chachapoly_finish() to compute the
// authentication tag and compared it in constant time to the
// tag received with the ciphertext.
// 
// If the tags are not equal, you must immediately discard
// all previous outputs of \c mbedtls_chachapoly_update(),
// otherwise you can now safely use the plaintext.
// 
// \param ctx       The ChachaPoly context to initialize. Must not be \c NULL.
pub extern external/mbedtls-chachapoly-init(^ctx1: c-pointer<mbedtls-chachapoly-context-c>): ()
  c inline "(void)mbedtls_chachapoly_init((struct mbedtls_chachapoly_context*)#1)"

// \brief           This function releases and clears the specified
// ChaCha20-Poly1305 context.
// 
// \param ctx       The ChachaPoly context to clear. This may be \c NULL, in which
// case this function is a no-op.
pub extern external/mbedtls-chachapoly-free(^ctx1: c-pointer<mbedtls-chachapoly-context-c>): ()
  c inline "(void)mbedtls_chachapoly_free((struct mbedtls_chachapoly_context*)#1)"

// \brief           This function sets the ChaCha20-Poly1305
// symmetric encryption key.
// 
// \param ctx       The ChaCha20-Poly1305 context to which the key should be
// bound. This must be initialized.
// \param key       The \c 256 Bit (\c 32 Bytes) key.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-chachapoly-setkey(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_chachapoly_setkey((struct mbedtls_chachapoly_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-chachapoly-setkey(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-chachapoly-setkey(ctx1, key.cextern/carray/ptr).int

// \brief           This function starts a ChaCha20-Poly1305 encryption or
// decryption operation.
// 
// \warning         You must never use the same nonce twice with the same key.
// This would void any confidentiality and authenticity
// guarantees for the messages encrypted with the same nonce
// and key.
// 
// \note            If the context is being used for AAD only (no data to
// encrypt or decrypt) then \p mode can be set to any value.
// 
// \warning         Decryption with the piecewise API is discouraged, see the
// warning on \c mbedtls_chachapoly_init().
// 
// \param ctx       The ChaCha20-Poly1305 context. This must be initialized
// and bound to a key.
// \param nonce     The nonce/IV to use for the message.
// This must be a readable buffer of length \c 12 Bytes.
// \param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or
// #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning).
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-chachapoly-starts(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^nonce: c-pointer<int>, ^mode: int32): int32
  c inline "(int)mbedtls_chachapoly_starts((struct mbedtls_chachapoly_context*)#1, (unsigned char*)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-chachapoly-starts(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^nonce: c-array<int>, ^mode: mbedtls-chachapoly-mode-t): <exn> int
  external/mbedtls-chachapoly-starts(ctx1, nonce.cextern/carray/ptr, mode.mbedtls-chachapoly-mode-t/int).int

// \brief           This function feeds additional data to be authenticated
// into an ongoing ChaCha20-Poly1305 operation.
// 
// The Additional Authenticated Data (AAD), also called
// Associated Data (AD) is only authenticated but not
// encrypted nor included in the encrypted output. It is
// usually transmitted separately from the ciphertext or
// computed locally by each party.
// 
// \note            This function is called before data is encrypted/decrypted.
// I.e. call this function to process the AAD before calling
// \c mbedtls_chachapoly_update().
// 
// You may call this function multiple times to process
// an arbitrary amount of AAD. It is permitted to call
// this function 0 times, if no AAD is used.
// 
// This function cannot be called any more if data has
// been processed by \c mbedtls_chachapoly_update(),
// or if the context has been finished.
// 
// \warning         Decryption with the piecewise API is discouraged, see the
// warning on \c mbedtls_chachapoly_init().
// 
// \param ctx       The ChaCha20-Poly1305 context. This must be initialized
// and bound to a key.
// \param aad_len   The length in Bytes of the AAD. The length has no
// restrictions.
// \param aad       Buffer containing the AAD.
// This pointer can be \c NULL if `aad_len == 0`.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA
// if \p ctx or \p aad are NULL.
// \return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE
// if the operations has not been started or has been
// finished, or if the AAD has been finished.
pub extern external/mbedtls-chachapoly-update-aad(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^aad: c-pointer<int>, ^aad-len: ssize_t): int32
  c inline "(int)mbedtls_chachapoly_update_aad((struct mbedtls_chachapoly_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-chachapoly-update-aad(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^aad: c-pointer<int>, ^aad-len: int): <> int
  external/mbedtls-chachapoly-update-aad(ctx1, aad, aad-len.ssize_t).int

// \brief           Thus function feeds data to be encrypted or decrypted
// into an on-going ChaCha20-Poly1305
// operation.
// 
// The direction (encryption or decryption) depends on the
// mode that was given when calling
// \c mbedtls_chachapoly_starts().
// 
// You may call this function multiple times to process
// an arbitrary amount of data. It is permitted to call
// this function 0 times, if no data is to be encrypted
// or decrypted.
// 
// \warning         Decryption with the piecewise API is discouraged, see the
// warning on \c mbedtls_chachapoly_init().
// 
// \param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.
// \param len       The length (in bytes) of the data to encrypt or decrypt.
// \param input     The buffer containing the data to encrypt or decrypt.
// This pointer can be \c NULL if `len == 0`.
// \param output    The buffer to where the encrypted or decrypted data is
// written. This must be able to hold \p len bytes.
// This pointer can be \c NULL if `len == 0`.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE
// if the operation has not been started or has been
// finished.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-chachapoly-update(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_chachapoly_update((struct mbedtls_chachapoly_context*)#1, (size_t)#2, (unsigned char*)#3, (unsigned char*)#4)"

pub inline fun ffi/mbedtls-chachapoly-update(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^len: int, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-chachapoly-update(ctx1, len.ssize_t, input, output).int

// \brief           This function finished the ChaCha20-Poly1305 operation and
// generates the MAC (authentication tag).
// 
// \param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.
// \param mac       The buffer to where the 128-bit (16 bytes) MAC is written.
// 
// \warning         Decryption with the piecewise API is discouraged, see the
// warning on \c mbedtls_chachapoly_init().
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE
// if the operation has not been started or has been
// finished.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-chachapoly-finish(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^mac: c-pointer<int>): int32
  c inline "(int)mbedtls_chachapoly_finish((struct mbedtls_chachapoly_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-chachapoly-finish(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^mac: c-array<int>): <> int
  external/mbedtls-chachapoly-finish(ctx1, mac.cextern/carray/ptr).int

// \brief           This function performs a complete ChaCha20-Poly1305
// authenticated encryption with the previously-set key.
// 
// \note            Before using this function, you must set the key with
// \c mbedtls_chachapoly_setkey().
// 
// \warning         You must never use the same nonce twice with the same key.
// This would void any confidentiality and authenticity
// guarantees for the messages encrypted with the same nonce
// and key.
// 
// \param ctx       The ChaCha20-Poly1305 context to use (holds the key).
// This must be initialized.
// \param length    The length (in bytes) of the data to encrypt or decrypt.
// \param nonce     The 96-bit (12 bytes) nonce/IV to use.
// \param aad       The buffer containing the additional authenticated
// data (AAD). This pointer can be \c NULL if `aad_len == 0`.
// \param aad_len   The length (in bytes) of the AAD data to process.
// \param input     The buffer containing the data to encrypt or decrypt.
// This pointer can be \c NULL if `ilen == 0`.
// \param output    The buffer to where the encrypted or decrypted data
// is written. This pointer can be \c NULL if `ilen == 0`.
// \param tag       The buffer to where the computed 128-bit (16 bytes) MAC
// is written. This must not be \c NULL.
// 
// \return          \c 0 on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-chachapoly-encrypt-and-tag(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^length: ssize_t, ^nonce: c-pointer<int>, ^aad: c-pointer<int>, ^aad-len: ssize_t, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-pointer<int>): int32
  c inline "(int)mbedtls_chachapoly_encrypt_and_tag((struct mbedtls_chachapoly_context*)#1, (size_t)#2, (unsigned char*)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (unsigned char*)#7, (unsigned char*)#8)"

pub inline fun ffi/mbedtls-chachapoly-encrypt-and-tag(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^length: int, ^nonce: c-array<int>, ^aad: c-pointer<int>, ^aad-len: int, ^input: c-pointer<int>, ^output: c-pointer<int>, ^tag: c-array<int>): <> int
  external/mbedtls-chachapoly-encrypt-and-tag(ctx1, length.ssize_t, nonce.cextern/carray/ptr, aad, aad-len.ssize_t, input, output, tag.cextern/carray/ptr).int

// \brief           This function performs a complete ChaCha20-Poly1305
// authenticated decryption with the previously-set key.
// 
// \note            Before using this function, you must set the key with
// \c mbedtls_chachapoly_setkey().
// 
// \param ctx       The ChaCha20-Poly1305 context to use (holds the key).
// \param length    The length (in Bytes) of the data to decrypt.
// \param nonce     The \c 96 Bit (\c 12 bytes) nonce/IV to use.
// \param aad       The buffer containing the additional authenticated data (AAD).
// This pointer can be \c NULL if `aad_len == 0`.
// \param aad_len   The length (in bytes) of the AAD data to process.
// \param tag       The buffer holding the authentication tag.
// This must be a readable buffer of length \c 16 Bytes.
// \param input     The buffer containing the data to decrypt.
// This pointer can be \c NULL if `ilen == 0`.
// \param output    The buffer to where the decrypted data is written.
// This pointer can be \c NULL if `ilen == 0`.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED
// if the data was not authentic.
// \return          Another negative error code on other kinds of failure.
pub extern external/mbedtls-chachapoly-auth-decrypt(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^length: ssize_t, ^nonce: c-pointer<int>, ^aad: c-pointer<int>, ^aad-len: ssize_t, ^tag: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_chachapoly_auth_decrypt((struct mbedtls_chachapoly_context*)#1, (size_t)#2, (unsigned char*)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (unsigned char*)#7, (unsigned char*)#8)"

pub inline fun ffi/mbedtls-chachapoly-auth-decrypt(^ctx1: c-pointer<mbedtls-chachapoly-context-c>, ^length: int, ^nonce: c-array<int>, ^aad: c-pointer<int>, ^aad-len: int, ^tag: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-chachapoly-auth-decrypt(ctx1, length.ssize_t, nonce.cextern/carray/ptr, aad, aad-len.ssize_t, tag.cextern/carray/ptr, input, output).int

// \brief           The ChaCha20-Poly1305 checkup routine.
// 
// \return          \c 0 on success.
// \return          \c 1 on failure.
pub extern external/mbedtls-chachapoly-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_chachapoly_self_test((int)#1)"

pub inline fun ffi/mbedtls-chachapoly-self-test(^verbose: int): <> int
  external/mbedtls-chachapoly-self-test(verbose.int32).int

// \brief           Initialize an ECJPAKE context.
// 
// \param ctx       The ECJPAKE context to initialize.
// This must not be \c NULL.
pub extern external/mbedtls-ecjpake-init(^ctx1: c-pointer<mbedtls-ecjpake-context-c>): ()
  c inline "(void)mbedtls_ecjpake_init((struct mbedtls_ecjpake_context*)#1)"

// \brief           Set up an ECJPAKE context for use.
// 
// \note            Currently the only values for hash/curve allowed by the
// standard are #MBEDTLS_MD_SHA256/#MBEDTLS_ECP_DP_SECP256R1.
// 
// \param ctx       The ECJPAKE context to set up. This must be initialized.
// \param role      The role of the caller. This must be either
// #MBEDTLS_ECJPAKE_CLIENT or #MBEDTLS_ECJPAKE_SERVER.
// \param hash      The identifier of the hash function to use,
// for example #MBEDTLS_MD_SHA256.
// \param curve     The identifier of the elliptic curve to use,
// for example #MBEDTLS_ECP_DP_SECP256R1.
// \param secret    The pre-shared secret (passphrase). This must be
// a readable not empty buffer of length \p len Bytes. It need
// only be valid for the duration of this call.
// \param len       The length of the pre-shared secret \p secret.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-setup(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^role: int32, ^hash: int32, ^curve: int32, ^secret: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ecjpake_setup((struct mbedtls_ecjpake_context*)#1, (int32_t)#2, (int32_t)#3, (int32_t)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-ecjpake-setup(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^role: mbedtls-ecjpake-role, ^hash: mbedtls-md-type-t, ^curve: mbedtls-ecp-group-id, ^secret: c-pointer<int>, ^len: int): <exn> int
  external/mbedtls-ecjpake-setup(ctx1, role.mbedtls-ecjpake-role/int, hash.mbedtls-md-type-t/int, curve.mbedtls-ecp-group-id/int, secret, len.ssize_t).int

// \brief               Set the point format for future reads and writes.
// 
// \param ctx           The ECJPAKE context to configure.
// \param point_format  The point format to use:
// #MBEDTLS_ECP_PF_UNCOMPRESSED (default)
// or #MBEDTLS_ECP_PF_COMPRESSED.
// 
// \return              \c 0 if successful.
// \return              #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if \p point_format
// is invalid.
pub extern external/mbedtls-ecjpake-set-point-format(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^point-format: int32): int32
  c inline "(int)mbedtls_ecjpake_set_point_format((struct mbedtls_ecjpake_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ecjpake-set-point-format(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^point-format: int): <> int
  external/mbedtls-ecjpake-set-point-format(ctx1, point-format.int32).int

// \brief           Check if an ECJPAKE context is ready for use.
// 
// \param ctx       The ECJPAKE context to check. This must be
// initialized.
// 
// \return          \c 0 if the context is ready for use.
// \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA otherwise.
pub extern external/mbedtls-ecjpake-check(^ctx1: c-pointer<mbedtls-ecjpake-context-c>): int32
  c inline "(int)mbedtls_ecjpake_check((struct mbedtls_ecjpake_context*)#1)"

pub inline fun ffi/mbedtls-ecjpake-check(^ctx1: c-pointer<mbedtls-ecjpake-context-c>): <> int
  external/mbedtls-ecjpake-check(ctx1).int

// \brief           Generate and write the first round message
// (TLS: contents of the Client/ServerHello extension,
// excluding extension type and length bytes).
// 
// \param ctx       The ECJPAKE context to use. This must be
// initialized and set up.
// \param buf       The buffer to write the contents to. This must be a
// writable buffer of length \p len Bytes.
// \param len       The length of \p buf in Bytes.
// \param olen      The address at which to store the total number
// of Bytes written to \p buf. This must not be \c NULL.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG parameter to be passed to \p f_rng. This
// may be \c NULL if \p f_rng doesn't use a context.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-write-round-one(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: ssize_t, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecjpake_write_round_one((struct mbedtls_ecjpake_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecjpake-write-round-one(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: int, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecjpake-write-round-one(ctx1, buf, len.ssize_t, olen, f-rng, p-rng).int

// \brief           Read and process the first round message
// (TLS: contents of the Client/ServerHello extension,
// excluding extension type and length bytes).
// 
// \param ctx       The ECJPAKE context to use. This must be initialized
// and set up.
// \param buf       The buffer holding the first round message. This must
// be a readable buffer of length \p len Bytes.
// \param len       The length in Bytes of \p buf.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-read-round-one(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ecjpake_read_round_one((struct mbedtls_ecjpake_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ecjpake-read-round-one(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ecjpake-read-round-one(ctx1, buf, len.ssize_t).int

// \brief           Generate and write the second round message
// (TLS: contents of the Client/ServerKeyExchange).
// 
// \param ctx       The ECJPAKE context to use. This must be initialized,
// set up, and already have performed round one.
// \param buf       The buffer to write the round two contents to.
// This must be a writable buffer of length \p len Bytes.
// \param len       The size of \p buf in Bytes.
// \param olen      The address at which to store the total number of Bytes
// written to \p buf. This must not be \c NULL.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG parameter to be passed to \p f_rng. This
// may be \c NULL if \p f_rng doesn't use a context.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-write-round-two(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: ssize_t, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecjpake_write_round_two((struct mbedtls_ecjpake_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecjpake-write-round-two(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: int, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecjpake-write-round-two(ctx1, buf, len.ssize_t, olen, f-rng, p-rng).int

// \brief           Read and process the second round message
// (TLS: contents of the Client/ServerKeyExchange).
// 
// \param ctx       The ECJPAKE context to use. This must be initialized
// and set up and already have performed round one.
// \param buf       The buffer holding the second round message. This must
// be a readable buffer of length \p len Bytes.
// \param len       The length in Bytes of \p buf.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-read-round-two(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ecjpake_read_round_two((struct mbedtls_ecjpake_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ecjpake-read-round-two(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ecjpake-read-round-two(ctx1, buf, len.ssize_t).int

// \brief           Derive the shared secret
// (TLS: Pre-Master Secret).
// 
// \param ctx       The ECJPAKE context to use. This must be initialized,
// set up and have performed both round one and two.
// \param buf       The buffer to write the derived secret to. This must
// be a writable buffer of length \p len Bytes.
// \param len       The length of \p buf in Bytes.
// \param olen      The address at which to store the total number of Bytes
// written to \p buf. This must not be \c NULL.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG parameter to be passed to \p f_rng. This
// may be \c NULL if \p f_rng doesn't use a context.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-derive-secret(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: ssize_t, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecjpake_derive_secret((struct mbedtls_ecjpake_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecjpake-derive-secret(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: int, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecjpake-derive-secret(ctx1, buf, len.ssize_t, olen, f-rng, p-rng).int

// \brief           Write the shared key material to be passed to a Key
// Derivation Function as described in RFC8236.
// 
// \param ctx       The ECJPAKE context to use. This must be initialized,
// set up and have performed both round one and two.
// \param buf       The buffer to write the derived secret to. This must
// be a writable buffer of length \p len Bytes.
// \param len       The length of \p buf in Bytes.
// \param olen      The address at which to store the total number of bytes
// written to \p buf. This must not be \c NULL.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG parameter to be passed to \p f_rng. This
// may be \c NULL if \p f_rng doesn't use a context.
// 
// \return          \c 0 if successful.
// \return          A negative error code on failure.
pub extern external/mbedtls-ecjpake-write-shared-key(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: ssize_t, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecjpake_write_shared_key((struct mbedtls_ecjpake_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecjpake-write-shared-key(^ctx1: c-pointer<mbedtls-ecjpake-context-c>, ^buf: c-pointer<int>, ^len: int, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecjpake-write-shared-key(ctx1, buf, len.ssize_t, olen, f-rng, p-rng).int

// \brief           This clears an ECJPAKE context and frees any
// embedded data structure.
// 
// \param ctx       The ECJPAKE context to free. This may be \c NULL,
// in which case this function does nothing. If it is not
// \c NULL, it must point to an initialized ECJPAKE context.
pub extern external/mbedtls-ecjpake-free(^ctx1: c-pointer<mbedtls-ecjpake-context-c>): ()
  c inline "(void)mbedtls_ecjpake_free((struct mbedtls_ecjpake_context*)#1)"

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if a test failed
pub extern external/mbedtls-ecjpake-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_ecjpake_self_test((int)#1)"

pub inline fun ffi/mbedtls-ecjpake-self-test(^verbose: int): <> int
  external/mbedtls-ecjpake-self-test(verbose.int32).int

// Open a handle to an existing persistent key.
// 
// Open a handle to a persistent key. A key is persistent if it was created
// with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key
// always has a nonzero key identifier, set with psa_set_key_id() when
// creating the key. Implementations may provide additional pre-provisioned
// keys that can be opened with psa_open_key(). Such keys have an application
// key identifier in the vendor range, as documented in the description of
// #psa_key_id_t.
// 
// The application must eventually close the handle with psa_close_key() or
// psa_destroy_key() to release associated resources. If the application dies
// without calling one of these functions, the implementation should perform
// the equivalent of a call to psa_close_key().
// 
// Some implementations permit an application to open the same key multiple
// times. If this is successful, each call to psa_open_key() will return a
// different key handle.
// 
// \note This API is not part of the PSA Cryptography API Release 1.0.0
// specification. It was defined in the 1.0 Beta 3 version of the
// specification but was removed in the 1.0.0 released version. This API is
// kept for the time being to not break applications relying on it. It is not
// deprecated yet but will be in the near future.
// 
// \note Applications that rely on opening a key multiple times will not be
// portable to implementations that only permit a single key handle to be
// opened. See also :ref:\`key-handles\`.
// 
// 
// \param key           The persistent identifier of the key.
// \param[out] handle   On success, a handle to the key.
// 
// \retval #PSA_SUCCESS
// Success. The application can now use the value of `*handle`
// to access the key.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY
// The implementation does not have sufficient resources to open the
// key. This can be due to reaching an implementation limit on the
// number of open keys, the number of open key handles, or available
// memory.
// \retval #PSA_ERROR_DOES_NOT_EXIST
// There is no persistent key with key identifier \p key.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p key is not a valid persistent key identifier.
// \retval #PSA_ERROR_NOT_PERMITTED
// The specified key exists, but the application does not have the
// permission to access it. Note that this specification does not
// define any way to create such a key, but it may be possible
// through implementation-specific means.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-open-key(^key: int32, ^handle1: c-pointer<int>): int32
  c inline "(psa_status_t)psa_open_key((mbedtls_svc_key_id_t)#1, (psa_key_handle_t*)#2)"

pub inline fun ffi/psa-open-key(^key: int, ^handle1: c-pointer<int>): <> int
  external/psa-open-key(key.int32, handle1).int

// Close a key handle.
// 
// If the handle designates a volatile key, this will destroy the key material
// and free all associated resources, just like psa_destroy_key().
// 
// If this is the last open handle to a persistent key, then closing the handle
// will free all resources associated with the key in volatile memory. The key
// data in persistent storage is not affected and can be opened again later
// with a call to psa_open_key().
// 
// Closing the key handle makes the handle invalid, and the key handle
// must not be used again by the application.
// 
// \note This API is not part of the PSA Cryptography API Release 1.0.0
// specification. It was defined in the 1.0 Beta 3 version of the
// specification but was removed in the 1.0.0 released version. This API is
// kept for the time being to not break applications relying on it. It is not
// deprecated yet but will be in the near future.
// 
// \note If the key handle was used to set up an active
// :ref:\`multipart operation <multipart-operations>\`, then closing the
// key handle can cause the multipart operation to fail. Applications should
// maintain the key handle until after the multipart operation has finished.
// 
// \param handle        The key handle to close.
// If this is \c 0, do nothing and return \c PSA_SUCCESS.
// 
// \retval #PSA_SUCCESS
// \p handle was a valid handle or \c 0. It is now closed.
// \retval #PSA_ERROR_INVALID_HANDLE
// \p handle is not a valid handle nor \c 0.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-close-key(^handle1: int32): int32
  c inline "(psa_status_t)psa_close_key((psa_key_handle_t)#1)"

pub inline fun ffi/psa-close-key(^handle1: int): <> int
  external/psa-close-key(handle1.int32).int

// \brief Library deinitialization.
// 
// This function clears all data associated with the PSA layer,
// including the whole key store.
// This function is not thread safe, it wipes every key slot regardless of
// state and reader count. It should only be called when no slot is in use.
// 
// This is an Mbed TLS extension.
pub extern external/mbedtls-psa-crypto-free(): ()
  c inline "(void)mbedtls_psa_crypto_free()"

// \brief Get statistics about
// resource consumption related to the PSA keystore.
// 
// \note When Mbed TLS is built as part of a service, with isolation
// between the application and the keystore, the service may or
// may not expose this function.
pub extern external/mbedtls-psa-get-stats(^stats: c-pointer<mbedtls-psa-stats-s-c>): ()
  c inline "(void)mbedtls_psa_get_stats((mbedtls_psa_stats_t*)#1)"

// \brief Inject an initial entropy seed for the random generator into
// secure storage.
// 
// This function injects data to be used as a seed for the random generator
// used by the PSA Crypto implementation. On devices that lack a trusted
// entropy source (preferably a hardware random number generator),
// the Mbed PSA Crypto implementation uses this value to seed its
// random generator.
// 
// On devices without a trusted entropy source, this function must be
// called exactly once in the lifetime of the device. On devices with
// a trusted entropy source, calling this function is optional.
// In all cases, this function may only be called before calling any
// other function in the PSA Crypto API, including psa_crypto_init().
// 
// When this function returns successfully, it populates a file in
// persistent storage. Once the file has been created, this function
// can no longer succeed.
// 
// If any error occurs, this function does not change the system state.
// You can call this function again after correcting the reason for the
// error if possible.
// 
// \warning This function **can** fail! Callers MUST check the return status.
// 
// \warning If you use this function, you should use it as part of a
// factory provisioning process. The value of the injected seed
// is critical to the security of the device. It must be
// *secret*, *unpredictable* and (statistically) *unique per device*.
// You should be generate it randomly using a cryptographically
// secure random generator seeded from trusted entropy sources.
// You should transmit it securely to the device and ensure
// that its value is not leaked or stored anywhere beyond the
// needs of transmitting it from the point of generation to
// the call of this function, and erase all copies of the value
// once this function returns.
// 
// This is an Mbed TLS extension.
// 
// \note This function is only available on the following platforms:
// * If the compile-time option MBEDTLS_PSA_INJECT_ENTROPY is enabled.
// Note that you must provide compatible implementations of
// mbedtls_nv_seed_read and mbedtls_nv_seed_write.
// * In a client-server integration of PSA Cryptography, on the client side,
// if the server supports this feature.
// \param[in] seed          Buffer containing the seed value to inject.
// \param[in] seed_size     Size of the \p seed buffer.
// The size of the seed in bytes must be greater
// or equal to both #MBEDTLS_ENTROPY_BLOCK_SIZE
// and the value of \c MBEDTLS_ENTROPY_MIN_PLATFORM
// in `library/entropy_poll.h` in the Mbed TLS source
// code.
// It must be less or equal to
// #MBEDTLS_ENTROPY_MAX_SEED_SIZE.
// 
// \retval #PSA_SUCCESS
// The seed value was injected successfully. The random generator
// of the PSA Crypto implementation is now ready for use.
// You may now call psa_crypto_init() and use the PSA Crypto
// implementation.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p seed_size is out of range.
// \retval #PSA_ERROR_STORAGE_FAILURE
// There was a failure reading or writing from storage.
// \retval #PSA_ERROR_NOT_PERMITTED
// The library has already been initialized. It is no longer
// possible to call this function.
pub extern external/mbedtls-psa-inject-entropy(^seed: c-pointer<int>, ^seed-size: ssize_t): int32
  c inline "(psa_status_t)mbedtls_psa_inject_entropy((uint8_t*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-psa-inject-entropy(^seed: c-pointer<int>, ^seed-size: int): <> int
  external/mbedtls-psa-inject-entropy(seed, seed-size.ssize_t).int

// Return an initial value for a PAKE cipher suite object.
pub extern external/psa-pake-cipher-suite-init(): psa-pake-cipher-suite-s
  c inline "(psa_pake_cipher_suite_t)psa_pake_cipher_suite_init()"

pub inline fun ffi/psa-pake-cipher-suite-init(): <> psa-pake-cipher-suite-s-c
  external/psa-pake-cipher-suite-init()

// Retrieve the PAKE algorithm from a PAKE cipher suite.
// 
// \param[in] cipher_suite     The cipher suite structure to query.
// 
// \return The PAKE algorithm stored in the cipher suite structure.
pub extern external/psa-pake-cs-get-algorithm(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int32
  c inline "(psa_algorithm_t)psa_pake_cs_get_algorithm((psa_pake_cipher_suite_t*)#1)"

pub inline fun ffi/psa-pake-cs-get-algorithm(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-pake-cs-get-algorithm(cipher-suite).int

// Declare the PAKE algorithm for the cipher suite.
// 
// This function overwrites any PAKE algorithm
// previously set in \p cipher_suite.
// 
// \param[out] cipher_suite    The cipher suite structure to write to.
// \param algorithm            The PAKE algorithm to write.
// (`PSA_ALG_XXX` values of type ::psa_algorithm_t
// such that #PSA_ALG_IS_PAKE(\c alg) is true.)
// If this is 0, the PAKE algorithm in
// \p cipher_suite becomes unspecified.
pub extern external/psa-pake-cs-set-algorithm(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>, ^algorithm: int32): ()
  c inline "(void)psa_pake_cs_set_algorithm((psa_pake_cipher_suite_t*)#1, (psa_algorithm_t)#2)"

pub inline fun ffi/psa-pake-cs-set-algorithm(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>, ^algorithm: int): <> ()
  external/psa-pake-cs-set-algorithm(cipher-suite, algorithm.int32)

// Retrieve the primitive from a PAKE cipher suite.
// 
// \param[in] cipher_suite     The cipher suite structure to query.
// 
// \return The primitive stored in the cipher suite structure.
pub extern external/psa-pake-cs-get-primitive(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int32
  c inline "(psa_pake_primitive_t)psa_pake_cs_get_primitive((psa_pake_cipher_suite_t*)#1)"

pub inline fun ffi/psa-pake-cs-get-primitive(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-pake-cs-get-primitive(cipher-suite).int

// Declare the primitive for a PAKE cipher suite.
// 
// This function overwrites any primitive previously set in \p cipher_suite.
// 
// \param[out] cipher_suite    The cipher suite structure to write to.
// \param primitive            The primitive to write. If this is 0, the
// primitive type in \p cipher_suite becomes
// unspecified.
pub extern external/psa-pake-cs-set-primitive(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>, ^primitive: int32): ()
  c inline "(void)psa_pake_cs_set_primitive((psa_pake_cipher_suite_t*)#1, (psa_pake_primitive_t)#2)"

pub inline fun ffi/psa-pake-cs-set-primitive(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>, ^primitive: int): <> ()
  external/psa-pake-cs-set-primitive(cipher-suite, primitive.int32)

// Retrieve the PAKE family from a PAKE cipher suite.
// 
// \param[in] cipher_suite     The cipher suite structure to query.
// 
// \return The PAKE family stored in the cipher suite structure.
pub extern external/psa-pake-cs-get-family(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int8
  c inline "(psa_pake_family_t)psa_pake_cs_get_family((psa_pake_cipher_suite_t*)#1)"

pub inline fun ffi/psa-pake-cs-get-family(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-pake-cs-get-family(cipher-suite).int

// Retrieve the PAKE primitive bit-size from a PAKE cipher suite.
// 
// \param[in] cipher_suite     The cipher suite structure to query.
// 
// \return The PAKE primitive bit-size stored in the cipher suite structure.
pub extern external/psa-pake-cs-get-bits(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int16
  c inline "(int16_t)psa_pake_cs_get_bits((psa_pake_cipher_suite_t*)#1)"

pub inline fun ffi/psa-pake-cs-get-bits(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-pake-cs-get-bits(cipher-suite).int

// Retrieve the hash algorithm from a PAKE cipher suite.
// 
// \param[in] cipher_suite      The cipher suite structure to query.
// 
// \return The hash algorithm stored in the cipher suite structure. The return
// value is 0 if the PAKE is not parametrised by a hash algorithm or if
// the hash algorithm is not set.
pub extern external/psa-pake-cs-get-hash(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int32
  c inline "(psa_algorithm_t)psa_pake_cs_get_hash((psa_pake_cipher_suite_t*)#1)"

pub inline fun ffi/psa-pake-cs-get-hash(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-pake-cs-get-hash(cipher-suite).int

// Declare the hash algorithm for a PAKE cipher suite.
// 
// This function overwrites any hash algorithm
// previously set in \p cipher_suite.
// 
// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
// for more information.
// 
// \param[out] cipher_suite     The cipher suite structure to write to.
// \param hash                  The hash involved in the cipher suite.
// (`PSA_ALG_XXX` values of type ::psa_algorithm_t
// such that #PSA_ALG_IS_HASH(\c alg) is true.)
// If this is 0, the hash algorithm in
// \p cipher_suite becomes unspecified.
pub extern external/psa-pake-cs-set-hash(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>, ^hash: int32): ()
  c inline "(void)psa_pake_cs_set_hash((psa_pake_cipher_suite_t*)#1, (psa_algorithm_t)#2)"

pub inline fun ffi/psa-pake-cs-set-hash(^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>, ^hash: int): <> ()
  external/psa-pake-cs-set-hash(cipher-suite, hash.int32)

// Return an initial value for a PAKE operation object.
pub extern external/psa-pake-operation-init(): psa-pake-operation-s
  c inline "(psa_pake_operation_t)psa_pake_operation_init()"

pub inline fun ffi/psa-pake-operation-init(): <> psa-pake-operation-s-c
  external/psa-pake-operation-init()

// Get the length of the password in bytes from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] password_len     Password length.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// Password hasn't been set yet.
pub extern external/psa-crypto-driver-pake-get-password-len(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^password-len: c-pointer<int>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_password_len((psa_crypto_driver_pake_inputs_t*)#1, (size_t*)#2)"

pub inline fun ffi/psa-crypto-driver-pake-get-password-len(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^password-len: c-pointer<int>): <> int
  external/psa-crypto-driver-pake-get-password-len(inputs, password-len).int

// Get the password from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] buffer           Return buffer for password.
// \param      buffer_size      Size of the return buffer in bytes.
// \param[out] buffer_length    Actual size of the password in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// Password hasn't been set yet.
pub extern external/psa-crypto-driver-pake-get-password(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^buffer: c-pointer<int>, ^buffer-size: ssize_t, ^buffer-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_password((psa_crypto_driver_pake_inputs_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-crypto-driver-pake-get-password(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^buffer: c-pointer<int>, ^buffer-size: int, ^buffer-length: c-pointer<int>): <> int
  external/psa-crypto-driver-pake-get-password(inputs, buffer, buffer-size.ssize_t, buffer-length).int

// Get the length of the user id in bytes from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] user_len         User id length.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// User id hasn't been set yet.
pub extern external/psa-crypto-driver-pake-get-user-len(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^user-len: c-pointer<int>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_user_len((psa_crypto_driver_pake_inputs_t*)#1, (size_t*)#2)"

pub inline fun ffi/psa-crypto-driver-pake-get-user-len(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^user-len: c-pointer<int>): <> int
  external/psa-crypto-driver-pake-get-user-len(inputs, user-len).int

// Get the length of the peer id in bytes from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] peer_len         Peer id length.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// Peer id hasn't been set yet.
pub extern external/psa-crypto-driver-pake-get-peer-len(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^peer-len: c-pointer<int>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_peer_len((psa_crypto_driver_pake_inputs_t*)#1, (size_t*)#2)"

pub inline fun ffi/psa-crypto-driver-pake-get-peer-len(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^peer-len: c-pointer<int>): <> int
  external/psa-crypto-driver-pake-get-peer-len(inputs, peer-len).int

// Get the user id from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] user_id          User id.
// \param      user_id_size     Size of \p user_id in bytes.
// \param[out] user_id_len      Size of the user id in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// User id hasn't been set yet.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p user_id is too small.
pub extern external/psa-crypto-driver-pake-get-user(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^user-id: c-pointer<int>, ^user-id-size: ssize_t, ^user-id-len: c-pointer<int>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_user((psa_crypto_driver_pake_inputs_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-crypto-driver-pake-get-user(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^user-id: c-pointer<int>, ^user-id-size: int, ^user-id-len: c-pointer<int>): <> int
  external/psa-crypto-driver-pake-get-user(inputs, user-id, user-id-size.ssize_t, user-id-len).int

// Get the peer id from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] peer_id          Peer id.
// \param      peer_id_size     Size of \p peer_id in bytes.
// \param[out] peer_id_length   Size of the peer id in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// Peer id hasn't been set yet.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p peer_id is too small.
pub extern external/psa-crypto-driver-pake-get-peer(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^peer-id: c-pointer<int>, ^peer-id-size: ssize_t, ^peer-id-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_peer((psa_crypto_driver_pake_inputs_t*)#1, (uint8_t*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/psa-crypto-driver-pake-get-peer(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^peer-id: c-pointer<int>, ^peer-id-size: int, ^peer-id-length: c-pointer<int>): <> int
  external/psa-crypto-driver-pake-get-peer(inputs, peer-id, peer-id-size.ssize_t, peer-id-length).int

// Get the cipher suite from given inputs.
// 
// \param[in]  inputs           Operation inputs.
// \param[out] cipher_suite     Return buffer for role.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BAD_STATE
// Cipher_suite hasn't been set yet.
pub extern external/psa-crypto-driver-pake-get-cipher-suite(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int32
  c inline "(psa_status_t)psa_crypto_driver_pake_get_cipher_suite((psa_crypto_driver_pake_inputs_t*)#1, (psa_pake_cipher_suite_t*)#2)"

pub inline fun ffi/psa-crypto-driver-pake-get-cipher-suite(^inputs: c-pointer<psa-crypto-driver-pake-inputs-s-c>, ^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-crypto-driver-pake-get-cipher-suite(inputs, cipher-suite).int

// Set the session information for a password-authenticated key exchange.
// 
// The sequence of operations to set up a password-authenticated key exchange
// is as follows:
// -# Allocate an operation object which will be passed to all the functions
// listed here.
// -# Initialize the operation object with one of the methods described in the
// documentation for #psa_pake_operation_t, e.g.
// #PSA_PAKE_OPERATION_INIT.
// -# Call psa_pake_setup() to specify the cipher suite.
// -# Call \c psa_pake_set_xxx() functions on the operation to complete the
// setup. The exact sequence of \c psa_pake_set_xxx() functions that needs
// to be called depends on the algorithm in use.
// 
// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
// for more information.
// 
// A typical sequence of calls to perform a password-authenticated key
// exchange:
// -# Call psa_pake_output(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to get the
// key share that needs to be sent to the peer.
// -# Call psa_pake_input(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to provide
// the key share that was received from the peer.
// -# Depending on the algorithm additional calls to psa_pake_output() and
// psa_pake_input() might be necessary.
// -# Call psa_pake_get_implicit_key() for accessing the shared secret.
// 
// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
// for more information.
// 
// If an error occurs at any step after a call to psa_pake_setup(),
// the operation will need to be reset by a call to psa_pake_abort(). The
// application may call psa_pake_abort() at any time after the operation
// has been initialized.
// 
// After a successful call to psa_pake_setup(), the application must
// eventually terminate the operation. The following events terminate an
// operation:
// - A call to psa_pake_abort().
// - A successful call to psa_pake_get_implicit_key().
// 
// \param[in,out] operation     The operation object to set up. It must have
// been initialized but not set up yet.
// \param[in] cipher_suite      The cipher suite to use. (A cipher suite fully
// characterizes a PAKE algorithm and determines
// the algorithm as well.)
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The algorithm in \p cipher_suite is not a PAKE algorithm, or the
// PAKE primitive in \p cipher_suite is not compatible with the
// PAKE algorithm, or the hash algorithm in \p cipher_suite is invalid
// or not compatible with the PAKE algorithm and primitive.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The algorithm in \p cipher_suite is not a supported PAKE algorithm,
// or the PAKE primitive in \p cipher_suite is not supported or not
// compatible with the PAKE algorithm, or the hash algorithm in
// \p cipher_suite is not supported or not compatible with the PAKE
// algorithm and primitive.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid, or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-setup(^operation: c-pointer<psa-pake-operation-s-c>, ^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): int32
  c inline "(psa_status_t)psa_pake_setup((psa_pake_operation_t*)#1, (psa_pake_cipher_suite_t*)#2)"

pub inline fun ffi/psa-pake-setup(^operation: c-pointer<psa-pake-operation-s-c>, ^cipher-suite: c-pointer<psa-pake-cipher-suite-s-c>): <> int
  external/psa-pake-setup(operation, cipher-suite).int

// Set the password for a password-authenticated key exchange from key ID.
// 
// Call this function when the password, or a value derived from the password,
// is already present in the key store.
// 
// \param[in,out] operation     The operation object to set the password for. It
// must have been set up by psa_pake_setup() and
// not yet in use (neither psa_pake_output() nor
// psa_pake_input() has been called yet). It must
// be on operation for which the password hasn't
// been set yet (psa_pake_set_password_key()
// hasn't been called yet).
// \param password              Identifier of the key holding the password or a
// value derived from the password (eg. by a
// memory-hard function).  It must remain valid
// until the operation terminates. It must be of
// type #PSA_KEY_TYPE_PASSWORD or
// #PSA_KEY_TYPE_PASSWORD_HASH. It has to allow
// the usage #PSA_KEY_USAGE_DERIVE.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_HANDLE
// \p password is not a valid key identifier.
// \retval #PSA_ERROR_NOT_PERMITTED
// The key does not have the #PSA_KEY_USAGE_DERIVE flag, or it does not
// permit the \p operation's algorithm.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The key type for \p password is not #PSA_KEY_TYPE_PASSWORD or
// #PSA_KEY_TYPE_PASSWORD_HASH, or \p password is not compatible with
// the \p operation's cipher suite.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The key type or key size of \p password is not supported with the
// \p operation's cipher suite.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must have been set up.), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-set-password-key(^operation: c-pointer<psa-pake-operation-s-c>, ^password: int32): int32
  c inline "(psa_status_t)psa_pake_set_password_key((psa_pake_operation_t*)#1, (mbedtls_svc_key_id_t)#2)"

pub inline fun ffi/psa-pake-set-password-key(^operation: c-pointer<psa-pake-operation-s-c>, ^password: int): <> int
  external/psa-pake-set-password-key(operation, password.int32).int

// Set the user ID for a password-authenticated key exchange.
// 
// Call this function to set the user ID. For PAKE algorithms that associate a
// user identifier with each side of the session you need to call
// psa_pake_set_peer() as well. For PAKE algorithms that associate a single
// user identifier with the session, call psa_pake_set_user() only.
// 
// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
// for more information.
// 
// \param[in,out] operation     The operation object to set the user ID for. It
// must have been set up by psa_pake_setup() and
// not yet in use (neither psa_pake_output() nor
// psa_pake_input() has been called yet). It must
// be on operation for which the user ID hasn't
// been set (psa_pake_set_user() hasn't been
// called yet).
// \param[in] user_id           The user ID to authenticate with.
// \param user_id_len           Size of the \p user_id buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p user_id is not valid for the \p operation's algorithm and cipher
// suite.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The value of \p user_id is not supported by the implementation.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid, or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-set-user(^operation: c-pointer<psa-pake-operation-s-c>, ^user-id: c-pointer<int>, ^user-id-len: ssize_t): int32
  c inline "(psa_status_t)psa_pake_set_user((psa_pake_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-pake-set-user(^operation: c-pointer<psa-pake-operation-s-c>, ^user-id: c-pointer<int>, ^user-id-len: int): <> int
  external/psa-pake-set-user(operation, user-id, user-id-len.ssize_t).int

// Set the peer ID for a password-authenticated key exchange.
// 
// Call this function in addition to psa_pake_set_user() for PAKE algorithms
// that associate a user identifier with each side of the session. For PAKE
// algorithms that associate a single user identifier with the session, call
// psa_pake_set_user() only.
// 
// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
// for more information.
// 
// \param[in,out] operation     The operation object to set the peer ID for. It
// must have been set up by psa_pake_setup() and
// not yet in use (neither psa_pake_output() nor
// psa_pake_input() has been called yet). It must
// be on operation for which the peer ID hasn't
// been set (psa_pake_set_peer() hasn't been
// called yet).
// \param[in] peer_id           The peer's ID to authenticate.
// \param peer_id_len           Size of the \p peer_id buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p peer_id is not valid for the \p operation's algorithm and cipher
// suite.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The algorithm doesn't associate a second identity with the session.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// Calling psa_pake_set_peer() is invalid with the \p operation's
// algorithm, the operation state is not valid, or the library has not
// been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-set-peer(^operation: c-pointer<psa-pake-operation-s-c>, ^peer-id: c-pointer<int>, ^peer-id-len: ssize_t): int32
  c inline "(psa_status_t)psa_pake_set_peer((psa_pake_operation_t*)#1, (uint8_t*)#2, (size_t)#3)"

pub inline fun ffi/psa-pake-set-peer(^operation: c-pointer<psa-pake-operation-s-c>, ^peer-id: c-pointer<int>, ^peer-id-len: int): <> int
  external/psa-pake-set-peer(operation, peer-id, peer-id-len.ssize_t).int

// Set the application role for a password-authenticated key exchange.
// 
// Not all PAKE algorithms need to differentiate the communicating entities.
// It is optional to call this function for PAKEs that don't require a role
// to be specified. For such PAKEs the application role parameter is ignored,
// or #PSA_PAKE_ROLE_NONE can be passed as \c role.
// 
// Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`
// values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true)
// for more information.
// 
// \param[in,out] operation     The operation object to specify the
// application's role for. It must have been set up
// by psa_pake_setup() and not yet in use (neither
// psa_pake_output() nor psa_pake_input() has been
// called yet). It must be on operation for which
// the application's role hasn't been specified
// (psa_pake_set_role() hasn't been called yet).
// \param role                  A value of type ::psa_pake_role_t indicating the
// application's role in the PAKE the algorithm
// that is being set up. For more information see
// the documentation of \c PSA_PAKE_ROLE_XXX
// constants.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// The \p role is not a valid PAKE role in the \p operationโs algorithm.
// \retval #PSA_ERROR_NOT_SUPPORTED
// The \p role for this algorithm is not supported or is not valid.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid, or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-set-role(^operation: c-pointer<psa-pake-operation-s-c>, ^role: int8): int32
  c inline "(psa_status_t)psa_pake_set_role((psa_pake_operation_t*)#1, (psa_pake_role_t)#2)"

pub inline fun ffi/psa-pake-set-role(^operation: c-pointer<psa-pake-operation-s-c>, ^role: int): <> int
  external/psa-pake-set-role(operation, role.int8).int

// Get output for a step of a password-authenticated key exchange.
// 
// Depending on the algorithm being executed, you might need to call this
// function several times or you might not need to call this at all.
// 
// The exact sequence of calls to perform a password-authenticated key
// exchange depends on the algorithm in use.  Refer to the documentation of
// individual PAKE algorithm types (`PSA_ALG_XXX` values of type
// ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true) for more
// information.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_pake_abort().
// 
// \param[in,out] operation    Active PAKE operation.
// \param step                 The step of the algorithm for which the output is
// requested.
// \param[out] output          Buffer where the output is to be written in the
// format appropriate for this \p step. Refer to
// the documentation of the individual
// \c PSA_PAKE_STEP_XXX constants for more
// information.
// \param output_size          Size of the \p output buffer in bytes. This must
// be at least #PSA_PAKE_OUTPUT_SIZE(\c alg, \c
// primitive, \p output_step) where \c alg and
// \p primitive are the PAKE algorithm and primitive
// in the operation's cipher suite, and \p step is
// the output step.
// 
// \param[out] output_length   On success, the number of bytes of the returned
// output.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_BUFFER_TOO_SMALL
// The size of the \p output buffer is too small.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p step is not compatible with the operation's algorithm.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p step is not supported with the operation's algorithm.
// \retval #PSA_ERROR_INSUFFICIENT_ENTROPY \emptydescription
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, and fully set
// up, and this call must conform to the algorithm's requirements
// for ordering of input and output steps), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-output(^operation: c-pointer<psa-pake-operation-s-c>, ^step: int8, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-length: c-pointer<int>): int32
  c inline "(psa_status_t)psa_pake_output((psa_pake_operation_t*)#1, (psa_pake_step_t)#2, (uint8_t*)#3, (size_t)#4, (size_t*)#5)"

pub inline fun ffi/psa-pake-output(^operation: c-pointer<psa-pake-operation-s-c>, ^step: int, ^output: c-pointer<int>, ^output-size: int, ^output-length: c-pointer<int>): <> int
  external/psa-pake-output(operation, step.int8, output, output-size.ssize_t, output-length).int

// Provide input for a step of a password-authenticated key exchange.
// 
// Depending on the algorithm being executed, you might need to call this
// function several times or you might not need to call this at all.
// 
// The exact sequence of calls to perform a password-authenticated key
// exchange depends on the algorithm in use.  Refer to the documentation of
// individual PAKE algorithm types (`PSA_ALG_XXX` values of type
// ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true) for more
// information.
// 
// If this function returns an error status, the operation enters an error
// state and must be aborted by calling psa_pake_abort().
// 
// \param[in,out] operation    Active PAKE operation.
// \param step                 The step for which the input is provided.
// \param[in] input            Buffer containing the input in the format
// appropriate for this \p step. Refer to the
// documentation of the individual
// \c PSA_PAKE_STEP_XXX constants for more
// information.
// \param input_length         Size of the \p input buffer in bytes.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_SIGNATURE
// The verification fails for a #PSA_PAKE_STEP_ZK_PROOF input step.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// \p input_length is not compatible with the \p operationโs algorithm,
// or the \p input is not valid for the \p operation's algorithm,
// cipher suite or \p step.
// \retval #PSA_ERROR_NOT_SUPPORTED
// \p step p is not supported with the \p operation's algorithm, or the
// \p input is not supported for the \p operation's algorithm, cipher
// suite or \p step.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The operation state is not valid (it must be active, and fully set
// up, and this call must conform to the algorithm's requirements
// for ordering of input and output steps), or
// the library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-input(^operation: c-pointer<psa-pake-operation-s-c>, ^step: int8, ^input: c-pointer<int>, ^input-length: ssize_t): int32
  c inline "(psa_status_t)psa_pake_input((psa_pake_operation_t*)#1, (psa_pake_step_t)#2, (uint8_t*)#3, (size_t)#4)"

pub inline fun ffi/psa-pake-input(^operation: c-pointer<psa-pake-operation-s-c>, ^step: int, ^input: c-pointer<int>, ^input-length: int): <> int
  external/psa-pake-input(operation, step.int8, input, input-length.ssize_t).int

// Get implicitly confirmed shared secret from a PAKE.
// 
// At this point there is a cryptographic guarantee that only the authenticated
// party who used the same password is able to compute the key. But there is no
// guarantee that the peer is the party it claims to be and was able to do so.
// 
// That is, the authentication is only implicit. Since the peer is not
// authenticated yet, no action should be taken yet that assumes that the peer
// is who it claims to be. For example, do not access restricted files on the
// peer's behalf until an explicit authentication has succeeded.
// 
// This function can be called after the key exchange phase of the operation
// has completed. It imports the shared secret output of the PAKE into the
// provided derivation operation. The input step
// #PSA_KEY_DERIVATION_INPUT_SECRET is used when placing the shared key
// material in the key derivation operation.
// 
// The exact sequence of calls to perform a password-authenticated key
// exchange depends on the algorithm in use.  Refer to the documentation of
// individual PAKE algorithm types (`PSA_ALG_XXX` values of type
// ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\c alg) is true) for more
// information.
// 
// When this function returns successfully, \p operation becomes inactive.
// If this function returns an error status, both \p operation
// and \c key_derivation operations enter an error state and must be aborted by
// calling psa_pake_abort() and psa_key_derivation_abort() respectively.
// 
// \param[in,out] operation    Active PAKE operation.
// \param[out] output          A key derivation operation that is ready
// for an input step of type
// #PSA_KEY_DERIVATION_INPUT_SECRET.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_INVALID_ARGUMENT
// #PSA_KEY_DERIVATION_INPUT_SECRET is not compatible with the
// algorithm in the \p output key derivation operation.
// \retval #PSA_ERROR_NOT_SUPPORTED
// Input from a PAKE is not supported by the algorithm in the \p output
// key derivation operation.
// \retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
// \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
// \retval #PSA_ERROR_DATA_INVALID \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The PAKE operation state is not valid (it must be active, but beyond
// that validity is specific to the algorithm), or
// the library has not been previously initialized by psa_crypto_init(),
// or the state of \p output is not valid for
// the #PSA_KEY_DERIVATION_INPUT_SECRET step. This can happen if the
// step is out of order or the application has done this step already
// and it may not be repeated.
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-get-implicit-key(^operation: c-pointer<psa-pake-operation-s-c>, ^output: c-pointer<psa-key-derivation-s-c>): int32
  c inline "(psa_status_t)psa_pake_get_implicit_key((psa_pake_operation_t*)#1, (psa_key_derivation_operation_t*)#2)"

pub inline fun ffi/psa-pake-get-implicit-key(^operation: c-pointer<psa-pake-operation-s-c>, ^output: c-pointer<psa-key-derivation-s-c>): <> int
  external/psa-pake-get-implicit-key(operation, output).int

// Abort a PAKE operation.
// 
// Aborting an operation frees all associated resources except for the \c
// operation structure itself. Once aborted, the operation object can be reused
// for another operation by calling psa_pake_setup() again.
// 
// This function may be called at any time after the operation
// object has been initialized as described in #psa_pake_operation_t.
// 
// In particular, calling psa_pake_abort() after the operation has been
// terminated by a call to psa_pake_abort() or psa_pake_get_implicit_key()
// is safe and has no effect.
// 
// \param[in,out] operation    The operation to abort.
// 
// \retval #PSA_SUCCESS
// Success.
// \retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
// \retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
// \retval #PSA_ERROR_BAD_STATE
// The library has not been previously initialized by psa_crypto_init().
// It is implementation-dependent whether a failure to initialize
// results in this error code.
pub extern external/psa-pake-abort(^operation: c-pointer<psa-pake-operation-s-c>): int32
  c inline "(psa_status_t)psa_pake_abort((psa_pake_operation_t*)#1)"

pub inline fun ffi/psa-pake-abort(^operation: c-pointer<psa-pake-operation-s-c>): <> int
  external/psa-pake-abort(operation).int

// \brief           Return information associated with the given PK type
// 
// \param pk_type   PK type to search for.
// 
// \return          The PK info associated with the type or NULL if not found.
pub extern external/mbedtls-pk-info-from-type(^pk-type: int32): c-pointer<mbedtls-pk-info-t-c>
  c inline "(intptr_t)mbedtls_pk_info_from_type((int32_t)#1)"

pub inline fun ffi/mbedtls-pk-info-from-type(^pk-type: mbedtls-pk-type-t): <exn> c-pointer<mbedtls-pk-info-t-c>
  external/mbedtls-pk-info-from-type(pk-type.mbedtls-pk-type-t/int)

// \brief           Initialize a #mbedtls_pk_context (as NONE).
// 
// \param ctx       The context to initialize.
// This must not be \c NULL.
pub extern external/mbedtls-pk-init(^ctx1: c-pointer<mbedtls-pk-context-c>): ()
  c inline "(void)mbedtls_pk_init((struct mbedtls_pk_context*)#1)"

// \brief           Free the components of a #mbedtls_pk_context.
// 
// \param ctx       The context to clear. It must have been initialized.
// If this is \c NULL, this function does nothing.
// 
// \note            For contexts that have been set up with
// mbedtls_pk_setup_opaque(), this does not free the underlying
// PSA key and you still need to call psa_destroy_key()
// independently if you want to destroy that key.
pub extern external/mbedtls-pk-free(^ctx1: c-pointer<mbedtls-pk-context-c>): ()
  c inline "(void)mbedtls_pk_free((struct mbedtls_pk_context*)#1)"

// \brief           Initialize a PK context with the information given
// and allocates the type-specific PK subcontext.
// 
// \param ctx       Context to initialize. It must not have been set
// up yet (type #MBEDTLS_PK_NONE).
// \param info      Information to use
// 
// \return          0 on success,
// MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,
// MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure.
// 
// \note            For contexts holding an RSA-alt key, use
// \c mbedtls_pk_setup_rsa_alt() instead.
pub extern external/mbedtls-pk-setup(^ctx1: c-pointer<mbedtls-pk-context-c>, ^info: c-pointer<mbedtls-pk-info-t-c>): int32
  c inline "(int)mbedtls_pk_setup((struct mbedtls_pk_context*)#1, (struct mbedtls_pk_info_t*)#2)"

pub inline fun ffi/mbedtls-pk-setup(^ctx1: c-pointer<mbedtls-pk-context-c>, ^info: c-pointer<mbedtls-pk-info-t-c>): <> int
  external/mbedtls-pk-setup(ctx1, info).int

// \brief           Initialize an RSA-alt context
// 
// \param ctx       Context to initialize. It must not have been set
// up yet (type #MBEDTLS_PK_NONE).
// \param key       RSA key pointer
// \param decrypt_func  Decryption function
// \param sign_func     Signing function
// \param key_len_func  Function returning key length in bytes
// 
// \return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the
// context wasn't already initialized as RSA_ALT.
// 
// \note            This function replaces \c mbedtls_pk_setup() for RSA-alt.
pub extern external/mbedtls-pk-setup-rsa-alt(^ctx1: c-pointer<mbedtls-pk-context-c>, ^key: c-pointer<()>, ^decrypt-func: c-pointer<intptr_t>, ^sign-func: c-pointer<intptr_t>, ^key-len-func: c-pointer<intptr_t>): int32
  c inline "(int)mbedtls_pk_setup_rsa_alt((struct mbedtls_pk_context*)#1, (void*)#2, (mbedtls_pk_rsa_alt_decrypt_func)#3, (mbedtls_pk_rsa_alt_sign_func)#4, (mbedtls_pk_rsa_alt_key_len_func)#5)"

pub inline fun ffi/mbedtls-pk-setup-rsa-alt(^ctx1: c-pointer<mbedtls-pk-context-c>, ^key: c-pointer<()>, ^decrypt-func: mbedtls-pk-rsa-alt-decrypt-func, ^sign-func: mbedtls-pk-rsa-alt-sign-func, ^key-len-func: mbedtls-pk-rsa-alt-key-len-func): <> int
  external/mbedtls-pk-setup-rsa-alt(ctx1, key, decrypt-func, sign-func, key-len-func).int

// \brief           Get the size in bits of the underlying key
// 
// \param ctx       The context to query. It must have been initialized.
// 
// \return          Key size in bits, or 0 on error
pub extern external/mbedtls-pk-get-bitlen(^ctx1: c-pointer<mbedtls-pk-context-c>): ssize_t
  c inline "(size_t)mbedtls_pk_get_bitlen((struct mbedtls_pk_context*)#1)"

pub inline fun ffi/mbedtls-pk-get-bitlen(^ctx1: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-pk-get-bitlen(ctx1).int

// \brief           Tell if a context can do the operation given by type
// 
// \param ctx       The context to query. It must have been initialized.
// \param type      The desired type.
// 
// \return          1 if the context can do operations on the given type.
// \return          0 if the context cannot do the operations on the given
// type. This is always the case for a context that has
// been initialized but not set up, or that has been
// cleared with mbedtls_pk_free().
pub extern external/mbedtls-pk-can-do(^ctx1: c-pointer<mbedtls-pk-context-c>, ^type1: int32): int32
  c inline "(int)mbedtls_pk_can_do((struct mbedtls_pk_context*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-pk-can-do(^ctx1: c-pointer<mbedtls-pk-context-c>, ^type1: mbedtls-pk-type-t): <exn> int
  external/mbedtls-pk-can-do(ctx1, type1.mbedtls-pk-type-t/int).int

// \brief           Determine valid PSA attributes that can be used to
// import a key into PSA.
// 
// The attributes determined by this function are suitable
// for calling mbedtls_pk_import_into_psa() to create
// a PSA key with the same key material.
// 
// The typical flow of operations involving this function is
// ```
// psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
// int ret = mbedtls_pk_get_psa_attributes(pk, &attributes);
// if (ret != 0) ...; // error handling omitted
// // Tweak attributes if desired
// psa_key_id_t key_id = 0;
// ret = mbedtls_pk_import_into_psa(pk, &attributes, &key_id);
// if (ret != 0) ...; // error handling omitted
// ```
// 
// \note            This function does not support RSA-alt contexts
// (set up with mbedtls_pk_setup_rsa_alt()).
// 
// \param[in] pk    The PK context to use. It must have been set up.
// It can either contain a key pair or just a public key.
// \param usage     A single `PSA_KEY_USAGE_xxx` flag among the following:
// - #PSA_KEY_USAGE_DECRYPT: \p pk must contain a
// key pair. The output \p attributes will contain a
// key pair type, and the usage policy will allow
// #PSA_KEY_USAGE_ENCRYPT as well as
// #PSA_KEY_USAGE_DECRYPT.
// - #PSA_KEY_USAGE_DERIVE: \p pk must contain a
// key pair. The output \p attributes will contain a
// key pair type.
// - #PSA_KEY_USAGE_ENCRYPT: The output
// \p attributes will contain a public key type.
// - #PSA_KEY_USAGE_SIGN_HASH: \p pk must contain a
// key pair. The output \p attributes will contain a
// key pair type, and the usage policy will allow
// #PSA_KEY_USAGE_VERIFY_HASH as well as
// #PSA_KEY_USAGE_SIGN_HASH.
// - #PSA_KEY_USAGE_SIGN_MESSAGE: \p pk must contain a
// key pair. The output \p attributes will contain a
// key pair type, and the usage policy will allow
// #PSA_KEY_USAGE_VERIFY_MESSAGE as well as
// #PSA_KEY_USAGE_SIGN_MESSAGE.
// - #PSA_KEY_USAGE_VERIFY_HASH: The output
// \p attributes will contain a public key type.
// - #PSA_KEY_USAGE_VERIFY_MESSAGE: The output
// \p attributes will contain a public key type.
// \param[out] attributes
// On success, valid attributes to import the key into PSA.
// - The lifetime and key identifier are unchanged. If the
// attribute structure was initialized or reset before
// calling this function, this will result in a volatile
// key. Call psa_set_key_identifier() before or after this
// function if you wish to create a persistent key. Call
// psa_set_key_lifetime() before or after this function if
// you wish to import the key in a secure element.
// - The key type and bit-size are determined by the contents
// of the PK context. If the PK context contains a key
// pair, the key type can be either a key pair type or
// the corresponding public key type, depending on
// \p usage. If the PK context contains a public key,
// the key type is a public key type.
// - The key's policy is determined by the key type and
// the \p usage parameter. The usage always allows
// \p usage, exporting and copying the key, and
// possibly other permissions as documented for the
// \p usage parameter.
// The permitted algorithm policy is determined as follows
// based on the #mbedtls_pk_type_t type of \p pk,
// the chosen \p usage and other factors:
// - #MBEDTLS_PK_RSA whose underlying
// #mbedtls_rsa_context has the padding mode
// #MBEDTLS_RSA_PKCS_V15:
// #PSA_ALG_RSA_PKCS1V15_SIGN(#PSA_ALG_ANY_HASH)
// if \p usage is SIGN/VERIFY, and
// #PSA_ALG_RSA_PKCS1V15_CRYPT
// if \p usage is ENCRYPT/DECRYPT.
// - #MBEDTLS_PK_RSA whose underlying
// #mbedtls_rsa_context has the padding mode
// #MBEDTLS_RSA_PKCS_V21 and the digest type
// corresponding to the PSA algorithm \c hash:
// #PSA_ALG_RSA_PSS_ANY_SALT(#PSA_ALG_ANY_HASH)
// if \p usage is SIGN/VERIFY, and
// #PSA_ALG_RSA_OAEP(\c hash)
// if \p usage is ENCRYPT/DECRYPT.
// - #MBEDTLS_PK_RSA_ALT: not supported.
// - #MBEDTLS_PK_ECDSA or #MBEDTLS_PK_ECKEY
// if \p usage is SIGN/VERIFY:
// #PSA_ALG_DETERMINISTIC_ECDSA(#PSA_ALG_ANY_HASH)
// if #MBEDTLS_ECDSA_DETERMINISTIC is enabled,
// otherwise #PSA_ALG_ECDSA(#PSA_ALG_ANY_HASH).
// - #MBEDTLS_PK_ECKEY_DH or #MBEDTLS_PK_ECKEY
// if \p usage is DERIVE:
// #PSA_ALG_ECDH.
// - #MBEDTLS_PK_OPAQUE: same as the primary algorithm
// set for the underlying PSA key, except that
// sign/decrypt flags are removed if the type is
// set to a public key type.
// The underlying key must allow \p usage.
// Note that the enrollment algorithm set with
// psa_set_key_enrollment_algorithm() is not copied.
// 
// \return          0 on success.
// #MBEDTLS_ERR_PK_TYPE_MISMATCH if \p pk does not contain
// a key of the type identified in \p attributes.
// Another error code on other failures.
pub extern external/mbedtls-pk-get-psa-attributes(^pk: c-pointer<mbedtls-pk-context-c>, ^usage: int32, ^attributes: c-pointer<psa-key-attributes-s-c>): int32
  c inline "(int)mbedtls_pk_get_psa_attributes((struct mbedtls_pk_context*)#1, (psa_key_usage_t)#2, (psa_key_attributes_t*)#3)"

pub inline fun ffi/mbedtls-pk-get-psa-attributes(^pk: c-pointer<mbedtls-pk-context-c>, ^usage: int, ^attributes: c-pointer<psa-key-attributes-s-c>): <> int
  external/mbedtls-pk-get-psa-attributes(pk, usage.int32, attributes).int

// \brief           Import a key into the PSA key store.
// 
// This function is equivalent to calling psa_import_key()
// with the key material from \p pk.
// 
// The typical way to use this function is:
// -# Call mbedtls_pk_get_psa_attributes() to obtain
// attributes for the given key.
// -# If desired, modify the attributes, for example:
// - To create a persistent key, call
// psa_set_key_identifier() and optionally
// psa_set_key_lifetime().
// - To import only the public part of a key pair:
// 
// psa_set_key_type(&attributes,
// PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(
// psa_get_key_type(&attributes)));
// - Restrict the key usage if desired.
// -# Call mbedtls_pk_import_into_psa().
// 
// \note            This function does not support RSA-alt contexts
// (set up with mbedtls_pk_setup_rsa_alt()).
// 
// \param[in] pk    The PK context to use. It must have been set up.
// It can either contain a key pair or just a public key.
// \param[in] attributes
// The attributes to use for the new key. They must be
// compatible with \p pk. In particular, the key type
// must match the content of \p pk.
// If \p pk contains a key pair, the key type in
// attributes can be either the key pair type or the
// corresponding public key type (to import only the
// public part).
// \param[out] key_id
// On success, the identifier of the newly created key.
// On error, this is #MBEDTLS_SVC_KEY_ID_INIT.
// 
// \return          0 on success.
// #MBEDTLS_ERR_PK_TYPE_MISMATCH if \p pk does not contain
// a key of the type identified in \p attributes.
// Another error code on other failures.
pub extern external/mbedtls-pk-import-into-psa(^pk: c-pointer<mbedtls-pk-context-c>, ^attributes: c-pointer<psa-key-attributes-s-c>, ^key-id: c-pointer<int>): int32
  c inline "(int)mbedtls_pk_import_into_psa((struct mbedtls_pk_context*)#1, (psa_key_attributes_t*)#2, (mbedtls_svc_key_id_t*)#3)"

pub inline fun ffi/mbedtls-pk-import-into-psa(^pk: c-pointer<mbedtls-pk-context-c>, ^attributes: c-pointer<psa-key-attributes-s-c>, ^key-id: c-pointer<int>): <> int
  external/mbedtls-pk-import-into-psa(pk, attributes, key-id).int

// \brief           Create a PK context starting from a key stored in PSA.
// This key:
// - must be exportable and
// - must be an RSA or EC key pair or public key (FFDH is not supported in PK).
// 
// The resulting PK object will be a transparent type:
// - #MBEDTLS_PK_RSA for RSA keys or
// - #MBEDTLS_PK_ECKEY for EC keys.
// 
// Once this functions returns the PK object will be completely
// independent from the original PSA key that it was generated
// from.
// Calling mbedtls_pk_sign(), mbedtls_pk_verify(),
// mbedtls_pk_encrypt(), mbedtls_pk_decrypt() on the resulting
// PK context will perform the corresponding algorithm for that
// PK context type.
// * For ECDSA, the choice of deterministic vs randomized will
// be based on the compile-time setting #MBEDTLS_ECDSA_DETERMINISTIC.
// * For an RSA key, the output PK context will allow both
// encrypt/decrypt and sign/verify regardless of the original
// key's policy.
// The original key's policy determines the output key's padding
// mode: PCKS1 v2.1 is set if the PSA key policy is OAEP or PSS,
// otherwise PKCS1 v1.5 is set.
// 
// \param key_id    The key identifier of the key stored in PSA.
// \param pk        The PK context that will be filled. It must be initialized,
// but not set up.
// 
// \return          0 on success.
// \return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA in case the provided input
// parameters are not correct.
pub extern external/mbedtls-pk-copy-from-psa(^key-id: int32, ^pk: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int)mbedtls_pk_copy_from_psa((mbedtls_svc_key_id_t)#1, (struct mbedtls_pk_context*)#2)"

pub inline fun ffi/mbedtls-pk-copy-from-psa(^key-id: int, ^pk: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-pk-copy-from-psa(key-id.int32, pk).int

// \brief           Create a PK context for the public key of a PSA key.
// 
// The key must be an RSA or ECC key. It can be either a
// public key or a key pair, and only the public key is copied.
// The resulting PK object will be a transparent type:
// - #MBEDTLS_PK_RSA for RSA keys or
// - #MBEDTLS_PK_ECKEY for EC keys.
// 
// Once this functions returns the PK object will be completely
// independent from the original PSA key that it was generated
// from.
// Calling mbedtls_pk_verify() or
// mbedtls_pk_encrypt() on the resulting
// PK context will perform the corresponding algorithm for that
// PK context type.
// 
// For an RSA key, the output PK context will allow both
// encrypt and verify regardless of the original key's policy.
// The original key's policy determines the output key's padding
// mode: PCKS1 v2.1 is set if the PSA key policy is OAEP or PSS,
// otherwise PKCS1 v1.5 is set.
// 
// \param key_id    The key identifier of the key stored in PSA.
// \param pk        The PK context that will be filled. It must be initialized,
// but not set up.
// 
// \return          0 on success.
// \return          MBEDTLS_ERR_PK_BAD_INPUT_DATA in case the provided input
// parameters are not correct.
pub extern external/mbedtls-pk-copy-public-from-psa(^key-id: int32, ^pk: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int)mbedtls_pk_copy_public_from_psa((mbedtls_svc_key_id_t)#1, (struct mbedtls_pk_context*)#2)"

pub inline fun ffi/mbedtls-pk-copy-public-from-psa(^key-id: int, ^pk: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-pk-copy-public-from-psa(key-id.int32, pk).int

// \brief           Verify signature (including padding if relevant).
// 
// \param ctx       The PK context to use. It must have been set up.
// \param md_alg    Hash algorithm used.
// This can be #MBEDTLS_MD_NONE if the signature algorithm
// does not rely on a hash algorithm (non-deterministic
// ECDSA, RSA PKCS#1 v1.5).
// For PKCS#1 v1.5, if \p md_alg is #MBEDTLS_MD_NONE, then
// \p hash is the DigestInfo structure used by RFC 8017
// &sect;9.2 steps 3&ndash;6. If \p md_alg is a valid hash
// algorithm then \p hash is the digest itself, and this
// function calculates the DigestInfo encoding internally.
// \param hash      Hash of the message to sign
// \param hash_len  Hash length
// \param sig       Signature to verify
// \param sig_len   Signature length
// 
// \note            For keys of type #MBEDTLS_PK_RSA, the signature algorithm is
// either PKCS#1 v1.5 or PSS (accepting any salt length),
// depending on the padding mode in the underlying RSA context.
// For a pk object constructed by parsing, this is PKCS#1 v1.5
// by default. Use mbedtls_pk_verify_ext() to explicitly select
// a different algorithm.
// 
// \return          0 on success (signature is valid),
// #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid
// signature in \p sig but its length is less than \p sig_len,
// or a specific error code.
pub extern external/mbedtls-pk-verify(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hash-len: ssize_t, ^sig: c-pointer<int>, ^sig-len: ssize_t): int32
  c inline "(int)mbedtls_pk_verify((struct mbedtls_pk_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-pk-verify(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hash-len: int, ^sig: c-pointer<int>, ^sig-len: int): <exn> int
  external/mbedtls-pk-verify(ctx1, md-alg.mbedtls-md-type-t/int, hash, hash-len.ssize_t, sig, sig-len.ssize_t).int

// \brief           Restartable version of \c mbedtls_pk_verify()
// 
// \note            Performs the same job as \c mbedtls_pk_verify(), but can
// return early and restart according to the limit set with
// \c mbedtls_ecp_set_max_ops() to reduce blocking for ECC
// operations. For RSA, same as \c mbedtls_pk_verify().
// 
// \param ctx       The PK context to use. It must have been set up.
// \param md_alg    Hash algorithm used (see notes)
// \param hash      Hash of the message to sign
// \param hash_len  Hash length or 0 (see notes)
// \param sig       Signature to verify
// \param sig_len   Signature length
// \param rs_ctx    Restart context (NULL to disable restart)
// 
// \return          See \c mbedtls_pk_verify(), or
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
pub extern external/mbedtls-pk-verify-restartable(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hash-len: ssize_t, ^sig: c-pointer<int>, ^sig-len: ssize_t, ^rs-ctx: c-pointer<mbedtls-pk-restart-ctx>): int32
  c inline "(int)mbedtls_pk_verify_restartable((struct mbedtls_pk_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (mbedtls_pk_restart_ctx*)#7)"

pub inline fun ffi/mbedtls-pk-verify-restartable(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hash-len: int, ^sig: c-pointer<int>, ^sig-len: int, ^rs-ctx: c-pointer<mbedtls-pk-restart-ctx>): <exn> int
  external/mbedtls-pk-verify-restartable(ctx1, md-alg.mbedtls-md-type-t/int, hash, hash-len.ssize_t, sig, sig-len.ssize_t, rs-ctx).int

// \brief           Verify signature, with options.
// (Includes verification of the padding depending on type.)
// 
// \param type      Signature type (inc. possible padding type) to verify
// \param options   Pointer to type-specific options, or NULL
// \param ctx       The PK context to use. It must have been set up.
// \param md_alg    Hash algorithm used (see notes)
// \param hash      Hash of the message to sign
// \param hash_len  Hash length or 0 (see notes)
// \param sig       Signature to verify
// \param sig_len   Signature length
// 
// \return          0 on success (signature is valid),
// #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be
// used for this type of signatures,
// #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid
// signature in \p sig but its length is less than \p sig_len,
// or a specific error code.
// 
// \note            If hash_len is 0, then the length associated with md_alg
// is used instead, or an error returned if it is invalid.
// 
// \note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0
// 
// \note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point
// to a mbedtls_pk_rsassa_pss_options structure,
// otherwise it must be NULL. Note that if
// #MBEDTLS_USE_PSA_CRYPTO is defined, the salt length is not
// verified as PSA_ALG_RSA_PSS_ANY_SALT is used.
pub extern external/mbedtls-pk-verify-ext(^type1: int32, ^options: c-pointer<()>, ^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hash-len: ssize_t, ^sig: c-pointer<int>, ^sig-len: ssize_t): int32
  c inline "(int)mbedtls_pk_verify_ext((int32_t)#1, (void*)#2, (struct mbedtls_pk_context*)#3, (int32_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (size_t)#8)"

pub inline fun ffi/mbedtls-pk-verify-ext(^type1: mbedtls-pk-type-t, ^options: c-pointer<()>, ^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hash-len: int, ^sig: c-pointer<int>, ^sig-len: int): <exn> int
  external/mbedtls-pk-verify-ext(type1.mbedtls-pk-type-t/int, options, ctx1, md-alg.mbedtls-md-type-t/int, hash, hash-len.ssize_t, sig, sig-len.ssize_t).int

// \brief           Make signature, including padding if relevant.
// 
// \param ctx       The PK context to use. It must have been set up
// with a private key.
// \param md_alg    Hash algorithm used (see notes)
// \param hash      Hash of the message to sign
// \param hash_len  Hash length
// \param sig       Place to write the signature.
// It must have enough room for the signature.
// #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.
// You may use a smaller buffer if it is large enough
// given the key type.
// \param sig_size  The size of the \p sig buffer in bytes.
// \param sig_len   On successful return,
// the number of bytes written to \p sig.
// \param f_rng     RNG function, must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \note            For keys of type #MBEDTLS_PK_RSA, the signature algorithm is
// either PKCS#1 v1.5 or PSS (using the largest possible salt
// length up to the hash length), depending on the padding mode
// in the underlying RSA context. For a pk object constructed
// by parsing, this is PKCS#1 v1.5 by default. Use
// mbedtls_pk_verify_ext() to explicitly select a different
// algorithm.
// 
// \return          0 on success, or a specific error code.
// 
// \note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.
// For ECDSA, md_alg may never be MBEDTLS_MD_NONE.
pub extern external/mbedtls-pk-sign(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hash-len: ssize_t, ^sig: c-pointer<int>, ^sig-size: ssize_t, ^sig-len: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_sign((struct mbedtls_pk_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (size_t*)#7, (int (*)(void*, unsigned char*, size_t))#8, (void*)#9)"

pub inline fun ffi/mbedtls-pk-sign(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hash-len: int, ^sig: c-pointer<int>, ^sig-size: int, ^sig-len: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <exn> int
  external/mbedtls-pk-sign(ctx1, md-alg.mbedtls-md-type-t/int, hash, hash-len.ssize_t, sig, sig-size.ssize_t, sig-len, f-rng, p-rng).int

// \brief           Make signature given a signature type.
// 
// \param pk_type   Signature type.
// \param ctx       The PK context to use. It must have been set up
// with a private key.
// \param md_alg    Hash algorithm used (see notes)
// \param hash      Hash of the message to sign
// \param hash_len  Hash length
// \param sig       Place to write the signature.
// It must have enough room for the signature.
// #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.
// You may use a smaller buffer if it is large enough
// given the key type.
// \param sig_size  The size of the \p sig buffer in bytes.
// \param sig_len   On successful return,
// the number of bytes written to \p sig.
// \param f_rng     RNG function, must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \return          0 on success, or a specific error code.
// 
// \note            When \p pk_type is #MBEDTLS_PK_RSASSA_PSS,
// see #PSA_ALG_RSA_PSS for a description of PSS options used.
// 
// \note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.
// For ECDSA, md_alg may never be MBEDTLS_MD_NONE.
pub extern external/mbedtls-pk-sign-ext(^pk-type: int32, ^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hash-len: ssize_t, ^sig: c-pointer<int>, ^sig-size: ssize_t, ^sig-len: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_sign_ext((int32_t)#1, (struct mbedtls_pk_context*)#2, (int32_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (size_t*)#8, (int (*)(void*, unsigned char*, size_t))#9, (void*)#10)"

pub inline fun ffi/mbedtls-pk-sign-ext(^pk-type: mbedtls-pk-type-t, ^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hash-len: int, ^sig: c-pointer<int>, ^sig-size: int, ^sig-len: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <exn> int
  external/mbedtls-pk-sign-ext(pk-type.mbedtls-pk-type-t/int, ctx1, md-alg.mbedtls-md-type-t/int, hash, hash-len.ssize_t, sig, sig-size.ssize_t, sig-len, f-rng, p-rng).int

// \brief           Restartable version of \c mbedtls_pk_sign()
// 
// \note            Performs the same job as \c mbedtls_pk_sign(), but can
// return early and restart according to the limit set with
// \c mbedtls_ecp_set_max_ops() to reduce blocking for ECC
// operations. For RSA, same as \c mbedtls_pk_sign().
// 
// \param ctx       The PK context to use. It must have been set up
// with a private key.
// \param md_alg    Hash algorithm used (see notes for mbedtls_pk_sign())
// \param hash      Hash of the message to sign
// \param hash_len  Hash length
// \param sig       Place to write the signature.
// It must have enough room for the signature.
// #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.
// You may use a smaller buffer if it is large enough
// given the key type.
// \param sig_size  The size of the \p sig buffer in bytes.
// \param sig_len   On successful return,
// the number of bytes written to \p sig.
// \param f_rng     RNG function, must not be \c NULL.
// \param p_rng     RNG parameter
// \param rs_ctx    Restart context (NULL to disable restart)
// 
// \return          See \c mbedtls_pk_sign().
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
pub extern external/mbedtls-pk-sign-restartable(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: int32, ^hash: c-pointer<int>, ^hash-len: ssize_t, ^sig: c-pointer<int>, ^sig-size: ssize_t, ^sig-len: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-pk-restart-ctx>): int32
  c inline "(int)mbedtls_pk_sign_restartable((struct mbedtls_pk_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (size_t*)#7, (int (*)(void*, unsigned char*, size_t))#8, (void*)#9, (mbedtls_pk_restart_ctx*)#10)"

pub inline fun ffi/mbedtls-pk-sign-restartable(^ctx1: c-pointer<mbedtls-pk-context-c>, ^md-alg: mbedtls-md-type-t, ^hash: c-pointer<int>, ^hash-len: int, ^sig: c-pointer<int>, ^sig-size: int, ^sig-len: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-pk-restart-ctx>): <exn> int
  external/mbedtls-pk-sign-restartable(ctx1, md-alg.mbedtls-md-type-t/int, hash, hash-len.ssize_t, sig, sig-size.ssize_t, sig-len, f-rng, p-rng, rs-ctx).int

// \brief           Decrypt message (including padding if relevant).
// 
// \param ctx       The PK context to use. It must have been set up
// with a private key.
// \param input     Input to decrypt
// \param ilen      Input size
// \param output    Decrypted output
// \param olen      Decrypted message length
// \param osize     Size of the output buffer
// \param f_rng     RNG function, must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \note            For keys of type #MBEDTLS_PK_RSA, the signature algorithm is
// either PKCS#1 v1.5 or OAEP, depending on the padding mode in
// the underlying RSA context. For a pk object constructed by
// parsing, this is PKCS#1 v1.5 by default.
// 
// \return          0 on success, or a specific error code.
pub extern external/mbedtls-pk-decrypt(^ctx1: c-pointer<mbedtls-pk-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^olen: c-pointer<int>, ^osize: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_decrypt((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t*)#5, (size_t)#6, (int (*)(void*, unsigned char*, size_t))#7, (void*)#8)"

pub inline fun ffi/mbedtls-pk-decrypt(^ctx1: c-pointer<mbedtls-pk-context-c>, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^olen: c-pointer<int>, ^osize: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-pk-decrypt(ctx1, input, ilen.ssize_t, output, olen, osize.ssize_t, f-rng, p-rng).int

// \brief           Encrypt message (including padding if relevant).
// 
// \param ctx       The PK context to use. It must have been set up.
// \param input     Message to encrypt
// \param ilen      Message size
// \param output    Encrypted output
// \param olen      Encrypted output length
// \param osize     Size of the output buffer
// \param f_rng     RNG function, must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \note            For keys of type #MBEDTLS_PK_RSA, the signature algorithm is
// either PKCS#1 v1.5 or OAEP, depending on the padding mode in
// the underlying RSA context. For a pk object constructed by
// parsing, this is PKCS#1 v1.5 by default.
// 
// \note            \p f_rng is used for padding generation.
// 
// \return          0 on success, or a specific error code.
pub extern external/mbedtls-pk-encrypt(^ctx1: c-pointer<mbedtls-pk-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t, ^output: c-pointer<int>, ^olen: c-pointer<int>, ^osize: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_encrypt((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t*)#5, (size_t)#6, (int (*)(void*, unsigned char*, size_t))#7, (void*)#8)"

pub inline fun ffi/mbedtls-pk-encrypt(^ctx1: c-pointer<mbedtls-pk-context-c>, ^input: c-pointer<int>, ^ilen: int, ^output: c-pointer<int>, ^olen: c-pointer<int>, ^osize: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-pk-encrypt(ctx1, input, ilen.ssize_t, output, olen, osize.ssize_t, f-rng, p-rng).int

// \brief           Check if a public-private pair of keys matches.
// 
// \param pub       Context holding a public key.
// \param prv       Context holding a private (and public) key.
// \param f_rng     RNG function, must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \return          \c 0 on success (keys were checked and match each other).
// \return          #MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE if the keys could not
// be checked - in that case they may or may not match.
// \return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA if a context is invalid.
// \return          Another non-zero value if the keys do not match.
pub extern external/mbedtls-pk-check-pair(^pub: c-pointer<mbedtls-pk-context-c>, ^prv: c-pointer<mbedtls-pk-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_check_pair((struct mbedtls_pk_context*)#1, (struct mbedtls_pk_context*)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4)"

pub inline fun ffi/mbedtls-pk-check-pair(^pub: c-pointer<mbedtls-pk-context-c>, ^prv: c-pointer<mbedtls-pk-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-pk-check-pair(pub, prv, f-rng, p-rng).int

// \brief           Export debug information
// 
// \param ctx       The PK context to use. It must have been initialized.
// \param items     Place to write debug items
// 
// \return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA
pub extern external/mbedtls-pk-debug(^ctx1: c-pointer<mbedtls-pk-context-c>, ^items: c-pointer<mbedtls-pk-debug-item-c>): int32
  c inline "(int)mbedtls_pk_debug((struct mbedtls_pk_context*)#1, (struct mbedtls_pk_debug_item*)#2)"

pub inline fun ffi/mbedtls-pk-debug(^ctx1: c-pointer<mbedtls-pk-context-c>, ^items: c-pointer<mbedtls-pk-debug-item-c>): <> int
  external/mbedtls-pk-debug(ctx1, items).int

// \brief           Access the type name
// 
// \param ctx       The PK context to use. It must have been initialized.
// 
// \return          Type name on success, or "invalid PK"
pub extern external/mbedtls-pk-get-name(^ctx1: c-pointer<mbedtls-pk-context-c>): c-pointer<int>
  c inline "(intptr_t)mbedtls_pk_get_name((struct mbedtls_pk_context*)#1)"

// \brief           Get the key type
// 
// \param ctx       The PK context to use. It must have been initialized.
// 
// \return          Type on success.
// \return          #MBEDTLS_PK_NONE for a context that has not been set up.
pub extern external/mbedtls-pk-get-type(^ctx1: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int32_t)mbedtls_pk_get_type((struct mbedtls_pk_context*)#1)"

pub inline fun ffi/mbedtls-pk-get-type(^ctx1: c-pointer<mbedtls-pk-context-c>): <exn> mbedtls-pk-type-t
  external/mbedtls-pk-get-type(ctx1).int/mbedtls-pk-type-t

// \ingroup pk_module */
// /**
// \brief           Parse a private key in PEM or DER format
// 
// \note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param ctx       The PK context to fill. It must have been initialized
// but not set up.
// \param key       Input buffer to parse.
// The buffer must contain the input exactly, with no
// extra trailing material. For PEM, the buffer must
// contain a null-terminated string.
// \param keylen    Size of \b key in bytes.
// For PEM data, this includes the terminating null byte,
// so \p keylen must be equal to `strlen(key) + 1`.
// \param pwd       Optional password for decryption.
// Pass \c NULL if expecting a non-encrypted key.
// Pass a string of \p pwdlen bytes if expecting an encrypted
// key; a non-encrypted key will also be accepted.
// The empty password is not supported.
// \param pwdlen    Size of the password in bytes.
// Ignored if \p pwd is \c NULL.
// \param f_rng     RNG function, must not be \c NULL. Used for blinding.
// \param p_rng     RNG parameter
// 
// \note            On entry, ctx must be empty, either freshly initialised
// with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
// specific key type, check the result with mbedtls_pk_can_do().
// 
// \note            The key is also checked for correctness.
// 
// \return          0 if successful, or a specific PK or PEM error code
pub extern external/mbedtls-pk-parse-key(^ctx1: c-pointer<mbedtls-pk-context-c>, ^key: c-pointer<int>, ^keylen: ssize_t, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_parse_key((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (int (*)(void*, unsigned char*, size_t))#6, (void*)#7)"

pub inline fun ffi/mbedtls-pk-parse-key(^ctx1: c-pointer<mbedtls-pk-context-c>, ^key: c-pointer<int>, ^keylen: int, ^pwd: c-pointer<int>, ^pwdlen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-pk-parse-key(ctx1, key, keylen.ssize_t, pwd, pwdlen.ssize_t, f-rng, p-rng).int

// \ingroup pk_module */
// /**
// \brief           Parse a public key in PEM or DER format
// 
// \note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param ctx       The PK context to fill. It must have been initialized
// but not set up.
// \param key       Input buffer to parse.
// The buffer must contain the input exactly, with no
// extra trailing material. For PEM, the buffer must
// contain a null-terminated string.
// \param keylen    Size of \b key in bytes.
// For PEM data, this includes the terminating null byte,
// so \p keylen must be equal to `strlen(key) + 1`.
// 
// \note            On entry, ctx must be empty, either freshly initialised
// with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
// specific key type, check the result with mbedtls_pk_can_do().
// 
// \note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for
// limitations.
// 
// \note            The key is also checked for correctness.
// 
// \return          0 if successful, or a specific PK or PEM error code
pub extern external/mbedtls-pk-parse-public-key(^ctx1: c-pointer<mbedtls-pk-context-c>, ^key: c-pointer<int>, ^keylen: ssize_t): int32
  c inline "(int)mbedtls_pk_parse_public_key((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-pk-parse-public-key(^ctx1: c-pointer<mbedtls-pk-context-c>, ^key: c-pointer<int>, ^keylen: int): <> int
  external/mbedtls-pk-parse-public-key(ctx1, key, keylen.ssize_t).int

// \ingroup pk_module */
// /**
// \brief           Load and parse a private key
// 
// \note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param ctx       The PK context to fill. It must have been initialized
// but not set up.
// \param path      filename to read the private key from
// \param password  Optional password to decrypt the file.
// Pass \c NULL if expecting a non-encrypted key.
// Pass a null-terminated string if expecting an encrypted
// key; a non-encrypted key will also be accepted.
// The empty password is not supported.
// \param f_rng     RNG function, must not be \c NULL. Used for blinding.
// \param p_rng     RNG parameter
// 
// \note            On entry, ctx must be empty, either freshly initialised
// with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
// specific key type, check the result with mbedtls_pk_can_do().
// 
// \note            The key is also checked for correctness.
// 
// \return          0 if successful, or a specific PK or PEM error code
pub extern external/mbedtls-pk-parse-keyfile(^ctx1: c-pointer<mbedtls-pk-context-c>, ^path: c-pointer<int>, ^password: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_pk_parse_keyfile((struct mbedtls_pk_context*)#1, (char*)#2, (char*)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-pk-parse-keyfile(^ctx1: c-pointer<mbedtls-pk-context-c>, ^path: c-pointer<int>, ^password: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-pk-parse-keyfile(ctx1, path, password, f-rng, p-rng).int

// \ingroup pk_module */
// /**
// \brief           Load and parse a public key
// 
// \param ctx       The PK context to fill. It must have been initialized
// but not set up.
// \param path      filename to read the public key from
// 
// \note            On entry, ctx must be empty, either freshly initialised
// with mbedtls_pk_init() or reset with mbedtls_pk_free(). If
// you need a specific key type, check the result with
// mbedtls_pk_can_do().
// 
// \note            The key is also checked for correctness.
// 
// \return          0 if successful, or a specific PK or PEM error code
pub extern external/mbedtls-pk-parse-public-keyfile(^ctx1: c-pointer<mbedtls-pk-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_pk_parse_public_keyfile((struct mbedtls_pk_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-pk-parse-public-keyfile(^ctx1: c-pointer<mbedtls-pk-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-pk-parse-public-keyfile(ctx1, path).int

// \brief           Write a private key to a PKCS#1 or SEC1 DER structure
// Note: data is written at the end of the buffer! Use the
// return value to determine where you should start
// using the buffer
// 
// \param ctx       PK context which must contain a valid private key.
// \param buf       buffer to write to
// \param size      size of the buffer
// 
// \return          length of data written if successful, or a specific
// error code
pub extern external/mbedtls-pk-write-key-der(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_pk_write_key_der((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-pk-write-key-der(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: int): <> int
  external/mbedtls-pk-write-key-der(ctx1, buf, size.ssize_t).int

// \brief           Write a public key to a SubjectPublicKeyInfo DER structure
// Note: data is written at the end of the buffer! Use the
// return value to determine where you should start
// using the buffer
// 
// \param ctx       PK context which must contain a valid public or private key.
// \param buf       buffer to write to
// \param size      size of the buffer
// 
// \return          length of data written if successful, or a specific
// error code
pub extern external/mbedtls-pk-write-pubkey-der(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_pk_write_pubkey_der((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-pk-write-pubkey-der(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: int): <> int
  external/mbedtls-pk-write-pubkey-der(ctx1, buf, size.ssize_t).int

// \brief           Write a public key to a PEM string
// 
// \param ctx       PK context which must contain a valid public or private key.
// \param buf       Buffer to write to. The output includes a
// terminating null byte.
// \param size      Size of the buffer in bytes.
// 
// \return          0 if successful, or a specific error code
pub extern external/mbedtls-pk-write-pubkey-pem(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_pk_write_pubkey_pem((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-pk-write-pubkey-pem(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: int): <> int
  external/mbedtls-pk-write-pubkey-pem(ctx1, buf, size.ssize_t).int

// \brief           Write a private key to a PKCS#1 or SEC1 PEM string
// 
// \param ctx       PK context which must contain a valid private key.
// \param buf       Buffer to write to. The output includes a
// terminating null byte.
// \param size      Size of the buffer in bytes.
// 
// \return          0 if successful, or a specific error code
pub extern external/mbedtls-pk-write-key-pem(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_pk_write_key_pem((struct mbedtls_pk_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-pk-write-key-pem(^ctx1: c-pointer<mbedtls-pk-context-c>, ^buf: c-pointer<int>, ^size: int): <> int
  external/mbedtls-pk-write-key-pem(ctx1, buf, size.ssize_t).int

// \brief           Parse a SubjectPublicKeyInfo DER structure
// 
// \param p         the position in the ASN.1 data
// \param end       end of the buffer
// \param pk        The PK context to fill. It must have been initialized
// but not set up.
// 
// \return          0 if successful, or a specific PK error code
pub extern external/mbedtls-pk-parse-subpubkey(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^pk: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int)mbedtls_pk_parse_subpubkey((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_pk_context*)#3)"

pub inline fun ffi/mbedtls-pk-parse-subpubkey(^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>, ^pk: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-pk-parse-subpubkey(p, end, pk).int

// \brief           Write a subjectPublicKey to ASN.1 data
// Note: function works backwards in data buffer
// 
// \param p         reference to current position pointer
// \param start     start of the buffer (for bounds-checking)
// \param key       PK context which must contain a valid public or private key.
// 
// \return          the length written or a negative error code
pub extern external/mbedtls-pk-write-pubkey(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^key: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int)mbedtls_pk_write_pubkey((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_pk_context*)#3)"

pub inline fun ffi/mbedtls-pk-write-pubkey(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^key: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-pk-write-pubkey(p, start, key).int

// \brief           Translate an ASN.1 OID into its numeric representation
// (e.g. "\x2A\x86\x48\x86\xF7\x0D" into "1.2.840.113549")
// 
// \param buf       buffer to put representation in
// \param size      size of the buffer
// \param oid       OID to translate
// 
// \return          Length of the string written (excluding final NULL) or
// MBEDTLS_ERR_OID_BUF_TOO_SMALL in case of error
pub extern external/mbedtls-oid-get-numeric-string(^buf: c-pointer<int>, ^size: ssize_t, ^oid: c-pointer<mbedtls-asn1-buf-c>): int32
  c inline "(int)mbedtls_oid_get_numeric_string((char*)#1, (size_t)#2, (struct mbedtls_asn1_buf*)#3)"

pub inline fun ffi/mbedtls-oid-get-numeric-string(^buf: c-pointer<int>, ^size: int, ^oid: c-pointer<mbedtls-asn1-buf-c>): <> int
  external/mbedtls-oid-get-numeric-string(buf, size.ssize_t, oid).int

// \brief           Translate a string containing a dotted-decimal
// representation of an ASN.1 OID into its encoded form
// (e.g. "1.2.840.113549" into "\x2A\x86\x48\x86\xF7\x0D").
// On success, this function allocates oid->buf from the
// heap. It must be freed by the caller using mbedtls_free().
// 
// \param oid       #mbedtls_asn1_buf to populate with the DER-encoded OID
// \param oid_str   string representation of the OID to parse
// \param size      length of the OID string, not including any null terminator
// 
// \return          0 if successful
// \return          #MBEDTLS_ERR_ASN1_INVALID_DATA if \p oid_str does not
// represent a valid OID
// \return          #MBEDTLS_ERR_ASN1_ALLOC_FAILED if the function fails to
// allocate oid->buf
pub extern external/mbedtls-oid-from-numeric-string(^oid: c-pointer<mbedtls-asn1-buf-c>, ^oid-str: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_oid_from_numeric_string((struct mbedtls_asn1_buf*)#1, (char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-oid-from-numeric-string(^oid: c-pointer<mbedtls-asn1-buf-c>, ^oid-str: c-pointer<int>, ^size: int): <> int
  external/mbedtls-oid-from-numeric-string(oid, oid-str, size.ssize_t).int

// \brief          Translate an X.509 extension OID into local values
// 
// \param oid      OID to use
// \param ext_type place to store the extension type
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-x509-ext-type(^oid: c-pointer<mbedtls-asn1-buf-c>, ^ext-type: c-pointer<int>): int32
  c inline "(int)mbedtls_oid_get_x509_ext_type((struct mbedtls_asn1_buf*)#1, (int*)#2)"

pub inline fun ffi/mbedtls-oid-get-x509-ext-type(^oid: c-pointer<mbedtls-asn1-buf-c>, ^ext-type: c-pointer<int>): <> int
  external/mbedtls-oid-get-x509-ext-type(oid, ext-type).int

// \brief          Translate an X.509 attribute type OID into the short name
// (e.g. the OID for an X520 Common Name into "CN")
// 
// \param oid      OID to use
// \param short_name    place to store the string pointer
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-attr-short-name(^oid: c-pointer<mbedtls-asn1-buf-c>, ^short-name: c-pointer<c-pointer<int>>): int32
  c inline "(int)mbedtls_oid_get_attr_short_name((struct mbedtls_asn1_buf*)#1, (char**)#2)"

pub inline fun ffi/mbedtls-oid-get-attr-short-name(^oid: c-pointer<mbedtls-asn1-buf-c>, ^short-name: c-pointer<c-pointer<int>>): <> int
  external/mbedtls-oid-get-attr-short-name(oid, short-name).int

// \brief          Translate PublicKeyAlgorithm OID into pk_type
// 
// \param oid      OID to use
// \param pk_alg   place to store public key algorithm
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-pk-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^pk-alg: c-pointer<mbedtls-pk-type-t>): int32
  c inline "(int)mbedtls_oid_get_pk_alg((struct mbedtls_asn1_buf*)#1, (int32_t*)#2)"

pub inline fun ffi/mbedtls-oid-get-pk-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^pk-alg: c-pointer<mbedtls-pk-type-t>): <> int
  external/mbedtls-oid-get-pk-alg(oid, pk-alg).int

// \brief          Translate pk_type into PublicKeyAlgorithm OID
// 
// \param pk_alg   Public key type to look for
// \param oid      place to store ASN.1 OID string pointer
// \param olen     length of the OID
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-oid-by-pk-alg(^pk-alg: int32, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_oid_get_oid_by_pk_alg((int32_t)#1, (char**)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-oid-get-oid-by-pk-alg(^pk-alg: mbedtls-pk-type-t, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): <exn> int
  external/mbedtls-oid-get-oid-by-pk-alg(pk-alg.mbedtls-pk-type-t/int, oid, olen).int

// \brief          Translate NamedCurve OID into an EC group identifier
// 
// \param oid      OID to use
// \param grp_id   place to store group id
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-ec-grp(^oid: c-pointer<mbedtls-asn1-buf-c>, ^grp-id: c-pointer<mbedtls-ecp-group-id>): int32
  c inline "(int)mbedtls_oid_get_ec_grp((struct mbedtls_asn1_buf*)#1, (int32_t*)#2)"

pub inline fun ffi/mbedtls-oid-get-ec-grp(^oid: c-pointer<mbedtls-asn1-buf-c>, ^grp-id: c-pointer<mbedtls-ecp-group-id>): <> int
  external/mbedtls-oid-get-ec-grp(oid, grp-id).int

// \brief          Translate EC group identifier into NamedCurve OID
// 
// \param grp_id   EC group identifier
// \param oid      place to store ASN.1 OID string pointer
// \param olen     length of the OID
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-oid-by-ec-grp(^grp-id: int32, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_oid_get_oid_by_ec_grp((int32_t)#1, (char**)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-oid-get-oid-by-ec-grp(^grp-id: mbedtls-ecp-group-id, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): <exn> int
  external/mbedtls-oid-get-oid-by-ec-grp(grp-id.mbedtls-ecp-group-id/int, oid, olen).int

// \brief          Translate AlgorithmIdentifier OID into an EC group identifier,
// for curves that are directly encoded at this level
// 
// \param oid      OID to use
// \param grp_id   place to store group id
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-ec-grp-algid(^oid: c-pointer<mbedtls-asn1-buf-c>, ^grp-id: c-pointer<mbedtls-ecp-group-id>): int32
  c inline "(int)mbedtls_oid_get_ec_grp_algid((struct mbedtls_asn1_buf*)#1, (int32_t*)#2)"

pub inline fun ffi/mbedtls-oid-get-ec-grp-algid(^oid: c-pointer<mbedtls-asn1-buf-c>, ^grp-id: c-pointer<mbedtls-ecp-group-id>): <> int
  external/mbedtls-oid-get-ec-grp-algid(oid, grp-id).int

// \brief          Translate EC group identifier into AlgorithmIdentifier OID,
// for curves that are directly encoded at this level
// 
// \param grp_id   EC group identifier
// \param oid      place to store ASN.1 OID string pointer
// \param olen     length of the OID
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-oid-by-ec-grp-algid(^grp-id: int32, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_oid_get_oid_by_ec_grp_algid((int32_t)#1, (char**)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-oid-get-oid-by-ec-grp-algid(^grp-id: mbedtls-ecp-group-id, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): <exn> int
  external/mbedtls-oid-get-oid-by-ec-grp-algid(grp-id.mbedtls-ecp-group-id/int, oid, olen).int

// \brief          Translate SignatureAlgorithm OID into md_type and pk_type
// 
// \param oid      OID to use
// \param md_alg   place to store message digest algorithm
// \param pk_alg   place to store public key algorithm
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-sig-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-alg: c-pointer<mbedtls-md-type-t>, ^pk-alg: c-pointer<mbedtls-pk-type-t>): int32
  c inline "(int)mbedtls_oid_get_sig_alg((struct mbedtls_asn1_buf*)#1, (int32_t*)#2, (int32_t*)#3)"

pub inline fun ffi/mbedtls-oid-get-sig-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-alg: c-pointer<mbedtls-md-type-t>, ^pk-alg: c-pointer<mbedtls-pk-type-t>): <> int
  external/mbedtls-oid-get-sig-alg(oid, md-alg, pk-alg).int

// \brief          Translate SignatureAlgorithm OID into description
// 
// \param oid      OID to use
// \param desc     place to store string pointer
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-sig-alg-desc(^oid: c-pointer<mbedtls-asn1-buf-c>, ^desc: c-pointer<c-pointer<int>>): int32
  c inline "(int)mbedtls_oid_get_sig_alg_desc((struct mbedtls_asn1_buf*)#1, (char**)#2)"

pub inline fun ffi/mbedtls-oid-get-sig-alg-desc(^oid: c-pointer<mbedtls-asn1-buf-c>, ^desc: c-pointer<c-pointer<int>>): <> int
  external/mbedtls-oid-get-sig-alg-desc(oid, desc).int

// \brief          Translate md_type and pk_type into SignatureAlgorithm OID
// 
// \param md_alg   message digest algorithm
// \param pk_alg   public key algorithm
// \param oid      place to store ASN.1 OID string pointer
// \param olen     length of the OID
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-oid-by-sig-alg(^pk-alg: int32, ^md-alg: int32, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_oid_get_oid_by_sig_alg((int32_t)#1, (int32_t)#2, (char**)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-oid-get-oid-by-sig-alg(^pk-alg: mbedtls-pk-type-t, ^md-alg: mbedtls-md-type-t, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): <exn> int
  external/mbedtls-oid-get-oid-by-sig-alg(pk-alg.mbedtls-pk-type-t/int, md-alg.mbedtls-md-type-t/int, oid, olen).int

// \brief          Translate hmac algorithm OID into md_type
// 
// \param oid      OID to use
// \param md_hmac  place to store message hmac algorithm
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-md-hmac(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-hmac: c-pointer<mbedtls-md-type-t>): int32
  c inline "(int)mbedtls_oid_get_md_hmac((struct mbedtls_asn1_buf*)#1, (int32_t*)#2)"

pub inline fun ffi/mbedtls-oid-get-md-hmac(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-hmac: c-pointer<mbedtls-md-type-t>): <> int
  external/mbedtls-oid-get-md-hmac(oid, md-hmac).int

// \brief          Translate hash algorithm OID into md_type
// 
// \param oid      OID to use
// \param md_alg   place to store message digest algorithm
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-md-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-alg: c-pointer<mbedtls-md-type-t>): int32
  c inline "(int)mbedtls_oid_get_md_alg((struct mbedtls_asn1_buf*)#1, (int32_t*)#2)"

pub inline fun ffi/mbedtls-oid-get-md-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-alg: c-pointer<mbedtls-md-type-t>): <> int
  external/mbedtls-oid-get-md-alg(oid, md-alg).int

// \brief          Translate Extended Key Usage OID into description
// 
// \param oid      OID to use
// \param desc     place to store string pointer
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-extended-key-usage(^oid: c-pointer<mbedtls-asn1-buf-c>, ^desc: c-pointer<c-pointer<int>>): int32
  c inline "(int)mbedtls_oid_get_extended_key_usage((struct mbedtls_asn1_buf*)#1, (char**)#2)"

pub inline fun ffi/mbedtls-oid-get-extended-key-usage(^oid: c-pointer<mbedtls-asn1-buf-c>, ^desc: c-pointer<c-pointer<int>>): <> int
  external/mbedtls-oid-get-extended-key-usage(oid, desc).int

// \brief          Translate certificate policies OID into description
// 
// \param oid      OID to use
// \param desc     place to store string pointer
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-certificate-policies(^oid: c-pointer<mbedtls-asn1-buf-c>, ^desc: c-pointer<c-pointer<int>>): int32
  c inline "(int)mbedtls_oid_get_certificate_policies((struct mbedtls_asn1_buf*)#1, (char**)#2)"

pub inline fun ffi/mbedtls-oid-get-certificate-policies(^oid: c-pointer<mbedtls-asn1-buf-c>, ^desc: c-pointer<c-pointer<int>>): <> int
  external/mbedtls-oid-get-certificate-policies(oid, desc).int

// \brief          Translate md_type into hash algorithm OID
// 
// \param md_alg   message digest algorithm
// \param oid      place to store ASN.1 OID string pointer
// \param olen     length of the OID
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-oid-by-md(^md-alg: int32, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_oid_get_oid_by_md((int32_t)#1, (char**)#2, (size_t*)#3)"

pub inline fun ffi/mbedtls-oid-get-oid-by-md(^md-alg: mbedtls-md-type-t, ^oid: c-pointer<c-pointer<int>>, ^olen: c-pointer<int>): <exn> int
  external/mbedtls-oid-get-oid-by-md(md-alg.mbedtls-md-type-t/int, oid, olen).int

// \brief          Translate encryption algorithm OID into cipher_type
// 
// \param oid           OID to use
// \param cipher_alg    place to store cipher algorithm
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-cipher-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^cipher-alg: c-pointer<mbedtls-cipher-type-t>): int32
  c inline "(int)mbedtls_oid_get_cipher_alg((struct mbedtls_asn1_buf*)#1, (int32_t*)#2)"

pub inline fun ffi/mbedtls-oid-get-cipher-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^cipher-alg: c-pointer<mbedtls-cipher-type-t>): <> int
  external/mbedtls-oid-get-cipher-alg(oid, cipher-alg).int

// \brief          Translate PKCS#12 PBE algorithm OID into md_type and
// cipher_type
// 
// \param oid           OID to use
// \param md_alg        place to store message digest algorithm
// \param cipher_alg    place to store cipher algorithm
// 
// \return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND
pub extern external/mbedtls-oid-get-pkcs12-pbe-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-alg: c-pointer<mbedtls-md-type-t>, ^cipher-alg: c-pointer<mbedtls-cipher-type-t>): int32
  c inline "(int)mbedtls_oid_get_pkcs12_pbe_alg((struct mbedtls_asn1_buf*)#1, (int32_t*)#2, (int32_t*)#3)"

pub inline fun ffi/mbedtls-oid-get-pkcs12-pbe-alg(^oid: c-pointer<mbedtls-asn1-buf-c>, ^md-alg: c-pointer<mbedtls-md-type-t>, ^cipher-alg: c-pointer<mbedtls-cipher-type-t>): <> int
  external/mbedtls-oid-get-pkcs12-pbe-alg(oid, md-alg, cipher-alg).int

// \brief          PKCS#5 PBES2 function
// 
// \note           When encrypting, #MBEDTLS_CIPHER_PADDING_PKCS7 must
// be enabled at compile time.
// 
// \deprecated     This function is deprecated and will be removed in a
// future version of the library.
// Please use mbedtls_pkcs5_pbes2_ext() instead.
// 
// \warning        When decrypting:
// - if #MBEDTLS_CIPHER_PADDING_PKCS7 is enabled at compile
// time, this function validates the CBC padding and returns
// #MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH if the padding is
// invalid. Note that this can help active adversaries
// attempting to brute-forcing the password. Note also that
// there is no guarantee that an invalid password will be
// detected (the chances of a valid padding with a random
// password are about 1/255).
// - if #MBEDTLS_CIPHER_PADDING_PKCS7 is disabled at compile
// time, this function does not validate the CBC padding.
// 
// \param pbe_params the ASN.1 algorithm parameters
// \param mode       either #MBEDTLS_PKCS5_DECRYPT or #MBEDTLS_PKCS5_ENCRYPT
// \param pwd        password to use when generating key
// \param pwdlen     length of password
// \param data       data to process
// \param datalen    length of data
// \param output     Output buffer.
// On success, it contains the encrypted or decrypted data,
// possibly followed by the CBC padding.
// On failure, the content is indeterminate.
// For decryption, there must be enough room for \p datalen
// bytes.
// For encryption, there must be enough room for
// \p datalen + 1 bytes, rounded up to the block size of
// the block cipher identified by \p pbe_params.
// 
// \returns        0 on success, or a MBEDTLS_ERR_XXX code if verification fails.
pub extern external/mbedtls-pkcs5-pbes2(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int32, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^data: c-pointer<int>, ^datalen: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_pkcs5_pbes2((struct mbedtls_asn1_buf*)#1, (int)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-pkcs5-pbes2(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int, ^pwd: c-pointer<int>, ^pwdlen: int, ^data: c-pointer<int>, ^datalen: int, ^output: c-pointer<int>): <> int
  external/mbedtls-pkcs5-pbes2(pbe-params, mode.int32, pwd, pwdlen.ssize_t, data, datalen.ssize_t, output).int

// \brief          PKCS#5 PBES2 function
// 
// \warning        When decrypting:
// - This function validates the CBC padding and returns
// #MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH if the padding is
// invalid. Note that this can help active adversaries
// attempting to brute-forcing the password. Note also that
// there is no guarantee that an invalid password will be
// detected (the chances of a valid padding with a random
// password are about 1/255).
// 
// \param pbe_params the ASN.1 algorithm parameters
// \param mode       either #MBEDTLS_PKCS5_DECRYPT or #MBEDTLS_PKCS5_ENCRYPT
// \param pwd        password to use when generating key
// \param pwdlen     length of password
// \param data       data to process
// \param datalen    length of data
// \param output     Output buffer.
// On success, it contains the decrypted data.
// On failure, the content is indetermidate.
// For decryption, there must be enough room for \p datalen
// bytes.
// For encryption, there must be enough room for
// \p datalen + 1 bytes, rounded up to the block size of
// the block cipher identified by \p pbe_params.
// \param output_size size of output buffer.
// This must be big enough to accommodate for output plus
// padding data.
// \param output_len On success, length of actual data written to the output buffer.
// 
// \returns        0 on success, or a MBEDTLS_ERR_XXX code if parsing or decryption fails.
pub extern external/mbedtls-pkcs5-pbes2-ext(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int32, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^data: c-pointer<int>, ^datalen: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-len: c-pointer<int>): int32
  c inline "(int)mbedtls_pkcs5_pbes2_ext((struct mbedtls_asn1_buf*)#1, (int)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (size_t)#8, (size_t*)#9)"

pub inline fun ffi/mbedtls-pkcs5-pbes2-ext(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int, ^pwd: c-pointer<int>, ^pwdlen: int, ^data: c-pointer<int>, ^datalen: int, ^output: c-pointer<int>, ^output-size: int, ^output-len: c-pointer<int>): <> int
  external/mbedtls-pkcs5-pbes2-ext(pbe-params, mode.int32, pwd, pwdlen.ssize_t, data, datalen.ssize_t, output, output-size.ssize_t, output-len).int

// \brief          PKCS#5 PBKDF2 using HMAC without using the HMAC context
// 
// \param md_type  Hash algorithm used
// \param password Password to use when generating key
// \param plen     Length of password
// \param salt     Salt to use when generating key
// \param slen     Length of salt
// \param iteration_count       Iteration count
// \param key_length            Length of generated key in bytes
// \param output   Generated key. Must be at least as big as key_length
// 
// \returns        0 on success, or a MBEDTLS_ERR_XXX code if verification fails.
pub extern external/mbedtls-pkcs5-pbkdf2-hmac-ext(^md-type: int32, ^password: c-pointer<int>, ^plen: ssize_t, ^salt: c-pointer<int>, ^slen: ssize_t, ^iteration-count: int32, ^key-length: int32, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_pkcs5_pbkdf2_hmac_ext((int32_t)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned int)#6, (int32_t)#7, (unsigned char*)#8)"

pub inline fun ffi/mbedtls-pkcs5-pbkdf2-hmac-ext(^md-type: mbedtls-md-type-t, ^password: c-pointer<int>, ^plen: int, ^salt: c-pointer<int>, ^slen: int, ^iteration-count: int, ^key-length: int, ^output: c-pointer<int>): <exn> int
  external/mbedtls-pkcs5-pbkdf2-hmac-ext(md-type.mbedtls-md-type-t/int, password, plen.ssize_t, salt, slen.ssize_t, iteration-count.int32, key-length.int32, output).int

// \brief          PKCS#5 PBKDF2 using HMAC
// 
// \deprecated     Superseded by mbedtls_pkcs5_pbkdf2_hmac_ext().
// 
// \param ctx      Generic HMAC context
// \param password Password to use when generating key
// \param plen     Length of password
// \param salt     Salt to use when generating key
// \param slen     Length of salt
// \param iteration_count       Iteration count
// \param key_length            Length of generated key in bytes
// \param output   Generated key. Must be at least as big as key_length
// 
// \returns        0 on success, or a MBEDTLS_ERR_XXX code if verification fails.
pub extern external/mbedtls-pkcs5-pbkdf2-hmac(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^password: c-pointer<int>, ^plen: ssize_t, ^salt: c-pointer<int>, ^slen: ssize_t, ^iteration-count: int32, ^key-length: int32, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_pkcs5_pbkdf2_hmac((struct mbedtls_md_context_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned int)#6, (int32_t)#7, (unsigned char*)#8)"

pub inline fun ffi/mbedtls-pkcs5-pbkdf2-hmac(^ctx1: c-pointer<mbedtls-md-context-t-c>, ^password: c-pointer<int>, ^plen: int, ^salt: c-pointer<int>, ^slen: int, ^iteration-count: int, ^key-length: int, ^output: c-pointer<int>): <> int
  external/mbedtls-pkcs5-pbkdf2-hmac(ctx1, password, plen.ssize_t, salt, slen.ssize_t, iteration-count.int32, key-length.int32, output).int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
pub extern external/mbedtls-pkcs5-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_pkcs5_self_test((int)#1)"

pub inline fun ffi/mbedtls-pkcs5-self-test(^verbose: int): <> int
  external/mbedtls-pkcs5-self-test(verbose.int32).int

pub extern external/mbedtls-ssl-list-ciphersuites(): c-pointer<int>
  c inline "(intptr_t)mbedtls_ssl_list_ciphersuites()"

pub extern external/mbedtls-ssl-ciphersuite-from-string(^ciphersuite-name: c-pointer<int>): c-pointer<mbedtls-ssl-ciphersuite-t-c>
  c inline "(intptr_t)mbedtls_ssl_ciphersuite_from_string((char*)#1)"

pub extern external/mbedtls-ssl-ciphersuite-from-id(^ciphersuite-id: int32): c-pointer<mbedtls-ssl-ciphersuite-t-c>
  c inline "(intptr_t)mbedtls_ssl_ciphersuite_from_id((int)#1)"

pub inline fun ffi/mbedtls-ssl-ciphersuite-from-id(^ciphersuite-id: int): <> c-pointer<mbedtls-ssl-ciphersuite-t-c>
  external/mbedtls-ssl-ciphersuite-from-id(ciphersuite-id.int32)

pub extern external/mbedtls-ssl-ciphersuite-get-cipher-key-bitlen(^info: c-pointer<mbedtls-ssl-ciphersuite-t-c>): ssize_t
  c inline "(size_t)mbedtls_ssl_ciphersuite_get_cipher_key_bitlen((struct mbedtls_ssl_ciphersuite_t*)#1)"

pub inline fun ffi/mbedtls-ssl-ciphersuite-get-cipher-key-bitlen(^info: c-pointer<mbedtls-ssl-ciphersuite-t-c>): <> int
  external/mbedtls-ssl-ciphersuite-get-cipher-key-bitlen(info).int

// \brief          Store the certificate DN in printable form into buf;
// no more than size characters will be written.
// 
// \param buf      Buffer to write to
// \param size     Maximum size of buffer
// \param dn       The X509 name to represent
// 
// \return         The length of the string written (not including the
// terminated nul byte), or a negative error code.
pub extern external/mbedtls-x509-dn-gets(^buf: c-pointer<int>, ^size: ssize_t, ^dn: c-pointer<mbedtls-asn1-named-data-c>): int32
  c inline "(int)mbedtls_x509_dn_gets((char*)#1, (size_t)#2, (mbedtls_x509_name*)#3)"

pub inline fun ffi/mbedtls-x509-dn-gets(^buf: c-pointer<int>, ^size: int, ^dn: c-pointer<mbedtls-asn1-named-data-c>): <> int
  external/mbedtls-x509-dn-gets(buf, size.ssize_t, dn).int

// \brief            Convert the certificate DN string \p name into
// a linked list of mbedtls_x509_name (equivalent to
// mbedtls_asn1_named_data).
// 
// \note             This function allocates a linked list, and places the head
// pointer in \p head. This list must later be freed by a
// call to mbedtls_asn1_free_named_data_list().
// 
// \param[out] head  Address in which to store the pointer to the head of the
// allocated list of mbedtls_x509_name
// \param[in] name   The string representation of a DN to convert
// 
// \return           0 on success, or a negative error code.
pub extern external/mbedtls-x509-string-to-names(^head: c-pointer<c-pointer<mbedtls-asn1-named-data-c>>, ^name: c-pointer<int>): int32
  c inline "(int)mbedtls_x509_string_to_names((struct mbedtls_asn1_named_data**)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509-string-to-names(^head: c-pointer<c-pointer<mbedtls-asn1-named-data-c>>, ^name: c-pointer<int>): <> int
  external/mbedtls-x509-string-to-names(head, name).int

// \brief          Store the certificate serial in printable form into buf;
// no more than size characters will be written.
// 
// \param buf      Buffer to write to
// \param size     Maximum size of buffer
// \param serial   The X509 serial to represent
// 
// \return         The length of the string written (not including the
// terminated nul byte), or a negative error code.
pub extern external/mbedtls-x509-serial-gets(^buf: c-pointer<int>, ^size: ssize_t, ^serial: c-pointer<mbedtls-asn1-buf-c>): int32
  c inline "(int)mbedtls_x509_serial_gets((char*)#1, (size_t)#2, (mbedtls_x509_buf*)#3)"

pub inline fun ffi/mbedtls-x509-serial-gets(^buf: c-pointer<int>, ^size: int, ^serial: c-pointer<mbedtls-asn1-buf-c>): <> int
  external/mbedtls-x509-serial-gets(buf, size.ssize_t, serial).int

// \brief          Compare pair of mbedtls_x509_time.
// 
// \param t1       mbedtls_x509_time to compare
// \param t2       mbedtls_x509_time to compare
// 
// \return         < 0 if t1 is before t2
// 0 if t1 equals t2
// > 0 if t1 is after t2
pub extern external/mbedtls-x509-time-cmp(^t1: c-pointer<mbedtls-x509-time-c>, ^t2: c-pointer<mbedtls-x509-time-c>): int32
  c inline "(int)mbedtls_x509_time_cmp((struct mbedtls_x509_time*)#1, (struct mbedtls_x509_time*)#2)"

pub inline fun ffi/mbedtls-x509-time-cmp(^t1: c-pointer<mbedtls-x509-time-c>, ^t2: c-pointer<mbedtls-x509-time-c>): <> int
  external/mbedtls-x509-time-cmp(t1, t2).int

// \brief          Fill mbedtls_x509_time with provided mbedtls_time_t.
// 
// \param tt       mbedtls_time_t to convert
// \param now      mbedtls_x509_time to fill with converted mbedtls_time_t
// 
// \return         \c 0 on success
// \return         A non-zero return value on failure.
pub extern external/mbedtls-x509-time-gmtime(^tt: int64, ^now: c-pointer<mbedtls-x509-time-c>): int32
  c inline "(int)mbedtls_x509_time_gmtime((mbedtls_time_t)#1, (struct mbedtls_x509_time*)#2)"

pub inline fun ffi/mbedtls-x509-time-gmtime(^tt: int, ^now: c-pointer<mbedtls-x509-time-c>): <> int
  external/mbedtls-x509-time-gmtime(tt.int64, now).int

// \brief          Check a given mbedtls_x509_time against the system time
// and tell if it's in the past.
// 
// \note           Intended usage is "if( is_past( valid_to ) ) ERROR".
// Hence the return value of 1 if on internal errors.
// 
// \param to       mbedtls_x509_time to check
// 
// \return         1 if the given time is in the past or an error occurred,
// 0 otherwise.
pub extern external/mbedtls-x509-time-is-past(^to: c-pointer<mbedtls-x509-time-c>): int32
  c inline "(int)mbedtls_x509_time_is_past((struct mbedtls_x509_time*)#1)"

pub inline fun ffi/mbedtls-x509-time-is-past(^to: c-pointer<mbedtls-x509-time-c>): <> int
  external/mbedtls-x509-time-is-past(to).int

// \brief          Check a given mbedtls_x509_time against the system time
// and tell if it's in the future.
// 
// \note           Intended usage is "if( is_future( valid_from ) ) ERROR".
// Hence the return value of 1 if on internal errors.
// 
// \param from     mbedtls_x509_time to check
// 
// \return         1 if the given time is in the future or an error occurred,
// 0 otherwise.
pub extern external/mbedtls-x509-time-is-future(^from: c-pointer<mbedtls-x509-time-c>): int32
  c inline "(int)mbedtls_x509_time_is_future((struct mbedtls_x509_time*)#1)"

pub inline fun ffi/mbedtls-x509-time-is-future(^from: c-pointer<mbedtls-x509-time-c>): <> int
  external/mbedtls-x509-time-is-future(from).int

// \brief          This function parses an item in the SubjectAlternativeNames
// extension. Please note that this function might allocate
// additional memory for a subject alternative name, thus
// mbedtls_x509_free_subject_alt_name has to be called
// to dispose of this additional memory afterwards.
// 
// \param san_buf  The buffer holding the raw data item of the subject
// alternative name.
// \param san      The target structure to populate with the parsed presentation
// of the subject alternative name encoded in \p san_buf.
// 
// \note           Supported GeneralName types, as defined in RFC 5280:
// "rfc822Name", "dnsName", "directoryName",
// "uniformResourceIdentifier" and "hardware_module_name"
// of type "otherName", as defined in RFC 4108.
// 
// \note           This function should be called on a single raw data of
// subject alternative name. For example, after successful
// certificate parsing, one must iterate on every item in the
// \c crt->subject_alt_names sequence, and pass it to
// this function.
// 
// \warning        The target structure contains pointers to the raw data of the
// parsed certificate, and its lifetime is restricted by the
// lifetime of the certificate.
// 
// \return         \c 0 on success
// \return         #MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE for an unsupported
// SAN type.
// \return         Another negative value for any other failure.
pub extern external/mbedtls-x509-parse-subject-alt-name(^san-buf: c-pointer<mbedtls-asn1-buf-c>, ^san: c-pointer<mbedtls-x509-subject-alternative-name-c>): int32
  c inline "(int)mbedtls_x509_parse_subject_alt_name((mbedtls_x509_buf*)#1, (struct mbedtls_x509_subject_alternative_name*)#2)"

pub inline fun ffi/mbedtls-x509-parse-subject-alt-name(^san-buf: c-pointer<mbedtls-asn1-buf-c>, ^san: c-pointer<mbedtls-x509-subject-alternative-name-c>): <> int
  external/mbedtls-x509-parse-subject-alt-name(san-buf, san).int

// \brief          Unallocate all data related to subject alternative name
// 
// \param san      SAN structure - extra memory owned by this structure will be freed
pub extern external/mbedtls-x509-free-subject-alt-name(^san: c-pointer<mbedtls-x509-subject-alternative-name-c>): ()
  c inline "(void)mbedtls_x509_free_subject_alt_name((struct mbedtls_x509_subject_alternative_name*)#1)"

// \brief          This function parses a CN string as an IP address.
// 
// \param cn       The CN string to parse. CN string MUST be null-terminated.
// \param dst      The target buffer to populate with the binary IP address.
// The buffer MUST be 16 bytes to save IPv6, and should be
// 4-byte aligned if the result will be used as struct in_addr.
// e.g. uint32_t dst[4]
// 
// \note           \p cn is parsed as an IPv6 address if string contains ':',
// else \p cn is parsed as an IPv4 address.
// 
// \return         Length of binary IP address; num bytes written to target.
// \return         \c 0 on failure to parse CN string as an IP address.
pub extern external/mbedtls-x509-crt-parse-cn-inet-pton(^cn: c-pointer<int>, ^dst: c-pointer<()>): ssize_t
  c inline "(size_t)mbedtls_x509_crt_parse_cn_inet_pton((char*)#1, (void*)#2)"

pub inline fun ffi/mbedtls-x509-crt-parse-cn-inet-pton(^cn: c-pointer<int>, ^dst: c-pointer<()>): <> int
  external/mbedtls-x509-crt-parse-cn-inet-pton(cn, dst).int

// \brief          Parse a DER-encoded CRL and append it to the chained list
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    points to the start of the chain
// \param buf      buffer holding the CRL data in DER format
// \param buflen   size of the buffer
// (including the terminating null byte for PEM data)
// 
// \return         0 if successful, or a specific X509 or PEM error code
pub extern external/mbedtls-x509-crl-parse-der(^chain: c-pointer<mbedtls-x509-crl-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_crl_parse_der((struct mbedtls_x509_crl*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-crl-parse-der(^chain: c-pointer<mbedtls-x509-crl-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-crl-parse-der(chain, buf, buflen.ssize_t).int

// \brief          Parse one or more CRLs and append them to the chained list
// 
// \note           Multiple CRLs are accepted only if using PEM format
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    points to the start of the chain
// \param buf      buffer holding the CRL data in PEM or DER format
// \param buflen   size of the buffer
// (including the terminating null byte for PEM data)
// 
// \return         0 if successful, or a specific X509 or PEM error code
pub extern external/mbedtls-x509-crl-parse(^chain: c-pointer<mbedtls-x509-crl-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_crl_parse((struct mbedtls_x509_crl*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-crl-parse(^chain: c-pointer<mbedtls-x509-crl-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-crl-parse(chain, buf, buflen.ssize_t).int

// \brief          Load one or more CRLs and append them to the chained list
// 
// \note           Multiple CRLs are accepted only if using PEM format
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    points to the start of the chain
// \param path     filename to read the CRLs from (in PEM or DER encoding)
// 
// \return         0 if successful, or a specific X509 or PEM error code
pub extern external/mbedtls-x509-crl-parse-file(^chain: c-pointer<mbedtls-x509-crl-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_x509_crl_parse_file((struct mbedtls_x509_crl*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509-crl-parse-file(^chain: c-pointer<mbedtls-x509-crl-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-x509-crl-parse-file(chain, path).int

// \brief          Returns an informational string about the CRL.
// 
// \param buf      Buffer to write to
// \param size     Maximum size of buffer
// \param prefix   A line prefix
// \param crl      The X509 CRL to represent
// 
// \return         The length of the string written (not including the
// terminated nul byte), or a negative error code.
pub extern external/mbedtls-x509-crl-info(^buf: c-pointer<int>, ^size: ssize_t, ^prefix: c-pointer<int>, ^crl: c-pointer<mbedtls-x509-crl-c>): int32
  c inline "(int)mbedtls_x509_crl_info((char*)#1, (size_t)#2, (char*)#3, (struct mbedtls_x509_crl*)#4)"

pub inline fun ffi/mbedtls-x509-crl-info(^buf: c-pointer<int>, ^size: int, ^prefix: c-pointer<int>, ^crl: c-pointer<mbedtls-x509-crl-c>): <> int
  external/mbedtls-x509-crl-info(buf, size.ssize_t, prefix, crl).int

// \brief          Initialize a CRL (chain)
// 
// \param crl      CRL chain to initialize
pub extern external/mbedtls-x509-crl-init(^crl: c-pointer<mbedtls-x509-crl-c>): ()
  c inline "(void)mbedtls_x509_crl_init((struct mbedtls_x509_crl*)#1)"

// \brief          Unallocate all CRL data
// 
// \param crl      CRL chain to free
pub extern external/mbedtls-x509-crl-free(^crl: c-pointer<mbedtls-x509-crl-c>): ()
  c inline "(void)mbedtls_x509_crl_free((struct mbedtls_x509_crl*)#1)"

// \brief           Set Subject Alternative Name
// 
// \param ctx       Certificate context to use
// \param san_list  List of SAN values
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
// 
// \note            "dnsName", "uniformResourceIdentifier", "IP address",
// "otherName", and "DirectoryName", as defined in RFC 5280,
// are supported.
pub extern external/mbedtls-x509write-crt-set-subject-alternative-name(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^san-list: c-pointer<mbedtls-x509-san-list-c>): int32
  c inline "(int)mbedtls_x509write_crt_set_subject_alternative_name((struct mbedtls_x509write_cert*)#1, (struct mbedtls_x509_san_list*)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-subject-alternative-name(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^san-list: c-pointer<mbedtls-x509-san-list-c>): <> int
  external/mbedtls-x509write-crt-set-subject-alternative-name(ctx1, san-list).int

// \brief          Parse a single DER formatted certificate and add it
// to the end of the provided chained list.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    The pointer to the start of the CRT chain to attach to.
// When parsing the first CRT in a chain, this should point
// to an instance of ::mbedtls_x509_crt initialized through
// mbedtls_x509_crt_init().
// \param buf      The buffer holding the DER encoded certificate.
// \param buflen   The size in Bytes of \p buf.
// 
// \note           This function makes an internal copy of the CRT buffer
// \p buf. In particular, \p buf may be destroyed or reused
// after this call returns. To avoid duplicating the CRT
// buffer (at the cost of stricter lifetime constraints),
// use mbedtls_x509_crt_parse_der_nocopy() instead.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-x509-crt-parse-der(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_crt_parse_der((struct mbedtls_x509_crt*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-crt-parse-der(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-crt-parse-der(chain, buf, buflen.ssize_t).int

// \brief            Parse a single DER formatted certificate and add it
// to the end of the provided chained list.
// 
// \note             If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain      The pointer to the start of the CRT chain to attach to.
// When parsing the first CRT in a chain, this should point
// to an instance of ::mbedtls_x509_crt initialized through
// mbedtls_x509_crt_init().
// \param buf        The buffer holding the DER encoded certificate.
// \param buflen     The size in Bytes of \p buf.
// \param make_copy  When not zero this function makes an internal copy of the
// CRT buffer \p buf. In particular, \p buf may be destroyed
// or reused after this call returns.
// When zero this function avoids duplicating the CRT buffer
// by taking temporary ownership thereof until the CRT
// is destroyed (like mbedtls_x509_crt_parse_der_nocopy())
// \param cb         A callback invoked for every unsupported certificate
// extension.
// \param p_ctx      An opaque context passed to the callback.
// 
// \note             This call is functionally equivalent to
// mbedtls_x509_crt_parse_der(), and/or
// mbedtls_x509_crt_parse_der_nocopy()
// but it calls the callback with every unsupported
// certificate extension and additionally the
// "certificate policies" extension if it contains any
// unsupported certificate policies.
// The callback must return a negative error code if it
// does not know how to handle such an extension.
// When the callback fails to parse a critical extension
// mbedtls_x509_crt_parse_der_with_ext_cb() also fails.
// When the callback fails to parse a non critical extension
// mbedtls_x509_crt_parse_der_with_ext_cb() simply skips
// the extension and continues parsing.
// Future versions of the library may invoke the callback
// in other cases, if and when the need arises.
// 
// \return           \c 0 if successful.
// \return           A negative error code on failure.
pub extern external/mbedtls-x509-crt-parse-der-with-ext-cb(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: ssize_t, ^make-copy: int32, ^cb: c-pointer<intptr_t>, ^p-ctx: c-pointer<()>): int32
  c inline "(int)mbedtls_x509_crt_parse_der_with_ext_cb((struct mbedtls_x509_crt*)#1, (unsigned char*)#2, (size_t)#3, (int)#4, (mbedtls_x509_crt_ext_cb_t)#5, (void*)#6)"

pub inline fun ffi/mbedtls-x509-crt-parse-der-with-ext-cb(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: int, ^make-copy: int, ^cb: mbedtls-x509-crt-ext-cb-t, ^p-ctx: c-pointer<()>): <> int
  external/mbedtls-x509-crt-parse-der-with-ext-cb(chain, buf, buflen.ssize_t, make-copy.int32, cb, p-ctx).int

// \brief          Parse a single DER formatted certificate and add it
// to the end of the provided chained list. This is a
// variant of mbedtls_x509_crt_parse_der() which takes
// temporary ownership of the CRT buffer until the CRT
// is destroyed.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    The pointer to the start of the CRT chain to attach to.
// When parsing the first CRT in a chain, this should point
// to an instance of ::mbedtls_x509_crt initialized through
// mbedtls_x509_crt_init().
// \param buf      The address of the readable buffer holding the DER encoded
// certificate to use. On success, this buffer must be
// retained and not be changed for the lifetime of the
// CRT chain \p chain, that is, until \p chain is destroyed
// through a call to mbedtls_x509_crt_free().
// \param buflen   The size in Bytes of \p buf.
// 
// \note           This call is functionally equivalent to
// mbedtls_x509_crt_parse_der(), but it avoids creating a
// copy of the input buffer at the cost of stronger lifetime
// constraints. This is useful in constrained environments
// where duplication of the CRT cannot be tolerated.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-x509-crt-parse-der-nocopy(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_crt_parse_der_nocopy((struct mbedtls_x509_crt*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-crt-parse-der-nocopy(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-crt-parse-der-nocopy(chain, buf, buflen.ssize_t).int

// \brief          Parse one DER-encoded or one or more concatenated PEM-encoded
// certificates and add them to the chained list.
// 
// For CRTs in PEM encoding, the function parses permissively:
// if at least one certificate can be parsed, the function
// returns the number of certificates for which parsing failed
// (hence \c 0 if all certificates were parsed successfully).
// If no certificate could be parsed, the function returns
// the first (negative) error encountered during parsing.
// 
// PEM encoded certificates may be interleaved by other data
// such as human readable descriptions of their content, as
// long as the certificates are enclosed in the PEM specific
// '-----{BEGIN/END} CERTIFICATE-----' delimiters.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    The chain to which to add the parsed certificates.
// \param buf      The buffer holding the certificate data in PEM or DER format.
// For certificates in PEM encoding, this may be a concatenation
// of multiple certificates; for DER encoding, the buffer must
// comprise exactly one certificate.
// \param buflen   The size of \p buf, including the terminating \c NULL byte
// in case of PEM encoded data.
// 
// \return         \c 0 if all certificates were parsed successfully.
// \return         The (positive) number of certificates that couldn't
// be parsed if parsing was partly successful (see above).
// \return         A negative X509 or PEM error code otherwise.
pub extern external/mbedtls-x509-crt-parse(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_crt_parse((struct mbedtls_x509_crt*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-crt-parse(^chain: c-pointer<mbedtls-x509-crt-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-crt-parse(chain, buf, buflen.ssize_t).int

// \brief          Load one or more certificates and add them
// to the chained list. Parses permissively. If some
// certificates can be parsed, the result is the number
// of failed certificates it encountered. If none complete
// correctly, the first error is returned.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param chain    points to the start of the chain
// \param path     filename to read the certificates from
// 
// \return         0 if all certificates parsed successfully, a positive number
// if partly successful or a specific X509 or PEM error code
pub extern external/mbedtls-x509-crt-parse-file(^chain: c-pointer<mbedtls-x509-crt-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_x509_crt_parse_file((struct mbedtls_x509_crt*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509-crt-parse-file(^chain: c-pointer<mbedtls-x509-crt-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-x509-crt-parse-file(chain, path).int

// \brief          Load one or more certificate files from a path and add them
// to the chained list. Parses permissively. If some
// certificates can be parsed, the result is the number
// of failed certificates it encountered. If none complete
// correctly, the first error is returned.
// 
// \param chain    points to the start of the chain
// \param path     directory / folder to read the certificate files from
// 
// \return         0 if all certificates parsed successfully, a positive number
// if partly successful or a specific X509 or PEM error code
pub extern external/mbedtls-x509-crt-parse-path(^chain: c-pointer<mbedtls-x509-crt-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_x509_crt_parse_path((struct mbedtls_x509_crt*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509-crt-parse-path(^chain: c-pointer<mbedtls-x509-crt-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-x509-crt-parse-path(chain, path).int

// \brief          Returns an informational string about the
// certificate.
// 
// \param buf      Buffer to write to
// \param size     Maximum size of buffer
// \param prefix   A line prefix
// \param crt      The X509 certificate to represent
// 
// \return         The length of the string written (not including the
// terminated nul byte), or a negative error code.
pub extern external/mbedtls-x509-crt-info(^buf: c-pointer<int>, ^size: ssize_t, ^prefix: c-pointer<int>, ^crt: c-pointer<mbedtls-x509-crt-c>): int32
  c inline "(int)mbedtls_x509_crt_info((char*)#1, (size_t)#2, (char*)#3, (struct mbedtls_x509_crt*)#4)"

pub inline fun ffi/mbedtls-x509-crt-info(^buf: c-pointer<int>, ^size: int, ^prefix: c-pointer<int>, ^crt: c-pointer<mbedtls-x509-crt-c>): <> int
  external/mbedtls-x509-crt-info(buf, size.ssize_t, prefix, crt).int

// \brief          Returns an informational string about the
// verification status of a certificate.
// 
// \param buf      Buffer to write to
// \param size     Maximum size of buffer
// \param prefix   A line prefix
// \param flags    Verification flags created by mbedtls_x509_crt_verify()
// 
// \return         The length of the string written (not including the
// terminated nul byte), or a negative error code.
pub extern external/mbedtls-x509-crt-verify-info(^buf: c-pointer<int>, ^size: ssize_t, ^prefix: c-pointer<int>, ^flags: int32): int32
  c inline "(int)mbedtls_x509_crt_verify_info((char*)#1, (size_t)#2, (char*)#3, (int32_t)#4)"

pub inline fun ffi/mbedtls-x509-crt-verify-info(^buf: c-pointer<int>, ^size: int, ^prefix: c-pointer<int>, ^flags: int): <> int
  external/mbedtls-x509-crt-verify-info(buf, size.ssize_t, prefix, flags.int32).int

// \brief          Verify a chain of certificates.
// 
// The verify callback is a user-supplied callback that
// can clear / modify / add flags for a certificate. If set,
// the verification callback is called for each
// certificate in the chain (from the trust-ca down to the
// presented crt). The parameters for the callback are:
// (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,
// int *flags). With the flags representing current flags for
// that specific certificate and the certificate depth from
// the bottom (Peer cert depth = 0).
// 
// All flags left after returning from the callback
// are also returned to the application. The function should
// return 0 for anything (including invalid certificates)
// other than fatal error, as a non-zero return code
// immediately aborts the verification process. For fatal
// errors, a specific error code should be used (different
// from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not
// be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR
// can be used if no better code is available.
// 
// \note           In case verification failed, the results can be displayed
// using \c mbedtls_x509_crt_verify_info()
// 
// \note           Same as \c mbedtls_x509_crt_verify_with_profile() with the
// default security profile.
// 
// \note           It is your responsibility to provide up-to-date CRLs for
// all trusted CAs. If no CRL is provided for the CA that was
// used to sign the certificate, CRL verification is skipped
// silently, that is *without* setting any flag.
// 
// \note           The \c trust_ca list can contain two types of certificates:
// (1) those of trusted root CAs, so that certificates
// chaining up to those CAs will be trusted, and (2)
// self-signed end-entity certificates to be trusted (for
// specific peers you know) - in that case, the self-signed
// certificate doesn't need to have the CA bit set.
// 
// \param crt      The certificate chain to be verified.
// \param trust_ca The list of trusted CAs.
// \param ca_crl   The list of CRLs for trusted CAs.
// \param cn       The expected Common Name. This will be checked to be
// present in the certificate's subjectAltNames extension or,
// if this extension is absent, as a CN component in its
// Subject name. DNS names and IP addresses are fully
// supported, while the URI subtype is partially supported:
// only exact matching, without any normalization procedures
// described in 7.4 of RFC5280, will result in a positive
// URI verification.
// This may be \c NULL if the CN need not be verified.
// \param flags    The address at which to store the result of the verification.
// If the verification couldn't be completed, the flag value is
// set to (uint32_t) -1.
// \param f_vrfy   The verification callback to use. See the documentation
// of mbedtls_x509_crt_verify() for more information.
// \param p_vrfy   The context to be passed to \p f_vrfy.
// 
// \return         \c 0 if the chain is valid with respect to the
// passed CN, CAs, CRLs and security profile.
// \return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the
// certificate chain verification failed. In this case,
// \c *flags will have one or more
// \c MBEDTLS_X509_BADCERT_XXX or \c MBEDTLS_X509_BADCRL_XXX
// flags set.
// \return         Another negative error code in case of a fatal error
// encountered during the verification process.
pub extern external/mbedtls-x509-crt-verify(^crt: c-pointer<mbedtls-x509-crt-c>, ^trust-ca: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>, ^cn: c-pointer<int>, ^flags: c-pointer<int>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>): int32
  c inline "(int)mbedtls_x509_crt_verify((struct mbedtls_x509_crt*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_x509_crl*)#3, (char*)#4, (int32_t*)#5, (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#6, (void*)#7)"

pub inline fun ffi/mbedtls-x509-crt-verify(^crt: c-pointer<mbedtls-x509-crt-c>, ^trust-ca: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>, ^cn: c-pointer<int>, ^flags: c-pointer<int>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>): <> int
  external/mbedtls-x509-crt-verify(crt, trust-ca, ca-crl, cn, flags, f-vrfy, p-vrfy).int

// \brief          Verify a chain of certificates with respect to
// a configurable security profile.
// 
// \note           Same as \c mbedtls_x509_crt_verify(), but with explicit
// security profile.
// 
// \note           The restrictions on keys (RSA minimum size, allowed curves
// for ECDSA) apply to all certificates: trusted root,
// intermediate CAs if any, and end entity certificate.
// 
// \param crt      The certificate chain to be verified.
// \param trust_ca The list of trusted CAs.
// \param ca_crl   The list of CRLs for trusted CAs.
// \param profile  The security profile to use for the verification.
// \param cn       The expected Common Name. This may be \c NULL if the
// CN need not be verified.
// \param flags    The address at which to store the result of the verification.
// If the verification couldn't be completed, the flag value is
// set to (uint32_t) -1.
// \param f_vrfy   The verification callback to use. See the documentation
// of mbedtls_x509_crt_verify() for more information.
// \param p_vrfy   The context to be passed to \p f_vrfy.
// 
// \return         \c 0 if the chain is valid with respect to the
// passed CN, CAs, CRLs and security profile.
// \return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the
// certificate chain verification failed. In this case,
// \c *flags will have one or more
// \c MBEDTLS_X509_BADCERT_XXX or \c MBEDTLS_X509_BADCRL_XXX
// flags set.
// \return         Another negative error code in case of a fatal error
// encountered during the verification process.
pub extern external/mbedtls-x509-crt-verify-with-profile(^crt: c-pointer<mbedtls-x509-crt-c>, ^trust-ca: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>, ^profile: c-pointer<mbedtls-x509-crt-profile-c>, ^cn: c-pointer<int>, ^flags: c-pointer<int>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>): int32
  c inline "(int)mbedtls_x509_crt_verify_with_profile((struct mbedtls_x509_crt*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_x509_crl*)#3, (struct mbedtls_x509_crt_profile*)#4, (char*)#5, (int32_t*)#6, (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#7, (void*)#8)"

pub inline fun ffi/mbedtls-x509-crt-verify-with-profile(^crt: c-pointer<mbedtls-x509-crt-c>, ^trust-ca: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>, ^profile: c-pointer<mbedtls-x509-crt-profile-c>, ^cn: c-pointer<int>, ^flags: c-pointer<int>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>): <> int
  external/mbedtls-x509-crt-verify-with-profile(crt, trust-ca, ca-crl, profile, cn, flags, f-vrfy, p-vrfy).int

// \brief          Restartable version of \c mbedtls_crt_verify_with_profile()
// 
// \note           Performs the same job as \c mbedtls_crt_verify_with_profile()
// but can return early and restart according to the limit
// set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
// 
// \param crt      The certificate chain to be verified.
// \param trust_ca The list of trusted CAs.
// \param ca_crl   The list of CRLs for trusted CAs.
// \param profile  The security profile to use for the verification.
// \param cn       The expected Common Name. This may be \c NULL if the
// CN need not be verified.
// \param flags    The address at which to store the result of the verification.
// If the verification couldn't be completed, the flag value is
// set to (uint32_t) -1.
// \param f_vrfy   The verification callback to use. See the documentation
// of mbedtls_x509_crt_verify() for more information.
// \param p_vrfy   The context to be passed to \p f_vrfy.
// \param rs_ctx   The restart context to use. This may be set to \c NULL
// to disable restartable ECC.
// 
// \return         See \c mbedtls_crt_verify_with_profile(), or
// \return         #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
pub extern external/mbedtls-x509-crt-verify-restartable(^crt: c-pointer<mbedtls-x509-crt-c>, ^trust-ca: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>, ^profile: c-pointer<mbedtls-x509-crt-profile-c>, ^cn: c-pointer<int>, ^flags: c-pointer<int>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-x509-crt-restart-ctx>): int32
  c inline "(int)mbedtls_x509_crt_verify_restartable((struct mbedtls_x509_crt*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_x509_crl*)#3, (struct mbedtls_x509_crt_profile*)#4, (char*)#5, (int32_t*)#6, (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#7, (void*)#8, (mbedtls_x509_crt_restart_ctx*)#9)"

pub inline fun ffi/mbedtls-x509-crt-verify-restartable(^crt: c-pointer<mbedtls-x509-crt-c>, ^trust-ca: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>, ^profile: c-pointer<mbedtls-x509-crt-profile-c>, ^cn: c-pointer<int>, ^flags: c-pointer<int>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>, ^rs-ctx: c-pointer<mbedtls-x509-crt-restart-ctx>): <> int
  external/mbedtls-x509-crt-verify-restartable(crt, trust-ca, ca-crl, profile, cn, flags, f-vrfy, p-vrfy, rs-ctx).int

// \brief          Check usage of certificate against keyUsage extension.
// 
// \param crt      Leaf certificate used.
// \param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT
// before using the certificate to perform an RSA key
// exchange).
// 
// \note           Except for decipherOnly and encipherOnly, a bit set in the
// usage argument means this bit MUST be set in the
// certificate. For decipherOnly and encipherOnly, it means
// that bit MAY be set.
// 
// \return         0 is these uses of the certificate are allowed,
// MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension
// is present but does not match the usage argument.
// 
// \note           You should only call this function on leaf certificates, on
// (intermediate) CAs the keyUsage extension is automatically
// checked by \c mbedtls_x509_crt_verify().
pub extern external/mbedtls-x509-crt-check-key-usage(^crt: c-pointer<mbedtls-x509-crt-c>, ^usage: int32): int32
  c inline "(int)mbedtls_x509_crt_check_key_usage((struct mbedtls_x509_crt*)#1, (unsigned int)#2)"

pub inline fun ffi/mbedtls-x509-crt-check-key-usage(^crt: c-pointer<mbedtls-x509-crt-c>, ^usage: int): <> int
  external/mbedtls-x509-crt-check-key-usage(crt, usage.int32).int

// \brief           Check usage of certificate against extendedKeyUsage.
// 
// \param crt       Leaf certificate used.
// \param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or
// MBEDTLS_OID_CLIENT_AUTH).
// \param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE()).
// 
// \return          0 if this use of the certificate is allowed,
// MBEDTLS_ERR_X509_BAD_INPUT_DATA if not.
// 
// \note            Usually only makes sense on leaf certificates.
pub extern external/mbedtls-x509-crt-check-extended-key-usage(^crt: c-pointer<mbedtls-x509-crt-c>, ^usage-oid: c-pointer<int>, ^usage-len: ssize_t): int32
  c inline "(int)mbedtls_x509_crt_check_extended_key_usage((struct mbedtls_x509_crt*)#1, (char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-crt-check-extended-key-usage(^crt: c-pointer<mbedtls-x509-crt-c>, ^usage-oid: c-pointer<int>, ^usage-len: int): <> int
  external/mbedtls-x509-crt-check-extended-key-usage(crt, usage-oid, usage-len.ssize_t).int

// \brief          Verify the certificate revocation status
// 
// \param crt      a certificate to be verified
// \param crl      the CRL to verify against
// 
// \return         1 if the certificate is revoked, 0 otherwise
pub extern external/mbedtls-x509-crt-is-revoked(^crt: c-pointer<mbedtls-x509-crt-c>, ^crl: c-pointer<mbedtls-x509-crl-c>): int32
  c inline "(int)mbedtls_x509_crt_is_revoked((struct mbedtls_x509_crt*)#1, (struct mbedtls_x509_crl*)#2)"

pub inline fun ffi/mbedtls-x509-crt-is-revoked(^crt: c-pointer<mbedtls-x509-crt-c>, ^crl: c-pointer<mbedtls-x509-crl-c>): <> int
  external/mbedtls-x509-crt-is-revoked(crt, crl).int

// \brief          Initialize a certificate (chain)
// 
// \param crt      Certificate chain to initialize
pub extern external/mbedtls-x509-crt-init(^crt: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "(void)mbedtls_x509_crt_init((struct mbedtls_x509_crt*)#1)"

// \brief          Unallocate all certificate data
// 
// \param crt      Certificate chain to free
pub extern external/mbedtls-x509-crt-free(^crt: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "(void)mbedtls_x509_crt_free((struct mbedtls_x509_crt*)#1)"

// \brief               Access the ca_istrue field
// 
// \param[in] crt       Certificate to be queried, must not be \c NULL
// 
// \return              \c 1 if this a CA certificate \c 0 otherwise.
// \return              MBEDTLS_ERR_X509_INVALID_EXTENSIONS if the certificate does not contain
// the Optional Basic Constraint extension.
pub extern external/mbedtls-x509-crt-get-ca-istrue(^crt: c-pointer<mbedtls-x509-crt-c>): int32
  c inline "(int)mbedtls_x509_crt_get_ca_istrue((struct mbedtls_x509_crt*)#1)"

pub inline fun ffi/mbedtls-x509-crt-get-ca-istrue(^crt: c-pointer<mbedtls-x509-crt-c>): <> int
  external/mbedtls-x509-crt-get-ca-istrue(crt).int

// \brief           Initialize a CRT writing context
// 
// \param ctx       CRT context to initialize
pub extern external/mbedtls-x509write-crt-init(^ctx1: c-pointer<mbedtls-x509write-cert-c>): ()
  c inline "(void)mbedtls_x509write_crt_init((struct mbedtls_x509write_cert*)#1)"

// \brief           Set the version for a Certificate
// Default: MBEDTLS_X509_CRT_VERSION_3
// 
// \param ctx       CRT context to use
// \param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or
// MBEDTLS_X509_CRT_VERSION_3)
pub extern external/mbedtls-x509write-crt-set-version(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^version: int32): ()
  c inline "(void)mbedtls_x509write_crt_set_version((struct mbedtls_x509write_cert*)#1, (int)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-version(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^version: int): <> ()
  external/mbedtls-x509write-crt-set-version(ctx1, version.int32)

// \brief           Set the serial number for a Certificate.
// 
// \deprecated      This function is deprecated and will be removed in a
// future version of the library. Please use
// mbedtls_x509write_crt_set_serial_raw() instead.
// 
// \note            Even though the MBEDTLS_BIGNUM_C guard looks redundant since
// X509 depends on PK and PK depends on BIGNUM, this emphasizes
// a direct dependency between X509 and BIGNUM which is going
// to be deprecated in the future.
// 
// \param ctx       CRT context to use
// \param serial    serial number to set
// 
// \return          0 if successful
pub extern external/mbedtls-x509write-crt-set-serial(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^serial: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_x509write_crt_set_serial((struct mbedtls_x509write_cert*)#1, (struct mbedtls_mpi*)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-serial(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^serial: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-x509write-crt-set-serial(ctx1, serial).int

// \brief           Set the serial number for a Certificate.
// 
// \param ctx          CRT context to use
// \param serial       A raw array of bytes containing the serial number in big
// endian format
// \param serial_len   Length of valid bytes (expressed in bytes) in \p serial
// input buffer
// 
// \return          0 if successful, or
// MBEDTLS_ERR_X509_BAD_INPUT_DATA if the provided input buffer
// is too big (longer than MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN)
pub extern external/mbedtls-x509write-crt-set-serial-raw(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^serial: c-pointer<int>, ^serial-len: ssize_t): int32
  c inline "(int)mbedtls_x509write_crt_set_serial_raw((struct mbedtls_x509write_cert*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509write-crt-set-serial-raw(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^serial: c-pointer<int>, ^serial-len: int): <> int
  external/mbedtls-x509write-crt-set-serial-raw(ctx1, serial, serial-len.ssize_t).int

// \brief           Set the validity period for a Certificate
// Timestamps should be in string format for UTC timezone
// i.e. "YYYYMMDDhhmmss"
// e.g. "20131231235959" for December 31st 2013
// at 23:59:59
// 
// \param ctx       CRT context to use
// \param not_before    not_before timestamp
// \param not_after     not_after timestamp
// 
// \return          0 if timestamp was parsed successfully, or
// a specific error code
pub extern external/mbedtls-x509write-crt-set-validity(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^not-before: c-pointer<int>, ^not-after: c-pointer<int>): int32
  c inline "(int)mbedtls_x509write_crt_set_validity((struct mbedtls_x509write_cert*)#1, (char*)#2, (char*)#3)"

pub inline fun ffi/mbedtls-x509write-crt-set-validity(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^not-before: c-pointer<int>, ^not-after: c-pointer<int>): <> int
  external/mbedtls-x509write-crt-set-validity(ctx1, not-before, not-after).int

// \brief           Set the issuer name for a Certificate
// Issuer names should contain a comma-separated list
// of OID types and values:
// e.g. "C=UK,O=ARM,CN=Mbed TLS CA"
// 
// \param ctx           CRT context to use
// \param issuer_name   issuer name to set
// 
// \return          0 if issuer name was parsed successfully, or
// a specific error code
pub extern external/mbedtls-x509write-crt-set-issuer-name(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^issuer-name: c-pointer<int>): int32
  c inline "(int)mbedtls_x509write_crt_set_issuer_name((struct mbedtls_x509write_cert*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-issuer-name(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^issuer-name: c-pointer<int>): <> int
  external/mbedtls-x509write-crt-set-issuer-name(ctx1, issuer-name).int

// \brief           Set the subject name for a Certificate
// Subject names should contain a comma-separated list
// of OID types and values:
// e.g. "C=UK,O=ARM,CN=Mbed TLS Server 1"
// 
// \param ctx           CRT context to use
// \param subject_name  subject name to set
// 
// \return          0 if subject name was parsed successfully, or
// a specific error code
pub extern external/mbedtls-x509write-crt-set-subject-name(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^subject-name: c-pointer<int>): int32
  c inline "(int)mbedtls_x509write_crt_set_subject_name((struct mbedtls_x509write_cert*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-subject-name(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^subject-name: c-pointer<int>): <> int
  external/mbedtls-x509write-crt-set-subject-name(ctx1, subject-name).int

// \brief           Set the subject public key for the certificate
// 
// \param ctx       CRT context to use
// \param key       public key to include
pub extern external/mbedtls-x509write-crt-set-subject-key(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^key: c-pointer<mbedtls-pk-context-c>): ()
  c inline "(void)mbedtls_x509write_crt_set_subject_key((struct mbedtls_x509write_cert*)#1, (struct mbedtls_pk_context*)#2)"

// \brief           Set the issuer key used for signing the certificate
// 
// \param ctx       CRT context to use
// \param key       private key to sign with
pub extern external/mbedtls-x509write-crt-set-issuer-key(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^key: c-pointer<mbedtls-pk-context-c>): ()
  c inline "(void)mbedtls_x509write_crt_set_issuer_key((struct mbedtls_x509write_cert*)#1, (struct mbedtls_pk_context*)#2)"

// \brief           Set the MD algorithm to use for the signature
// (e.g. MBEDTLS_MD_SHA1)
// 
// \param ctx       CRT context to use
// \param md_alg    MD algorithm to use
pub extern external/mbedtls-x509write-crt-set-md-alg(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^md-alg: int32): ()
  c inline "(void)mbedtls_x509write_crt_set_md_alg((struct mbedtls_x509write_cert*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-md-alg(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^md-alg: mbedtls-md-type-t): <exn> ()
  external/mbedtls-x509write-crt-set-md-alg(ctx1, md-alg.mbedtls-md-type-t/int)

// \brief           Generic function to add to or replace an extension in the
// CRT
// 
// \param ctx       CRT context to use
// \param oid       OID of the extension
// \param oid_len   length of the OID
// \param critical  if the extension is critical (per the RFC's definition)
// \param val       value of the extension OCTET STRING
// \param val_len   length of the value data
// 
// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-extension(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^oid: c-pointer<int>, ^oid-len: ssize_t, ^critical: int32, ^val: c-pointer<int>, ^val-len: ssize_t): int32
  c inline "(int)mbedtls_x509write_crt_set_extension((struct mbedtls_x509write_cert*)#1, (char*)#2, (size_t)#3, (int)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-x509write-crt-set-extension(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^oid: c-pointer<int>, ^oid-len: int, ^critical: int, ^val: c-pointer<int>, ^val-len: int): <> int
  external/mbedtls-x509write-crt-set-extension(ctx1, oid, oid-len.ssize_t, critical.int32, val, val-len.ssize_t).int

// \brief           Set the basicConstraints extension for a CRT
// 
// \param ctx       CRT context to use
// \param is_ca     is this a CA certificate
// \param max_pathlen   maximum length of certificate chains below this
// certificate (only for CA certificates, -1 is
// unlimited)
// 
// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-basic-constraints(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^is-ca: int32, ^max-pathlen: int32): int32
  c inline "(int)mbedtls_x509write_crt_set_basic_constraints((struct mbedtls_x509write_cert*)#1, (int)#2, (int)#3)"

pub inline fun ffi/mbedtls-x509write-crt-set-basic-constraints(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^is-ca: int, ^max-pathlen: int): <> int
  external/mbedtls-x509write-crt-set-basic-constraints(ctx1, is-ca.int32, max-pathlen.int32).int

// \brief           Set the subjectKeyIdentifier extension for a CRT
// Requires that mbedtls_x509write_crt_set_subject_key() has been
// called before
// 
// \param ctx       CRT context to use
// 
// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-subject-key-identifier(^ctx1: c-pointer<mbedtls-x509write-cert-c>): int32
  c inline "(int)mbedtls_x509write_crt_set_subject_key_identifier((struct mbedtls_x509write_cert*)#1)"

pub inline fun ffi/mbedtls-x509write-crt-set-subject-key-identifier(^ctx1: c-pointer<mbedtls-x509write-cert-c>): <> int
  external/mbedtls-x509write-crt-set-subject-key-identifier(ctx1).int

// \brief           Set the authorityKeyIdentifier extension for a CRT
// Requires that mbedtls_x509write_crt_set_issuer_key() has been
// called before
// 
// \param ctx       CRT context to use
// 
// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-authority-key-identifier(^ctx1: c-pointer<mbedtls-x509write-cert-c>): int32
  c inline "(int)mbedtls_x509write_crt_set_authority_key_identifier((struct mbedtls_x509write_cert*)#1)"

pub inline fun ffi/mbedtls-x509write-crt-set-authority-key-identifier(^ctx1: c-pointer<mbedtls-x509write-cert-c>): <> int
  external/mbedtls-x509write-crt-set-authority-key-identifier(ctx1).int

// \brief           Set the Key Usage Extension flags
// (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)
// 
// \param ctx       CRT context to use
// \param key_usage key usage flags to set
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-key-usage(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^key-usage: int32): int32
  c inline "(int)mbedtls_x509write_crt_set_key_usage((struct mbedtls_x509write_cert*)#1, (unsigned int)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-key-usage(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^key-usage: int): <> int
  external/mbedtls-x509write-crt-set-key-usage(ctx1, key-usage.int32).int

// \brief           Set the Extended Key Usage Extension
// (e.g. MBEDTLS_OID_SERVER_AUTH)
// 
// \param ctx       CRT context to use
// \param exts      extended key usage extensions to set, a sequence of
// MBEDTLS_ASN1_OID objects
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-ext-key-usage(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^exts: c-pointer<mbedtls-asn1-sequence-c>): int32
  c inline "(int)mbedtls_x509write_crt_set_ext_key_usage((struct mbedtls_x509write_cert*)#1, (struct mbedtls_asn1_sequence*)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-ext-key-usage(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^exts: c-pointer<mbedtls-asn1-sequence-c>): <> int
  external/mbedtls-x509write-crt-set-ext-key-usage(ctx1, exts).int

// \brief           Set the Netscape Cert Type flags
// (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)
// 
// \param ctx           CRT context to use
// \param ns_cert_type  Netscape Cert Type flags to set
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-crt-set-ns-cert-type(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^ns-cert-type: int8): int32
  c inline "(int)mbedtls_x509write_crt_set_ns_cert_type((struct mbedtls_x509write_cert*)#1, (unsigned char)#2)"

pub inline fun ffi/mbedtls-x509write-crt-set-ns-cert-type(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^ns-cert-type: int): <> int
  external/mbedtls-x509write-crt-set-ns-cert-type(ctx1, ns-cert-type.int8).int

// \brief           Free the contents of a CRT write context
// 
// \param ctx       CRT context to free
pub extern external/mbedtls-x509write-crt-free(^ctx1: c-pointer<mbedtls-x509write-cert-c>): ()
  c inline "(void)mbedtls_x509write_crt_free((struct mbedtls_x509write_cert*)#1)"

// \brief           Write a built up certificate to a X509 DER structure
// Note: data is written at the end of the buffer! Use the
// return value to determine where you should start
// using the buffer
// 
// \param ctx       certificate to write away
// \param buf       buffer to write to
// \param size      size of the buffer
// \param f_rng     RNG function. This must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \return          length of data written if successful, or a specific
// error code
// 
// \note            \p f_rng is used for the signature operation.
pub extern external/mbedtls-x509write-crt-der(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^buf: c-pointer<int>, ^size: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_x509write_crt_der((struct mbedtls_x509write_cert*)#1, (unsigned char*)#2, (size_t)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-x509write-crt-der(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^buf: c-pointer<int>, ^size: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-x509write-crt-der(ctx1, buf, size.ssize_t, f-rng, p-rng).int

// \brief           Write a built up certificate to a X509 PEM string
// 
// \param ctx       certificate to write away
// \param buf       buffer to write to
// \param size      size of the buffer
// \param f_rng     RNG function. This must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \return          0 if successful, or a specific error code
// 
// \note            \p f_rng is used for the signature operation.
pub extern external/mbedtls-x509write-crt-pem(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^buf: c-pointer<int>, ^size: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_x509write_crt_pem((struct mbedtls_x509write_cert*)#1, (unsigned char*)#2, (size_t)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-x509write-crt-pem(^ctx1: c-pointer<mbedtls-x509write-cert-c>, ^buf: c-pointer<int>, ^size: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-x509write-crt-pem(ctx1, buf, size.ssize_t, f-rng, p-rng).int

// \brief          This function initializes the DHM context.
// 
// \param ctx      The DHM context to initialize.
pub extern external/mbedtls-dhm-init(^ctx1: c-pointer<mbedtls-dhm-context-c>): ()
  c inline "(void)mbedtls_dhm_init((struct mbedtls_dhm_context*)#1)"

// \brief          This function parses the DHM parameters in a
// TLS ServerKeyExchange handshake message
// (DHM modulus, generator, and public key).
// 
// \note           In a TLS handshake, this is the how the client
// sets up its DHM context from the server's public
// DHM key material.
// 
// \param ctx      The DHM context to use. This must be initialized.
// \param p        On input, *p must be the start of the input buffer.
// On output, *p is updated to point to the end of the data
// that has been read. On success, this is the first byte
// past the end of the ServerKeyExchange parameters.
// On error, this is the point at which an error has been
// detected, which is usually not useful except to debug
// failures.
// \param end      The end of the input buffer.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
pub extern external/mbedtls-dhm-read-params(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>): int32
  c inline "(int)mbedtls_dhm_read_params((struct mbedtls_dhm_context*)#1, (unsigned char**)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-dhm-read-params(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^p: c-pointer<c-pointer<int>>, ^end: c-pointer<int>): <> int
  external/mbedtls-dhm-read-params(ctx1, p, end).int

// \brief          This function generates a DHM key pair and exports its
// public part together with the DHM parameters in the format
// used in a TLS ServerKeyExchange handshake message.
// 
// \note           This function assumes that the DHM parameters \c ctx->P
// and \c ctx->G have already been properly set. For that, use
// mbedtls_dhm_set_group() below in conjunction with
// mbedtls_mpi_read_binary() and mbedtls_mpi_read_string().
// 
// \note           In a TLS handshake, this is the how the server generates
// and exports its DHM key material.
// 
// \param ctx      The DHM context to use. This must be initialized
// and have the DHM parameters set. It may or may not
// already have imported the peer's public key.
// \param x_size   The private key size in Bytes.
// \param olen     The address at which to store the number of Bytes
// written on success. This must not be \c NULL.
// \param output   The destination buffer. This must be a writable buffer of
// sufficient size to hold the reduced binary presentation of
// the modulus, the generator and the public key, each wrapped
// with a 2-byte length field. It is the responsibility of the
// caller to ensure that enough space is available. Refer to
// mbedtls_mpi_size() to computing the byte-size of an MPI.
// \param f_rng    The RNG function. Must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context parameter.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
pub extern external/mbedtls-dhm-make-params(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^x-size: int32, ^output: c-pointer<int>, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_dhm_make_params((struct mbedtls_dhm_context*)#1, (int)#2, (unsigned char*)#3, (size_t*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-dhm-make-params(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^x-size: int, ^output: c-pointer<int>, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-dhm-make-params(ctx1, x-size.int32, output, olen, f-rng, p-rng).int

// \brief          This function sets the prime modulus and generator.
// 
// \note           This function can be used to set \c ctx->P, \c ctx->G
// in preparation for mbedtls_dhm_make_params().
// 
// \param ctx      The DHM context to configure. This must be initialized.
// \param P        The MPI holding the DHM prime modulus. This must be
// an initialized MPI.
// \param G        The MPI holding the DHM generator. This must be an
// initialized MPI.
// 
// \return         \c 0 if successful.
// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
pub extern external/mbedtls-dhm-set-group(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^p: c-pointer<mbedtls-mpi-c>, ^g: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_dhm_set_group((struct mbedtls_dhm_context*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-dhm-set-group(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^p: c-pointer<mbedtls-mpi-c>, ^g: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-dhm-set-group(ctx1, p, g).int

// \brief          This function imports the raw public value of the peer.
// 
// \note           In a TLS handshake, this is the how the server imports
// the Client's public DHM key.
// 
// \param ctx      The DHM context to use. This must be initialized and have
// its DHM parameters set, e.g. via mbedtls_dhm_set_group().
// It may or may not already have generated its own private key.
// \param input    The input buffer containing the \c G^Y value of the peer.
// This must be a readable buffer of size \p ilen Bytes.
// \param ilen     The size of the input buffer \p input in Bytes.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
pub extern external/mbedtls-dhm-read-public(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^input: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_dhm_read_public((struct mbedtls_dhm_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-dhm-read-public(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^input: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-dhm-read-public(ctx1, input, ilen.ssize_t).int

// \brief          This function creates a DHM key pair and exports
// the raw public key in big-endian format.
// 
// \note           The destination buffer is always fully written
// so as to contain a big-endian representation of G^X mod P.
// If it is larger than \c ctx->len, it is padded accordingly
// with zero-bytes at the beginning.
// 
// \param ctx      The DHM context to use. This must be initialized and
// have the DHM parameters set. It may or may not already
// have imported the peer's public key.
// \param x_size   The private key size in Bytes.
// \param output   The destination buffer. This must be a writable buffer of
// size \p olen Bytes.
// \param olen     The length of the destination buffer. This must be at least
// equal to `ctx->len` (the size of \c P).
// \param f_rng    The RNG function. This must not be \c NULL.
// \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL
// if \p f_rng doesn't need a context argument.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.
pub extern external/mbedtls-dhm-make-public(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^x-size: int32, ^output: c-pointer<int>, ^olen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_dhm_make_public((struct mbedtls_dhm_context*)#1, (int)#2, (unsigned char*)#3, (size_t)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-dhm-make-public(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^x-size: int, ^output: c-pointer<int>, ^olen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-dhm-make-public(ctx1, x-size.int32, output, olen.ssize_t, f-rng, p-rng).int

// \brief          This function derives and exports the shared secret
// \c (G^Y)^X mod \c P.
// 
// \note           If \p f_rng is not \c NULL, it is used to blind the input as
// a countermeasure against timing attacks. Blinding is used
// only if our private key \c X is re-used, and not used
// otherwise. We recommend always passing a non-NULL
// \p f_rng argument.
// 
// \param ctx           The DHM context to use. This must be initialized
// and have its own private key generated and the peer's
// public key imported.
// \param output        The buffer to write the generated shared key to. This
// must be a writable buffer of size \p output_size Bytes.
// \param output_size   The size of the destination buffer. This must be at
// least the size of \c ctx->len (the size of \c P).
// \param olen          On exit, holds the actual number of Bytes written.
// \param f_rng         The RNG function. Must not be \c NULL. Used for
// blinding.
// \param p_rng         The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng doesn't need a context parameter.
// 
// \return              \c 0 on success.
// \return              An \c MBEDTLS_ERR_DHM_XXX error code on failure.
pub extern external/mbedtls-dhm-calc-secret(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^output: c-pointer<int>, ^output-size: ssize_t, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_dhm_calc_secret((struct mbedtls_dhm_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-dhm-calc-secret(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^output: c-pointer<int>, ^output-size: int, ^olen: c-pointer<int>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-dhm-calc-secret(ctx1, output, output-size.ssize_t, olen, f-rng, p-rng).int

// \brief          This function returns the size of the prime modulus in bits.
// 
// \param ctx      The DHM context to query.
// 
// \return         The size of the prime modulus in bits,
// i.e. the number n such that 2^(n-1) <= P < 2^n.
pub extern external/mbedtls-dhm-get-bitlen(^ctx1: c-pointer<mbedtls-dhm-context-c>): ssize_t
  c inline "(size_t)mbedtls_dhm_get_bitlen((struct mbedtls_dhm_context*)#1)"

pub inline fun ffi/mbedtls-dhm-get-bitlen(^ctx1: c-pointer<mbedtls-dhm-context-c>): <> int
  external/mbedtls-dhm-get-bitlen(ctx1).int

// \brief          This function returns the size of the prime modulus in bytes.
// 
// \param ctx      The DHM context to query.
// 
// \return         The size of the prime modulus in bytes,
// i.e. the number n such that 2^(8*(n-1)) <= P < 2^(8*n).
pub extern external/mbedtls-dhm-get-len(^ctx1: c-pointer<mbedtls-dhm-context-c>): ssize_t
  c inline "(size_t)mbedtls_dhm_get_len((struct mbedtls_dhm_context*)#1)"

pub inline fun ffi/mbedtls-dhm-get-len(^ctx1: c-pointer<mbedtls-dhm-context-c>): <> int
  external/mbedtls-dhm-get-len(ctx1).int

// \brief          This function copies a parameter of a DHM key.
// 
// \param ctx      The DHM context to query.
// \param param    The parameter to copy.
// \param dest     The MPI object to copy the value into. It must be
// initialized.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_DHM_BAD_INPUT_DATA if \p param is invalid.
// \return         An \c MBEDTLS_ERR_MPI_XXX error code if the copy fails.
pub extern external/mbedtls-dhm-get-value(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^param: int32, ^dest: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_dhm_get_value((struct mbedtls_dhm_context*)#1, (int32_t)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-dhm-get-value(^ctx1: c-pointer<mbedtls-dhm-context-c>, ^param: mbedtls-dhm-parameter, ^dest: c-pointer<mbedtls-mpi-c>): <exn> int
  external/mbedtls-dhm-get-value(ctx1, param.mbedtls-dhm-parameter/int, dest).int

// \brief          This function frees and clears the components
// of a DHM context.
// 
// \param ctx      The DHM context to free and clear. This may be \c NULL,
// in which case this function is a no-op. If it is not \c NULL,
// it must point to an initialized DHM context.
pub extern external/mbedtls-dhm-free(^ctx1: c-pointer<mbedtls-dhm-context-c>): ()
  c inline "(void)mbedtls_dhm_free((struct mbedtls_dhm_context*)#1)"

// \brief             This function parses DHM parameters in PEM or DER format.
// 
// \param dhm         The DHM context to import the DHM parameters into.
// This must be initialized.
// \param dhmin       The input buffer. This must be a readable buffer of
// length \p dhminlen Bytes.
// \param dhminlen    The size of the input buffer \p dhmin, including the
// terminating \c NULL Byte for PEM data.
// 
// \return            \c 0 on success.
// \return            An \c MBEDTLS_ERR_DHM_XXX or \c MBEDTLS_ERR_PEM_XXX error
// code on failure.
pub extern external/mbedtls-dhm-parse-dhm(^dhm: c-pointer<mbedtls-dhm-context-c>, ^dhmin: c-pointer<int>, ^dhminlen: ssize_t): int32
  c inline "(int)mbedtls_dhm_parse_dhm((struct mbedtls_dhm_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-dhm-parse-dhm(^dhm: c-pointer<mbedtls-dhm-context-c>, ^dhmin: c-pointer<int>, ^dhminlen: int): <> int
  external/mbedtls-dhm-parse-dhm(dhm, dhmin, dhminlen.ssize_t).int

// \brief          This function loads and parses DHM parameters from a file.
// 
// \param dhm      The DHM context to load the parameters to.
// This must be initialized.
// \param path     The filename to read the DHM parameters from.
// This must not be \c NULL.
// 
// \return         \c 0 on success.
// \return         An \c MBEDTLS_ERR_DHM_XXX or \c MBEDTLS_ERR_PEM_XXX
// error code on failure.
pub extern external/mbedtls-dhm-parse-dhmfile(^dhm: c-pointer<mbedtls-dhm-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_dhm_parse_dhmfile((struct mbedtls_dhm_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-dhm-parse-dhmfile(^dhm: c-pointer<mbedtls-dhm-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-dhm-parse-dhmfile(dhm, path).int

// \brief          The DMH checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-dhm-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_dhm_self_test((int)#1)"

pub inline fun ffi/mbedtls-dhm-self-test(^verbose: int): <> int
  external/mbedtls-dhm-self-test(verbose.int32).int

// \brief          Return the ECP group for provided context.
// 
// \note           To access group specific fields, users should use
// `mbedtls_ecp_curve_info_from_grp_id` or
// `mbedtls_ecp_group_load` on the extracted `group_id`.
// 
// \param ctx      The ECDH context to parse. This must not be \c NULL.
// 
// \return         The \c mbedtls_ecp_group_id of the context.
pub extern external/mbedtls-ecdh-get-grp-id(^ctx1: c-pointer<mbedtls-ecdh-context-c>): int32
  c inline "(int32_t)mbedtls_ecdh_get_grp_id((struct mbedtls_ecdh_context*)#1)"

pub inline fun ffi/mbedtls-ecdh-get-grp-id(^ctx1: c-pointer<mbedtls-ecdh-context-c>): <exn> mbedtls-ecp-group-id
  external/mbedtls-ecdh-get-grp-id(ctx1).int/mbedtls-ecp-group-id

// \brief          Check whether a given group can be used for ECDH.
// 
// \param gid      The ECP group ID to check.
// 
// \return         \c 1 if the group can be used, \c 0 otherwise
pub extern external/mbedtls-ecdh-can-do(^gid: int32): int32
  c inline "(int)mbedtls_ecdh_can_do((int32_t)#1)"

pub inline fun ffi/mbedtls-ecdh-can-do(^gid: mbedtls-ecp-group-id): <exn> int
  external/mbedtls-ecdh-can-do(gid.mbedtls-ecp-group-id/int).int

// \brief           This function generates an ECDH keypair on an elliptic
// curve.
// 
// This function performs the first of two core computations
// implemented during the ECDH key exchange. The second core
// computation is performed by mbedtls_ecdh_compute_shared().
// 
// \see             ecp.h
// 
// \param grp       The ECP group to use. This must be initialized and have
// domain parameters loaded, for example through
// mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().
// \param d         The destination MPI (private key).
// This must be initialized.
// \param Q         The destination point (public key).
// This must be initialized.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL in case \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          Another \c MBEDTLS_ERR_ECP_XXX or
// \c MBEDTLS_MPI_XXX error code on failure.
pub extern external/mbedtls-ecdh-gen-public(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdh_gen_public((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_ecp_point*)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-ecdh-gen-public(^grp: c-pointer<mbedtls-ecp-group-c>, ^d: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecdh-gen-public(grp, d, q, f-rng, p-rng).int

// \brief           This function computes the shared secret.
// 
// This function performs the second of two core computations
// implemented during the ECDH key exchange. The first core
// computation is performed by mbedtls_ecdh_gen_public().
// 
// \see             ecp.h
// 
// \note            If \p f_rng is not NULL, it is used to implement
// countermeasures against side-channel attacks.
// For more information, see mbedtls_ecp_mul().
// 
// \param grp       The ECP group to use. This must be initialized and have
// domain parameters loaded, for example through
// mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().
// \param z         The destination MPI (shared secret).
// This must be initialized.
// \param Q         The public key from another party.
// This must be initialized.
// \param d         Our secret exponent (private key).
// This must be initialized.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL if \p f_rng is \c NULL or doesn't need a
// context argument.
// 
// \return          \c 0 on success.
// \return          Another \c MBEDTLS_ERR_ECP_XXX or
// \c MBEDTLS_MPI_XXX error code on failure.
pub extern external/mbedtls-ecdh-compute-shared(^grp: c-pointer<mbedtls-ecp-group-c>, ^z: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^d: c-pointer<mbedtls-mpi-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdh_compute_shared((struct mbedtls_ecp_group*)#1, (struct mbedtls_mpi*)#2, (struct mbedtls_ecp_point*)#3, (struct mbedtls_mpi*)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecdh-compute-shared(^grp: c-pointer<mbedtls-ecp-group-c>, ^z: c-pointer<mbedtls-mpi-c>, ^q: c-pointer<mbedtls-ecp-point-c>, ^d: c-pointer<mbedtls-mpi-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecdh-compute-shared(grp, z, q, d, f-rng, p-rng).int

// \brief           This function initializes an ECDH context.
// 
// \param ctx       The ECDH context to initialize. This must not be \c NULL.
pub extern external/mbedtls-ecdh-init(^ctx1: c-pointer<mbedtls-ecdh-context-c>): ()
  c inline "(void)mbedtls_ecdh_init((struct mbedtls_ecdh_context*)#1)"

// \brief           This function sets up the ECDH context with the information
// given.
// 
// This function should be called after mbedtls_ecdh_init() but
// before mbedtls_ecdh_make_params(). There is no need to call
// this function before mbedtls_ecdh_read_params().
// 
// This is the first function used by a TLS server for ECDHE
// ciphersuites.
// 
// \param ctx       The ECDH context to set up. This must be initialized.
// \param grp_id    The group id of the group to set up the context for.
// 
// \return          \c 0 on success.
pub extern external/mbedtls-ecdh-setup(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^grp-id: int32): int32
  c inline "(int)mbedtls_ecdh_setup((struct mbedtls_ecdh_context*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-ecdh-setup(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^grp-id: mbedtls-ecp-group-id): <exn> int
  external/mbedtls-ecdh-setup(ctx1, grp-id.mbedtls-ecp-group-id/int).int

// \brief           This function frees a context.
// 
// \param ctx       The context to free. This may be \c NULL, in which
// case this function does nothing. If it is not \c NULL,
// it must point to an initialized ECDH context.
pub extern external/mbedtls-ecdh-free(^ctx1: c-pointer<mbedtls-ecdh-context-c>): ()
  c inline "(void)mbedtls_ecdh_free((struct mbedtls_ecdh_context*)#1)"

// \brief           This function generates an EC key pair and exports its
// in the format used in a TLS ServerKeyExchange handshake
// message.
// 
// This is the second function used by a TLS server for ECDHE
// ciphersuites. (It is called after mbedtls_ecdh_setup().)
// 
// \see             ecp.h
// 
// \param ctx       The ECDH context to use. This must be initialized
// and bound to a group, for example via mbedtls_ecdh_setup().
// \param olen      The address at which to store the number of Bytes written.
// \param buf       The destination buffer. This must be a writable buffer of
// length \p blen Bytes.
// \param blen      The length of the destination buffer \p buf in Bytes.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL in case \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
pub extern external/mbedtls-ecdh-make-params(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdh_make_params((struct mbedtls_ecdh_context*)#1, (size_t*)#2, (unsigned char*)#3, (size_t)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecdh-make-params(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecdh-make-params(ctx1, olen, buf, blen.ssize_t, f-rng, p-rng).int

// \brief           This function parses the ECDHE parameters in a
// TLS ServerKeyExchange handshake message.
// 
// \note            In a TLS handshake, this is the how the client
// sets up its ECDHE context from the server's public
// ECDHE key material.
// 
// \see             ecp.h
// 
// \param ctx       The ECDHE context to use. This must be initialized.
// \param buf       On input, \c *buf must be the start of the input buffer.
// On output, \c *buf is updated to point to the end of the
// data that has been read. On success, this is the first byte
// past the end of the ServerKeyExchange parameters.
// On error, this is the point at which an error has been
// detected, which is usually not useful except to debug
// failures.
// \param end       The end of the input buffer.
// 
// \return          \c 0 on success.
// \return          An \c MBEDTLS_ERR_ECP_XXX error code on failure.
pub extern external/mbedtls-ecdh-read-params(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^buf: c-pointer<c-pointer<int>>, ^end: c-pointer<int>): int32
  c inline "(int)mbedtls_ecdh_read_params((struct mbedtls_ecdh_context*)#1, (unsigned char**)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-ecdh-read-params(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^buf: c-pointer<c-pointer<int>>, ^end: c-pointer<int>): <> int
  external/mbedtls-ecdh-read-params(ctx1, buf, end).int

// \brief           This function sets up an ECDH context from an EC key.
// 
// It is used by clients and servers in place of the
// ServerKeyEchange for static ECDH, and imports ECDH
// parameters from the EC key information of a certificate.
// 
// \see             ecp.h
// 
// \param ctx       The ECDH context to set up. This must be initialized.
// \param key       The EC key to use. This must be initialized.
// \param side      Defines the source of the key. Possible values are:
// - #MBEDTLS_ECDH_OURS: The key is ours.
// - #MBEDTLS_ECDH_THEIRS: The key is that of the peer.
// 
// \return          \c 0 on success.
// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
pub extern external/mbedtls-ecdh-get-params(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^side: int32): int32
  c inline "(int)mbedtls_ecdh_get_params((struct mbedtls_ecdh_context*)#1, (struct mbedtls_ecp_keypair*)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-ecdh-get-params(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^key: c-pointer<mbedtls-ecp-keypair-c>, ^side: mbedtls-ecdh-side): <exn> int
  external/mbedtls-ecdh-get-params(ctx1, key, side.mbedtls-ecdh-side/int).int

// \brief           This function generates a public key and exports it
// as a TLS ClientKeyExchange payload.
// 
// This is the second function used by a TLS client for ECDH(E)
// ciphersuites.
// 
// \see             ecp.h
// 
// \param ctx       The ECDH context to use. This must be initialized
// and bound to a group, the latter usually by
// mbedtls_ecdh_read_params().
// \param olen      The address at which to store the number of Bytes written.
// This must not be \c NULL.
// \param buf       The destination buffer. This must be a writable buffer
// of length \p blen Bytes.
// \param blen      The size of the destination buffer \p buf in Bytes.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG context to be passed to \p f_rng. This may be
// \c NULL in case \p f_rng doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
pub extern external/mbedtls-ecdh-make-public(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdh_make_public((struct mbedtls_ecdh_context*)#1, (size_t*)#2, (unsigned char*)#3, (size_t)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecdh-make-public(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecdh-make-public(ctx1, olen, buf, blen.ssize_t, f-rng, p-rng).int

// \brief       This function parses and processes the ECDHE payload of a
// TLS ClientKeyExchange message.
// 
// This is the third function used by a TLS server for ECDH(E)
// ciphersuites. (It is called after mbedtls_ecdh_setup() and
// mbedtls_ecdh_make_params().)
// 
// \see         ecp.h
// 
// \param ctx   The ECDH context to use. This must be initialized
// and bound to a group, for example via mbedtls_ecdh_setup().
// \param buf   The pointer to the ClientKeyExchange payload. This must
// be a readable buffer of length \p blen Bytes.
// \param blen  The length of the input buffer \p buf in Bytes.
// 
// \return      \c 0 on success.
// \return      An \c MBEDTLS_ERR_ECP_XXX error code on failure.
pub extern external/mbedtls-ecdh-read-public(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^buf: c-pointer<int>, ^blen: ssize_t): int32
  c inline "(int)mbedtls_ecdh_read_public((struct mbedtls_ecdh_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ecdh-read-public(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^buf: c-pointer<int>, ^blen: int): <> int
  external/mbedtls-ecdh-read-public(ctx1, buf, blen.ssize_t).int

// \brief           This function derives and exports the shared secret.
// 
// This is the last function used by both TLS client
// and servers.
// 
// \note            If \p f_rng is not NULL, it is used to implement
// countermeasures against side-channel attacks.
// For more information, see mbedtls_ecp_mul().
// 
// \see             ecp.h
// 
// \param ctx       The ECDH context to use. This must be initialized
// and have its own private key generated and the peer's
// public key imported.
// \param olen      The address at which to store the total number of
// Bytes written on success. This must not be \c NULL.
// \param buf       The buffer to write the generated shared key to. This
// must be a writable buffer of size \p blen Bytes.
// \param blen      The length of the destination buffer \p buf in Bytes.
// \param f_rng     The RNG function to use. This must not be \c NULL.
// \param p_rng     The RNG context. This may be \c NULL if \p f_rng
// doesn't need a context argument.
// 
// \return          \c 0 on success.
// \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
// operations was reached: see \c mbedtls_ecp_set_max_ops().
// \return          Another \c MBEDTLS_ERR_ECP_XXX error code on failure.
pub extern external/mbedtls-ecdh-calc-secret(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ecdh_calc_secret((struct mbedtls_ecdh_context*)#1, (size_t*)#2, (unsigned char*)#3, (size_t)#4, (int (*)(void*, unsigned char*, size_t))#5, (void*)#6)"

pub inline fun ffi/mbedtls-ecdh-calc-secret(^ctx1: c-pointer<mbedtls-ecdh-context-c>, ^olen: c-pointer<int>, ^buf: c-pointer<int>, ^blen: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ecdh-calc-secret(ctx1, olen, buf, blen.ssize_t, f-rng, p-rng).int

// \brief               Return the name of the ciphersuite associated with the
// given ID
// 
// \param ciphersuite_id SSL ciphersuite ID
// 
// \return              a string containing the ciphersuite name
pub extern external/mbedtls-ssl-get-ciphersuite-name(^ciphersuite-id: int32): c-pointer<int>
  c inline "(intptr_t)mbedtls_ssl_get_ciphersuite_name((int)#1)"

pub inline fun ffi/mbedtls-ssl-get-ciphersuite-name(^ciphersuite-id: int): <> c-pointer<int>
  external/mbedtls-ssl-get-ciphersuite-name(ciphersuite-id.int32)

// \brief               Return the ID of the ciphersuite associated with the
// given name
// 
// \param ciphersuite_name SSL ciphersuite name
// 
// \return              the ID with the ciphersuite or 0 if not found
pub extern external/mbedtls-ssl-get-ciphersuite-id(^ciphersuite-name: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_get_ciphersuite_id((char*)#1)"

pub inline fun ffi/mbedtls-ssl-get-ciphersuite-id(^ciphersuite-name: c-pointer<int>): <> int
  external/mbedtls-ssl-get-ciphersuite-id(ciphersuite-name).int

// \brief          Initialize an SSL context
// Just makes the context ready for mbedtls_ssl_setup() or
// mbedtls_ssl_free()
// 
// \param ssl      SSL context
pub extern external/mbedtls-ssl-init(^ssl: c-pointer<mbedtls-ssl-context-c>): ()
  c inline "(void)mbedtls_ssl_init((struct mbedtls_ssl_context*)#1)"

// \brief          Set up an SSL context for use
// 
// \note           No copy of the configuration context is made, it can be
// shared by many mbedtls_ssl_context structures.
// 
// \warning        The conf structure will be accessed during the session.
// It must not be modified or freed as long as the session
// is active.
// 
// \warning        This function must be called exactly once per context.
// Calling mbedtls_ssl_setup again is not supported, even
// if no session is active.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param ssl      SSL context
// \param conf     SSL configuration to use
// 
// \return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if
// memory allocation failed
pub extern external/mbedtls-ssl-setup(^ssl: c-pointer<mbedtls-ssl-context-c>, ^conf: c-pointer<mbedtls-ssl-config-c>): int32
  c inline "(int)mbedtls_ssl_setup((struct mbedtls_ssl_context*)#1, (struct mbedtls_ssl_config*)#2)"

pub inline fun ffi/mbedtls-ssl-setup(^ssl: c-pointer<mbedtls-ssl-context-c>, ^conf: c-pointer<mbedtls-ssl-config-c>): <> int
  external/mbedtls-ssl-setup(ssl, conf).int

// \brief          Reset an already initialized SSL context for re-use
// while retaining application-set variables, function
// pointers and data.
// 
// \param ssl      SSL context
// \return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED or
// MBEDTLS_ERR_SSL_HW_ACCEL_FAILED
pub extern external/mbedtls-ssl-session-reset(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_session_reset((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-session-reset(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-session-reset(ssl).int

// \brief          Set the current endpoint type
// 
// \param conf     SSL configuration
// \param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER
pub extern external/mbedtls-ssl-conf-endpoint(^conf: c-pointer<mbedtls-ssl-config-c>, ^endpoint: int32): ()
  c inline "(void)mbedtls_ssl_conf_endpoint((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-endpoint(^conf: c-pointer<mbedtls-ssl-config-c>, ^endpoint: int): <> ()
  external/mbedtls-ssl-conf-endpoint(conf, endpoint.int32)

// \brief           Set the transport type (TLS or DTLS).
// Default: TLS
// 
// \note            For DTLS, you must either provide a recv callback that
// doesn't block, or one that handles timeouts, see
// \c mbedtls_ssl_set_bio(). You also need to provide timer
// callbacks with \c mbedtls_ssl_set_timer_cb().
// 
// \param conf      SSL configuration
// \param transport transport type:
// MBEDTLS_SSL_TRANSPORT_STREAM for TLS,
// MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS.
pub extern external/mbedtls-ssl-conf-transport(^conf: c-pointer<mbedtls-ssl-config-c>, ^transport: int32): ()
  c inline "(void)mbedtls_ssl_conf_transport((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-transport(^conf: c-pointer<mbedtls-ssl-config-c>, ^transport: int): <> ()
  external/mbedtls-ssl-conf-transport(conf, transport.int32)

// \brief          Set the certificate verification mode
// Default: NONE on server, REQUIRED on client
// 
// \param conf     SSL configuration
// \param authmode can be:
// 
// MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked
// (default on server)
// (insecure on client)
// 
// MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the
// handshake continues even if verification failed;
// mbedtls_ssl_get_verify_result() can be called after the
// handshake is complete.
// 
// MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,
// handshake is aborted if verification failed.
// (default on client)
// 
// \note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode.
// With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at
// the right time(s), which may not be obvious, while REQUIRED always perform
// the verification as soon as possible. For example, REQUIRED was protecting
// against the "triple handshake" attack even before it was found.
pub extern external/mbedtls-ssl-conf-authmode(^conf: c-pointer<mbedtls-ssl-config-c>, ^authmode: int32): ()
  c inline "(void)mbedtls_ssl_conf_authmode((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-authmode(^conf: c-pointer<mbedtls-ssl-config-c>, ^authmode: int): <> ()
  external/mbedtls-ssl-conf-authmode(conf, authmode.int32)

// \brief          Set the verification callback (Optional).
// 
// If set, the provided verify callback is called for each
// certificate in the peer's CRT chain, including the trusted
// root. For more information, please see the documentation of
// \c mbedtls_x509_crt_verify().
// 
// \note           For per context callbacks and contexts, please use
// mbedtls_ssl_set_verify() instead.
// 
// \param conf     The SSL configuration to use.
// \param f_vrfy   The verification callback to use during CRT verification.
// \param p_vrfy   The opaque context to be passed to the callback.
pub extern external/mbedtls-ssl-conf-verify(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_verify((struct mbedtls_ssl_config*)#1, (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#2, (void*)#3)"

// \brief          Set the random number generator callback
// 
// \param conf     SSL configuration
// \param f_rng    RNG function (mandatory)
// \param p_rng    RNG parameter
pub extern external/mbedtls-ssl-conf-rng(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_rng((struct mbedtls_ssl_config*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3)"

// \brief          Set the debug callback
// 
// The callback has the following argument:
// void *           opaque context for the callback
// int              debug level
// const char *     file name
// int              line number
// const char *     message
// 
// \param conf     SSL configuration
// \param f_dbg    debug function
// \param p_dbg    debug parameter
pub extern external/mbedtls-ssl-conf-dbg(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-dbg: c-pointer<intptr_t>, ^p-dbg: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_dbg((struct mbedtls_ssl_config*)#1, (void (*)(void*, int, char*, int, char*))#2, (void*)#3)"

// \brief          Set the underlying BIO callbacks for write, read and
// read-with-timeout.
// 
// \param ssl      SSL context
// \param p_bio    parameter (context) shared by BIO callbacks
// \param f_send   write callback
// \param f_recv   read callback
// \param f_recv_timeout blocking read callback with timeout.
// 
// \note           One of f_recv or f_recv_timeout can be NULL, in which case
// the other is used. If both are non-NULL, f_recv_timeout is
// used and f_recv is ignored (as if it were NULL).
// 
// \note           The two most common use cases are:
// - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL
// - blocking I/O, f_recv == NULL, f_recv_timeout != NULL
// 
// \note           For DTLS, you need to provide either a non-NULL
// f_recv_timeout callback, or a f_recv that doesn't block.
// 
// \note           See the documentations of \c mbedtls_ssl_send_t,
// \c mbedtls_ssl_recv_t and \c mbedtls_ssl_recv_timeout_t for
// the conventions those callbacks must follow.
// 
// \note           On some platforms, net_sockets.c provides
// \c mbedtls_net_send(), \c mbedtls_net_recv() and
// \c mbedtls_net_recv_timeout() that are suitable to be used
// here.
pub extern external/mbedtls-ssl-set-bio(^ssl: c-pointer<mbedtls-ssl-context-c>, ^p-bio: c-pointer<()>, ^f-send: c-pointer<mbedtls-ssl-send-t>, ^f-recv: c-pointer<mbedtls-ssl-recv-t>, ^f-recv-timeout: c-pointer<mbedtls-ssl-recv-timeout-t>): ()
  c inline "(void)mbedtls_ssl_set_bio((struct mbedtls_ssl_context*)#1, (void*)#2, (mbedtls_ssl_send_t*)#3, (mbedtls_ssl_recv_t*)#4, (mbedtls_ssl_recv_timeout_t*)#5)"

// \brief             Configure the use of the Connection ID (CID)
// extension in the next handshake.
// 
// Reference: RFC 9146 (or draft-ietf-tls-dtls-connection-id-05
// https://tools.ietf.org/html/draft-ietf-tls-dtls-connection-id-05
// for legacy version)
// 
// The DTLS CID extension allows the reliable association of
// DTLS records to DTLS connections across changes in the
// underlying transport (changed IP and Port metadata) by
// adding explicit connection identifiers (CIDs) to the
// headers of encrypted DTLS records. The desired CIDs are
// configured by the application layer and are exchanged in
// new `ClientHello` / `ServerHello` extensions during the
// handshake, where each side indicates the CID it wants the
// peer to use when writing encrypted messages. The CIDs are
// put to use once records get encrypted: the stack discards
// any incoming records that don't include the configured CID
// in their header, and adds the peer's requested CID to the
// headers of outgoing messages.
// 
// This API enables or disables the use of the CID extension
// in the next handshake and sets the value of the CID to
// be used for incoming messages.
// 
// \param ssl         The SSL context to configure. This must be initialized.
// \param enable      This value determines whether the CID extension should
// be used or not. Possible values are:
// - MBEDTLS_SSL_CID_ENABLED to enable the use of the CID.
// - MBEDTLS_SSL_CID_DISABLED (default) to disable the use
// of the CID.
// \param own_cid     The address of the readable buffer holding the CID we want
// the peer to use when sending encrypted messages to us.
// This may be \c NULL if \p own_cid_len is \c 0.
// This parameter is unused if \p enable is set to
// MBEDTLS_SSL_CID_DISABLED.
// \param own_cid_len The length of \p own_cid.
// This parameter is unused if \p enable is set to
// MBEDTLS_SSL_CID_DISABLED.
// 
// \note              The value of \p own_cid_len must match the value of the
// \c len parameter passed to mbedtls_ssl_conf_cid()
// when configuring the ::mbedtls_ssl_config that \p ssl
// is bound to.
// 
// \note              This CID configuration applies to subsequent handshakes
// performed on the SSL context \p ssl, but does not trigger
// one. You still have to call `mbedtls_ssl_handshake()`
// (for the initial handshake) or `mbedtls_ssl_renegotiate()`
// (for a renegotiation handshake) explicitly after a
// successful call to this function to run the handshake.
// 
// \note              This call cannot guarantee that the use of the CID
// will be successfully negotiated in the next handshake,
// because the peer might not support it. Specifically:
// - On the Client, enabling the use of the CID through
// this call implies that the `ClientHello` in the next
// handshake will include the CID extension, thereby
// offering the use of the CID to the server. Only if
// the `ServerHello` contains the CID extension, too,
// the CID extension will actually be put to use.
// - On the Server, enabling the use of the CID through
// this call implies that the server will look for
// the CID extension in a `ClientHello` from the client,
// and, if present, reply with a CID extension in its
// `ServerHello`.
// 
// \note              To check whether the use of the CID was negotiated
// after the subsequent handshake has completed, please
// use the API mbedtls_ssl_get_peer_cid().
// 
// \warning           If the use of the CID extension is enabled in this call
// and the subsequent handshake negotiates its use, Mbed TLS
// will silently drop every packet whose CID does not match
// the CID configured in \p own_cid. It is the responsibility
// of the user to adapt the underlying transport to take care
// of CID-based demultiplexing before handing datagrams to
// Mbed TLS.
// 
// \return            \c 0 on success. In this case, the CID configuration
// applies to the next handshake.
// \return            A negative error code on failure.
pub extern external/mbedtls-ssl-set-cid(^ssl: c-pointer<mbedtls-ssl-context-c>, ^enable: int32, ^own-cid: c-pointer<int>, ^own-cid-len: ssize_t): int32
  c inline "(int)mbedtls_ssl_set_cid((struct mbedtls_ssl_context*)#1, (int)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ssl-set-cid(^ssl: c-pointer<mbedtls-ssl-context-c>, ^enable: int, ^own-cid: c-pointer<int>, ^own-cid-len: int): <> int
  external/mbedtls-ssl-set-cid(ssl, enable.int32, own-cid, own-cid-len.ssize_t).int

// \brief              Get information about our request for usage of the CID
// extension in the current connection.
// 
// \param ssl          The SSL context to query.
// \param enabled      The address at which to store whether the CID extension
// is requested to be used or not. If the CID is
// requested, `*enabled` is set to
// MBEDTLS_SSL_CID_ENABLED; otherwise, it is set to
// MBEDTLS_SSL_CID_DISABLED.
// \param own_cid      The address of the buffer in which to store our own
// CID (if the CID extension is requested). This may be
// \c NULL in case the value of our CID isn't needed. If
// it is not \c NULL, \p own_cid_len must not be \c NULL.
// \param own_cid_len  The address at which to store the size of our own CID
// (if the CID extension is requested). This is also the
// number of Bytes in \p own_cid that have been written.
// This may be \c NULL in case the length of our own CID
// isn't needed. If it is \c NULL, \p own_cid must be
// \c NULL, too.
// 
// \note                If we are requesting an empty CID this function sets
// `*enabled` to #MBEDTLS_SSL_CID_DISABLED (the rationale
// for this is that the resulting outcome is the
// same as if the CID extensions wasn't requested).
// 
// \return            \c 0 on success.
// \return            A negative error code on failure.
pub extern external/mbedtls-ssl-get-own-cid(^ssl: c-pointer<mbedtls-ssl-context-c>, ^enabled: c-pointer<int>, ^own-cid: c-pointer<int>, ^own-cid-len: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_get_own_cid((struct mbedtls_ssl_context*)#1, (int*)#2, (unsigned char*)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-ssl-get-own-cid(^ssl: c-pointer<mbedtls-ssl-context-c>, ^enabled: c-pointer<int>, ^own-cid: c-array<int>, ^own-cid-len: c-pointer<int>): <> int
  external/mbedtls-ssl-get-own-cid(ssl, enabled, own-cid.cextern/carray/ptr, own-cid-len).int

// \brief              Get information about the use of the CID extension
// in the current connection.
// 
// \param ssl          The SSL context to query.
// \param enabled      The address at which to store whether the CID extension
// is currently in use or not. If the CID is in use,
// `*enabled` is set to MBEDTLS_SSL_CID_ENABLED;
// otherwise, it is set to MBEDTLS_SSL_CID_DISABLED.
// \param peer_cid     The address of the buffer in which to store the CID
// chosen by the peer (if the CID extension is used).
// This may be \c NULL in case the value of peer CID
// isn't needed. If it is not \c NULL, \p peer_cid_len
// must not be \c NULL.
// \param peer_cid_len The address at which to store the size of the CID
// chosen by the peer (if the CID extension is used).
// This is also the number of Bytes in \p peer_cid that
// have been written.
// This may be \c NULL in case the length of the peer CID
// isn't needed. If it is \c NULL, \p peer_cid must be
// \c NULL, too.
// 
// \note               This applies to the state of the CID negotiated in
// the last complete handshake. If a handshake is in
// progress, this function will attempt to complete
// the handshake first.
// 
// \note               If CID extensions have been exchanged but both client
// and server chose to use an empty CID, this function
// sets `*enabled` to #MBEDTLS_SSL_CID_DISABLED
// (the rationale for this is that the resulting
// communication is the same as if the CID extensions
// hadn't been used).
// 
// \return            \c 0 on success.
// \return            A negative error code on failure.
pub extern external/mbedtls-ssl-get-peer-cid(^ssl: c-pointer<mbedtls-ssl-context-c>, ^enabled: c-pointer<int>, ^peer-cid: c-pointer<int>, ^peer-cid-len: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_get_peer_cid((struct mbedtls_ssl_context*)#1, (int*)#2, (unsigned char*)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-ssl-get-peer-cid(^ssl: c-pointer<mbedtls-ssl-context-c>, ^enabled: c-pointer<int>, ^peer-cid: c-array<int>, ^peer-cid-len: c-pointer<int>): <> int
  external/mbedtls-ssl-get-peer-cid(ssl, enabled, peer-cid.cextern/carray/ptr, peer-cid-len).int

// \brief          Set the Maximum Transport Unit (MTU).
// Special value: 0 means unset (no limit).
// This represents the maximum size of a datagram payload
// handled by the transport layer (usually UDP) as determined
// by the network link and stack. In practice, this controls
// the maximum size datagram the DTLS layer will pass to the
// \c f_send() callback set using \c mbedtls_ssl_set_bio().
// 
// \note           The limit on datagram size is converted to a limit on
// record payload by subtracting the current overhead of
// encapsulation and encryption/authentication if any.
// 
// \note           This can be called at any point during the connection, for
// example when a Path Maximum Transfer Unit (PMTU)
// estimate becomes available from other sources,
// such as lower (or higher) protocol layers.
// 
// \note           This setting only controls the size of the packets we send,
// and does not restrict the size of the datagrams we're
// willing to receive. Client-side, you can request the
// server to use smaller records with \c
// mbedtls_ssl_conf_max_frag_len().
// 
// \note           If both a MTU and a maximum fragment length have been
// configured (or negotiated with the peer), the resulting
// lower limit on record payload (see first note) is used.
// 
// \note           This can only be used to decrease the maximum size
// of datagrams (hence records, see first note) sent. It
// cannot be used to increase the maximum size of records over
// the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN.
// 
// \note           Values lower than the current record layer expansion will
// result in an error when trying to send data.
// 
// \param ssl      SSL context
// \param mtu      Value of the path MTU in bytes
pub extern external/mbedtls-ssl-set-mtu(^ssl: c-pointer<mbedtls-ssl-context-c>, ^mtu: int16): ()
  c inline "(void)mbedtls_ssl_set_mtu((struct mbedtls_ssl_context*)#1, (int16_t)#2)"

pub inline fun ffi/mbedtls-ssl-set-mtu(^ssl: c-pointer<mbedtls-ssl-context-c>, ^mtu: int): <> ()
  external/mbedtls-ssl-set-mtu(ssl, mtu.int16)

// \brief          Set a connection-specific verification callback (optional).
// 
// If set, the provided verify callback is called for each
// certificate in the peer's CRT chain, including the trusted
// root. For more information, please see the documentation of
// \c mbedtls_x509_crt_verify().
// 
// \note           This call is analogous to mbedtls_ssl_conf_verify() but
// binds the verification callback and context to an SSL context
// as opposed to an SSL configuration.
// If mbedtls_ssl_conf_verify() and mbedtls_ssl_set_verify()
// are both used, mbedtls_ssl_set_verify() takes precedence.
// 
// \param ssl      The SSL context to use.
// \param f_vrfy   The verification callback to use during CRT verification.
// \param p_vrfy   The opaque context to be passed to the callback.
pub extern external/mbedtls-ssl-set-verify(^ssl: c-pointer<mbedtls-ssl-context-c>, ^f-vrfy: c-pointer<intptr_t>, ^p-vrfy: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_set_verify((struct mbedtls_ssl_context*)#1, (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#2, (void*)#3)"

// \brief          Set the timeout period for mbedtls_ssl_read()
// (Default: no timeout.)
// 
// \param conf     SSL configuration context
// \param timeout  Timeout value in milliseconds.
// Use 0 for no timeout (default).
// 
// \note           With blocking I/O, this will only work if a non-NULL
// \c f_recv_timeout was set with \c mbedtls_ssl_set_bio().
// With non-blocking I/O, this will only work if timer
// callbacks were set with \c mbedtls_ssl_set_timer_cb().
// 
// \note           With non-blocking I/O, you may also skip this function
// altogether and handle timeouts at the application layer.
pub extern external/mbedtls-ssl-conf-read-timeout(^conf: c-pointer<mbedtls-ssl-config-c>, ^timeout: int32): ()
  c inline "(void)mbedtls_ssl_conf_read_timeout((struct mbedtls_ssl_config*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-ssl-conf-read-timeout(^conf: c-pointer<mbedtls-ssl-config-c>, ^timeout: int): <> ()
  external/mbedtls-ssl-conf-read-timeout(conf, timeout.int32)

// \brief          Check whether a buffer contains a valid and authentic record
// that has not been seen before. (DTLS only).
// 
// This function does not change the user-visible state
// of the SSL context. Its sole purpose is to provide
// an indication of the legitimacy of an incoming record.
// 
// This can be useful e.g. in distributed server environments
// using the DTLS Connection ID feature, in which connections
// might need to be passed between service instances on a change
// of peer address, but where such disruptive operations should
// only happen after the validity of incoming records has been
// confirmed.
// 
// \param ssl      The SSL context to use.
// \param buf      The address of the buffer holding the record to be checked.
// This must be a read/write buffer of length \p buflen Bytes.
// \param buflen   The length of \p buf in Bytes.
// 
// \note           This routine only checks whether the provided buffer begins
// with a valid and authentic record that has not been seen
// before, but does not check potential data following the
// initial record. In particular, it is possible to pass DTLS
// datagrams containing multiple records, in which case only
// the first record is checked.
// 
// \note           This function modifies the input buffer \p buf. If you need
// to preserve the original record, you have to maintain a copy.
// 
// \return         \c 0 if the record is valid and authentic and has not been
// seen before.
// \return         MBEDTLS_ERR_SSL_INVALID_MAC if the check completed
// successfully but the record was found to be not authentic.
// \return         MBEDTLS_ERR_SSL_INVALID_RECORD if the check completed
// successfully but the record was found to be invalid for
// a reason different from authenticity checking.
// \return         MBEDTLS_ERR_SSL_UNEXPECTED_RECORD if the check completed
// successfully but the record was found to be unexpected
// in the state of the SSL context, including replayed records.
// \return         Another negative error code on different kinds of failure.
// In this case, the SSL context becomes unusable and needs
// to be freed or reset before reuse.
pub extern external/mbedtls-ssl-check-record(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_ssl_check_record((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-check-record(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-ssl-check-record(ssl, buf, buflen.ssize_t).int

// \brief          Set the timer callbacks (Mandatory for DTLS.)
// 
// \param ssl      SSL context
// \param p_timer  parameter (context) shared by timer callbacks
// \param f_set_timer   set timer callback
// \param f_get_timer   get timer callback. Must return:
// 
// \note           See the documentation of \c mbedtls_ssl_set_timer_t and
// \c mbedtls_ssl_get_timer_t for the conventions this pair of
// callbacks must follow.
// 
// \note           On some platforms, timing.c provides
// \c mbedtls_timing_set_delay() and
// \c mbedtls_timing_get_delay() that are suitable for using
// here, except if using an event-driven style.
// 
// \note           See also the "DTLS tutorial" article in our knowledge base.
// https://mbed-tls.readthedocs.io/en/latest/kb/how-to/dtls-tutorial
pub extern external/mbedtls-ssl-set-timer-cb(^ssl: c-pointer<mbedtls-ssl-context-c>, ^p-timer: c-pointer<()>, ^f-set-timer: c-pointer<mbedtls-ssl-set-timer-t>, ^f-get-timer: c-pointer<mbedtls-ssl-get-timer-t>): ()
  c inline "(void)mbedtls_ssl_set_timer_cb((struct mbedtls_ssl_context*)#1, (void*)#2, (mbedtls_ssl_set_timer_t*)#3, (mbedtls_ssl_get_timer_t*)#4)"

// \brief           Configure SSL session ticket callbacks (server only).
// (Default: none.)
// 
// \note            On server, session tickets are enabled by providing
// non-NULL callbacks.
// 
// \note            On client, use \c mbedtls_ssl_conf_session_tickets().
// 
// \param conf      SSL configuration context
// \param f_ticket_write    Callback for writing a ticket
// \param f_ticket_parse    Callback for parsing a ticket
// \param p_ticket          Context shared by the two callbacks
pub extern external/mbedtls-ssl-conf-session-tickets-cb(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-ticket-write: c-pointer<mbedtls-ssl-ticket-write-t>, ^f-ticket-parse: c-pointer<mbedtls-ssl-ticket-parse-t>, ^p-ticket: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_session_tickets_cb((struct mbedtls_ssl_config*)#1, (mbedtls_ssl_ticket_write_t*)#2, (mbedtls_ssl_ticket_parse_t*)#3, (void*)#4)"

// \brief   Configure a key export callback.
// (Default: none.)
// 
// This API can be used for two purposes:
// - Debugging: Use this API to e.g. generate an NSSKeylog
// file and use it to inspect encrypted traffic in tools
// such as Wireshark.
// - Application-specific export: Use this API to implement
// key exporters, e.g. for EAP-TLS or DTLS-SRTP.
// 
// 
// \param ssl            The SSL context to which the export
// callback should be attached.
// \param f_export_keys  The callback for the key export.
// \param p_export_keys  The opaque context pointer to be passed to the
// callback \p f_export_keys.
pub extern external/mbedtls-ssl-set-export-keys-cb(^ssl: c-pointer<mbedtls-ssl-context-c>, ^f-export-keys: c-pointer<mbedtls-ssl-export-keys-t>, ^p-export-keys: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_set_export_keys_cb((struct mbedtls_ssl_context*)#1, (mbedtls_ssl_export_keys_t*)#2, (void*)#3)"

// \brief           Register callbacks for DTLS cookies
// (Server only. DTLS only.)
// 
// Default: dummy callbacks that fail, in order to force you to
// register working callbacks (and initialize their context).
// 
// To disable HelloVerifyRequest, register NULL callbacks.
// 
// \warning         Disabling hello verification allows your server to be used
// for amplification in DoS attacks against other hosts.
// Only disable if you known this can't happen in your
// particular environment.
// 
// \note            See comments on \c mbedtls_ssl_handshake() about handling
// the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected
// on the first handshake attempt when this is enabled.
// 
// \note            This is also necessary to handle client reconnection from
// the same port as described in RFC 6347 section 4.2.8 (only
// the variant with cookies is supported currently). See
// comments on \c mbedtls_ssl_read() for details.
// 
// \param conf              SSL configuration
// \param f_cookie_write    Cookie write callback
// \param f_cookie_check    Cookie check callback
// \param p_cookie          Context for both callbacks
pub extern external/mbedtls-ssl-conf-dtls-cookies(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-cookie-write: c-pointer<mbedtls-ssl-cookie-write-t>, ^f-cookie-check: c-pointer<mbedtls-ssl-cookie-check-t>, ^p-cookie: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_dtls_cookies((struct mbedtls_ssl_config*)#1, (mbedtls_ssl_cookie_write_t*)#2, (mbedtls_ssl_cookie_check_t*)#3, (void*)#4)"

// \brief          Set client's transport-level identification info.
// (Server only. DTLS only.)
// 
// This is usually the IP address (and port), but could be
// anything identify the client depending on the underlying
// network stack. Used for HelloVerifyRequest with DTLS.
// This is *not* used to route the actual packets.
// 
// \param ssl      SSL context
// \param info     Transport-level info identifying the client (eg IP + port)
// \param ilen     Length of info in bytes
// 
// \note           An internal copy is made, so the info buffer can be reused.
// 
// \return         0 on success,
// MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,
// MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory.
pub extern external/mbedtls-ssl-set-client-transport-id(^ssl: c-pointer<mbedtls-ssl-context-c>, ^info: c-pointer<int>, ^ilen: ssize_t): int32
  c inline "(int)mbedtls_ssl_set_client_transport_id((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-set-client-transport-id(^ssl: c-pointer<mbedtls-ssl-context-c>, ^info: c-pointer<int>, ^ilen: int): <> int
  external/mbedtls-ssl-set-client-transport-id(ssl, info, ilen.ssize_t).int

// \brief          Enable or disable anti-replay protection for DTLS.
// (DTLS only, no effect on TLS.)
// Default: enabled.
// 
// \param conf     SSL configuration
// \param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED.
// 
// \warning        Disabling this is a security risk unless the application
// protocol handles duplicated packets in a safe way. You
// should not disable this without careful consideration.
// However, if your application already detects duplicated
// packets and needs information about them to adjust its
// transmission strategy, then you'll want to disable this.
pub extern external/mbedtls-ssl-conf-dtls-anti-replay(^conf: c-pointer<mbedtls-ssl-config-c>, ^mode: int8): ()
  c inline "(void)mbedtls_ssl_conf_dtls_anti_replay((struct mbedtls_ssl_config*)#1, (char)#2)"

pub inline fun ffi/mbedtls-ssl-conf-dtls-anti-replay(^conf: c-pointer<mbedtls-ssl-config-c>, ^mode: int): <> ()
  external/mbedtls-ssl-conf-dtls-anti-replay(conf, mode.int8)

// \brief          Set a limit on the number of records with a bad MAC
// before terminating the connection.
// (DTLS only, no effect on TLS.)
// Default: 0 (disabled).
// 
// \param conf     SSL configuration
// \param limit    Limit, or 0 to disable.
// 
// \note           If the limit is N, then the connection is terminated when
// the Nth non-authentic record is seen.
// 
// \note           Records with an invalid header are not counted, only the
// ones going through the authentication-decryption phase.
// 
// \note           This is a security trade-off related to the fact that it's
// often relatively easy for an active attacker to inject UDP
// datagrams. On one hand, setting a low limit here makes it
// easier for such an attacker to forcibly terminated a
// connection. On the other hand, a high limit or no limit
// might make us waste resources checking authentication on
// many bogus packets.
pub extern external/mbedtls-ssl-conf-dtls-badmac-limit(^conf: c-pointer<mbedtls-ssl-config-c>, ^limit: int32): ()
  c inline "(void)mbedtls_ssl_conf_dtls_badmac_limit((struct mbedtls_ssl_config*)#1, (unsigned int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-dtls-badmac-limit(^conf: c-pointer<mbedtls-ssl-config-c>, ^limit: int): <> ()
  external/mbedtls-ssl-conf-dtls-badmac-limit(conf, limit.int32)

// \brief          Allow or disallow packing of multiple handshake records
// within a single datagram.
// 
// \param ssl           The SSL context to configure.
// \param allow_packing This determines whether datagram packing may
// be used or not. A value of \c 0 means that every
// record will be sent in a separate datagram; a
// value of \c 1 means that, if space permits,
// multiple handshake messages (including CCS) belonging to
// a single flight may be packed within a single datagram.
// 
// \note           This is enabled by default and should only be disabled
// for test purposes, or if datagram packing causes
// interoperability issues with peers that don't support it.
// 
// \note           Allowing datagram packing reduces the network load since
// there's less overhead if multiple messages share the same
// datagram. Also, it increases the handshake efficiency
// since messages belonging to a single datagram will not
// be reordered in transit, and so future message buffering
// or flight retransmission (if no buffering is used) as
// means to deal with reordering are needed less frequently.
// 
// \note           Application records are not affected by this option and
// are currently always sent in separate datagrams.
pub extern external/mbedtls-ssl-set-datagram-packing(^ssl: c-pointer<mbedtls-ssl-context-c>, ^allow-packing: int32): ()
  c inline "(void)mbedtls_ssl_set_datagram_packing((struct mbedtls_ssl_context*)#1, (unsigned int)#2)"

pub inline fun ffi/mbedtls-ssl-set-datagram-packing(^ssl: c-pointer<mbedtls-ssl-context-c>, ^allow-packing: int): <> ()
  external/mbedtls-ssl-set-datagram-packing(ssl, allow-packing.int32)

// \brief          Set retransmit timeout values for the DTLS handshake.
// (DTLS only, no effect on TLS.)
// 
// \param conf     SSL configuration
// \param min      Initial timeout value in milliseconds.
// Default: 1000 (1 second).
// \param max      Maximum timeout value in milliseconds.
// Default: 60000 (60 seconds).
// 
// \note           Default values are from RFC 6347 section 4.2.4.1.
// 
// \note           The 'min' value should typically be slightly above the
// expected round-trip time to your peer, plus whatever time
// it takes for the peer to process the message. For example,
// if your RTT is about 600ms and you peer needs up to 1s to
// do the cryptographic operations in the handshake, then you
// should set 'min' slightly above 1600. Lower values of 'min'
// might cause spurious resends which waste network resources,
// while larger value of 'min' will increase overall latency
// on unreliable network links.
// 
// \note           The more unreliable your network connection is, the larger
// your max / min ratio needs to be in order to achieve
// reliable handshakes.
// 
// \note           Messages are retransmitted up to log2(ceil(max/min)) times.
// For example, if min = 1s and max = 5s, the retransmit plan
// goes: send ... 1s -> resend ... 2s -> resend ... 4s ->
// resend ... 5s -> give up and return a timeout error.
pub extern external/mbedtls-ssl-conf-handshake-timeout(^conf: c-pointer<mbedtls-ssl-config-c>, ^min: int32, ^max: int32): ()
  c inline "(void)mbedtls_ssl_conf_handshake_timeout((struct mbedtls_ssl_config*)#1, (int32_t)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-ssl-conf-handshake-timeout(^conf: c-pointer<mbedtls-ssl-config-c>, ^min: int, ^max: int): <> ()
  external/mbedtls-ssl-conf-handshake-timeout(conf, min.int32, max.int32)

// \brief          Set the session cache callbacks (server-side only)
// If not set, no session resuming is done (except if session
// tickets are enabled too).
// 
// The session cache has the responsibility to check for stale
// entries based on timeout. See RFC 5246 for recommendations.
// 
// Warning: session.peer_cert is cleared by the SSL/TLS layer on
// connection shutdown, so do not cache the pointer! Either set
// it to NULL or make a full copy of the certificate.
// 
// The get callback is called once during the initial handshake
// to enable session resuming. The get function has the
// following parameters: (void *parameter, mbedtls_ssl_session *session)
// If a valid entry is found, it should fill the master of
// the session object with the cached values and return 0,
// return 1 otherwise. Optionally peer_cert can be set as well
// if it is properly present in cache entry.
// 
// The set callback is called once during the initial handshake
// to enable session resuming after the entire handshake has
// been finished. The set function has the following parameters:
// (void *parameter, const mbedtls_ssl_session *session). The function
// should create a cache entry for future retrieval based on
// the data in the session structure and should keep in mind
// that the mbedtls_ssl_session object presented (and all its referenced
// data) is cleared by the SSL/TLS layer when the connection is
// terminated. It is recommended to add metadata to determine if
// an entry is still valid in the future. Return 0 if
// successfully cached, return 1 otherwise.
// 
// \param conf           SSL configuration
// \param p_cache        parameter (context) for both callbacks
// \param f_get_cache    session get callback
// \param f_set_cache    session set callback
pub extern external/mbedtls-ssl-conf-session-cache(^conf: c-pointer<mbedtls-ssl-config-c>, ^p-cache: c-pointer<()>, ^f-get-cache: c-pointer<mbedtls-ssl-cache-get-t>, ^f-set-cache: c-pointer<mbedtls-ssl-cache-set-t>): ()
  c inline "(void)mbedtls_ssl_conf_session_cache((struct mbedtls_ssl_config*)#1, (void*)#2, (mbedtls_ssl_cache_get_t*)#3, (mbedtls_ssl_cache_set_t*)#4)"

// \brief          Load a session for session resumption.
// 
// Sessions loaded through this call will be considered
// for session resumption in the next handshake.
// 
// \note           Even if this call succeeds, it is not guaranteed that
// the next handshake will indeed be shortened through the
// use of session resumption: The server is always free
// to reject any attempt for resumption and fall back to
// a full handshake.
// 
// \note           This function can handle a variety of mechanisms for session
// resumption: For TLS 1.2, both session ID-based resumption and
// ticket-based resumption will be considered. For TLS 1.3,
// once implemented, sessions equate to tickets, and loading
// one or more sessions via this call will lead to their
// corresponding tickets being advertised as resumption PSKs
// by the client.
// 
// \note           Calling this function multiple times will only be useful
// once TLS 1.3 is supported. For TLS 1.2 connections, this
// function should be called at most once.
// 
// \param ssl      The SSL context representing the connection which should
// be attempted to be setup using session resumption. This
// must be initialized via mbedtls_ssl_init() and bound to
// an SSL configuration via mbedtls_ssl_setup(), but
// the handshake must not yet have been started.
// \param session  The session to be considered for session resumption.
// This must be a session previously exported via
// mbedtls_ssl_get_session(), and potentially serialized and
// deserialized through mbedtls_ssl_session_save() and
// mbedtls_ssl_session_load() in the meantime.
// 
// \return         \c 0 if successful.
// \return         \c MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if the session
// could not be loaded because of an implementation limitation.
// This error is non-fatal, and has no observable effect on
// the SSL context or the session that was attempted to be loaded.
// \return         Another negative error code on other kinds of failure.
// 
// \sa             mbedtls_ssl_get_session()
// \sa             mbedtls_ssl_session_load()
pub extern external/mbedtls-ssl-set-session(^ssl: c-pointer<mbedtls-ssl-context-c>, ^session: c-pointer<mbedtls-ssl-session-c>): int32
  c inline "(int)mbedtls_ssl_set_session((struct mbedtls_ssl_context*)#1, (struct mbedtls_ssl_session*)#2)"

pub inline fun ffi/mbedtls-ssl-set-session(^ssl: c-pointer<mbedtls-ssl-context-c>, ^session: c-pointer<mbedtls-ssl-session-c>): <> int
  external/mbedtls-ssl-set-session(ssl, session).int

// \brief          Load serialized session data into a session structure.
// On client, this can be used for loading saved sessions
// before resuming them with mbedtls_ssl_set_session().
// On server, this can be used for alternative implementations
// of session cache or session tickets.
// 
// \warning        If a peer certificate chain is associated with the session,
// the serialized state will only contain the peer's
// end-entity certificate and the result of the chain
// verification (unless verification was disabled), but not
// the rest of the chain.
// 
// \see            mbedtls_ssl_session_save()
// \see            mbedtls_ssl_set_session()
// 
// \param session  The session structure to be populated. It must have been
// initialised with mbedtls_ssl_session_init() but not
// populated yet.
// \param buf      The buffer holding the serialized session data. It must be a
// readable buffer of at least \p len bytes.
// \param len      The size of the serialized data in bytes.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.
// \return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid.
// \return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data
// was generated in a different version or configuration of
// Mbed TLS.
// \return         Another negative value for other kinds of errors (for
// example, unsupported features in the embedded certificate).
pub extern external/mbedtls-ssl-session-load(^session: c-pointer<mbedtls-ssl-session-c>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ssl_session_load((struct mbedtls_ssl_session*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-session-load(^session: c-pointer<mbedtls-ssl-session-c>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ssl-session-load(session, buf, len.ssize_t).int

// \brief          Save session structure as serialized data in a buffer.
// On client, this can be used for saving session data,
// potentially in non-volatile storage, for resuming later.
// On server, this can be used for alternative implementations
// of session cache or session tickets.
// 
// \see            mbedtls_ssl_session_load()
// 
// \param session  The session structure to be saved.
// \param buf      The buffer to write the serialized data to. It must be a
// writeable buffer of at least \p buf_len bytes, or may be \c
// NULL if \p buf_len is \c 0.
// \param buf_len  The number of bytes available for writing in \p buf.
// \param olen     The size in bytes of the data that has been or would have
// been written. It must point to a valid \c size_t.
// 
// \note           \p olen is updated to the correct value regardless of
// whether \p buf_len was large enough. This makes it possible
// to determine the necessary size by calling this function
// with \p buf set to \c NULL and \p buf_len to \c 0.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \p buf is too small.
pub extern external/mbedtls-ssl-session-save(^session: c-pointer<mbedtls-ssl-session-c>, ^buf: c-pointer<int>, ^buf-len: ssize_t, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_session_save((struct mbedtls_ssl_session*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-ssl-session-save(^session: c-pointer<mbedtls-ssl-session-c>, ^buf: c-pointer<int>, ^buf-len: int, ^olen: c-pointer<int>): <> int
  external/mbedtls-ssl-session-save(session, buf, buf-len.ssize_t, olen).int

// \brief               Set the list of allowed ciphersuites and the preference
// order. First in the list has the highest preference.
// 
// For TLS 1.2, the notion of ciphersuite determines both
// the key exchange mechanism and the suite of symmetric
// algorithms to be used during and after the handshake.
// 
// For TLS 1.3 (in development), the notion of ciphersuite
// only determines the suite of symmetric algorithms to be
// used during and after the handshake, while key exchange
// mechanisms are configured separately.
// 
// In Mbed TLS, ciphersuites for both TLS 1.2 and TLS 1.3
// are configured via this function. For users of TLS 1.3,
// there will be separate API for the configuration of key
// exchange mechanisms.
// 
// The list of ciphersuites passed to this function may
// contain a mixture of TLS 1.2 and TLS 1.3 ciphersuite
// identifiers. This is useful if negotiation of TLS 1.3
// should be attempted, but a fallback to TLS 1.2 would
// be tolerated.
// 
// \note                By default, the server chooses its preferred
// ciphersuite among those that the client supports. If
// mbedtls_ssl_conf_preference_order() is called to prefer
// the client's preferences, the server instead chooses
// the client's preferred ciphersuite among those that
// the server supports.
// 
// \warning             The ciphersuites array \p ciphersuites is not copied.
// It must remain valid for the lifetime of the SSL
// configuration \p conf.
// 
// \param conf          The SSL configuration to modify.
// \param ciphersuites  A 0-terminated list of IANA identifiers of supported
// ciphersuites, accessible through \c MBEDTLS_TLS_XXX
// and \c MBEDTLS_TLS1_3_XXX macros defined in
// ssl_ciphersuites.h.
pub extern external/mbedtls-ssl-conf-ciphersuites(^conf: c-pointer<mbedtls-ssl-config-c>, ^ciphersuites: c-pointer<int>): ()
  c inline "(void)mbedtls_ssl_conf_ciphersuites((struct mbedtls_ssl_config*)#1, (int*)#2)"

// \brief Set the supported key exchange modes for TLS 1.3 connections.
// 
// In contrast to TLS 1.2, the ciphersuite concept in TLS 1.3 does not
// include the choice of key exchange mechanism. It is therefore not
// covered by the API mbedtls_ssl_conf_ciphersuites(). See the
// documentation of mbedtls_ssl_conf_ciphersuites() for more
// information on the ciphersuite concept in TLS 1.2 and TLS 1.3.
// 
// The present function is specific to TLS 1.3 and allows users to
// configure the set of supported key exchange mechanisms in TLS 1.3.
// 
// \param conf       The SSL configuration the change should apply to.
// \param kex_modes  A bitwise combination of one or more of the following:
// - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK
// This flag enables pure-PSK key exchanges.
// - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL
// This flag enables combined PSK-ephemeral key exchanges.
// - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL
// This flag enables pure-ephemeral key exchanges.
// For convenience, the following pre-defined macros are
// available for combinations of the above:
// - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL
// Includes all of pure-PSK, PSK-ephemeral and pure-ephemeral.
// - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL
// Includes both pure-PSK and combined PSK-ephemeral
// key exchanges, but excludes pure-ephemeral key exchanges.
// - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL
// Includes both pure-ephemeral and combined PSK-ephemeral
// key exchanges.
// 
// \note  If a PSK-based key exchange mode shall be supported, applications
// must also use the APIs mbedtls_ssl_conf_psk() or
// mbedtls_ssl_conf_psk_cb() or mbedtls_ssl_conf_psk_opaque()
// to configure the PSKs to be used.
// 
// \note  If a pure-ephemeral key exchange mode shall be supported,
// server-side applications must also provide a certificate via
// mbedtls_ssl_conf_own_cert().
pub extern external/mbedtls-ssl-conf-tls13-key-exchange-modes(^conf: c-pointer<mbedtls-ssl-config-c>, ^kex-modes: int32): ()
  c inline "(void)mbedtls_ssl_conf_tls13_key_exchange_modes((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-tls13-key-exchange-modes(^conf: c-pointer<mbedtls-ssl-config-c>, ^kex-modes: int): <> ()
  external/mbedtls-ssl-conf-tls13-key-exchange-modes(conf, kex-modes.int32)

// \brief               Specify the length of Connection IDs for incoming
// encrypted DTLS records, as well as the behaviour
// on unexpected CIDs.
// 
// By default, the CID length is set to \c 0,
// and unexpected CIDs are silently ignored.
// 
// \param conf          The SSL configuration to modify.
// \param len           The length in Bytes of the CID fields in encrypted
// DTLS records using the CID mechanism. This must
// not be larger than #MBEDTLS_SSL_CID_OUT_LEN_MAX.
// \param ignore_other_cids This determines the stack's behaviour when
// receiving a record with an unexpected CID.
// Possible values are:
// - #MBEDTLS_SSL_UNEXPECTED_CID_IGNORE
// In this case, the record is silently ignored.
// - #MBEDTLS_SSL_UNEXPECTED_CID_FAIL
// In this case, the stack fails with the specific
// error code #MBEDTLS_ERR_SSL_UNEXPECTED_CID.
// 
// \note                The CID specification allows implementations to either
// use a common length for all incoming connection IDs or
// allow variable-length incoming IDs. Mbed TLS currently
// requires a common length for all connections sharing the
// same SSL configuration; this allows simpler parsing of
// record headers.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if \p len
// is too large.
pub extern external/mbedtls-ssl-conf-cid(^conf: c-pointer<mbedtls-ssl-config-c>, ^len: ssize_t, ^ignore-other-cids: int32): int32
  c inline "(int)mbedtls_ssl_conf_cid((struct mbedtls_ssl_config*)#1, (size_t)#2, (int)#3)"

pub inline fun ffi/mbedtls-ssl-conf-cid(^conf: c-pointer<mbedtls-ssl-config-c>, ^len: int, ^ignore-other-cids: int): <> int
  external/mbedtls-ssl-conf-cid(conf, len.ssize_t, ignore-other-cids.int32).int

// \brief          Set the X.509 security profile used for verification
// 
// \note           The restrictions are enforced for all certificates in the
// chain. However, signatures in the handshake are not covered
// by this setting but by \b mbedtls_ssl_conf_sig_hashes().
// 
// \param conf     SSL configuration
// \param profile  Profile to use
pub extern external/mbedtls-ssl-conf-cert-profile(^conf: c-pointer<mbedtls-ssl-config-c>, ^profile: c-pointer<mbedtls-x509-crt-profile-c>): ()
  c inline "(void)mbedtls_ssl_conf_cert_profile((struct mbedtls_ssl_config*)#1, (struct mbedtls_x509_crt_profile*)#2)"

// \brief          Set the data required to verify peer certificate
// 
// \note           See \c mbedtls_x509_crt_verify() for notes regarding the
// parameters ca_chain (maps to trust_ca for that function)
// and ca_crl.
// 
// \param conf     SSL configuration
// \param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)
// \param ca_crl   trusted CA CRLs
pub extern external/mbedtls-ssl-conf-ca-chain(^conf: c-pointer<mbedtls-ssl-config-c>, ^ca-chain: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>): ()
  c inline "(void)mbedtls_ssl_conf_ca_chain((struct mbedtls_ssl_config*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_x509_crl*)#3)"

// \brief          Set own certificate chain and private key
// 
// \note           own_cert should contain in order from the bottom up your
// certificate chain. The top certificate (self-signed)
// can be omitted.
// 
// \note           On server, this function can be called multiple times to
// provision more than one cert/key pair (eg one ECDSA, one
// RSA with SHA-256, one RSA with SHA-1). An adequate
// certificate will be selected according to the client's
// advertised capabilities. In case multiple certificates are
// adequate, preference is given to the one set by the first
// call to this function, then second, etc.
// 
// \note           On client, only the first call has any effect. That is,
// only one client certificate can be provisioned. The
// server's preferences in its CertificateRequest message will
// be ignored and our only cert will be sent regardless of
// whether it matches those preferences - the server can then
// decide what it wants to do with it.
// 
// \note           The provided \p pk_key needs to match the public key in the
// first certificate in \p own_cert, or all handshakes using
// that certificate will fail. It is your responsibility
// to ensure that; this function will not perform any check.
// You may use mbedtls_pk_check_pair() in order to perform
// this check yourself, but be aware that this function can
// be computationally expensive on some key types.
// 
// \param conf     SSL configuration
// \param own_cert own public certificate chain
// \param pk_key   own private key
// 
// \return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED
pub extern external/mbedtls-ssl-conf-own-cert(^conf: c-pointer<mbedtls-ssl-config-c>, ^own-cert: c-pointer<mbedtls-x509-crt-c>, ^pk-key: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int)mbedtls_ssl_conf_own_cert((struct mbedtls_ssl_config*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_pk_context*)#3)"

pub inline fun ffi/mbedtls-ssl-conf-own-cert(^conf: c-pointer<mbedtls-ssl-config-c>, ^own-cert: c-pointer<mbedtls-x509-crt-c>, ^pk-key: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-ssl-conf-own-cert(conf, own-cert, pk-key).int

// \brief          Configure pre-shared keys (PSKs) and their
// identities to be used in PSK-based ciphersuites.
// 
// Only one PSK can be registered, through either
// mbedtls_ssl_conf_psk() or mbedtls_ssl_conf_psk_opaque().
// If you attempt to register more than one PSK, this function
// fails, though this may change in future versions, which
// may add support for multiple PSKs.
// 
// \note           This is mainly useful for clients. Servers will usually
// want to use \c mbedtls_ssl_conf_psk_cb() instead.
// 
// \note           A PSK set by \c mbedtls_ssl_set_hs_psk() in the PSK callback
// takes precedence over a PSK configured by this function.
// 
// \param conf     The SSL configuration to register the PSK with.
// \param psk      The pointer to the pre-shared key to use.
// \param psk_len  The length of the pre-shared key in bytes.
// \param psk_identity      The pointer to the pre-shared key identity.
// \param psk_identity_len  The length of the pre-shared key identity
// in bytes.
// 
// \note           The PSK and its identity are copied internally and
// hence need not be preserved by the caller for the lifetime
// of the SSL configuration.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no more PSKs
// can be configured. In this case, the old PSK(s) remain intact.
// \return         Another negative error code on other kinds of failure.
pub extern external/mbedtls-ssl-conf-psk(^conf: c-pointer<mbedtls-ssl-config-c>, ^psk: c-pointer<int>, ^psk-len: ssize_t, ^psk-identity: c-pointer<int>, ^psk-identity-len: ssize_t): int32
  c inline "(int)mbedtls_ssl_conf_psk((struct mbedtls_ssl_config*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ssl-conf-psk(^conf: c-pointer<mbedtls-ssl-config-c>, ^psk: c-pointer<int>, ^psk-len: int, ^psk-identity: c-pointer<int>, ^psk-identity-len: int): <> int
  external/mbedtls-ssl-conf-psk(conf, psk, psk-len.ssize_t, psk-identity, psk-identity-len.ssize_t).int

// \brief          Set the pre-shared Key (PSK) for the current handshake.
// 
// \note           This should only be called inside the PSK callback,
// i.e. the function passed to \c mbedtls_ssl_conf_psk_cb().
// 
// \note           A PSK set by this function takes precedence over a PSK
// configured by \c mbedtls_ssl_conf_psk().
// 
// \param ssl      The SSL context to configure a PSK for.
// \param psk      The pointer to the pre-shared key.
// \param psk_len  The length of the pre-shared key in bytes.
// 
// \return         \c 0 if successful.
// \return         An \c MBEDTLS_ERR_SSL_XXX error code on failure.
pub extern external/mbedtls-ssl-set-hs-psk(^ssl: c-pointer<mbedtls-ssl-context-c>, ^psk: c-pointer<int>, ^psk-len: ssize_t): int32
  c inline "(int)mbedtls_ssl_set_hs_psk((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-set-hs-psk(^ssl: c-pointer<mbedtls-ssl-context-c>, ^psk: c-pointer<int>, ^psk-len: int): <> int
  external/mbedtls-ssl-set-hs-psk(ssl, psk, psk-len.ssize_t).int

// \brief          Set the PSK callback (server-side only).
// 
// If set, the PSK callback is called for each
// handshake where a PSK-based ciphersuite was negotiated.
// The caller provides the identity received and wants to
// receive the actual PSK data and length.
// 
// The callback has the following parameters:
// - \c void*: The opaque pointer \p p_psk.
// - \c mbedtls_ssl_context*: The SSL context to which
// the operation applies.
// - \c const unsigned char*: The PSK identity
// selected by the client.
// - \c size_t: The length of the PSK identity
// selected by the client.
// 
// If a valid PSK identity is found, the callback should use
// \c mbedtls_ssl_set_hs_psk() or
// \c mbedtls_ssl_set_hs_psk_opaque()
// on the SSL context to set the correct PSK and return \c 0.
// Any other return value will result in a denied PSK identity.
// 
// \note           A dynamic PSK (i.e. set by the PSK callback) takes
// precedence over a static PSK (i.e. set by
// \c mbedtls_ssl_conf_psk() or
// \c mbedtls_ssl_conf_psk_opaque()).
// This means that if you set a PSK callback using this
// function, you don't need to set a PSK using
// \c mbedtls_ssl_conf_psk() or
// \c mbedtls_ssl_conf_psk_opaque()).
// 
// \param conf     The SSL configuration to register the callback with.
// \param f_psk    The callback for selecting and setting the PSK based
// in the PSK identity chosen by the client.
// \param p_psk    A pointer to an opaque structure to be passed to
// the callback, for example a PSK store.
pub extern external/mbedtls-ssl-conf-psk-cb(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-psk: c-pointer<intptr_t>, ^p-psk: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_psk_cb((struct mbedtls_ssl_config*)#1, (int (*)(void*, struct mbedtls_ssl_context*, unsigned char*, size_t))#2, (void*)#3)"

// \brief          Set the Diffie-Hellman public P and G values
// from big-endian binary presentations.
// (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)
// 
// \param conf     SSL configuration
// \param dhm_P    Diffie-Hellman-Merkle modulus in big-endian binary form
// \param P_len    Length of DHM modulus
// \param dhm_G    Diffie-Hellman-Merkle generator in big-endian binary form
// \param G_len    Length of DHM generator
// 
// \return         0 if successful
pub extern external/mbedtls-ssl-conf-dh-param-bin(^conf: c-pointer<mbedtls-ssl-config-c>, ^dhm-p: c-pointer<int>, ^p-len: ssize_t, ^dhm-g: c-pointer<int>, ^g-len: ssize_t): int32
  c inline "(int)mbedtls_ssl_conf_dh_param_bin((struct mbedtls_ssl_config*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ssl-conf-dh-param-bin(^conf: c-pointer<mbedtls-ssl-config-c>, ^dhm-p: c-pointer<int>, ^p-len: int, ^dhm-g: c-pointer<int>, ^g-len: int): <> int
  external/mbedtls-ssl-conf-dh-param-bin(conf, dhm-p, p-len.ssize_t, dhm-g, g-len.ssize_t).int

// \brief          Set the Diffie-Hellman public P and G values,
// read from existing context (server-side only)
// 
// \param conf     SSL configuration
// \param dhm_ctx  Diffie-Hellman-Merkle context
// 
// \return         0 if successful
pub extern external/mbedtls-ssl-conf-dh-param-ctx(^conf: c-pointer<mbedtls-ssl-config-c>, ^dhm-ctx: c-pointer<mbedtls-dhm-context-c>): int32
  c inline "(int)mbedtls_ssl_conf_dh_param_ctx((struct mbedtls_ssl_config*)#1, (struct mbedtls_dhm_context*)#2)"

pub inline fun ffi/mbedtls-ssl-conf-dh-param-ctx(^conf: c-pointer<mbedtls-ssl-config-c>, ^dhm-ctx: c-pointer<mbedtls-dhm-context-c>): <> int
  external/mbedtls-ssl-conf-dh-param-ctx(conf, dhm-ctx).int

// \brief          Set the minimum length for Diffie-Hellman parameters.
// (Client-side only.)
// (Default: 1024 bits.)
// 
// \param conf     SSL configuration
// \param bitlen   Minimum bit length of the DHM prime
pub extern external/mbedtls-ssl-conf-dhm-min-bitlen(^conf: c-pointer<mbedtls-ssl-config-c>, ^bitlen: int32): ()
  c inline "(void)mbedtls_ssl_conf_dhm_min_bitlen((struct mbedtls_ssl_config*)#1, (unsigned int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-dhm-min-bitlen(^conf: c-pointer<mbedtls-ssl-config-c>, ^bitlen: int): <> ()
  external/mbedtls-ssl-conf-dhm-min-bitlen(conf, bitlen.int32)

// \brief          Set the allowed curves in order of preference.
// 
// On server: this only affects selection of the ECDHE curve;
// the curves used for ECDH and ECDSA are determined by the
// list of available certificates instead.
// 
// On client: this affects the list of curves offered for any
// use. The server can override our preference order.
// 
// Both sides: limits the set of curves accepted for use in
// ECDHE and in the peer's end-entity certificate.
// 
// \deprecated     Superseded by mbedtls_ssl_conf_groups().
// 
// \note           This has no influence on which curves are allowed inside the
// certificate chains, see \c mbedtls_ssl_conf_cert_profile()
// for that. For the end-entity certificate however, the key
// will be accepted only if it is allowed both by this list
// and by the cert profile.
// 
// \note           This list should be ordered by decreasing preference
// (preferred curve first).
// 
// \note           The default list is the same set of curves that
// #mbedtls_x509_crt_profile_default allows, plus
// ECDHE-only curves selected according to the same criteria.
// The order favors curves with the lowest resource usage.
// 
// \note           New minor versions of Mbed TLS may extend this list,
// for example if new curves are added to the library.
// New minor versions of Mbed TLS will not remove items
// from this list unless serious security concerns require it.
// New minor versions of Mbed TLS may change the order in
// keeping with the general principle of favoring the lowest
// resource usage.
// 
// \param conf     SSL configuration
// \param curves   Ordered list of allowed curves,
// terminated by MBEDTLS_ECP_DP_NONE.
pub extern external/mbedtls-ssl-conf-curves(^conf: c-pointer<mbedtls-ssl-config-c>, ^curves: c-pointer<mbedtls-ecp-group-id>): ()
  c inline "(void)mbedtls_ssl_conf_curves((struct mbedtls_ssl_config*)#1, (int32_t*)#2)"

// \brief          Set the allowed groups in order of preference.
// 
// On server: This only affects the choice of key agreement mechanism
// 
// On client: this affects the list of groups offered for any
// use. The server can override our preference order.
// 
// Both sides: limits the set of groups accepted for use in
// key sharing.
// 
// \note           This function replaces the deprecated mbedtls_ssl_conf_curves(),
// which only allows ECP curves to be configured.
// 
// \note           The most recent invocation of either mbedtls_ssl_conf_curves()
// or mbedtls_ssl_conf_groups() nullifies all previous invocations
// of both.
// 
// \note           This list should be ordered by decreasing preference
// (preferred group first).
// 
// \note           When this function is not called, a default list is used,
// consisting of all supported curves at 255 bits and above,
// and all supported finite fields at 2048 bits and above.
// The order favors groups with the lowest resource usage.
// 
// \note           New minor versions of Mbed TLS will not remove items
// from the default list unless serious security concerns require it.
// New minor versions of Mbed TLS may change the order in
// keeping with the general principle of favoring the lowest
// resource usage.
// 
// \param conf     SSL configuration
// \param groups   List of allowed groups ordered by preference, terminated by 0.
// Must contain valid IANA NamedGroup IDs (provided via either an integer
// or using MBEDTLS_TLS1_3_NAMED_GROUP_XXX macros).
pub extern external/mbedtls-ssl-conf-groups(^conf: c-pointer<mbedtls-ssl-config-c>, ^groups: c-pointer<int>): ()
  c inline "(void)mbedtls_ssl_conf_groups((struct mbedtls_ssl_config*)#1, (int16_t*)#2)"

// \brief          Set the allowed hashes for signatures during the handshake.
// 
// \note           This only affects which hashes are offered and can be used
// for signatures during the handshake. Hashes for message
// authentication and the TLS PRF are controlled by the
// ciphersuite, see \c mbedtls_ssl_conf_ciphersuites(). Hashes
// used for certificate signature are controlled by the
// verification profile, see \c mbedtls_ssl_conf_cert_profile().
// 
// \deprecated     Superseded by mbedtls_ssl_conf_sig_algs().
// 
// \note           This list should be ordered by decreasing preference
// (preferred hash first).
// 
// \note           By default, all supported hashes whose length is at least
// 256 bits are allowed. This is the same set as the default
// for certificate verification
// (#mbedtls_x509_crt_profile_default).
// The preference order is currently unspecified and may
// change in future versions.
// 
// \note           New minor versions of Mbed TLS may extend this list,
// for example if new curves are added to the library.
// New minor versions of Mbed TLS will not remove items
// from this list unless serious security concerns require it.
// 
// \param conf     SSL configuration
// \param hashes   Ordered list of allowed signature hashes,
// terminated by \c MBEDTLS_MD_NONE.
pub extern external/mbedtls-ssl-conf-sig-hashes(^conf: c-pointer<mbedtls-ssl-config-c>, ^hashes: c-pointer<int>): ()
  c inline "(void)mbedtls_ssl_conf_sig_hashes((struct mbedtls_ssl_config*)#1, (int*)#2)"

// \brief          Configure allowed signature algorithms for use in TLS
// 
// \param conf     The SSL configuration to use.
// \param sig_algs List of allowed IANA values for TLS 1.3 signature algorithms,
// terminated by #MBEDTLS_TLS1_3_SIG_NONE. The list must remain
// available throughout the lifetime of the conf object.
// - For TLS 1.3, values of \c MBEDTLS_TLS1_3_SIG_XXXX should be
// used.
// - For TLS 1.2, values should be given as
// "(HashAlgorithm << 8) | SignatureAlgorithm".
pub extern external/mbedtls-ssl-conf-sig-algs(^conf: c-pointer<mbedtls-ssl-config-c>, ^sig-algs: c-pointer<int>): ()
  c inline "(void)mbedtls_ssl_conf_sig_algs((struct mbedtls_ssl_config*)#1, (int16_t*)#2)"

// \brief          Set or reset the hostname to check against the received
// server certificate. It sets the ServerName TLS extension,
// too, if that extension is enabled. (client-side only)
// 
// \param ssl      SSL context
// \param hostname the server hostname, may be NULL to clear hostname
// 
// \note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN.
// 
// \return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on
// allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on
// too long input hostname.
// 
// Hostname set to the one provided on success (cleared
// when NULL). On allocation failure hostname is cleared.
// On too long input failure, old hostname is unchanged.
pub extern external/mbedtls-ssl-set-hostname(^ssl: c-pointer<mbedtls-ssl-context-c>, ^hostname: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_set_hostname((struct mbedtls_ssl_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-ssl-set-hostname(^ssl: c-pointer<mbedtls-ssl-context-c>, ^hostname: c-pointer<int>): <> int
  external/mbedtls-ssl-set-hostname(ssl, hostname).int

// \brief          Retrieve SNI extension value for the current handshake.
// Available in \c f_cert_cb of \c mbedtls_ssl_conf_cert_cb(),
// this is the same value passed to \c f_sni callback of
// \c mbedtls_ssl_conf_sni() and may be used instead of
// \c mbedtls_ssl_conf_sni().
// 
// \param ssl      SSL context
// \param name_len pointer into which to store length of returned value.
// 0 if SNI extension is not present or not yet processed.
// 
// \return         const pointer to SNI extension value.
// - value is valid only when called in \c f_cert_cb
// registered with \c mbedtls_ssl_conf_cert_cb().
// - value is NULL if SNI extension is not present.
// - value is not '\0'-terminated. Use \c name_len for len.
// - value must not be freed.
pub extern external/mbedtls-ssl-get-hs-sni(^ssl: c-pointer<mbedtls-ssl-context-c>, ^name-len: c-pointer<int>): c-pointer<int>
  c inline "(intptr_t)mbedtls_ssl_get_hs_sni((struct mbedtls_ssl_context*)#1, (size_t*)#2)"

// \brief          Set own certificate and key for the current handshake
// 
// \note           Same as \c mbedtls_ssl_conf_own_cert() but for use within
// the SNI callback or the certificate selection callback.
// 
// \note           Passing null \c own_cert clears the certificate list for
// the current handshake.
// 
// \param ssl      SSL context
// \param own_cert own public certificate chain
// \param pk_key   own private key
// 
// \return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED
pub extern external/mbedtls-ssl-set-hs-own-cert(^ssl: c-pointer<mbedtls-ssl-context-c>, ^own-cert: c-pointer<mbedtls-x509-crt-c>, ^pk-key: c-pointer<mbedtls-pk-context-c>): int32
  c inline "(int)mbedtls_ssl_set_hs_own_cert((struct mbedtls_ssl_context*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_pk_context*)#3)"

pub inline fun ffi/mbedtls-ssl-set-hs-own-cert(^ssl: c-pointer<mbedtls-ssl-context-c>, ^own-cert: c-pointer<mbedtls-x509-crt-c>, ^pk-key: c-pointer<mbedtls-pk-context-c>): <> int
  external/mbedtls-ssl-set-hs-own-cert(ssl, own-cert, pk-key).int

// \brief          Set the data required to verify peer certificate for the
// current handshake
// 
// \note           Same as \c mbedtls_ssl_conf_ca_chain() but for use within
// the SNI callback or the certificate selection callback.
// 
// \param ssl      SSL context
// \param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)
// \param ca_crl   trusted CA CRLs
pub extern external/mbedtls-ssl-set-hs-ca-chain(^ssl: c-pointer<mbedtls-ssl-context-c>, ^ca-chain: c-pointer<mbedtls-x509-crt-c>, ^ca-crl: c-pointer<mbedtls-x509-crl-c>): ()
  c inline "(void)mbedtls_ssl_set_hs_ca_chain((struct mbedtls_ssl_context*)#1, (struct mbedtls_x509_crt*)#2, (struct mbedtls_x509_crl*)#3)"

// \brief          Set DN hints sent to client in CertificateRequest message
// 
// \note           Same as \c mbedtls_ssl_conf_dn_hints() but for use within
// the SNI callback or the certificate selection callback.
// 
// \param ssl      SSL context
// \param crt      crt chain whose subject DNs are issuer DNs of client certs
// from which the client should select client peer certificate.
pub extern external/mbedtls-ssl-set-hs-dn-hints(^ssl: c-pointer<mbedtls-ssl-context-c>, ^crt: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "(void)mbedtls_ssl_set_hs_dn_hints((struct mbedtls_ssl_context*)#1, (struct mbedtls_x509_crt*)#2)"

// \brief          Set authmode for the current handshake.
// 
// \note           Same as \c mbedtls_ssl_conf_authmode() but for use within
// the SNI callback or the certificate selection callback.
// 
// \param ssl      SSL context
// \param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or
// MBEDTLS_SSL_VERIFY_REQUIRED
pub extern external/mbedtls-ssl-set-hs-authmode(^ssl: c-pointer<mbedtls-ssl-context-c>, ^authmode: int32): ()
  c inline "(void)mbedtls_ssl_set_hs_authmode((struct mbedtls_ssl_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-set-hs-authmode(^ssl: c-pointer<mbedtls-ssl-context-c>, ^authmode: int): <> ()
  external/mbedtls-ssl-set-hs-authmode(ssl, authmode.int32)

// \brief          Set server side ServerName TLS extension callback
// (optional, server-side only).
// 
// If set, the ServerName callback is called whenever the
// server receives a ServerName TLS extension from the client
// during a handshake. The ServerName callback has the
// following parameters: (void *parameter, mbedtls_ssl_context *ssl,
// const unsigned char *hostname, size_t len). If a suitable
// certificate is found, the callback must set the
// certificate(s) and key(s) to use with \c
// mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),
// and may optionally adjust the CA and associated CRL with \c
// mbedtls_ssl_set_hs_ca_chain() as well as the client
// authentication mode with \c mbedtls_ssl_set_hs_authmode(),
// then must return 0. If no matching name is found, the
// callback may return non-zero to abort the handshake.
// 
// \param conf     SSL configuration
// \param f_sni    verification function
// \param p_sni    verification parameter
pub extern external/mbedtls-ssl-conf-sni(^conf: c-pointer<mbedtls-ssl-config-c>, ^f-sni: c-pointer<intptr_t>, ^p-sni: c-pointer<()>): ()
  c inline "(void)mbedtls_ssl_conf_sni((struct mbedtls_ssl_config*)#1, (int (*)(void*, struct mbedtls_ssl_context*, unsigned char*, size_t))#2, (void*)#3)"

// \brief          Set the supported Application Layer Protocols.
// 
// \param conf     SSL configuration
// \param protos   Pointer to a NULL-terminated list of supported protocols,
// in decreasing preference order. The pointer to the list is
// recorded by the library for later reference as required, so
// the lifetime of the table must be at least as long as the
// lifetime of the SSL configuration structure.
// 
// \return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA.
pub extern external/mbedtls-ssl-conf-alpn-protocols(^conf: c-pointer<mbedtls-ssl-config-c>, ^protos: c-pointer<c-pointer<int>>): int32
  c inline "(int)mbedtls_ssl_conf_alpn_protocols((struct mbedtls_ssl_config*)#1, (char**)#2)"

pub inline fun ffi/mbedtls-ssl-conf-alpn-protocols(^conf: c-pointer<mbedtls-ssl-config-c>, ^protos: c-pointer<c-pointer<int>>): <> int
  external/mbedtls-ssl-conf-alpn-protocols(conf, protos).int

// \brief          Get the name of the negotiated Application Layer Protocol.
// This function should be called after the handshake is
// completed.
// 
// \param ssl      SSL context
// 
// \return         Protocol name, or NULL if no protocol was negotiated.
pub extern external/mbedtls-ssl-get-alpn-protocol(^ssl: c-pointer<mbedtls-ssl-context-c>): c-pointer<int>
  c inline "(intptr_t)mbedtls_ssl_get_alpn_protocol((struct mbedtls_ssl_context*)#1)"

// \brief          Set the maximum supported version sent from the client side
// and/or accepted at the server side.
// 
// See also the documentation of mbedtls_ssl_conf_min_version().
// 
// \note           This ignores ciphersuites from higher versions.
// 
// \note           This function is deprecated and has been replaced by
// \c mbedtls_ssl_conf_max_tls_version().
// 
// \param conf     SSL configuration
// \param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)
// \param minor    Minor version number
// (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,
// #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)
pub extern external/mbedtls-ssl-conf-max-version(^conf: c-pointer<mbedtls-ssl-config-c>, ^major: int32, ^minor: int32): ()
  c inline "(void)mbedtls_ssl_conf_max_version((struct mbedtls_ssl_config*)#1, (int)#2, (int)#3)"

pub inline fun ffi/mbedtls-ssl-conf-max-version(^conf: c-pointer<mbedtls-ssl-config-c>, ^major: int, ^minor: int): <> ()
  external/mbedtls-ssl-conf-max-version(conf, major.int32, minor.int32)

// \brief          Set the minimum accepted SSL/TLS protocol version
// 
// \note           By default, all supported versions are accepted.
// Future versions of the library may disable older
// protocol versions by default if they become deprecated.
// 
// \note           The following versions are supported (if enabled at
// compile time):
// - (D)TLS 1.2: \p major = #MBEDTLS_SSL_MAJOR_VERSION_3,
// \p minor = #MBEDTLS_SSL_MINOR_VERSION_3
// - TLS 1.3: \p major = #MBEDTLS_SSL_MAJOR_VERSION_3,
// \p minor = #MBEDTLS_SSL_MINOR_VERSION_4
// 
// Note that the numbers in the constant names are the
// TLS internal protocol numbers, and the minor versions
// differ by one from the human-readable versions!
// 
// \note           Input outside of the SSL_MAX_XXXXX_VERSION and
// SSL_MIN_XXXXX_VERSION range is ignored.
// 
// \note           After the handshake, you can call
// mbedtls_ssl_get_version_number() to see what version was
// negotiated.
// 
// \note           This function is deprecated and has been replaced by
// \c mbedtls_ssl_conf_min_tls_version().
// 
// \param conf     SSL configuration
// \param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)
// \param minor    Minor version number
// (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,
// #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)
pub extern external/mbedtls-ssl-conf-min-version(^conf: c-pointer<mbedtls-ssl-config-c>, ^major: int32, ^minor: int32): ()
  c inline "(void)mbedtls_ssl_conf_min_version((struct mbedtls_ssl_config*)#1, (int)#2, (int)#3)"

pub inline fun ffi/mbedtls-ssl-conf-min-version(^conf: c-pointer<mbedtls-ssl-config-c>, ^major: int, ^minor: int): <> ()
  external/mbedtls-ssl-conf-min-version(conf, major.int32, minor.int32)

// \brief           Enable or disable Encrypt-then-MAC
// (Default: MBEDTLS_SSL_ETM_ENABLED)
// 
// \note            This should always be enabled, it is a security
// improvement, and should not cause any interoperability
// issue (used only if the peer supports it too).
// 
// \param conf      SSL configuration
// \param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED
pub extern external/mbedtls-ssl-conf-encrypt-then-mac(^conf: c-pointer<mbedtls-ssl-config-c>, ^etm: int8): ()
  c inline "(void)mbedtls_ssl_conf_encrypt_then_mac((struct mbedtls_ssl_config*)#1, (char)#2)"

pub inline fun ffi/mbedtls-ssl-conf-encrypt-then-mac(^conf: c-pointer<mbedtls-ssl-config-c>, ^etm: int): <> ()
  external/mbedtls-ssl-conf-encrypt-then-mac(conf, etm.int8)

// \brief           Enable or disable Extended Master Secret negotiation.
// (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)
// 
// \note            This should always be enabled, it is a security fix to the
// protocol, and should not cause any interoperability issue
// (used only if the peer supports it too).
// 
// \param conf      SSL configuration
// \param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED
pub extern external/mbedtls-ssl-conf-extended-master-secret(^conf: c-pointer<mbedtls-ssl-config-c>, ^ems: int8): ()
  c inline "(void)mbedtls_ssl_conf_extended_master_secret((struct mbedtls_ssl_config*)#1, (char)#2)"

pub inline fun ffi/mbedtls-ssl-conf-extended-master-secret(^conf: c-pointer<mbedtls-ssl-config-c>, ^ems: int): <> ()
  external/mbedtls-ssl-conf-extended-master-secret(conf, ems.int8)

// \brief          Whether to send a list of acceptable CAs in
// CertificateRequest messages.
// (Default: do send)
// 
// \param conf     SSL configuration
// \param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or
// MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED
pub extern external/mbedtls-ssl-conf-cert-req-ca-list(^conf: c-pointer<mbedtls-ssl-config-c>, ^cert-req-ca-list: int8): ()
  c inline "(void)mbedtls_ssl_conf_cert_req_ca_list((struct mbedtls_ssl_config*)#1, (char)#2)"

pub inline fun ffi/mbedtls-ssl-conf-cert-req-ca-list(^conf: c-pointer<mbedtls-ssl-config-c>, ^cert-req-ca-list: int): <> ()
  external/mbedtls-ssl-conf-cert-req-ca-list(conf, cert-req-ca-list.int8)

// \brief          Set the maximum fragment length to emit and/or negotiate.
// (Typical: the smaller of #MBEDTLS_SSL_IN_CONTENT_LEN and
// #MBEDTLS_SSL_OUT_CONTENT_LEN, usually `2^14` bytes)
// (Server: set maximum fragment length to emit,
// usually negotiated by the client during handshake)
// (Client: set maximum fragment length to emit *and*
// negotiate with the server during handshake)
// (Default: #MBEDTLS_SSL_MAX_FRAG_LEN_NONE)
// 
// \note           On the client side, the maximum fragment length extension
// *will not* be used, unless the maximum fragment length has
// been set via this function to a value different than
// #MBEDTLS_SSL_MAX_FRAG_LEN_NONE.
// 
// \note           With TLS, this currently only affects ApplicationData (sent
// with \c mbedtls_ssl_read()), not handshake messages.
// With DTLS, this affects both ApplicationData and handshake.
// 
// \note           This sets the maximum length for a record's payload,
// excluding record overhead that will be added to it, see
// \c mbedtls_ssl_get_record_expansion().
// 
// \note           For DTLS, it is also possible to set a limit for the total
// size of datagrams passed to the transport layer, including
// record overhead, see \c mbedtls_ssl_set_mtu().
// 
// \param conf     SSL configuration
// \param mfl_code Code for maximum fragment length (allowed values:
// MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,
// MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)
// 
// \return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA
pub extern external/mbedtls-ssl-conf-max-frag-len(^conf: c-pointer<mbedtls-ssl-config-c>, ^mfl-code: int8): int32
  c inline "(int)mbedtls_ssl_conf_max_frag_len((struct mbedtls_ssl_config*)#1, (unsigned char)#2)"

pub inline fun ffi/mbedtls-ssl-conf-max-frag-len(^conf: c-pointer<mbedtls-ssl-config-c>, ^mfl-code: int): <> int
  external/mbedtls-ssl-conf-max-frag-len(conf, mfl-code.int8).int

// \brief          Pick the ciphersuites order according to the second parameter
// in the SSL Server module (MBEDTLS_SSL_SRV_C).
// (Default, if never called: MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER)
// 
// \param conf     SSL configuration
// \param order    Server or client (MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER
// or MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT)
pub extern external/mbedtls-ssl-conf-preference-order(^conf: c-pointer<mbedtls-ssl-config-c>, ^order: int32): ()
  c inline "(void)mbedtls_ssl_conf_preference_order((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-preference-order(^conf: c-pointer<mbedtls-ssl-config-c>, ^order: int): <> ()
  external/mbedtls-ssl-conf-preference-order(conf, order.int32)

// \brief          Enable / Disable session tickets (client only).
// (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)
// 
// \note           On server, use \c mbedtls_ssl_conf_session_tickets_cb().
// 
// \param conf     SSL configuration
// \param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or
// MBEDTLS_SSL_SESSION_TICKETS_DISABLED)
pub extern external/mbedtls-ssl-conf-session-tickets(^conf: c-pointer<mbedtls-ssl-config-c>, ^use-tickets: int32): ()
  c inline "(void)mbedtls_ssl_conf_session_tickets((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-session-tickets(^conf: c-pointer<mbedtls-ssl-config-c>, ^use-tickets: int): <> ()
  external/mbedtls-ssl-conf-session-tickets(conf, use-tickets.int32)

// \brief   Number of NewSessionTicket messages for the server to send
// after handshake completion.
// 
// \note    The default value is
// \c MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS.
// 
// \note    In case of a session resumption, this setting only partially apply.
// At most one ticket is sent in that case to just renew the pool of
// tickets of the client. The rationale is to avoid the number of
// tickets on the server to become rapidly out of control when the
// server has the same configuration for all its connection instances.
// 
// \param conf    SSL configuration
// \param num_tickets    Number of NewSessionTicket.
pub extern external/mbedtls-ssl-conf-new-session-tickets(^conf: c-pointer<mbedtls-ssl-config-c>, ^num-tickets: int16): ()
  c inline "(void)mbedtls_ssl_conf_new_session_tickets((struct mbedtls_ssl_config*)#1, (int16_t)#2)"

pub inline fun ffi/mbedtls-ssl-conf-new-session-tickets(^conf: c-pointer<mbedtls-ssl-config-c>, ^num-tickets: int): <> ()
  external/mbedtls-ssl-conf-new-session-tickets(conf, num-tickets.int16)

// \brief          Enable / Disable renegotiation support for connection when
// initiated by peer
// (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)
// 
// \warning        It is recommended to always disable renegotiation unless you
// know you need it and you know what you're doing. In the
// past, there have been several issues associated with
// renegotiation or a poor understanding of its properties.
// 
// \note           Server-side, enabling renegotiation also makes the server
// susceptible to a resource DoS by a malicious client.
// 
// \param conf    SSL configuration
// \param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or
// MBEDTLS_SSL_RENEGOTIATION_DISABLED)
pub extern external/mbedtls-ssl-conf-renegotiation(^conf: c-pointer<mbedtls-ssl-config-c>, ^renegotiation: int32): ()
  c inline "(void)mbedtls_ssl_conf_renegotiation((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-renegotiation(^conf: c-pointer<mbedtls-ssl-config-c>, ^renegotiation: int): <> ()
  external/mbedtls-ssl-conf-renegotiation(conf, renegotiation.int32)

// \brief          Prevent or allow legacy renegotiation.
// (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)
// 
// MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to
// be established even if the peer does not support
// secure renegotiation, but does not allow renegotiation
// to take place if not secure.
// (Interoperable and secure option)
// 
// MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations
// with non-upgraded peers. Allowing legacy renegotiation
// makes the connection vulnerable to specific man in the
// middle attacks. (See RFC 5746)
// (Most interoperable and least secure option)
// 
// MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections
// if peer does not support secure renegotiation. Results
// in interoperability issues with non-upgraded peers
// that do not support renegotiation altogether.
// (Most secure option, interoperability issues)
// 
// \param conf     SSL configuration
// \param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,
// SSL_ALLOW_LEGACY_RENEGOTIATION or
// MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)
pub extern external/mbedtls-ssl-conf-legacy-renegotiation(^conf: c-pointer<mbedtls-ssl-config-c>, ^allow-legacy: int32): ()
  c inline "(void)mbedtls_ssl_conf_legacy_renegotiation((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-legacy-renegotiation(^conf: c-pointer<mbedtls-ssl-config-c>, ^allow-legacy: int): <> ()
  external/mbedtls-ssl-conf-legacy-renegotiation(conf, allow-legacy.int32)

// \brief          Enforce renegotiation requests.
// (Default: enforced, max_records = 16)
// 
// When we request a renegotiation, the peer can comply or
// ignore the request. This function allows us to decide
// whether to enforce our renegotiation requests by closing
// the connection if the peer doesn't comply.
// 
// However, records could already be in transit from the peer
// when the request is emitted. In order to increase
// reliability, we can accept a number of records before the
// expected handshake records.
// 
// The optimal value is highly dependent on the specific usage
// scenario.
// 
// \note           With DTLS and server-initiated renegotiation, the
// HelloRequest is retransmitted every time mbedtls_ssl_read() times
// out or receives Application Data, until:
// - max_records records have beens seen, if it is >= 0, or
// - the number of retransmits that would happen during an
// actual handshake has been reached.
// Please remember the request might be lost a few times
// if you consider setting max_records to a really low value.
// 
// \warning        On client, the grace period can only happen during
// mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()
// which always behave as if max_record was 0. The reason is,
// if we receive application data from the server, we need a
// place to write it, which only happens during mbedtls_ssl_read().
// 
// \param conf     SSL configuration
// \param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to
// enforce renegotiation, or a non-negative value to enforce
// it but allow for a grace period of max_records records.
pub extern external/mbedtls-ssl-conf-renegotiation-enforced(^conf: c-pointer<mbedtls-ssl-config-c>, ^max-records: int32): ()
  c inline "(void)mbedtls_ssl_conf_renegotiation_enforced((struct mbedtls_ssl_config*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-conf-renegotiation-enforced(^conf: c-pointer<mbedtls-ssl-config-c>, ^max-records: int): <> ()
  external/mbedtls-ssl-conf-renegotiation-enforced(conf, max-records.int32)

// \brief          Set record counter threshold for periodic renegotiation.
// (Default: 2^48 - 1)
// 
// Renegotiation is automatically triggered when a record
// counter (outgoing or incoming) crosses the defined
// threshold. The default value is meant to prevent the
// connection from being closed when the counter is about to
// reached its maximal value (it is not allowed to wrap).
// 
// Lower values can be used to enforce policies such as "keys
// must be refreshed every N packets with cipher X".
// 
// The renegotiation period can be disabled by setting
// conf->disable_renegotiation to
// MBEDTLS_SSL_RENEGOTIATION_DISABLED.
// 
// \note           When the configured transport is
// MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation
// period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,
// the maximum renegotiation period is 2^64 - 1.
// 
// \param conf     SSL configuration
// \param period   The threshold value: a big-endian 64-bit number.
pub extern external/mbedtls-ssl-conf-renegotiation-period(^conf: c-pointer<mbedtls-ssl-config-c>, ^period: c-pointer<int>): ()
  c inline "(void)mbedtls_ssl_conf_renegotiation_period((struct mbedtls_ssl_config*)#1, (unsigned char*)#2)"

// \brief          Check if there is data already read from the
// underlying transport but not yet processed.
// 
// \param ssl      SSL context
// 
// \return         0 if nothing's pending, 1 otherwise.
// 
// \note           This is different in purpose and behaviour from
// \c mbedtls_ssl_get_bytes_avail in that it considers
// any kind of unprocessed data, not only unread
// application data. If \c mbedtls_ssl_get_bytes
// returns a non-zero value, this function will
// also signal pending data, but the converse does
// not hold. For example, in DTLS there might be
// further records waiting to be processed from
// the current underlying transport's datagram.
// 
// \note           If this function returns 1 (data pending), this
// does not imply that a subsequent call to
// \c mbedtls_ssl_read will provide any data;
// e.g., the unprocessed data might turn out
// to be an alert or a handshake message.
// 
// \note           This function is useful in the following situation:
// If the SSL/TLS module successfully returns from an
// operation - e.g. a handshake or an application record
// read - and you're awaiting incoming data next, you
// must not immediately idle on the underlying transport
// to have data ready, but you need to check the value
// of this function first. The reason is that the desired
// data might already be read but not yet processed.
// If, in contrast, a previous call to the SSL/TLS module
// returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary
// to call this function, as the latter error code entails
// that all internal data has been processed.
pub extern external/mbedtls-ssl-check-pending(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_check_pending((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-check-pending(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-check-pending(ssl).int

// \brief          Return the number of application data bytes
// remaining to be read from the current record.
// 
// \param ssl      SSL context
// 
// \return         How many bytes are available in the application
// data record read buffer.
// 
// \note           When working over a datagram transport, this is
// useful to detect the current datagram's boundary
// in case \c mbedtls_ssl_read has written the maximal
// amount of data fitting into the input buffer.
pub extern external/mbedtls-ssl-get-bytes-avail(^ssl: c-pointer<mbedtls-ssl-context-c>): ssize_t
  c inline "(size_t)mbedtls_ssl_get_bytes_avail((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-get-bytes-avail(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-get-bytes-avail(ssl).int

// \brief          Return the result of the certificate verification
// 
// \param ssl      The SSL context to use.
// 
// \return         \c 0 if the certificate verification was successful.
// \return         \c -1u if the result is not available. This may happen
// e.g. if the handshake aborts early, or a verification
// callback returned a fatal error.
// \return         A bitwise combination of \c MBEDTLS_X509_BADCERT_XXX
// and \c MBEDTLS_X509_BADCRL_XXX failure flags; see x509.h.
pub extern external/mbedtls-ssl-get-verify-result(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int32_t)mbedtls_ssl_get_verify_result((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-get-verify-result(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-get-verify-result(ssl).int

// \brief          Return the id of the current ciphersuite
// 
// \param ssl      SSL context
// 
// \return         a ciphersuite id
pub extern external/mbedtls-ssl-get-ciphersuite-id-from-ssl(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_get_ciphersuite_id_from_ssl((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-get-ciphersuite-id-from-ssl(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-get-ciphersuite-id-from-ssl(ssl).int

// \brief          Return the name of the current ciphersuite
// 
// \param ssl      SSL context
// 
// \return         a string containing the ciphersuite name
pub extern external/mbedtls-ssl-get-ciphersuite(^ssl: c-pointer<mbedtls-ssl-context-c>): c-pointer<int>
  c inline "(intptr_t)mbedtls_ssl_get_ciphersuite((struct mbedtls_ssl_context*)#1)"

// \brief          Return the current TLS version
// 
// \param ssl      SSL context
// 
// \return         a string containing the TLS version
pub extern external/mbedtls-ssl-get-version(^ssl: c-pointer<mbedtls-ssl-context-c>): c-pointer<int>
  c inline "(intptr_t)mbedtls_ssl_get_version((struct mbedtls_ssl_context*)#1)"

// \brief          Return the (maximum) number of bytes added by the record
// layer: header + encryption/MAC overhead (inc. padding)
// 
// \param ssl      SSL context
// 
// \return         Current maximum record expansion in bytes
pub extern external/mbedtls-ssl-get-record-expansion(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_get_record_expansion((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-get-record-expansion(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-get-record-expansion(ssl).int

// \brief          Return the current maximum outgoing record payload in bytes.
// 
// \note           The logic to determine the maximum outgoing record payload is
// version-specific. It takes into account various factors, such as
// the mbedtls_config.h setting \c MBEDTLS_SSL_OUT_CONTENT_LEN, extensions
// such as the max fragment length or record size limit extension if
// used, and for DTLS the path MTU as configured and current
// record expansion.
// 
// \note           With DTLS, \c mbedtls_ssl_write() will return an error if
// called with a larger length value.
// With TLS, \c mbedtls_ssl_write() will fragment the input if
// necessary and return the number of bytes written; it is up
// to the caller to call \c mbedtls_ssl_write() again in
// order to send the remaining bytes if any.
// 
// \sa             mbedtls_ssl_get_max_out_record_payload()
// \sa             mbedtls_ssl_get_record_expansion()
// 
// \param ssl      SSL context
// 
// \return         Current maximum payload for an outgoing record,
// or a negative error code.
pub extern external/mbedtls-ssl-get-max-out-record-payload(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_get_max_out_record_payload((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-get-max-out-record-payload(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-get-max-out-record-payload(ssl).int

// \brief          Return the current maximum incoming record payload in bytes.
// 
// \note           The logic to determine the maximum incoming record payload is
// version-specific. It takes into account various factors, such as
// the mbedtls_config.h setting \c MBEDTLS_SSL_IN_CONTENT_LEN, extensions
// such as the max fragment length extension or record size limit
// extension if used, and the current record expansion.
// 
// \sa             mbedtls_ssl_set_mtu()
// \sa             mbedtls_ssl_get_max_in_record_payload()
// \sa             mbedtls_ssl_get_record_expansion()
// 
// \param ssl      SSL context
// 
// \return         Current maximum payload for an incoming record,
// or a negative error code.
pub extern external/mbedtls-ssl-get-max-in-record-payload(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_get_max_in_record_payload((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-get-max-in-record-payload(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-get-max-in-record-payload(ssl).int

// \brief          Return the peer certificate from the current connection.
// 
// \param  ssl     The SSL context to use. This must be initialized and setup.
// 
// \return         The current peer certificate, if available.
// The returned certificate is owned by the SSL context and
// is valid only until the next call to the SSL API.
// \return         \c NULL if no peer certificate is available. This might
// be because the chosen ciphersuite doesn't use CRTs
// (PSK-based ciphersuites, for example), or because
// #MBEDTLS_SSL_KEEP_PEER_CERTIFICATE has been disabled,
// allowing the stack to free the peer's CRT to save memory.
// 
// \note           For one-time inspection of the peer's certificate during
// the handshake, consider registering an X.509 CRT verification
// callback through mbedtls_ssl_conf_verify() instead of calling
// this function. Using mbedtls_ssl_conf_verify() also comes at
// the benefit of allowing you to influence the verification
// process, for example by masking expected and tolerated
// verification failures.
// 
// \warning        You must not use the pointer returned by this function
// after any further call to the SSL API, including
// mbedtls_ssl_read() and mbedtls_ssl_write(); this is
// because the pointer might change during renegotiation,
// which happens transparently to the user.
// If you want to use the certificate across API calls,
// you must make a copy.
pub extern external/mbedtls-ssl-get-peer-cert(^ssl: c-pointer<mbedtls-ssl-context-c>): c-pointer<mbedtls-x509-crt-c>
  c inline "(intptr_t)mbedtls_ssl_get_peer_cert((struct mbedtls_ssl_context*)#1)"

// \brief          Export a session in order to resume it later.
// 
// \param ssl      The SSL context representing the connection for which to
// to export a session structure for later resumption.
// \param session  The target structure in which to store the exported session.
// This must have been initialized with mbedtls_ssl_session_init()
// but otherwise be unused.
// 
// \note           This function can handle a variety of mechanisms for session
// resumption: For TLS 1.2, both session ID-based resumption and
// ticket-based resumption will be considered. For TLS 1.3,
// once implemented, sessions equate to tickets, and calling
// this function multiple times will export the available
// tickets one a time until no further tickets are available,
// in which case MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE will
// be returned.
// 
// \note           Calling this function multiple times will only be useful
// once TLS 1.3 is supported. For TLS 1.2 connections, this
// function should be called at most once.
// 
// \return         \c 0 if successful. In this case, \p session can be used for
// session resumption by passing it to mbedtls_ssl_set_session(),
// and serialized for storage via mbedtls_ssl_session_save().
// \return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no further session
// is available for export.
// This error is a non-fatal, and has no observable effect on
// the SSL context or the destination session.
// \return         Another negative error code on other kinds of failure.
// 
// \sa             mbedtls_ssl_set_session()
// \sa             mbedtls_ssl_session_save()
pub extern external/mbedtls-ssl-get-session(^ssl: c-pointer<mbedtls-ssl-context-c>, ^session: c-pointer<mbedtls-ssl-session-c>): int32
  c inline "(int)mbedtls_ssl_get_session((struct mbedtls_ssl_context*)#1, (struct mbedtls_ssl_session*)#2)"

pub inline fun ffi/mbedtls-ssl-get-session(^ssl: c-pointer<mbedtls-ssl-context-c>, ^session: c-pointer<mbedtls-ssl-session-c>): <> int
  external/mbedtls-ssl-get-session(ssl, session).int

// \brief          Perform the SSL handshake
// 
// \param ssl      SSL context
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
// if the handshake is incomplete and waiting for data to
// be available for reading from or writing to the underlying
// transport - in this case you must call this function again
// when the underlying transport is ready for the operation.
// \return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
// operation is in progress (see
// mbedtls_ssl_conf_async_private_cb()) - in this case you
// must call this function again when the operation is ready.
// \return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
// operation is in progress (see mbedtls_ecp_set_max_ops()) -
// in this case you must call this function again to complete
// the handshake when you're done attending other tasks.
// \return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use
// and the client did not demonstrate reachability yet - in
// this case you must stop using the context (see below).
// \return         #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA if early data, as
// defined in RFC 8446 (TLS 1.3 specification), has been
// received as part of the handshake. This is server specific
// and may occur only if the early data feature has been
// enabled on server (see mbedtls_ssl_conf_early_data()
// documentation). You must call mbedtls_ssl_read_early_data()
// to read the early data before resuming the handshake.
// \return         Another SSL error code - in this case you must stop using
// the context (see below).
// 
// \warning        If this function returns something other than
// \c 0,
// #MBEDTLS_ERR_SSL_WANT_READ,
// #MBEDTLS_ERR_SSL_WANT_WRITE,
// #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
// #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or
// #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA,
// you must stop using the SSL context for reading or writing,
// and either free it or call \c mbedtls_ssl_session_reset()
// on it before re-using it for a new connection; the current
// connection must be closed.
// 
// \note           If DTLS is in use, then you may choose to handle
// #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging
// purposes, as it is an expected return value rather than an
// actual error, but you still need to reset/free the context.
// 
// \note           Remarks regarding event-driven DTLS:
// If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram
// from the underlying transport layer is currently being processed,
// and it is safe to idle until the timer or the underlying transport
// signal a new event. This is not true for a successful handshake,
// in which case the datagram of the underlying transport that is
// currently being processed might or might not contain further
// DTLS records.
// 
// \note           If the context is configured to allow TLS 1.3, or if
// #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
pub extern external/mbedtls-ssl-handshake(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_handshake((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-handshake(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-handshake(ssl).int

// \brief          Perform a single step of the SSL handshake
// 
// \note           The state of the context (ssl->state) will be at
// the next state after this function returns \c 0. Do not
// call this function if mbedtls_ssl_is_handshake_over()
// returns \c 1.
// 
// \warning        Whilst in the past you may have used direct access to the
// context state (ssl->state) in order to ascertain when to
// stop calling this function and although you can still do
// so with something like ssl->MBEDTLS_PRIVATE(state) or by
// defining MBEDTLS_ALLOW_PRIVATE_ACCESS, this is now
// considered deprecated and could be broken in any future
// release. If you still find you have good reason for such
// direct access, then please do contact the team to explain
// this (raise an issue or post to the mailing list), so that
// we can add a solution to your problem that will be
// guaranteed to work in the future.
// 
// \param ssl      SSL context
// 
// \return         See mbedtls_ssl_handshake().
// 
// \warning        If this function returns something other than \c 0,
// #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,
// #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,
// #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or
// #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA, you must stop using
// the SSL context for reading or writing, and either free it
// or call \c mbedtls_ssl_session_reset() on it before
// re-using it for a new connection; the current connection
// must be closed.
pub extern external/mbedtls-ssl-handshake-step(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_handshake_step((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-handshake-step(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-handshake-step(ssl).int

// \brief          Initiate an SSL renegotiation on the running connection.
// Client: perform the renegotiation right now.
// Server: request renegotiation, which will be performed
// during the next call to mbedtls_ssl_read() if honored by
// client.
// 
// \param ssl      SSL context
// 
// \return         0 if successful, or any mbedtls_ssl_handshake() return
// value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't
// happen during a renegotiation.
// 
// \warning        If this function returns something other than \c 0,
// #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,
// #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or
// #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using
// the SSL context for reading or writing, and either free it
// or call \c mbedtls_ssl_session_reset() on it before
// re-using it for a new connection; the current connection
// must be closed.
pub extern external/mbedtls-ssl-renegotiate(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_renegotiate((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-renegotiate(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-renegotiate(ssl).int

// \brief          Read at most 'len' application data bytes
// 
// \param ssl      SSL context
// \param buf      buffer that will hold the data
// \param len      maximum number of bytes to read
// 
// \return         The (positive) number of bytes read if successful.
// \return         \c 0 if the read end of the underlying transport was closed
// without sending a CloseNotify beforehand, which might happen
// because of various reasons (internal error of an underlying
// stack, non-conformant peer not sending a CloseNotify and
// such) - in this case you must stop using the context
// (see below).
// \return         #MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY if the underlying
// transport is still functional, but the peer has
// acknowledged to not send anything anymore.
// \return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
// if the handshake is incomplete and waiting for data to
// be available for reading from or writing to the underlying
// transport - in this case you must call this function again
// when the underlying transport is ready for the operation.
// \return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
// operation is in progress (see
// mbedtls_ssl_conf_async_private_cb()) - in this case you
// must call this function again when the operation is ready.
// \return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
// operation is in progress (see mbedtls_ecp_set_max_ops()) -
// in this case you must call this function again to complete
// the handshake when you're done attending other tasks.
// \return         #MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server
// side of a DTLS connection and the client is initiating a
// new connection using the same source port. See below.
// \return         #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA if early data, as
// defined in RFC 8446 (TLS 1.3 specification), has been
// received as part of the handshake. This is server specific
// and may occur only if the early data feature has been
// enabled on server (see mbedtls_ssl_conf_early_data()
// documentation). You must call mbedtls_ssl_read_early_data()
// to read the early data before resuming the handshake.
// \return         Another SSL error code - in this case you must stop using
// the context (see below).
// 
// \warning        If this function returns something other than
// a positive value,
// #MBEDTLS_ERR_SSL_WANT_READ,
// #MBEDTLS_ERR_SSL_WANT_WRITE,
// #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,
// #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,
// #MBEDTLS_ERR_SSL_CLIENT_RECONNECT or
// #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA,
// you must stop using the SSL context for reading or writing,
// and either free it or call \c mbedtls_ssl_session_reset()
// on it before re-using it for a new connection; the current
// connection must be closed.
// 
// \note           When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT
// (which can only happen server-side), it means that a client
// is initiating a new connection using the same source port.
// You can either treat that as a connection close and wait
// for the client to resend a ClientHello, or directly
// continue with \c mbedtls_ssl_handshake() with the same
// context (as it has been reset internally). Either way, you
// must make sure this is seen by the application as a new
// connection: application state, if any, should be reset, and
// most importantly the identity of the client must be checked
// again. WARNING: not validating the identity of the client
// again, or not transmitting the new identity to the
// application layer, would allow authentication bypass!
// 
// \note           Remarks regarding event-driven DTLS:
// - If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram
// from the underlying transport layer is currently being processed,
// and it is safe to idle until the timer or the underlying transport
// signal a new event.
// - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was
// initially available on the underlying transport, as this data may have
// been only e.g. duplicated messages or a renegotiation request.
// Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even
// when reacting to an incoming-data event from the underlying transport.
// - On success, the datagram of the underlying transport that is currently
// being processed may contain further DTLS records. You should call
// \c mbedtls_ssl_check_pending to check for remaining records.
pub extern external/mbedtls-ssl-read(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ssl_read((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-read(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ssl-read(ssl, buf, len.ssize_t).int

// \brief          Try to write exactly 'len' application data bytes
// 
// \warning        This function will do partial writes in some cases. If the
// return value is non-negative but less than length, the
// function must be called again with updated arguments:
// buf + ret, len - ret (if ret is the return value) until
// it returns a value equal to the last 'len' argument.
// 
// \param ssl      SSL context
// \param buf      buffer holding the data
// \param len      how many bytes must be written
// 
// \return         The (non-negative) number of bytes actually written if
// successful (may be less than \p len).
// \return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE
// if the handshake is incomplete and waiting for data to
// be available for reading from or writing to the underlying
// transport - in this case you must call this function again
// when the underlying transport is ready for the operation.
// \return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous
// operation is in progress (see
// mbedtls_ssl_conf_async_private_cb()) - in this case you
// must call this function again when the operation is ready.
// \return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic
// operation is in progress (see mbedtls_ecp_set_max_ops()) -
// in this case you must call this function again to complete
// the handshake when you're done attending other tasks.
// \return         #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA if early data, as
// defined in RFC 8446 (TLS 1.3 specification), has been
// received as part of the handshake. This is server specific
// and may occur only if the early data feature has been
// enabled on server (see mbedtls_ssl_conf_early_data()
// documentation). You must call mbedtls_ssl_read_early_data()
// to read the early data before resuming the handshake.
// \return         Another SSL error code - in this case you must stop using
// the context (see below).
// 
// \warning        If this function returns something other than
// a non-negative value,
// #MBEDTLS_ERR_SSL_WANT_READ,
// #MBEDTLS_ERR_SSL_WANT_WRITE,
// #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,
// #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or
// #MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA,
// you must stop using the SSL context for reading or writing,
// and either free it or call \c mbedtls_ssl_session_reset()
// on it before re-using it for a new connection; the current
// connection must be closed.
// 
// \note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,
// it must be called later with the *same* arguments,
// until it returns a value greater than or equal to 0. When
// the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be
// some partial data in the output buffer, however this is not
// yet sent.
// 
// \note           If the requested length is greater than the maximum
// fragment length (either the built-in limit or the one set
// or negotiated with the peer), then:
// - with TLS, less bytes than requested are written.
// - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.
// \c mbedtls_ssl_get_max_out_record_payload() may be used to
// query the active maximum fragment length.
// 
// \note           Attempting to write 0 bytes will result in an empty TLS
// application record being sent.
pub extern external/mbedtls-ssl-write(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ssl_write((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-write(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ssl-write(ssl, buf, len.ssize_t).int

// \brief           Send an alert message
// 
// \param ssl       SSL context
// \param level     The alert level of the message
// (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)
// \param message   The alert message (SSL_ALERT_MSG_*)
// 
// \return          0 if successful, or a specific SSL error code.
// 
// \note           If this function returns something other than 0 or
// MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using
// the SSL context for reading or writing, and either free it or
// call \c mbedtls_ssl_session_reset() on it before re-using it
// for a new connection; the current connection must be closed.
pub extern external/mbedtls-ssl-send-alert-message(^ssl: c-pointer<mbedtls-ssl-context-c>, ^level: int8, ^message: int8): int32
  c inline "(int)mbedtls_ssl_send_alert_message((struct mbedtls_ssl_context*)#1, (unsigned char)#2, (unsigned char)#3)"

pub inline fun ffi/mbedtls-ssl-send-alert-message(^ssl: c-pointer<mbedtls-ssl-context-c>, ^level: int, ^message: int): <> int
  external/mbedtls-ssl-send-alert-message(ssl, level.int8, message.int8).int

// \brief          Notify the peer that the connection is being closed
// 
// \param ssl      SSL context
// 
// \return          0 if successful, or a specific SSL error code.
// 
// \note           If this function returns something other than 0 or
// MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using
// the SSL context for reading or writing, and either free it or
// call \c mbedtls_ssl_session_reset() on it before re-using it
// for a new connection; the current connection must be closed.
pub extern external/mbedtls-ssl-close-notify(^ssl: c-pointer<mbedtls-ssl-context-c>): int32
  c inline "(int)mbedtls_ssl_close_notify((struct mbedtls_ssl_context*)#1)"

pub inline fun ffi/mbedtls-ssl-close-notify(^ssl: c-pointer<mbedtls-ssl-context-c>): <> int
  external/mbedtls-ssl-close-notify(ssl).int

// \brief          Free referenced items in an SSL context and clear memory
// 
// \param ssl      SSL context
pub extern external/mbedtls-ssl-free(^ssl: c-pointer<mbedtls-ssl-context-c>): ()
  c inline "(void)mbedtls_ssl_free((struct mbedtls_ssl_context*)#1)"

// \brief          Save an active connection as serialized data in a buffer.
// This allows the freeing or re-using of the SSL context
// while still picking up the connection later in a way that
// it entirely transparent to the peer.
// 
// \see            mbedtls_ssl_context_load()
// 
// \note           The serialized data only contains the data that is
// necessary to resume the connection: negotiated protocol
// options, session identifier, keys, etc.
// Loading a saved SSL context does not restore settings and
// state related to how the application accesses the context,
// such as configured callback functions, user data, pending
// incoming or outgoing data, etc.
// 
// \note           This feature is currently only available under certain
// conditions, see the documentation of the return value
// #MBEDTLS_ERR_SSL_BAD_INPUT_DATA for details.
// 
// \note           When this function succeeds, it calls
// mbedtls_ssl_session_reset() on \p ssl which as a result is
// no longer associated with the connection that has been
// serialized. This avoids creating copies of the connection
// state. You're then free to either re-use the context
// structure for a different connection, or call
// mbedtls_ssl_free() on it. See the documentation of
// mbedtls_ssl_session_reset() for more details.
// 
// \param ssl      The SSL context to save. On success, it is no longer
// associated with the connection that has been serialized.
// \param buf      The buffer to write the serialized data to. It must be a
// writeable buffer of at least \p buf_len bytes, or may be \c
// NULL if \p buf_len is \c 0.
// \param buf_len  The number of bytes available for writing in \p buf.
// \param olen     The size in bytes of the data that has been or would have
// been written. It must point to a valid \c size_t.
// 
// \note           \p olen is updated to the correct value regardless of
// whether \p buf_len was large enough. This makes it possible
// to determine the necessary size by calling this function
// with \p buf set to \c NULL and \p buf_len to \c 0. However,
// the value of \p olen is only guaranteed to be correct when
// the function returns #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL or
// \c 0. If the return value is different, then the value of
// \p olen is undefined.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \p buf is too small.
// \return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed
// while resetting the context.
// \return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if a handshake is in
// progress, or there is pending data for reading or sending,
// or the connection does not use DTLS 1.2 with an AEAD
// ciphersuite, or renegotiation is enabled.
pub extern external/mbedtls-ssl-context-save(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^buf-len: ssize_t, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_context_save((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-ssl-context-save(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^buf-len: int, ^olen: c-pointer<int>): <> int
  external/mbedtls-ssl-context-save(ssl, buf, buf-len.ssize_t, olen).int

// \brief          Load serialized connection data to an SSL context.
// 
// \see            mbedtls_ssl_context_save()
// 
// \warning        The same serialized data must never be loaded into more
// that one context. In order to ensure that, after
// successfully loading serialized data to an SSL context, you
// should immediately destroy or invalidate all copies of the
// serialized data that was loaded. Loading the same data in
// more than one context would cause severe security failures
// including but not limited to loss of confidentiality.
// 
// \note           Before calling this function, the SSL context must be
// prepared in one of the two following ways. The first way is
// to take a context freshly initialised with
// mbedtls_ssl_init() and call mbedtls_ssl_setup() on it with
// the same ::mbedtls_ssl_config structure that was used in
// the original connection. The second way is to
// call mbedtls_ssl_session_reset() on a context that was
// previously prepared as above but used in the meantime.
// Either way, you must not use the context to perform a
// handshake between calling mbedtls_ssl_setup() or
// mbedtls_ssl_session_reset() and calling this function. You
// may however call other setter functions in that time frame
// as indicated in the note below.
// 
// \note           Before or after calling this function successfully, you
// also need to configure some connection-specific callbacks
// and settings before you can use the connection again
// (unless they were already set before calling
// mbedtls_ssl_session_reset() and the values are suitable for
// the present connection). Specifically, you want to call
// at least mbedtls_ssl_set_bio(),
// mbedtls_ssl_set_timer_cb(), and
// mbedtls_ssl_set_user_data_n() or
// mbedtls_ssl_set_user_data_p() if they were set originally.
// All other SSL setter functions
// are not necessary to call, either because they're only used
// in handshakes, or because the setting is already saved. You
// might choose to call them anyway, for example in order to
// share code between the cases of establishing a new
// connection and the case of loading an already-established
// connection.
// 
// \note           If you have new information about the path MTU, you want to
// call mbedtls_ssl_set_mtu() after calling this function, as
// otherwise this function would overwrite your
// newly-configured value with the value that was active when
// the context was saved.
// 
// \note           When this function returns an error code, it calls
// mbedtls_ssl_free() on \p ssl. In this case, you need to
// prepare the context with the usual sequence starting with a
// call to mbedtls_ssl_init() if you want to use it again.
// 
// \param ssl      The SSL context structure to be populated. It must have
// been prepared as described in the note above.
// \param buf      The buffer holding the serialized connection data. It must
// be a readable buffer of at least \p len bytes.
// \param len      The size of the serialized data in bytes.
// 
// \return         \c 0 if successful.
// \return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.
// \return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data
// comes from a different Mbed TLS version or build.
// \return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid.
pub extern external/mbedtls-ssl-context-load(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ssl_context_load((struct mbedtls_ssl_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-context-load(^ssl: c-pointer<mbedtls-ssl-context-c>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ssl-context-load(ssl, buf, len.ssize_t).int

// \brief          Initialize an SSL configuration context
// Just makes the context ready for
// mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free().
// 
// \note           You need to call mbedtls_ssl_config_defaults() unless you
// manually set all of the relevant fields yourself.
// 
// \param conf     SSL configuration context
pub extern external/mbedtls-ssl-config-init(^conf: c-pointer<mbedtls-ssl-config-c>): ()
  c inline "(void)mbedtls_ssl_config_init((struct mbedtls_ssl_config*)#1)"

// \brief          Load reasonable default SSL configuration values.
// (You need to call mbedtls_ssl_config_init() first.)
// 
// \param conf     SSL configuration context
// \param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER
// \param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or
// MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS
// \param preset   a MBEDTLS_SSL_PRESET_XXX value
// 
// \note           See \c mbedtls_ssl_conf_transport() for notes on DTLS.
// 
// \return         0 if successful, or
// MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error.
pub extern external/mbedtls-ssl-config-defaults(^conf: c-pointer<mbedtls-ssl-config-c>, ^endpoint: int32, ^transport: int32, ^preset: int32): int32
  c inline "(int)mbedtls_ssl_config_defaults((struct mbedtls_ssl_config*)#1, (int)#2, (int)#3, (int)#4)"

pub inline fun ffi/mbedtls-ssl-config-defaults(^conf: c-pointer<mbedtls-ssl-config-c>, ^endpoint: int, ^transport: int, ^preset: int): <> int
  external/mbedtls-ssl-config-defaults(conf, endpoint.int32, transport.int32, preset.int32).int

// \brief          Free an SSL configuration context
// 
// \param conf     SSL configuration context
pub extern external/mbedtls-ssl-config-free(^conf: c-pointer<mbedtls-ssl-config-c>): ()
  c inline "(void)mbedtls_ssl_config_free((struct mbedtls_ssl_config*)#1)"

// \brief          Initialize SSL session structure
// 
// \param session  SSL session
pub extern external/mbedtls-ssl-session-init(^session: c-pointer<mbedtls-ssl-session-c>): ()
  c inline "(void)mbedtls_ssl_session_init((struct mbedtls_ssl_session*)#1)"

// \brief          Free referenced items in an SSL session including the
// peer certificate and clear memory
// 
// \note           A session object can be freed even if the SSL context
// that was used to retrieve the session is still in use.
// 
// \param session  SSL session
pub extern external/mbedtls-ssl-session-free(^session: c-pointer<mbedtls-ssl-session-c>): ()
  c inline "(void)mbedtls_ssl_session_free((struct mbedtls_ssl_session*)#1)"

// \brief          TLS-PRF function for key derivation.
// 
// \param prf      The tls_prf type function type to be used.
// \param secret   Secret for the key derivation function.
// \param slen     Length of the secret.
// \param label    String label for the key derivation function,
// terminated with null character.
// \param random   Random bytes.
// \param rlen     Length of the random bytes buffer.
// \param dstbuf   The buffer holding the derived key.
// \param dlen     Length of the output buffer.
// 
// \return         0 on success. An SSL specific error on failure.
pub extern external/mbedtls-ssl-tls-prf(^prf: int32, ^secret: c-pointer<int>, ^slen: ssize_t, ^label: c-pointer<int>, ^random: c-pointer<int>, ^rlen: ssize_t, ^dstbuf: c-pointer<int>, ^dlen: ssize_t): int32
  c inline "(int)mbedtls_ssl_tls_prf((int32_t)#1, (unsigned char*)#2, (size_t)#3, (char*)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (size_t)#8)"

pub inline fun ffi/mbedtls-ssl-tls-prf(^prf: mbedtls-tls-prf-types, ^secret: c-pointer<int>, ^slen: int, ^label: c-pointer<int>, ^random: c-pointer<int>, ^rlen: int, ^dstbuf: c-pointer<int>, ^dlen: int): <exn> int
  external/mbedtls-ssl-tls-prf(prf.mbedtls-tls-prf-types/int, secret, slen.ssize_t, label, random, rlen.ssize_t, dstbuf, dlen.ssize_t).int

// \brief   Set the threshold error level to handle globally all debug output.
// Debug messages that have a level over the threshold value are
// discarded.
// (Default value: 0 = No debug )
// 
// \param threshold     threshold level of messages to filter on. Messages at a
// higher level will be discarded.
// - Debug levels
// - 0 No debug
// - 1 Error
// - 2 State change
// - 3 Informational
// - 4 Verbose
pub extern external/mbedtls-debug-set-threshold(^threshold: int32): ()
  c inline "(void)mbedtls_debug_set_threshold((int)#1)"

pub inline fun ffi/mbedtls-debug-set-threshold(^threshold: int): <> ()
  external/mbedtls-debug-set-threshold(threshold.int32)

// Get the version number.
// 
// \return          The constructed version number in the format
// MMNNPP00 (Major, Minor, Patch).
pub extern external/mbedtls-version-get-number(): int32
  c inline "(unsigned int)mbedtls_version_get_number()"

pub inline fun ffi/mbedtls-version-get-number(): <> int
  external/mbedtls-version-get-number().int

// Get the version string ("x.y.z").
// 
// \param string    The string that will receive the value.
// (Should be at least 9 bytes in size)
pub extern external/mbedtls-version-get-string(^string: c-pointer<int>): ()
  c inline "(void)mbedtls_version_get_string((char*)#1)"

// Get the full version string ("Mbed TLS x.y.z").
// 
// \param string    The string that will receive the value. The Mbed TLS version
// string will use 18 bytes AT MOST including a terminating
// null byte.
// (So the buffer should be at least 18 bytes to receive this
// version string).
pub extern external/mbedtls-version-get-string-full(^string: c-pointer<int>): ()
  c inline "(void)mbedtls_version_get_string_full((char*)#1)"

// \brief           Check if support for a feature was compiled into this
// Mbed TLS binary. This allows you to see at runtime if the
// library was for instance compiled with or without
// Multi-threading support.
// 
// \note            only checks against defines in the sections "System
// support", "Mbed TLS modules" and "Mbed TLS feature
// support" in mbedtls_config.h
// 
// \param feature   The string for the define to check (e.g. "MBEDTLS_AES_C")
// 
// \return          0 if the feature is present,
// -1 if the feature is not present and
// -2 if support for feature checking as a whole was not
// compiled in.
pub extern external/mbedtls-version-check-feature(^feature: c-pointer<int>): int32
  c inline "(int)mbedtls_version_check_feature((char*)#1)"

pub inline fun ffi/mbedtls-version-check-feature(^feature: c-pointer<int>): <> int
  external/mbedtls-version-check-feature(feature).int

// \brief          Encode a buffer into base64 format
// 
// \param dst      destination buffer
// \param dlen     size of the destination buffer
// \param olen     number of bytes written
// \param src      source buffer
// \param slen     amount of data to be encoded
// 
// \return         0 if successful, or MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL.
// *olen is always updated to reflect the amount
// of data that has (or would have) been written.
// If that length cannot be represented, then no data is
// written to the buffer and *olen is set to the maximum
// length representable as a size_t.
// 
// \note           Call this function with dlen = 0 to obtain the
// required buffer size in *olen
pub extern external/mbedtls-base64-encode(^dst: c-pointer<int>, ^dlen: ssize_t, ^olen: c-pointer<int>, ^src: c-pointer<int>, ^slen: ssize_t): int32
  c inline "(int)mbedtls_base64_encode((unsigned char*)#1, (size_t)#2, (size_t*)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-base64-encode(^dst: c-pointer<int>, ^dlen: int, ^olen: c-pointer<int>, ^src: c-pointer<int>, ^slen: int): <> int
  external/mbedtls-base64-encode(dst, dlen.ssize_t, olen, src, slen.ssize_t).int

// \brief          Decode a base64-formatted buffer
// 
// \param dst      destination buffer (can be NULL for checking size)
// \param dlen     size of the destination buffer
// \param olen     number of bytes written
// \param src      source buffer
// \param slen     amount of data to be decoded
// 
// \return         0 if successful, MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL, or
// MBEDTLS_ERR_BASE64_INVALID_CHARACTER if the input data is
// not correct. *olen is always updated to reflect the amount
// of data that has (or would have) been written.
// 
// \note           Call this function with *dst = NULL or dlen = 0 to obtain
// the required buffer size in *olen
pub extern external/mbedtls-base64-decode(^dst: c-pointer<int>, ^dlen: ssize_t, ^olen: c-pointer<int>, ^src: c-pointer<int>, ^slen: ssize_t): int32
  c inline "(int)mbedtls_base64_decode((unsigned char*)#1, (size_t)#2, (size_t*)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-base64-decode(^dst: c-pointer<int>, ^dlen: int, ^olen: c-pointer<int>, ^src: c-pointer<int>, ^slen: int): <> int
  external/mbedtls-base64-decode(dst, dlen.ssize_t, olen, src, slen.ssize_t).int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
pub extern external/mbedtls-base64-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_base64_self_test((int)#1)"

pub inline fun ffi/mbedtls-base64-self-test(^verbose: int): <> int
  external/mbedtls-base64-self-test(verbose.int32).int

// \brief   Initialize use of stack-based memory allocator.
// The stack-based allocator does memory management inside the
// presented buffer and does not call calloc() and free().
// It sets the global mbedtls_calloc() and mbedtls_free() pointers
// to its own functions.
// (Provided mbedtls_calloc() and mbedtls_free() are thread-safe if
// MBEDTLS_THREADING_C is defined)
// 
// \note    This code is not optimized and provides a straight-forward
// implementation of a stack-based memory allocator.
// 
// \param buf   buffer to use as heap
// \param len   size of the buffer
pub extern external/mbedtls-memory-buffer-alloc-init(^buf: c-pointer<int>, ^len: ssize_t): ()
  c inline "(void)mbedtls_memory_buffer_alloc_init((unsigned char*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-memory-buffer-alloc-init(^buf: c-pointer<int>, ^len: int): <> ()
  external/mbedtls-memory-buffer-alloc-init(buf, len.ssize_t)

// \brief   Free the mutex for thread-safety and clear remaining memory
pub extern external/mbedtls-memory-buffer-alloc-free(): ()
  c inline "(void)mbedtls_memory_buffer_alloc_free()"

// \brief   Determine when the allocator should automatically verify the state
// of the entire chain of headers / meta-data.
// (Default: MBEDTLS_MEMORY_VERIFY_NONE)
// 
// \param verify    One of MBEDTLS_MEMORY_VERIFY_NONE, MBEDTLS_MEMORY_VERIFY_ALLOC,
// MBEDTLS_MEMORY_VERIFY_FREE or MBEDTLS_MEMORY_VERIFY_ALWAYS
pub extern external/mbedtls-memory-buffer-set-verify(^verify: int32): ()
  c inline "(void)mbedtls_memory_buffer_set_verify((int)#1)"

pub inline fun ffi/mbedtls-memory-buffer-set-verify(^verify: int): <> ()
  external/mbedtls-memory-buffer-set-verify(verify.int32)

// \brief   Verifies that all headers in the memory buffer are correct
// and contain sane values. Helps debug buffer-overflow errors.
// 
// Prints out first failure if MBEDTLS_MEMORY_DEBUG is defined.
// Prints out full header information if MBEDTLS_MEMORY_DEBUG
// is defined. (Includes stack trace information for each block if
// MBEDTLS_MEMORY_BACKTRACE is defined as well).
// 
// \return             0 if verified, 1 otherwise
pub extern external/mbedtls-memory-buffer-alloc-verify(): int32
  c inline "(int)mbedtls_memory_buffer_alloc_verify()"

pub inline fun ffi/mbedtls-memory-buffer-alloc-verify(): <> int
  external/mbedtls-memory-buffer-alloc-verify().int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if a test failed
pub extern external/mbedtls-memory-buffer-alloc-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_memory_buffer_alloc_self_test((int)#1)"

pub inline fun ffi/mbedtls-memory-buffer-alloc-self-test(^verbose: int): <> int
  external/mbedtls-memory-buffer-alloc-self-test(verbose.int32).int

// \brief          Load a Certificate Signing Request (CSR) in DER format
// 
// \note           Any unsupported requested extensions are silently
// ignored, unless the critical flag is set, in which case
// the CSR is rejected.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param csr      CSR context to fill
// \param buf      buffer holding the CRL data
// \param buflen   size of the buffer
// 
// \return         0 if successful, or a specific X509 error code
pub extern external/mbedtls-x509-csr-parse-der(^csr: c-pointer<mbedtls-x509-csr-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_csr_parse_der((struct mbedtls_x509_csr*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-csr-parse-der(^csr: c-pointer<mbedtls-x509-csr-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-csr-parse-der(csr, buf, buflen.ssize_t).int

// \brief          Load a Certificate Signing Request (CSR) in DER format
// 
// \note           Any unsupported requested extensions are silently
// ignored, unless the critical flag is set, in which case
// the result of the callback function decides whether
// CSR is rejected.
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param csr      CSR context to fill
// \param buf      buffer holding the CRL data
// \param buflen   size of the buffer
// \param cb       A callback invoked for every unsupported certificate
// extension.
// \param p_ctx    An opaque context passed to the callback.
// 
// \return         0 if successful, or a specific X509 error code
pub extern external/mbedtls-x509-csr-parse-der-with-ext-cb(^csr: c-pointer<mbedtls-x509-csr-c>, ^buf: c-pointer<int>, ^buflen: ssize_t, ^cb: c-pointer<intptr_t>, ^p-ctx: c-pointer<()>): int32
  c inline "(int)mbedtls_x509_csr_parse_der_with_ext_cb((struct mbedtls_x509_csr*)#1, (unsigned char*)#2, (size_t)#3, (mbedtls_x509_csr_ext_cb_t)#4, (void*)#5)"

pub inline fun ffi/mbedtls-x509-csr-parse-der-with-ext-cb(^csr: c-pointer<mbedtls-x509-csr-c>, ^buf: c-pointer<int>, ^buflen: int, ^cb: mbedtls-x509-csr-ext-cb-t, ^p-ctx: c-pointer<()>): <> int
  external/mbedtls-x509-csr-parse-der-with-ext-cb(csr, buf, buflen.ssize_t, cb, p-ctx).int

// \brief          Load a Certificate Signing Request (CSR), DER or PEM format
// 
// \note           See notes for \c mbedtls_x509_csr_parse_der()
// 
// \note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto
// subsystem must have been initialized by calling
// psa_crypto_init() before calling this function.
// 
// \param csr      CSR context to fill
// \param buf      buffer holding the CRL data
// \param buflen   size of the buffer
// (including the terminating null byte for PEM data)
// 
// \return         0 if successful, or a specific X509 or PEM error code
pub extern external/mbedtls-x509-csr-parse(^csr: c-pointer<mbedtls-x509-csr-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_x509_csr_parse((struct mbedtls_x509_csr*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-x509-csr-parse(^csr: c-pointer<mbedtls-x509-csr-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-x509-csr-parse(csr, buf, buflen.ssize_t).int

// \brief          Load a Certificate Signing Request (CSR)
// 
// \note           See notes for \c mbedtls_x509_csr_parse()
// 
// \param csr      CSR context to fill
// \param path     filename to read the CSR from
// 
// \return         0 if successful, or a specific X509 or PEM error code
pub extern external/mbedtls-x509-csr-parse-file(^csr: c-pointer<mbedtls-x509-csr-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_x509_csr_parse_file((struct mbedtls_x509_csr*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509-csr-parse-file(^csr: c-pointer<mbedtls-x509-csr-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-x509-csr-parse-file(csr, path).int

// \brief          Returns an informational string about the
// CSR.
// 
// \param buf      Buffer to write to
// \param size     Maximum size of buffer
// \param prefix   A line prefix
// \param csr      The X509 CSR to represent
// 
// \return         The length of the string written (not including the
// terminated nul byte), or a negative error code.
pub extern external/mbedtls-x509-csr-info(^buf: c-pointer<int>, ^size: ssize_t, ^prefix: c-pointer<int>, ^csr: c-pointer<mbedtls-x509-csr-c>): int32
  c inline "(int)mbedtls_x509_csr_info((char*)#1, (size_t)#2, (char*)#3, (struct mbedtls_x509_csr*)#4)"

pub inline fun ffi/mbedtls-x509-csr-info(^buf: c-pointer<int>, ^size: int, ^prefix: c-pointer<int>, ^csr: c-pointer<mbedtls-x509-csr-c>): <> int
  external/mbedtls-x509-csr-info(buf, size.ssize_t, prefix, csr).int

// \brief          Initialize a CSR
// 
// \param csr      CSR to initialize
pub extern external/mbedtls-x509-csr-init(^csr: c-pointer<mbedtls-x509-csr-c>): ()
  c inline "(void)mbedtls_x509_csr_init((struct mbedtls_x509_csr*)#1)"

// \brief          Unallocate all CSR data
// 
// \param csr      CSR to free
pub extern external/mbedtls-x509-csr-free(^csr: c-pointer<mbedtls-x509-csr-c>): ()
  c inline "(void)mbedtls_x509_csr_free((struct mbedtls_x509_csr*)#1)"

// \brief           Initialize a CSR context
// 
// \param ctx       CSR context to initialize
pub extern external/mbedtls-x509write-csr-init(^ctx1: c-pointer<mbedtls-x509write-csr-c>): ()
  c inline "(void)mbedtls_x509write_csr_init((struct mbedtls_x509write_csr*)#1)"

// \brief           Set the subject name for a CSR
// Subject names should contain a comma-separated list
// of OID types and values:
// e.g. "C=UK,O=ARM,CN=Mbed TLS Server 1"
// 
// \param ctx           CSR context to use
// \param subject_name  subject name to set
// 
// \return          0 if subject name was parsed successfully, or
// a specific error code
pub extern external/mbedtls-x509write-csr-set-subject-name(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^subject-name: c-pointer<int>): int32
  c inline "(int)mbedtls_x509write_csr_set_subject_name((struct mbedtls_x509write_csr*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-x509write-csr-set-subject-name(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^subject-name: c-pointer<int>): <> int
  external/mbedtls-x509write-csr-set-subject-name(ctx1, subject-name).int

// \brief           Set the key for a CSR (public key will be included,
// private key used to sign the CSR when writing it)
// 
// \param ctx       CSR context to use
// \param key       Asymmetric key to include
pub extern external/mbedtls-x509write-csr-set-key(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^key: c-pointer<mbedtls-pk-context-c>): ()
  c inline "(void)mbedtls_x509write_csr_set_key((struct mbedtls_x509write_csr*)#1, (struct mbedtls_pk_context*)#2)"

// \brief           Set the MD algorithm to use for the signature
// (e.g. MBEDTLS_MD_SHA1)
// 
// \param ctx       CSR context to use
// \param md_alg    MD algorithm to use
pub extern external/mbedtls-x509write-csr-set-md-alg(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^md-alg: int32): ()
  c inline "(void)mbedtls_x509write_csr_set_md_alg((struct mbedtls_x509write_csr*)#1, (int32_t)#2)"

pub inline fun ffi/mbedtls-x509write-csr-set-md-alg(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^md-alg: mbedtls-md-type-t): <exn> ()
  external/mbedtls-x509write-csr-set-md-alg(ctx1, md-alg.mbedtls-md-type-t/int)

// \brief           Set the Key Usage Extension flags
// (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)
// 
// \param ctx       CSR context to use
// \param key_usage key usage flags to set
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
// 
// \note            The <code>decipherOnly</code> flag from the Key Usage
// extension is represented by bit 8 (i.e.
// <code>0x8000</code>), which cannot typically be represented
// in an unsigned char. Therefore, the flag
// <code>decipherOnly</code> (i.e.
// #MBEDTLS_X509_KU_DECIPHER_ONLY) cannot be set using this
// function.
pub extern external/mbedtls-x509write-csr-set-key-usage(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^key-usage: int8): int32
  c inline "(int)mbedtls_x509write_csr_set_key_usage((struct mbedtls_x509write_csr*)#1, (unsigned char)#2)"

pub inline fun ffi/mbedtls-x509write-csr-set-key-usage(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^key-usage: int): <> int
  external/mbedtls-x509write-csr-set-key-usage(ctx1, key-usage.int8).int

// \brief           Set Subject Alternative Name
// 
// \param ctx       CSR context to use
// \param san_list  List of SAN values
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
// 
// \note            Only "dnsName", "uniformResourceIdentifier" and "otherName",
// as defined in RFC 5280, are supported.
pub extern external/mbedtls-x509write-csr-set-subject-alternative-name(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^san-list: c-pointer<mbedtls-x509-san-list-c>): int32
  c inline "(int)mbedtls_x509write_csr_set_subject_alternative_name((struct mbedtls_x509write_csr*)#1, (struct mbedtls_x509_san_list*)#2)"

pub inline fun ffi/mbedtls-x509write-csr-set-subject-alternative-name(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^san-list: c-pointer<mbedtls-x509-san-list-c>): <> int
  external/mbedtls-x509write-csr-set-subject-alternative-name(ctx1, san-list).int

// \brief           Set the Netscape Cert Type flags
// (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)
// 
// \param ctx           CSR context to use
// \param ns_cert_type  Netscape Cert Type flags to set
// 
// \return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-csr-set-ns-cert-type(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^ns-cert-type: int8): int32
  c inline "(int)mbedtls_x509write_csr_set_ns_cert_type((struct mbedtls_x509write_csr*)#1, (unsigned char)#2)"

pub inline fun ffi/mbedtls-x509write-csr-set-ns-cert-type(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^ns-cert-type: int): <> int
  external/mbedtls-x509write-csr-set-ns-cert-type(ctx1, ns-cert-type.int8).int

// \brief           Generic function to add to or replace an extension in the
// CSR
// 
// \param ctx       CSR context to use
// \param oid       OID of the extension
// \param oid_len   length of the OID
// \param critical  Set to 1 to mark the extension as critical, 0 otherwise.
// \param val       value of the extension OCTET STRING
// \param val_len   length of the value data
// 
// \return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED
pub extern external/mbedtls-x509write-csr-set-extension(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^oid: c-pointer<int>, ^oid-len: ssize_t, ^critical: int32, ^val: c-pointer<int>, ^val-len: ssize_t): int32
  c inline "(int)mbedtls_x509write_csr_set_extension((struct mbedtls_x509write_csr*)#1, (char*)#2, (size_t)#3, (int)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-x509write-csr-set-extension(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^oid: c-pointer<int>, ^oid-len: int, ^critical: int, ^val: c-pointer<int>, ^val-len: int): <> int
  external/mbedtls-x509write-csr-set-extension(ctx1, oid, oid-len.ssize_t, critical.int32, val, val-len.ssize_t).int

// \brief           Free the contents of a CSR context
// 
// \param ctx       CSR context to free
pub extern external/mbedtls-x509write-csr-free(^ctx1: c-pointer<mbedtls-x509write-csr-c>): ()
  c inline "(void)mbedtls_x509write_csr_free((struct mbedtls_x509write_csr*)#1)"

// \brief           Write a CSR (Certificate Signing Request) to a
// DER structure
// Note: data is written at the end of the buffer! Use the
// return value to determine where you should start
// using the buffer
// 
// \param ctx       CSR to write away
// \param buf       buffer to write to
// \param size      size of the buffer
// \param f_rng     RNG function. This must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \return          length of data written if successful, or a specific
// error code
// 
// \note            \p f_rng is used for the signature operation.
pub extern external/mbedtls-x509write-csr-der(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^buf: c-pointer<int>, ^size: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_x509write_csr_der((struct mbedtls_x509write_csr*)#1, (unsigned char*)#2, (size_t)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-x509write-csr-der(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^buf: c-pointer<int>, ^size: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-x509write-csr-der(ctx1, buf, size.ssize_t, f-rng, p-rng).int

// \brief           Write a CSR (Certificate Signing Request) to a
// PEM string
// 
// \param ctx       CSR to write away
// \param buf       buffer to write to
// \param size      size of the buffer
// \param f_rng     RNG function. This must not be \c NULL.
// \param p_rng     RNG parameter
// 
// \return          0 if successful, or a specific error code
// 
// \note            \p f_rng is used for the signature operation.
pub extern external/mbedtls-x509write-csr-pem(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^buf: c-pointer<int>, ^size: ssize_t, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_x509write_csr_pem((struct mbedtls_x509write_csr*)#1, (unsigned char*)#2, (size_t)#3, (int (*)(void*, unsigned char*, size_t))#4, (void*)#5)"

pub inline fun ffi/mbedtls-x509write-csr-pem(^ctx1: c-pointer<mbedtls-x509write-csr-c>, ^buf: c-pointer<int>, ^size: int, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-x509write-csr-pem(ctx1, buf, size.ssize_t, f-rng, p-rng).int

// \brief  This is the HMAC-based Extract-and-Expand Key Derivation Function
// (HKDF).
// 
// \param  md        A hash function; md.size denotes the length of the hash
// function output in bytes.
// \param  salt      An optional salt value (a non-secret random value);
// if the salt is not provided, a string of all zeros of
// md.size length is used as the salt.
// \param  salt_len  The length in bytes of the optional \p salt.
// \param  ikm       The input keying material.
// \param  ikm_len   The length in bytes of \p ikm.
// \param  info      An optional context and application specific information
// string. This can be a zero-length string.
// \param  info_len  The length of \p info in bytes.
// \param  okm       The output keying material of \p okm_len bytes.
// \param  okm_len   The length of the output keying material in bytes. This
// must be less than or equal to 255 * md.size bytes.
// 
// \return 0 on success.
// \return #MBEDTLS_ERR_HKDF_BAD_INPUT_DATA when the parameters are invalid.
// \return An MBEDTLS_ERR_MD_* error for errors returned from the underlying
// MD layer.
pub extern external/mbedtls-hkdf(^md: c-pointer<mbedtls-md-info-t-c>, ^salt: c-pointer<int>, ^salt-len: ssize_t, ^ikm: c-pointer<int>, ^ikm-len: ssize_t, ^info: c-pointer<int>, ^info-len: ssize_t, ^okm: c-pointer<int>, ^okm-len: ssize_t): int32
  c inline "(int)mbedtls_hkdf((struct mbedtls_md_info_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7, (unsigned char*)#8, (size_t)#9)"

pub inline fun ffi/mbedtls-hkdf(^md: c-pointer<mbedtls-md-info-t-c>, ^salt: c-pointer<int>, ^salt-len: int, ^ikm: c-pointer<int>, ^ikm-len: int, ^info: c-pointer<int>, ^info-len: int, ^okm: c-pointer<int>, ^okm-len: int): <> int
  external/mbedtls-hkdf(md, salt, salt-len.ssize_t, ikm, ikm-len.ssize_t, info, info-len.ssize_t, okm, okm-len.ssize_t).int

// \brief  Take the input keying material \p ikm and extract from it a
// fixed-length pseudorandom key \p prk.
// 
// \warning    This function should only be used if the security of it has been
// studied and established in that particular context (eg. TLS 1.3
// key schedule). For standard HKDF security guarantees use
// \c mbedtls_hkdf instead.
// 
// \param       md        A hash function; md.size denotes the length of the
// hash function output in bytes.
// \param       salt      An optional salt value (a non-secret random value);
// if the salt is not provided, a string of all zeros
// of md.size length is used as the salt.
// \param       salt_len  The length in bytes of the optional \p salt.
// \param       ikm       The input keying material.
// \param       ikm_len   The length in bytes of \p ikm.
// \param[out]  prk       A pseudorandom key of at least md.size bytes.
// 
// \return 0 on success.
// \return #MBEDTLS_ERR_HKDF_BAD_INPUT_DATA when the parameters are invalid.
// \return An MBEDTLS_ERR_MD_* error for errors returned from the underlying
// MD layer.
pub extern external/mbedtls-hkdf-extract(^md: c-pointer<mbedtls-md-info-t-c>, ^salt: c-pointer<int>, ^salt-len: ssize_t, ^ikm: c-pointer<int>, ^ikm-len: ssize_t, ^prk: c-pointer<int>): int32
  c inline "(int)mbedtls_hkdf_extract((struct mbedtls_md_info_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-hkdf-extract(^md: c-pointer<mbedtls-md-info-t-c>, ^salt: c-pointer<int>, ^salt-len: int, ^ikm: c-pointer<int>, ^ikm-len: int, ^prk: c-pointer<int>): <> int
  external/mbedtls-hkdf-extract(md, salt, salt-len.ssize_t, ikm, ikm-len.ssize_t, prk).int

// \brief  Expand the supplied \p prk into several additional pseudorandom
// keys, which is the output of the HKDF.
// 
// \warning    This function should only be used if the security of it has been
// studied and established in that particular context (eg. TLS 1.3
// key schedule). For standard HKDF security guarantees use
// \c mbedtls_hkdf instead.
// 
// \param  md        A hash function; md.size denotes the length of the hash
// function output in bytes.
// \param  prk       A pseudorandom key of at least md.size bytes. \p prk is
// usually the output from the HKDF extract step.
// \param  prk_len   The length in bytes of \p prk.
// \param  info      An optional context and application specific information
// string. This can be a zero-length string.
// \param  info_len  The length of \p info in bytes.
// \param  okm       The output keying material of \p okm_len bytes.
// \param  okm_len   The length of the output keying material in bytes. This
// must be less than or equal to 255 * md.size bytes.
// 
// \return 0 on success.
// \return #MBEDTLS_ERR_HKDF_BAD_INPUT_DATA when the parameters are invalid.
// \return An MBEDTLS_ERR_MD_* error for errors returned from the underlying
// MD layer.
pub extern external/mbedtls-hkdf-expand(^md: c-pointer<mbedtls-md-info-t-c>, ^prk: c-pointer<int>, ^prk-len: ssize_t, ^info: c-pointer<int>, ^info-len: ssize_t, ^okm: c-pointer<int>, ^okm-len: ssize_t): int32
  c inline "(int)mbedtls_hkdf_expand((struct mbedtls_md_info_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (unsigned char*)#6, (size_t)#7)"

pub inline fun ffi/mbedtls-hkdf-expand(^md: c-pointer<mbedtls-md-info-t-c>, ^prk: c-pointer<int>, ^prk-len: int, ^info: c-pointer<int>, ^info-len: int, ^okm: c-pointer<int>, ^okm-len: int): <> int
  external/mbedtls-hkdf-expand(md, prk, prk-len.ssize_t, info, info-len.ssize_t, okm, okm-len.ssize_t).int

pub extern external/mbedtls-timing-get-timer(^val: c-pointer<mbedtls-timing-hr-time-c>, ^reset: int32): int64
  c inline "(unsigned long)mbedtls_timing_get_timer((struct mbedtls_timing_hr_time*)#1, (int)#2)"

pub inline fun ffi/mbedtls-timing-get-timer(^val: c-pointer<mbedtls-timing-hr-time-c>, ^reset: int): <> int
  external/mbedtls-timing-get-timer(val, reset.int32).int

// \brief          Set a pair of delays to watch
// (See \c mbedtls_timing_get_delay().)
// 
// \param data     Pointer to timing data.
// Must point to a valid \c mbedtls_timing_delay_context struct.
// \param int_ms   First (intermediate) delay in milliseconds.
// The effect if int_ms > fin_ms is unspecified.
// \param fin_ms   Second (final) delay in milliseconds.
// Pass 0 to cancel the current delay.
// 
// \note           To set a single delay, either use \c mbedtls_timing_set_timer
// directly or use this function with int_ms == fin_ms.
pub extern external/mbedtls-timing-set-delay(^data: c-pointer<()>, ^int-ms: int32, ^fin-ms: int32): ()
  c inline "(void)mbedtls_timing_set_delay((void*)#1, (int32_t)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-timing-set-delay(^data: c-pointer<()>, ^int-ms: int, ^fin-ms: int): <> ()
  external/mbedtls-timing-set-delay(data, int-ms.int32, fin-ms.int32)

// \brief          Get the status of delays
// (Memory helper: number of delays passed.)
// 
// \param data     Pointer to timing data
// Must point to a valid \c mbedtls_timing_delay_context struct.
// 
// \return         -1 if cancelled (fin_ms = 0),
// 0 if none of the delays are passed,
// 1 if only the intermediate delay is passed,
// 2 if the final delay is passed.
pub extern external/mbedtls-timing-get-delay(^data: c-pointer<()>): int32
  c inline "(int)mbedtls_timing_get_delay((void*)#1)"

pub inline fun ffi/mbedtls-timing-get-delay(^data: c-pointer<()>): <> int
  external/mbedtls-timing-get-delay(data).int

// \brief          Get the final timing delay
// 
// \param data     Pointer to timing data
// Must point to a valid \c mbedtls_timing_delay_context struct.
// 
// \return         Final timing delay in milliseconds.
pub extern external/mbedtls-timing-get-final-delay(^data: c-pointer<mbedtls-timing-delay-context-c>): int32
  c inline "(int32_t)mbedtls_timing_get_final_delay((struct mbedtls_timing_delay_context*)#1)"

pub inline fun ffi/mbedtls-timing-get-final-delay(^data: c-pointer<mbedtls-timing-delay-context-c>): <> int
  external/mbedtls-timing-get-final-delay(data).int

// \brief           This function initializes the specified key wrapping context
// to make references valid and prepare the context
// for mbedtls_nist_kw_setkey() or mbedtls_nist_kw_free().
// 
// \param ctx       The key wrapping context to initialize.
pub extern external/mbedtls-nist-kw-init(^ctx1: c-pointer<mbedtls-nist-kw-context-c>): ()
  c inline "(void)mbedtls_nist_kw_init((mbedtls_nist_kw_context*)#1)"

// \brief           This function initializes the key wrapping context set in the
// \p ctx parameter and sets the encryption key.
// 
// \param ctx       The key wrapping context.
// \param cipher    The 128-bit block cipher to use. Only AES is supported.
// \param key       The Key Encryption Key (KEK).
// \param keybits   The KEK size in bits. This must be acceptable by the cipher.
// \param is_wrap   Specify whether the operation within the context is wrapping or unwrapping
// 
// \return          \c 0 on success.
// \return          \c MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA for any invalid input.
// \return          \c MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE for 128-bit block ciphers
// which are not supported.
// \return          cipher-specific error code on failure of the underlying cipher.
pub extern external/mbedtls-nist-kw-setkey(^ctx1: c-pointer<mbedtls-nist-kw-context-c>, ^cipher: int32, ^key: c-pointer<int>, ^keybits: int32, ^is-wrap: int32): int32
  c inline "(int)mbedtls_nist_kw_setkey((mbedtls_nist_kw_context*)#1, (int32_t)#2, (unsigned char*)#3, (unsigned int)#4, (int)#5)"

pub inline fun ffi/mbedtls-nist-kw-setkey(^ctx1: c-pointer<mbedtls-nist-kw-context-c>, ^cipher: mbedtls-cipher-id-t, ^key: c-pointer<int>, ^keybits: int, ^is-wrap: int): <exn> int
  external/mbedtls-nist-kw-setkey(ctx1, cipher.mbedtls-cipher-id-t/int, key, keybits.int32, is-wrap.int32).int

// \brief   This function releases and clears the specified key wrapping context
// and underlying cipher sub-context.
// 
// \param ctx       The key wrapping context to clear.
pub extern external/mbedtls-nist-kw-free(^ctx1: c-pointer<mbedtls-nist-kw-context-c>): ()
  c inline "(void)mbedtls_nist_kw_free((mbedtls_nist_kw_context*)#1)"

// \brief           This function encrypts a buffer using key wrapping.
// 
// \param ctx       The key wrapping context to use for encryption.
// \param mode      The key wrapping mode to use (MBEDTLS_KW_MODE_KW or MBEDTLS_KW_MODE_KWP)
// \param input     The buffer holding the input data.
// \param in_len    The length of the input data in Bytes.
// The input uses units of 8 Bytes called semiblocks.
// <ul><li>For KW mode: a multiple of 8 bytes between 16 and 2^57-8 inclusive. </li>
// <li>For KWP mode: any length between 1 and 2^32-1 inclusive.</li></ul>
// \param[out] output    The buffer holding the output data.
// <ul><li>For KW mode: Must be at least 8 bytes larger than \p in_len.</li>
// <li>For KWP mode: Must be at least 8 bytes larger rounded up to a multiple of
// 8 bytes for KWP (15 bytes at most).</li></ul>
// \param[out] out_len The number of bytes written to the output buffer. \c 0 on failure.
// \param[in] out_size The capacity of the output buffer.
// 
// \return          \c 0 on success.
// \return          \c MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA for invalid input length.
// \return          cipher-specific error code on failure of the underlying cipher.
pub extern external/mbedtls-nist-kw-wrap(^ctx1: c-pointer<mbedtls-nist-kw-context-c>, ^mode: int32, ^input: c-pointer<int>, ^in-len: ssize_t, ^output: c-pointer<int>, ^out-len: c-pointer<int>, ^out-size: ssize_t): int32
  c inline "(int)mbedtls_nist_kw_wrap((mbedtls_nist_kw_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t*)#6, (size_t)#7)"

pub inline fun ffi/mbedtls-nist-kw-wrap(^ctx1: c-pointer<mbedtls-nist-kw-context-c>, ^mode: mbedtls-nist-kw-mode-t, ^input: c-pointer<int>, ^in-len: int, ^output: c-pointer<int>, ^out-len: c-pointer<int>, ^out-size: int): <exn> int
  external/mbedtls-nist-kw-wrap(ctx1, mode.mbedtls-nist-kw-mode-t/int, input, in-len.ssize_t, output, out-len, out-size.ssize_t).int

// \brief           This function decrypts a buffer using key wrapping.
// 
// \param ctx       The key wrapping context to use for decryption.
// \param mode      The key wrapping mode to use (MBEDTLS_KW_MODE_KW or MBEDTLS_KW_MODE_KWP)
// \param input     The buffer holding the input data.
// \param in_len    The length of the input data in Bytes.
// The input uses units of 8 Bytes called semiblocks.
// The input must be a multiple of semiblocks.
// <ul><li>For KW mode: a multiple of 8 bytes between 24 and 2^57 inclusive. </li>
// <li>For KWP mode: a multiple of 8 bytes between 16 and 2^32 inclusive.</li></ul>
// \param[out] output    The buffer holding the output data.
// The output buffer's minimal length is 8 bytes shorter than \p in_len.
// \param[out] out_len The number of bytes written to the output buffer. \c 0 on failure.
// For KWP mode, the length could be up to 15 bytes shorter than \p in_len,
// depending on how much padding was added to the data.
// \param[in] out_size The capacity of the output buffer.
// 
// \return          \c 0 on success.
// \return          \c MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA for invalid input length.
// \return          \c MBEDTLS_ERR_CIPHER_AUTH_FAILED for verification failure of the ciphertext.
// \return          cipher-specific error code on failure of the underlying cipher.
pub extern external/mbedtls-nist-kw-unwrap(^ctx1: c-pointer<mbedtls-nist-kw-context-c>, ^mode: int32, ^input: c-pointer<int>, ^in-len: ssize_t, ^output: c-pointer<int>, ^out-len: c-pointer<int>, ^out-size: ssize_t): int32
  c inline "(int)mbedtls_nist_kw_unwrap((mbedtls_nist_kw_context*)#1, (int32_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t*)#6, (size_t)#7)"

pub inline fun ffi/mbedtls-nist-kw-unwrap(^ctx1: c-pointer<mbedtls-nist-kw-context-c>, ^mode: mbedtls-nist-kw-mode-t, ^input: c-pointer<int>, ^in-len: int, ^output: c-pointer<int>, ^out-len: c-pointer<int>, ^out-size: int): <exn> int
  external/mbedtls-nist-kw-unwrap(ctx1, mode.mbedtls-nist-kw-mode-t/int, input, in-len.ssize_t, output, out-len, out-size.ssize_t).int

// \brief          The key wrapping checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-nist-kw-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_nist_kw_self_test((int)#1)"

pub inline fun ffi/mbedtls-nist-kw-self-test(^verbose: int): <> int
  external/mbedtls-nist-kw-self-test(verbose.int32).int

// \brief          Initialize a context
// Just makes the context ready to be used or freed safely.
// 
// \param ctx      Context to initialize
pub extern external/mbedtls-net-init(^ctx1: c-pointer<mbedtls-net-context-c>): ()
  c inline "(void)mbedtls_net_init((struct mbedtls_net_context*)#1)"

// \brief          Initiate a connection with host:port in the given protocol
// 
// \param ctx      Socket to use
// \param host     Host to connect to
// \param port     Port to connect to
// \param proto    Protocol: MBEDTLS_NET_PROTO_TCP or MBEDTLS_NET_PROTO_UDP
// 
// \return         0 if successful, or one of:
// MBEDTLS_ERR_NET_SOCKET_FAILED,
// MBEDTLS_ERR_NET_UNKNOWN_HOST,
// MBEDTLS_ERR_NET_CONNECT_FAILED
// 
// \note           Sets the socket in connected mode even with UDP.
pub extern external/mbedtls-net-connect(^ctx1: c-pointer<mbedtls-net-context-c>, ^host: c-pointer<int>, ^port: c-pointer<int>, ^proto: int32): int32
  c inline "(int)mbedtls_net_connect((struct mbedtls_net_context*)#1, (char*)#2, (char*)#3, (int)#4)"

pub inline fun ffi/mbedtls-net-connect(^ctx1: c-pointer<mbedtls-net-context-c>, ^host: c-pointer<int>, ^port: c-pointer<int>, ^proto: int): <> int
  external/mbedtls-net-connect(ctx1, host, port, proto.int32).int

// \brief          Create a receiving socket on bind_ip:port in the chosen
// protocol. If bind_ip == NULL, all interfaces are bound.
// 
// \param ctx      Socket to use
// \param bind_ip  IP to bind to, can be NULL
// \param port     Port number to use
// \param proto    Protocol: MBEDTLS_NET_PROTO_TCP or MBEDTLS_NET_PROTO_UDP
// 
// \return         0 if successful, or one of:
// MBEDTLS_ERR_NET_SOCKET_FAILED,
// MBEDTLS_ERR_NET_UNKNOWN_HOST,
// MBEDTLS_ERR_NET_BIND_FAILED,
// MBEDTLS_ERR_NET_LISTEN_FAILED
// 
// \note           Regardless of the protocol, opens the sockets and binds it.
// In addition, make the socket listening if protocol is TCP.
pub extern external/mbedtls-net-bind(^ctx1: c-pointer<mbedtls-net-context-c>, ^bind-ip: c-pointer<int>, ^port: c-pointer<int>, ^proto: int32): int32
  c inline "(int)mbedtls_net_bind((struct mbedtls_net_context*)#1, (char*)#2, (char*)#3, (int)#4)"

pub inline fun ffi/mbedtls-net-bind(^ctx1: c-pointer<mbedtls-net-context-c>, ^bind-ip: c-pointer<int>, ^port: c-pointer<int>, ^proto: int): <> int
  external/mbedtls-net-bind(ctx1, bind-ip, port, proto.int32).int

// \brief           Accept a connection from a remote client
// 
// \param bind_ctx  Relevant socket
// \param client_ctx Will contain the connected client socket
// \param client_ip Will contain the client IP address, can be NULL
// \param buf_size  Size of the client_ip buffer
// \param cip_len   Will receive the size of the client IP written,
// can be NULL if client_ip is null
// 
// \return          0 if successful, or
// MBEDTLS_ERR_NET_SOCKET_FAILED,
// MBEDTLS_ERR_NET_BIND_FAILED,
// MBEDTLS_ERR_NET_ACCEPT_FAILED, or
// MBEDTLS_ERR_NET_BUFFER_TOO_SMALL if buf_size is too small,
// MBEDTLS_ERR_SSL_WANT_READ if bind_fd was set to
// non-blocking and accept() would block.
pub extern external/mbedtls-net-accept(^bind-ctx: c-pointer<mbedtls-net-context-c>, ^client-ctx: c-pointer<mbedtls-net-context-c>, ^client-ip: c-pointer<()>, ^buf-size: ssize_t, ^cip-len: c-pointer<int>): int32
  c inline "(int)mbedtls_net_accept((struct mbedtls_net_context*)#1, (struct mbedtls_net_context*)#2, (void*)#3, (size_t)#4, (size_t*)#5)"

pub inline fun ffi/mbedtls-net-accept(^bind-ctx: c-pointer<mbedtls-net-context-c>, ^client-ctx: c-pointer<mbedtls-net-context-c>, ^client-ip: c-pointer<()>, ^buf-size: int, ^cip-len: c-pointer<int>): <> int
  external/mbedtls-net-accept(bind-ctx, client-ctx, client-ip, buf-size.ssize_t, cip-len).int

// \brief          Check and wait for the context to be ready for read/write
// 
// \note           The current implementation of this function uses
// select() and returns an error if the file descriptor
// is \c FD_SETSIZE or greater.
// 
// \param ctx      Socket to check
// \param rw       Bitflag composed of MBEDTLS_NET_POLL_READ and
// MBEDTLS_NET_POLL_WRITE specifying the events
// to wait for:
// - If MBEDTLS_NET_POLL_READ is set, the function
// will return as soon as the net context is available
// for reading.
// - If MBEDTLS_NET_POLL_WRITE is set, the function
// will return as soon as the net context is available
// for writing.
// \param timeout  Maximal amount of time to wait before returning,
// in milliseconds. If \c timeout is zero, the
// function returns immediately. If \c timeout is
// -1u, the function blocks potentially indefinitely.
// 
// \return         Bitmask composed of MBEDTLS_NET_POLL_READ/WRITE
// on success or timeout, or a negative return code otherwise.
pub extern external/mbedtls-net-poll(^ctx1: c-pointer<mbedtls-net-context-c>, ^rw: int32, ^timeout: int32): int32
  c inline "(int)mbedtls_net_poll((struct mbedtls_net_context*)#1, (int32_t)#2, (int32_t)#3)"

pub inline fun ffi/mbedtls-net-poll(^ctx1: c-pointer<mbedtls-net-context-c>, ^rw: int, ^timeout: int): <> int
  external/mbedtls-net-poll(ctx1, rw.int32, timeout.int32).int

// \brief          Set the socket blocking
// 
// \param ctx      Socket to set
// 
// \return         0 if successful, or a non-zero error code
pub extern external/mbedtls-net-set-block(^ctx1: c-pointer<mbedtls-net-context-c>): int32
  c inline "(int)mbedtls_net_set_block((struct mbedtls_net_context*)#1)"

pub inline fun ffi/mbedtls-net-set-block(^ctx1: c-pointer<mbedtls-net-context-c>): <> int
  external/mbedtls-net-set-block(ctx1).int

// \brief          Set the socket non-blocking
// 
// \param ctx      Socket to set
// 
// \return         0 if successful, or a non-zero error code
pub extern external/mbedtls-net-set-nonblock(^ctx1: c-pointer<mbedtls-net-context-c>): int32
  c inline "(int)mbedtls_net_set_nonblock((struct mbedtls_net_context*)#1)"

pub inline fun ffi/mbedtls-net-set-nonblock(^ctx1: c-pointer<mbedtls-net-context-c>): <> int
  external/mbedtls-net-set-nonblock(ctx1).int

// \brief          Portable usleep helper
// 
// \param usec     Amount of microseconds to sleep
// 
// \note           Real amount of time slept will not be less than
// select()'s timeout granularity (typically, 10ms).
pub extern external/mbedtls-net-usleep(^usec: int64): ()
  c inline "(void)mbedtls_net_usleep((unsigned long)#1)"

pub inline fun ffi/mbedtls-net-usleep(^usec: int): <> ()
  external/mbedtls-net-usleep(usec.int64)

// \brief          Read at most 'len' characters. If no error occurs,
// the actual amount read is returned.
// 
// \param ctx      Socket
// \param buf      The buffer to write to
// \param len      Maximum length of the buffer
// 
// \return         the number of bytes received,
// or a non-zero error code; with a non-blocking socket,
// MBEDTLS_ERR_SSL_WANT_READ indicates read() would block.
pub extern external/mbedtls-net-recv(^ctx1: c-pointer<()>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_net_recv((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-net-recv(^ctx1: c-pointer<()>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-net-recv(ctx1, buf, len.ssize_t).int

// \brief          Write at most 'len' characters. If no error occurs,
// the actual amount read is returned.
// 
// \param ctx      Socket
// \param buf      The buffer to read from
// \param len      The length of the buffer
// 
// \return         the number of bytes sent,
// or a non-zero error code; with a non-blocking socket,
// MBEDTLS_ERR_SSL_WANT_WRITE indicates write() would block.
pub extern external/mbedtls-net-send(^ctx1: c-pointer<()>, ^buf: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_net_send((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-net-send(^ctx1: c-pointer<()>, ^buf: c-pointer<int>, ^len: int): <> int
  external/mbedtls-net-send(ctx1, buf, len.ssize_t).int

// \brief          Read at most 'len' characters, blocking for at most
// 'timeout' seconds. If no error occurs, the actual amount
// read is returned.
// 
// \note           The current implementation of this function uses
// select() and returns an error if the file descriptor
// is \c FD_SETSIZE or greater.
// 
// \param ctx      Socket
// \param buf      The buffer to write to
// \param len      Maximum length of the buffer
// \param timeout  Maximum number of milliseconds to wait for data
// 0 means no timeout (wait forever)
// 
// \return         The number of bytes received if successful.
// MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out.
// MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.
// Another negative error code (MBEDTLS_ERR_NET_xxx)
// for other failures.
// 
// \note           This function will block (until data becomes available or
// timeout is reached) even if the socket is set to
// non-blocking. Handling timeouts with non-blocking reads
// requires a different strategy.
pub extern external/mbedtls-net-recv-timeout(^ctx1: c-pointer<()>, ^buf: c-pointer<int>, ^len: ssize_t, ^timeout: int32): int32
  c inline "(int)mbedtls_net_recv_timeout((void*)#1, (unsigned char*)#2, (size_t)#3, (int32_t)#4)"

pub inline fun ffi/mbedtls-net-recv-timeout(^ctx1: c-pointer<()>, ^buf: c-pointer<int>, ^len: int, ^timeout: int): <> int
  external/mbedtls-net-recv-timeout(ctx1, buf, len.ssize_t, timeout.int32).int

// \brief          Closes down the connection and free associated data
// 
// \param ctx      The context to close
// 
// \note           This function frees and clears data associated with the
// context but does not free the memory pointed to by \p ctx.
// This memory is the responsibility of the caller.
pub extern external/mbedtls-net-close(^ctx1: c-pointer<mbedtls-net-context-c>): ()
  c inline "(void)mbedtls_net_close((struct mbedtls_net_context*)#1)"

// \brief          Gracefully shutdown the connection and free associated data
// 
// \param ctx      The context to free
// 
// \note           This function frees and clears data associated with the
// context but does not free the memory pointed to by \p ctx.
// This memory is the responsibility of the caller.
pub extern external/mbedtls-net-free(^ctx1: c-pointer<mbedtls-net-context-c>): ()
  c inline "(void)mbedtls_net_free((struct mbedtls_net_context*)#1)"

// \brief           Platform-specific entropy poll callback
pub extern external/mbedtls-platform-entropy-poll(^data: c-pointer<()>, ^output: c-pointer<int>, ^len: ssize_t, ^olen: c-pointer<int>): int32
  c inline "(int)mbedtls_platform_entropy_poll((void*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-platform-entropy-poll(^data: c-pointer<()>, ^output: c-pointer<int>, ^len: int, ^olen: c-pointer<int>): <> int
  external/mbedtls-platform-entropy-poll(data, output, len.ssize_t, olen).int

// \brief           Initialize the context
// 
// \param ctx       Entropy context to initialize
pub extern external/mbedtls-entropy-init(^ctx1: c-pointer<mbedtls-entropy-context-c>): ()
  c inline "(void)mbedtls_entropy_init((struct mbedtls_entropy_context*)#1)"

// \brief           Free the data in the context
// 
// \param ctx       Entropy context to free
pub extern external/mbedtls-entropy-free(^ctx1: c-pointer<mbedtls-entropy-context-c>): ()
  c inline "(void)mbedtls_entropy_free((struct mbedtls_entropy_context*)#1)"

// \brief           Adds an entropy source to poll
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param ctx       Entropy context
// \param f_source  Entropy function
// \param p_source  Function data
// \param threshold Minimum required from source before entropy is released
// ( with mbedtls_entropy_func() ) (in bytes)
// \param strong    MBEDTLS_ENTROPY_SOURCE_STRONG or
// MBEDTLS_ENTROPY_SOURCE_WEAK.
// At least one strong source needs to be added.
// Weaker sources (such as the cycle counter) can be used as
// a complement.
// 
// \return          0 if successful or MBEDTLS_ERR_ENTROPY_MAX_SOURCES
pub extern external/mbedtls-entropy-add-source(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^f-source: c-pointer<intptr_t>, ^p-source: c-pointer<()>, ^threshold: ssize_t, ^strong: int32): int32
  c inline "(int)mbedtls_entropy_add_source((struct mbedtls_entropy_context*)#1, (mbedtls_entropy_f_source_ptr)#2, (void*)#3, (size_t)#4, (int)#5)"

pub inline fun ffi/mbedtls-entropy-add-source(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^f-source: mbedtls-entropy-f-source-ptr, ^p-source: c-pointer<()>, ^threshold: int, ^strong: int): <> int
  external/mbedtls-entropy-add-source(ctx1, f-source, p-source, threshold.ssize_t, strong.int32).int

// \brief           Trigger an extra gather poll for the accumulator
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param ctx       Entropy context
// 
// \return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED
pub extern external/mbedtls-entropy-gather(^ctx1: c-pointer<mbedtls-entropy-context-c>): int32
  c inline "(int)mbedtls_entropy_gather((struct mbedtls_entropy_context*)#1)"

pub inline fun ffi/mbedtls-entropy-gather(^ctx1: c-pointer<mbedtls-entropy-context-c>): <> int
  external/mbedtls-entropy-gather(ctx1).int

// \brief           Retrieve entropy from the accumulator
// (Maximum length: MBEDTLS_ENTROPY_BLOCK_SIZE)
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param data      Entropy context
// \param output    Buffer to fill
// \param len       Number of bytes desired, must be at most MBEDTLS_ENTROPY_BLOCK_SIZE
// 
// \return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED
pub extern external/mbedtls-entropy-func(^data: c-pointer<()>, ^output: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_entropy_func((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-entropy-func(^data: c-pointer<()>, ^output: c-pointer<int>, ^len: int): <> int
  external/mbedtls-entropy-func(data, output, len.ssize_t).int

// \brief           Add data to the accumulator manually
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param ctx       Entropy context
// \param data      Data to add
// \param len       Length of data
// 
// \return          0 if successful
pub extern external/mbedtls-entropy-update-manual(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^data: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_entropy_update_manual((struct mbedtls_entropy_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-entropy-update-manual(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^data: c-pointer<int>, ^len: int): <> int
  external/mbedtls-entropy-update-manual(ctx1, data, len.ssize_t).int

// \brief               Write a seed file
// 
// \param ctx           Entropy context
// \param path          Name of the file
// 
// \return              0 if successful,
// MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR on file error, or
// MBEDTLS_ERR_ENTROPY_SOURCE_FAILED
pub extern external/mbedtls-entropy-write-seed-file(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_entropy_write_seed_file((struct mbedtls_entropy_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-entropy-write-seed-file(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-entropy-write-seed-file(ctx1, path).int

// \brief               Read and update a seed file. Seed is added to this
// instance. No more than MBEDTLS_ENTROPY_MAX_SEED_SIZE bytes are
// read from the seed file. The rest is ignored.
// 
// \param ctx           Entropy context
// \param path          Name of the file
// 
// \return              0 if successful,
// MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR on file error,
// MBEDTLS_ERR_ENTROPY_SOURCE_FAILED
pub extern external/mbedtls-entropy-update-seed-file(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_entropy_update_seed_file((struct mbedtls_entropy_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-entropy-update-seed-file(^ctx1: c-pointer<mbedtls-entropy-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-entropy-update-seed-file(ctx1, path).int

// \brief          Checkup routine
// 
// This module self-test also calls the entropy self-test,
// mbedtls_entropy_source_self_test();
// 
// \return         0 if successful, or 1 if a test failed
pub extern external/mbedtls-entropy-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_entropy_self_test((int)#1)"

pub inline fun ffi/mbedtls-entropy-self-test(^verbose: int): <> int
  external/mbedtls-entropy-self-test(verbose.int32).int

// \brief            PKCS12 Password Based function (encryption / decryption)
// for cipher-based and mbedtls_md-based PBE's
// 
// \note             When encrypting, #MBEDTLS_CIPHER_PADDING_PKCS7 must
// be enabled at compile time.
// 
// \deprecated       This function is deprecated and will be removed in a
// future version of the library.
// Please use mbedtls_pkcs12_pbe_ext() instead.
// 
// \warning          When decrypting:
// - if #MBEDTLS_CIPHER_PADDING_PKCS7 is enabled at compile
// time, this function validates the CBC padding and returns
// #MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH if the padding is
// invalid. Note that this can help active adversaries
// attempting to brute-forcing the password. Note also that
// there is no guarantee that an invalid password will be
// detected (the chances of a valid padding with a random
// password are about 1/255).
// - if #MBEDTLS_CIPHER_PADDING_PKCS7 is disabled at compile
// time, this function does not validate the CBC padding.
// 
// \param pbe_params an ASN1 buffer containing the pkcs-12 PbeParams structure
// \param mode       either #MBEDTLS_PKCS12_PBE_ENCRYPT or
// #MBEDTLS_PKCS12_PBE_DECRYPT
// \param cipher_type the cipher used
// \param md_type    the mbedtls_md used
// \param pwd        Latin1-encoded password used. This may only be \c NULL when
// \p pwdlen is 0. No null terminator should be used.
// \param pwdlen     length of the password (may be 0)
// \param data       the input data
// \param len        data length
// \param output     Output buffer.
// On success, it contains the encrypted or decrypted data,
// possibly followed by the CBC padding.
// On failure, the content is indeterminate.
// For decryption, there must be enough room for \p len
// bytes.
// For encryption, there must be enough room for
// \p len + 1 bytes, rounded up to the block size of
// the block cipher identified by \p pbe_params.
// 
// \return           0 if successful, or a MBEDTLS_ERR_XXX code
pub extern external/mbedtls-pkcs12-pbe(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int32, ^cipher-type: int32, ^md-type: int32, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^data: c-pointer<int>, ^len: ssize_t, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_pkcs12_pbe((struct mbedtls_asn1_buf*)#1, (int)#2, (int32_t)#3, (int32_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (size_t)#8, (unsigned char*)#9)"

pub inline fun ffi/mbedtls-pkcs12-pbe(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int, ^cipher-type: mbedtls-cipher-type-t, ^md-type: mbedtls-md-type-t, ^pwd: c-pointer<int>, ^pwdlen: int, ^data: c-pointer<int>, ^len: int, ^output: c-pointer<int>): <exn> int
  external/mbedtls-pkcs12-pbe(pbe-params, mode.int32, cipher-type.mbedtls-cipher-type-t/int, md-type.mbedtls-md-type-t/int, pwd, pwdlen.ssize_t, data, len.ssize_t, output).int

// \brief            PKCS12 Password Based function (encryption / decryption)
// for cipher-based and mbedtls_md-based PBE's
// 
// 
// \warning          When decrypting:
// - This function validates the CBC padding and returns
// #MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH if the padding is
// invalid. Note that this can help active adversaries
// attempting to brute-forcing the password. Note also that
// there is no guarantee that an invalid password will be
// detected (the chances of a valid padding with a random
// password are about 1/255).
// 
// \param pbe_params an ASN1 buffer containing the pkcs-12 PbeParams structure
// \param mode       either #MBEDTLS_PKCS12_PBE_ENCRYPT or
// #MBEDTLS_PKCS12_PBE_DECRYPT
// \param cipher_type the cipher used
// \param md_type    the mbedtls_md used
// \param pwd        Latin1-encoded password used. This may only be \c NULL when
// \p pwdlen is 0. No null terminator should be used.
// \param pwdlen     length of the password (may be 0)
// \param data       the input data
// \param len        data length
// \param output     Output buffer.
// On success, it contains the encrypted or decrypted data,
// possibly followed by the CBC padding.
// On failure, the content is indeterminate.
// For decryption, there must be enough room for \p len
// bytes.
// For encryption, there must be enough room for
// \p len + 1 bytes, rounded up to the block size of
// the block cipher identified by \p pbe_params.
// \param output_size size of output buffer.
// This must be big enough to accommodate for output plus
// padding data.
// \param output_len On success, length of actual data written to the output buffer.
// 
// \return           0 if successful, or a MBEDTLS_ERR_XXX code
pub extern external/mbedtls-pkcs12-pbe-ext(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int32, ^cipher-type: int32, ^md-type: int32, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^data: c-pointer<int>, ^len: ssize_t, ^output: c-pointer<int>, ^output-size: ssize_t, ^output-len: c-pointer<int>): int32
  c inline "(int)mbedtls_pkcs12_pbe_ext((struct mbedtls_asn1_buf*)#1, (int)#2, (int32_t)#3, (int32_t)#4, (unsigned char*)#5, (size_t)#6, (unsigned char*)#7, (size_t)#8, (unsigned char*)#9, (size_t)#10, (size_t*)#11)"

pub inline fun ffi/mbedtls-pkcs12-pbe-ext(^pbe-params: c-pointer<mbedtls-asn1-buf-c>, ^mode: int, ^cipher-type: mbedtls-cipher-type-t, ^md-type: mbedtls-md-type-t, ^pwd: c-pointer<int>, ^pwdlen: int, ^data: c-pointer<int>, ^len: int, ^output: c-pointer<int>, ^output-size: int, ^output-len: c-pointer<int>): <exn> int
  external/mbedtls-pkcs12-pbe-ext(pbe-params, mode.int32, cipher-type.mbedtls-cipher-type-t/int, md-type.mbedtls-md-type-t/int, pwd, pwdlen.ssize_t, data, len.ssize_t, output, output-size.ssize_t, output-len).int

// \brief            The PKCS#12 derivation function uses a password and a salt
// to produce pseudo-random bits for a particular "purpose".
// 
// Depending on the given id, this function can produce an
// encryption/decryption key, an initialization vector or an
// integrity key.
// 
// \param data       buffer to store the derived data in
// \param datalen    length of buffer to fill
// \param pwd        The password to use. For compliance with PKCS#12 ยงB.1, this
// should be a BMPString, i.e. a Unicode string where each
// character is encoded as 2 bytes in big-endian order, with
// no byte order mark and with a null terminator (i.e. the
// last two bytes should be 0x00 0x00).
// \param pwdlen     length of the password (may be 0).
// \param salt       Salt buffer to use. This may only be \c NULL when
// \p saltlen is 0.
// \param saltlen    length of the salt (may be zero)
// \param mbedtls_md mbedtls_md type to use during the derivation
// \param id         id that describes the purpose (can be
// #MBEDTLS_PKCS12_DERIVE_KEY, #MBEDTLS_PKCS12_DERIVE_IV or
// #MBEDTLS_PKCS12_DERIVE_MAC_KEY)
// \param iterations number of iterations
// 
// \return          0 if successful, or a MD, BIGNUM type error.
pub extern external/mbedtls-pkcs12-derivation(^data: c-pointer<int>, ^datalen: ssize_t, ^pwd: c-pointer<int>, ^pwdlen: ssize_t, ^salt: c-pointer<int>, ^saltlen: ssize_t, ^mbedtls-md: int32, ^id: int32, ^iterations: int32): int32
  c inline "(int)mbedtls_pkcs12_derivation((unsigned char*)#1, (size_t)#2, (unsigned char*)#3, (size_t)#4, (unsigned char*)#5, (size_t)#6, (int32_t)#7, (int)#8, (int)#9)"

pub inline fun ffi/mbedtls-pkcs12-derivation(^data: c-pointer<int>, ^datalen: int, ^pwd: c-pointer<int>, ^pwdlen: int, ^salt: c-pointer<int>, ^saltlen: int, ^mbedtls-md: mbedtls-md-type-t, ^id: int, ^iterations: int): <exn> int
  external/mbedtls-pkcs12-derivation(data, datalen.ssize_t, pwd, pwdlen.ssize_t, salt, saltlen.ssize_t, mbedtls-md.mbedtls-md-type-t/int, id.int32, iterations.int32).int

// \brief          Initialize mbedtls_pkcs7 structure.
// 
// \param pkcs7    mbedtls_pkcs7 structure.
pub extern external/mbedtls-pkcs7-init(^pkcs7: c-pointer<mbedtls-pkcs7-c>): ()
  c inline "(void)mbedtls_pkcs7_init((struct mbedtls_pkcs7*)#1)"

// \brief          Parse a single DER formatted PKCS #7 detached signature.
// 
// \param pkcs7    The mbedtls_pkcs7 structure to be filled by the parser.
// \param buf      The buffer holding only the DER encoded PKCS #7 content.
// \param buflen   The size in bytes of \p buf. The size must be exactly the
// length of the DER encoded PKCS #7 content.
// 
// \note           This function makes an internal copy of the PKCS #7 buffer
// \p buf. In particular, \p buf may be destroyed or reused
// after this call returns.
// \note           Signatures with internal data are not supported.
// 
// \return         The \c mbedtls_pkcs7_type of \p buf, if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-pkcs7-parse-der(^pkcs7: c-pointer<mbedtls-pkcs7-c>, ^buf: c-pointer<int>, ^buflen: ssize_t): int32
  c inline "(int)mbedtls_pkcs7_parse_der((struct mbedtls_pkcs7*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-pkcs7-parse-der(^pkcs7: c-pointer<mbedtls-pkcs7-c>, ^buf: c-pointer<int>, ^buflen: int): <> int
  external/mbedtls-pkcs7-parse-der(pkcs7, buf, buflen.ssize_t).int

// \brief          Verification of PKCS #7 signature against a caller-supplied
// certificate.
// 
// For each signer in the PKCS structure, this function computes
// a signature over the supplied data, using the supplied
// certificate and the same digest algorithm as specified by the
// signer. It then compares this signature against the
// signer's signature; verification succeeds if any comparison
// matches.
// 
// This function does not use the certificates held within the
// PKCS #7 structure itself, and does not check that the
// certificate is signed by a trusted certification authority.
// 
// \param pkcs7    mbedtls_pkcs7 structure containing signature.
// \param cert     Certificate containing key to verify signature.
// \param data     Plain data on which signature has to be verified.
// \param datalen  Length of the data.
// 
// \note           This function internally calculates the hash on the supplied
// plain data for signature verification.
// 
// \return         0 if the signature verifies, or a negative error code on failure.
pub extern external/mbedtls-pkcs7-signed-data-verify(^pkcs7: c-pointer<mbedtls-pkcs7-c>, ^cert: c-pointer<mbedtls-x509-crt-c>, ^data: c-pointer<int>, ^datalen: ssize_t): int32
  c inline "(int)mbedtls_pkcs7_signed_data_verify((struct mbedtls_pkcs7*)#1, (struct mbedtls_x509_crt*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-pkcs7-signed-data-verify(^pkcs7: c-pointer<mbedtls-pkcs7-c>, ^cert: c-pointer<mbedtls-x509-crt-c>, ^data: c-pointer<int>, ^datalen: int): <> int
  external/mbedtls-pkcs7-signed-data-verify(pkcs7, cert, data, datalen.ssize_t).int

// \brief          Verification of PKCS #7 signature against a caller-supplied
// certificate.
// 
// For each signer in the PKCS structure, this function
// validates a signature over the supplied hash, using the
// supplied certificate and the same digest algorithm as
// specified by the signer. Verification succeeds if any
// signature is good.
// 
// This function does not use the certificates held within the
// PKCS #7 structure itself, and does not check that the
// certificate is signed by a trusted certification authority.
// 
// \param pkcs7    PKCS #7 structure containing signature.
// \param cert     Certificate containing key to verify signature.
// \param hash     Hash of the plain data on which signature has to be verified.
// \param hashlen  Length of the hash.
// 
// \note           This function is different from mbedtls_pkcs7_signed_data_verify()
// in that it is directly passed the hash of the data.
// 
// \return         0 if the signature verifies, or a negative error code on failure.
pub extern external/mbedtls-pkcs7-signed-hash-verify(^pkcs7: c-pointer<mbedtls-pkcs7-c>, ^cert: c-pointer<mbedtls-x509-crt-c>, ^hash: c-pointer<int>, ^hashlen: ssize_t): int32
  c inline "(int)mbedtls_pkcs7_signed_hash_verify((struct mbedtls_pkcs7*)#1, (struct mbedtls_x509_crt*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-pkcs7-signed-hash-verify(^pkcs7: c-pointer<mbedtls-pkcs7-c>, ^cert: c-pointer<mbedtls-x509-crt-c>, ^hash: c-pointer<int>, ^hashlen: int): <> int
  external/mbedtls-pkcs7-signed-hash-verify(pkcs7, cert, hash, hashlen.ssize_t).int

// \brief          Unallocate all PKCS #7 data and zeroize the memory.
// It doesn't free \p pkcs7 itself. This should be done by the caller.
// 
// \param pkcs7    mbedtls_pkcs7 structure to free.
pub extern external/mbedtls-pkcs7-free(^pkcs7: c-pointer<mbedtls-pkcs7-c>): ()
  c inline "(void)mbedtls_pkcs7_free((struct mbedtls_pkcs7*)#1)"

// \brief          This function initializes the specified AES context.
// 
// It must be the first API called before using
// the context.
// 
// \param ctx      The AES context to initialize. This must not be \c NULL.
pub extern external/mbedtls-aes-init(^ctx1: c-pointer<mbedtls-aes-context-c>): ()
  c inline "(void)mbedtls_aes_init((struct mbedtls_aes_context*)#1)"

// \brief          This function releases and clears the specified AES context.
// 
// \param ctx      The AES context to clear.
// If this is \c NULL, this function does nothing.
// Otherwise, the context must have been at least initialized.
pub extern external/mbedtls-aes-free(^ctx1: c-pointer<mbedtls-aes-context-c>): ()
  c inline "(void)mbedtls_aes_free((struct mbedtls_aes_context*)#1)"

// \brief          This function initializes the specified AES XTS context.
// 
// It must be the first API called before using
// the context.
// 
// \param ctx      The AES XTS context to initialize. This must not be \c NULL.
pub extern external/mbedtls-aes-xts-init(^ctx1: c-pointer<mbedtls-aes-xts-context-c>): ()
  c inline "(void)mbedtls_aes_xts_init((struct mbedtls_aes_xts_context*)#1)"

// \brief          This function releases and clears the specified AES XTS context.
// 
// \param ctx      The AES XTS context to clear.
// If this is \c NULL, this function does nothing.
// Otherwise, the context must have been at least initialized.
pub extern external/mbedtls-aes-xts-free(^ctx1: c-pointer<mbedtls-aes-xts-context-c>): ()
  c inline "(void)mbedtls_aes_xts_free((struct mbedtls_aes_xts_context*)#1)"

// \brief          This function sets the encryption key.
// 
// \param ctx      The AES context to which the key should be bound.
// It must be initialized.
// \param key      The encryption key.
// This must be a readable buffer of size \p keybits bits.
// \param keybits  The size of data passed in bits. Valid options are:
// <ul><li>128 bits</li>
// <li>192 bits</li>
// <li>256 bits</li></ul>
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
pub extern external/mbedtls-aes-setkey-enc(^ctx1: c-pointer<mbedtls-aes-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_aes_setkey_enc((struct mbedtls_aes_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-aes-setkey-enc(^ctx1: c-pointer<mbedtls-aes-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-aes-setkey-enc(ctx1, key, keybits.int32).int

// \brief          This function sets the decryption key.
// 
// \param ctx      The AES context to which the key should be bound.
// It must be initialized.
// \param key      The decryption key.
// This must be a readable buffer of size \p keybits bits.
// \param keybits  The size of data passed. Valid options are:
// <ul><li>128 bits</li>
// <li>192 bits</li>
// <li>256 bits</li></ul>
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
pub extern external/mbedtls-aes-setkey-dec(^ctx1: c-pointer<mbedtls-aes-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_aes_setkey_dec((struct mbedtls_aes_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-aes-setkey-dec(^ctx1: c-pointer<mbedtls-aes-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-aes-setkey-dec(ctx1, key, keybits.int32).int

// \brief          This function prepares an XTS context for encryption and
// sets the encryption key.
// 
// \param ctx      The AES XTS context to which the key should be bound.
// It must be initialized.
// \param key      The encryption key. This is comprised of the XTS key1
// concatenated with the XTS key2.
// This must be a readable buffer of size \p keybits bits.
// \param keybits  The size of \p key passed in bits. Valid options are:
// <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>
// <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
pub extern external/mbedtls-aes-xts-setkey-enc(^ctx1: c-pointer<mbedtls-aes-xts-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_aes_xts_setkey_enc((struct mbedtls_aes_xts_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-aes-xts-setkey-enc(^ctx1: c-pointer<mbedtls-aes-xts-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-aes-xts-setkey-enc(ctx1, key, keybits.int32).int

// \brief          This function prepares an XTS context for decryption and
// sets the decryption key.
// 
// \param ctx      The AES XTS context to which the key should be bound.
// It must be initialized.
// \param key      The decryption key. This is comprised of the XTS key1
// concatenated with the XTS key2.
// This must be a readable buffer of size \p keybits bits.
// \param keybits  The size of \p key passed in bits. Valid options are:
// <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>
// <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure.
pub extern external/mbedtls-aes-xts-setkey-dec(^ctx1: c-pointer<mbedtls-aes-xts-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_aes_xts_setkey_dec((struct mbedtls_aes_xts_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-aes-xts-setkey-dec(^ctx1: c-pointer<mbedtls-aes-xts-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-aes-xts-setkey-dec(ctx1, key, keybits.int32).int

// \brief          This function performs an AES single-block encryption or
// decryption operation.
// 
// It performs the operation defined in the \p mode parameter
// (encrypt or decrypt), on the input data buffer defined in
// the \p input parameter.
// 
// mbedtls_aes_init(), and either mbedtls_aes_setkey_enc() or
// mbedtls_aes_setkey_dec() must be called before the first
// call to this API with the same context.
// 
// \param ctx      The AES context to use for encryption or decryption.
// It must be initialized and bound to a key.
// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
// #MBEDTLS_AES_DECRYPT.
// \param input    The buffer holding the input data.
// It must be readable and at least \c 16 Bytes long.
// \param output   The buffer where the output data will be written.
// It must be writeable and at least \c 16 Bytes long.
// 
// \return         \c 0 on success.
pub extern external/mbedtls-aes-crypt-ecb(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int32, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_ecb((struct mbedtls_aes_context*)#1, (int)#2, (unsigned char*)#3, (unsigned char*)#4)"

pub inline fun ffi/mbedtls-aes-crypt-ecb(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-aes-crypt-ecb(ctx1, mode.int32, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief  This function performs an AES-CBC encryption or decryption operation
// on full blocks.
// 
// It performs the operation defined in the \p mode
// parameter (encrypt/decrypt), on the input data buffer defined in
// the \p input parameter.
// 
// It can be called as many times as needed, until all the input
// data is processed. mbedtls_aes_init(), and either
// mbedtls_aes_setkey_enc() or mbedtls_aes_setkey_dec() must be called
// before the first call to this API with the same context.
// 
// \note   This function operates on full blocks, that is, the input size
// must be a multiple of the AES block size of \c 16 Bytes.
// 
// \note   Upon exit, the content of the IV is updated so that you can
// call the same function again on the next
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If you need to retain the contents of the IV, you should
// either save it manually or use the cipher module instead.
// 
// 
// \param ctx      The AES context to use for encryption or decryption.
// It must be initialized and bound to a key.
// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
// #MBEDTLS_AES_DECRYPT.
// \param length   The length of the input data in Bytes. This must be a
// multiple of the block size (\c 16 Bytes).
// \param iv       Initialization vector (updated after use).
// It must be a readable and writeable buffer of \c 16 Bytes.
// \param input    The buffer holding the input data.
// It must be readable and of size \p length Bytes.
// \param output   The buffer holding the output data.
// It must be writeable and of size \p length Bytes.
// 
// \return         \c 0 on success.
// \return         #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH
// on failure.
pub extern external/mbedtls-aes-crypt-cbc(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_cbc((struct mbedtls_aes_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-aes-crypt-cbc(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int, ^length: int, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aes-crypt-cbc(ctx1, mode.int32, length.ssize_t, iv.cextern/carray/ptr, input, output).int

// \brief      This function performs an AES-XTS encryption or decryption
// operation for an entire XTS data unit.
// 
// AES-XTS encrypts or decrypts blocks based on their location as
// defined by a data unit number. The data unit number must be
// provided by \p data_unit.
// 
// NIST SP 800-38E limits the maximum size of a data unit to 2^20
// AES blocks. If the data unit is larger than this, this function
// returns #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH.
// 
// \param ctx          The AES XTS context to use for AES XTS operations.
// It must be initialized and bound to a key.
// \param mode         The AES operation: #MBEDTLS_AES_ENCRYPT or
// #MBEDTLS_AES_DECRYPT.
// \param length       The length of a data unit in Bytes. This can be any
// length between 16 bytes and 2^24 bytes inclusive
// (between 1 and 2^20 block cipher blocks).
// \param data_unit    The address of the data unit encoded as an array of 16
// bytes in little-endian format. For disk encryption, this
// is typically the index of the block device sector that
// contains the data.
// \param input        The buffer holding the input data (which is an entire
// data unit). This function reads \p length Bytes from \p
// input.
// \param output       The buffer holding the output data (which is an entire
// data unit). This function writes \p length Bytes to \p
// output.
// 
// \return             \c 0 on success.
// \return             #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH if \p length is
// smaller than an AES block in size (16 Bytes) or if \p
// length is larger than 2^20 blocks (16 MiB).
pub extern external/mbedtls-aes-crypt-xts(^ctx1: c-pointer<mbedtls-aes-xts-context-c>, ^mode: int32, ^length: ssize_t, ^data-unit: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_xts((struct mbedtls_aes_xts_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-aes-crypt-xts(^ctx1: c-pointer<mbedtls-aes-xts-context-c>, ^mode: int, ^length: int, ^data-unit: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aes-crypt-xts(ctx1, mode.int32, length.ssize_t, data-unit.cextern/carray/ptr, input, output).int

// \brief This function performs an AES-CFB128 encryption or decryption
// operation.
// 
// It performs the operation defined in the \p mode
// parameter (encrypt or decrypt), on the input data buffer
// defined in the \p input parameter.
// 
// For CFB, you must set up the context with mbedtls_aes_setkey_enc(),
// regardless of whether you are performing an encryption or decryption
// operation, that is, regardless of the \p mode parameter. This is
// because CFB mode uses the same key schedule for encryption and
// decryption.
// 
// \note  Upon exit, the content of the IV is updated so that you can
// call the same function again on the next
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If you need to retain the contents of the
// IV, you must either save it manually or use the cipher
// module instead.
// 
// 
// \param ctx      The AES context to use for encryption or decryption.
// It must be initialized and bound to a key.
// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
// #MBEDTLS_AES_DECRYPT.
// \param length   The length of the input data in Bytes.
// \param iv_off   The offset in IV (updated after use).
// It must point to a valid \c size_t.
// \param iv       The initialization vector (updated after use).
// It must be a readable and writeable buffer of \c 16 Bytes.
// \param input    The buffer holding the input data.
// It must be readable and of size \p length Bytes.
// \param output   The buffer holding the output data.
// It must be writeable and of size \p length Bytes.
// 
// \return         \c 0 on success.
pub extern external/mbedtls-aes-crypt-cfb128(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int32, ^length: ssize_t, ^iv-off: c-pointer<int>, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_cfb128((struct mbedtls_aes_context*)#1, (int)#2, (size_t)#3, (size_t*)#4, (unsigned char*)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-aes-crypt-cfb128(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int, ^length: int, ^iv-off: c-pointer<int>, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aes-crypt-cfb128(ctx1, mode.int32, length.ssize_t, iv-off, iv.cextern/carray/ptr, input, output).int

// \brief This function performs an AES-CFB8 encryption or decryption
// operation.
// 
// It performs the operation defined in the \p mode
// parameter (encrypt/decrypt), on the input data buffer defined
// in the \p input parameter.
// 
// Due to the nature of CFB, you must use the same key schedule for
// both encryption and decryption operations. Therefore, you must
// use the context initialized with mbedtls_aes_setkey_enc() for
// both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT.
// 
// \note  Upon exit, the content of the IV is updated so that you can
// call the same function again on the next
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If you need to retain the contents of the
// IV, you should either save it manually or use the cipher
// module instead.
// 
// 
// \param ctx      The AES context to use for encryption or decryption.
// It must be initialized and bound to a key.
// \param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or
// #MBEDTLS_AES_DECRYPT
// \param length   The length of the input data.
// \param iv       The initialization vector (updated after use).
// It must be a readable and writeable buffer of \c 16 Bytes.
// \param input    The buffer holding the input data.
// It must be readable and of size \p length Bytes.
// \param output   The buffer holding the output data.
// It must be writeable and of size \p length Bytes.
// 
// \return         \c 0 on success.
pub extern external/mbedtls-aes-crypt-cfb8(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_cfb8((struct mbedtls_aes_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-aes-crypt-cfb8(^ctx1: c-pointer<mbedtls-aes-context-c>, ^mode: int, ^length: int, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aes-crypt-cfb8(ctx1, mode.int32, length.ssize_t, iv.cextern/carray/ptr, input, output).int

// \brief       This function performs an AES-OFB (Output Feedback Mode)
// encryption or decryption operation.
// 
// For OFB, you must set up the context with
// mbedtls_aes_setkey_enc(), regardless of whether you are
// performing an encryption or decryption operation. This is
// because OFB mode uses the same key schedule for encryption and
// decryption.
// 
// The OFB operation is identical for encryption or decryption,
// therefore no operation mode needs to be specified.
// 
// \note        Upon exit, the content of iv, the Initialisation Vector, is
// updated so that you can call the same function again on the next
// block(s) of data and get the same result as if it was encrypted
// in one call. This allows a "streaming" usage, by initialising
// iv_off to 0 before the first call, and preserving its value
// between calls.
// 
// For non-streaming use, the iv should be initialised on each call
// to a unique value, and iv_off set to 0 on each call.
// 
// If you need to retain the contents of the initialisation vector,
// you must either save it manually or use the cipher module
// instead.
// 
// \warning     For the OFB mode, the initialisation vector must be unique
// every encryption operation. Reuse of an initialisation vector
// will compromise security.
// 
// \param ctx      The AES context to use for encryption or decryption.
// It must be initialized and bound to a key.
// \param length   The length of the input data.
// \param iv_off   The offset in IV (updated after use).
// It must point to a valid \c size_t.
// \param iv       The initialization vector (updated after use).
// It must be a readable and writeable buffer of \c 16 Bytes.
// \param input    The buffer holding the input data.
// It must be readable and of size \p length Bytes.
// \param output   The buffer holding the output data.
// It must be writeable and of size \p length Bytes.
// 
// \return         \c 0 on success.
pub extern external/mbedtls-aes-crypt-ofb(^ctx1: c-pointer<mbedtls-aes-context-c>, ^length: ssize_t, ^iv-off: c-pointer<int>, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_ofb((struct mbedtls_aes_context*)#1, (size_t)#2, (size_t*)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-aes-crypt-ofb(^ctx1: c-pointer<mbedtls-aes-context-c>, ^length: int, ^iv-off: c-pointer<int>, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aes-crypt-ofb(ctx1, length.ssize_t, iv-off, iv.cextern/carray/ptr, input, output).int

// \brief      This function performs an AES-CTR encryption or decryption
// operation.
// 
// Due to the nature of CTR, you must use the same key schedule
// for both encryption and decryption operations. Therefore, you
// must use the context initialized with mbedtls_aes_setkey_enc()
// for both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT.
// 
// \warning    You must never reuse a nonce value with the same key. Doing so
// would void the encryption for the two messages encrypted with
// the same nonce and key.
// 
// There are two common strategies for managing nonces with CTR:
// 
// 1. You can handle everything as a single message processed over
// successive calls to this function. In that case, you want to
// set \p nonce_counter and \p nc_off to 0 for the first call, and
// then preserve the values of \p nonce_counter, \p nc_off and \p
// stream_block across calls to this function as they will be
// updated by this function.
// 
// With this strategy, you must not encrypt more than 2**128
// blocks of data with the same key.
// 
// 2. You can encrypt separate messages by dividing the \p
// nonce_counter buffer in two areas: the first one used for a
// per-message nonce, handled by yourself, and the second one
// updated by this function internally.
// 
// For example, you might reserve the first 12 bytes for the
// per-message nonce, and the last 4 bytes for internal use. In that
// case, before calling this function on a new message you need to
// set the first 12 bytes of \p nonce_counter to your chosen nonce
// value, the last 4 to 0, and \p nc_off to 0 (which will cause \p
// stream_block to be ignored). That way, you can encrypt at most
// 2**96 messages of up to 2**32 blocks each with the same key.
// 
// The per-message nonce (or information sufficient to reconstruct
// it) needs to be communicated with the ciphertext and must be unique.
// The recommended way to ensure uniqueness is to use a message
// counter. An alternative is to generate random nonces, but this
// limits the number of messages that can be securely encrypted:
// for example, with 96-bit random nonces, you should not encrypt
// more than 2**32 messages with the same key.
// 
// Note that for both strategies, sizes are measured in blocks and
// that an AES block is 16 bytes.
// 
// \warning    Upon return, \p stream_block contains sensitive data. Its
// content must not be written to insecure storage and should be
// securely discarded as soon as it's no longer needed.
// 
// \param ctx              The AES context to use for encryption or decryption.
// It must be initialized and bound to a key.
// \param length           The length of the input data.
// \param nc_off           The offset in the current \p stream_block, for
// resuming within the current cipher stream. The
// offset pointer should be 0 at the start of a stream.
// It must point to a valid \c size_t.
// \param nonce_counter    The 128-bit nonce and counter.
// It must be a readable-writeable buffer of \c 16 Bytes.
// \param stream_block     The saved stream block for resuming. This is
// overwritten by the function.
// It must be a readable-writeable buffer of \c 16 Bytes.
// \param input            The buffer holding the input data.
// It must be readable and of size \p length Bytes.
// \param output           The buffer holding the output data.
// It must be writeable and of size \p length Bytes.
// 
// \return                 \c 0 on success.
pub extern external/mbedtls-aes-crypt-ctr(^ctx1: c-pointer<mbedtls-aes-context-c>, ^length: ssize_t, ^nc-off: c-pointer<int>, ^nonce-counter: c-pointer<int>, ^stream-block: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aes_crypt_ctr((struct mbedtls_aes_context*)#1, (size_t)#2, (size_t*)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-aes-crypt-ctr(^ctx1: c-pointer<mbedtls-aes-context-c>, ^length: int, ^nc-off: c-pointer<int>, ^nonce-counter: c-array<int>, ^stream-block: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aes-crypt-ctr(ctx1, length.ssize_t, nc-off, nonce-counter.cextern/carray/ptr, stream-block.cextern/carray/ptr, input, output).int

// \brief           Internal AES block encryption function. This is only
// exposed to allow overriding it using
// \c MBEDTLS_AES_ENCRYPT_ALT.
// 
// \param ctx       The AES context to use for encryption.
// \param input     The plaintext block.
// \param output    The output (ciphertext) block.
// 
// \return          \c 0 on success.
pub extern external/mbedtls-internal-aes-encrypt(^ctx1: c-pointer<mbedtls-aes-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_aes_encrypt((struct mbedtls_aes_context*)#1, (unsigned char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-internal-aes-encrypt(^ctx1: c-pointer<mbedtls-aes-context-c>, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-internal-aes-encrypt(ctx1, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief           Internal AES block decryption function. This is only
// exposed to allow overriding it using see
// \c MBEDTLS_AES_DECRYPT_ALT.
// 
// \param ctx       The AES context to use for decryption.
// \param input     The ciphertext block.
// \param output    The output (plaintext) block.
// 
// \return          \c 0 on success.
pub extern external/mbedtls-internal-aes-decrypt(^ctx1: c-pointer<mbedtls-aes-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_internal_aes_decrypt((struct mbedtls_aes_context*)#1, (unsigned char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-internal-aes-decrypt(^ctx1: c-pointer<mbedtls-aes-context-c>, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-internal-aes-decrypt(ctx1, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief          Checkup routine.
// 
// \return         \c 0 on success.
// \return         \c 1 on failure.
pub extern external/mbedtls-aes-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_aes_self_test((int)#1)"

pub inline fun ffi/mbedtls-aes-self-test(^verbose: int): <> int
  external/mbedtls-aes-self-test(verbose.int32).int

// \brief          This function initializes the specified ARIA context.
// 
// It must be the first API called before using
// the context.
// 
// \param ctx      The ARIA context to initialize. This must not be \c NULL.
pub extern external/mbedtls-aria-init(^ctx1: c-pointer<mbedtls-aria-context-c>): ()
  c inline "(void)mbedtls_aria_init((struct mbedtls_aria_context*)#1)"

// \brief          This function releases and clears the specified ARIA context.
// 
// \param ctx      The ARIA context to clear. This may be \c NULL, in which
// case this function returns immediately. If it is not \c NULL,
// it must point to an initialized ARIA context.
pub extern external/mbedtls-aria-free(^ctx1: c-pointer<mbedtls-aria-context-c>): ()
  c inline "(void)mbedtls_aria_free((struct mbedtls_aria_context*)#1)"

// \brief          This function sets the encryption key.
// 
// \param ctx      The ARIA context to which the key should be bound.
// This must be initialized.
// \param key      The encryption key. This must be a readable buffer
// of size \p keybits Bits.
// \param keybits  The size of \p key in Bits. Valid options are:
// <ul><li>128 bits</li>
// <li>192 bits</li>
// <li>256 bits</li></ul>
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-aria-setkey-enc(^ctx1: c-pointer<mbedtls-aria-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_aria_setkey_enc((struct mbedtls_aria_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-aria-setkey-enc(^ctx1: c-pointer<mbedtls-aria-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-aria-setkey-enc(ctx1, key, keybits.int32).int

// \brief          This function sets the decryption key.
// 
// \param ctx      The ARIA context to which the key should be bound.
// This must be initialized.
// \param key      The decryption key. This must be a readable buffer
// of size \p keybits Bits.
// \param keybits  The size of data passed. Valid options are:
// <ul><li>128 bits</li>
// <li>192 bits</li>
// <li>256 bits</li></ul>
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-aria-setkey-dec(^ctx1: c-pointer<mbedtls-aria-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_aria_setkey_dec((struct mbedtls_aria_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-aria-setkey-dec(^ctx1: c-pointer<mbedtls-aria-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-aria-setkey-dec(ctx1, key, keybits.int32).int

// \brief          This function performs an ARIA single-block encryption or
// decryption operation.
// 
// It performs encryption or decryption (depending on whether
// the key was set for encryption on decryption) on the input
// data buffer defined in the \p input parameter.
// 
// mbedtls_aria_init(), and either mbedtls_aria_setkey_enc() or
// mbedtls_aria_setkey_dec() must be called before the first
// call to this API with the same context.
// 
// \param ctx      The ARIA context to use for encryption or decryption.
// This must be initialized and bound to a key.
// \param input    The 16-Byte buffer holding the input data.
// \param output   The 16-Byte buffer holding the output data.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-aria-crypt-ecb(^ctx1: c-pointer<mbedtls-aria-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aria_crypt_ecb((struct mbedtls_aria_context*)#1, (unsigned char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-aria-crypt-ecb(^ctx1: c-pointer<mbedtls-aria-context-c>, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-aria-crypt-ecb(ctx1, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief  This function performs an ARIA-CBC encryption or decryption operation
// on full blocks.
// 
// It performs the operation defined in the \p mode
// parameter (encrypt/decrypt), on the input data buffer defined in
// the \p input parameter.
// 
// It can be called as many times as needed, until all the input
// data is processed. mbedtls_aria_init(), and either
// mbedtls_aria_setkey_enc() or mbedtls_aria_setkey_dec() must be called
// before the first call to this API with the same context.
// 
// \note   This function operates on aligned blocks, that is, the input size
// must be a multiple of the ARIA block size of 16 Bytes.
// 
// \note   Upon exit, the content of the IV is updated so that you can
// call the same function again on the next
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If you need to retain the contents of the IV, you should
// either save it manually or use the cipher module instead.
// 
// 
// \param ctx      The ARIA context to use for encryption or decryption.
// This must be initialized and bound to a key.
// \param mode     The mode of operation. This must be either
// #MBEDTLS_ARIA_ENCRYPT for encryption, or
// #MBEDTLS_ARIA_DECRYPT for decryption.
// \param length   The length of the input data in Bytes. This must be a
// multiple of the block size (16 Bytes).
// \param iv       Initialization vector (updated after use).
// This must be a readable buffer of size 16 Bytes.
// \param input    The buffer holding the input data. This must
// be a readable buffer of length \p length Bytes.
// \param output   The buffer holding the output data. This must
// be a writable buffer of length \p length Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-aria-crypt-cbc(^ctx1: c-pointer<mbedtls-aria-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aria_crypt_cbc((struct mbedtls_aria_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-aria-crypt-cbc(^ctx1: c-pointer<mbedtls-aria-context-c>, ^mode: int, ^length: int, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aria-crypt-cbc(ctx1, mode.int32, length.ssize_t, iv.cextern/carray/ptr, input, output).int

// \brief This function performs an ARIA-CFB128 encryption or decryption
// operation.
// 
// It performs the operation defined in the \p mode
// parameter (encrypt or decrypt), on the input data buffer
// defined in the \p input parameter.
// 
// For CFB, you must set up the context with mbedtls_aria_setkey_enc(),
// regardless of whether you are performing an encryption or decryption
// operation, that is, regardless of the \p mode parameter. This is
// because CFB mode uses the same key schedule for encryption and
// decryption.
// 
// \note  Upon exit, the content of the IV is updated so that you can
// call the same function again on the next
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If you need to retain the contents of the
// IV, you must either save it manually or use the cipher
// module instead.
// 
// 
// \param ctx      The ARIA context to use for encryption or decryption.
// This must be initialized and bound to a key.
// \param mode     The mode of operation. This must be either
// #MBEDTLS_ARIA_ENCRYPT for encryption, or
// #MBEDTLS_ARIA_DECRYPT for decryption.
// \param length   The length of the input data \p input in Bytes.
// \param iv_off   The offset in IV (updated after use).
// This must not be larger than 15.
// \param iv       The initialization vector (updated after use).
// This must be a readable buffer of size 16 Bytes.
// \param input    The buffer holding the input data. This must
// be a readable buffer of length \p length Bytes.
// \param output   The buffer holding the output data. This must
// be a writable buffer of length \p length Bytes.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
pub extern external/mbedtls-aria-crypt-cfb128(^ctx1: c-pointer<mbedtls-aria-context-c>, ^mode: int32, ^length: ssize_t, ^iv-off: c-pointer<int>, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aria_crypt_cfb128((struct mbedtls_aria_context*)#1, (int)#2, (size_t)#3, (size_t*)#4, (unsigned char*)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-aria-crypt-cfb128(^ctx1: c-pointer<mbedtls-aria-context-c>, ^mode: int, ^length: int, ^iv-off: c-pointer<int>, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aria-crypt-cfb128(ctx1, mode.int32, length.ssize_t, iv-off, iv.cextern/carray/ptr, input, output).int

// \brief      This function performs an ARIA-CTR encryption or decryption
// operation.
// 
// Due to the nature of CTR, you must use the same key schedule
// for both encryption and decryption operations. Therefore, you
// must use the context initialized with mbedtls_aria_setkey_enc()
// for both #MBEDTLS_ARIA_ENCRYPT and #MBEDTLS_ARIA_DECRYPT.
// 
// \warning    You must never reuse a nonce value with the same key. Doing so
// would void the encryption for the two messages encrypted with
// the same nonce and key.
// 
// There are two common strategies for managing nonces with CTR:
// 
// 1. You can handle everything as a single message processed over
// successive calls to this function. In that case, you want to
// set \p nonce_counter and \p nc_off to 0 for the first call, and
// then preserve the values of \p nonce_counter, \p nc_off and \p
// stream_block across calls to this function as they will be
// updated by this function.
// 
// With this strategy, you must not encrypt more than 2**128
// blocks of data with the same key.
// 
// 2. You can encrypt separate messages by dividing the \p
// nonce_counter buffer in two areas: the first one used for a
// per-message nonce, handled by yourself, and the second one
// updated by this function internally.
// 
// For example, you might reserve the first 12 bytes for the
// per-message nonce, and the last 4 bytes for internal use. In that
// case, before calling this function on a new message you need to
// set the first 12 bytes of \p nonce_counter to your chosen nonce
// value, the last 4 to 0, and \p nc_off to 0 (which will cause \p
// stream_block to be ignored). That way, you can encrypt at most
// 2**96 messages of up to 2**32 blocks each with the same key.
// 
// The per-message nonce (or information sufficient to reconstruct
// it) needs to be communicated with the ciphertext and must be unique.
// The recommended way to ensure uniqueness is to use a message
// counter. An alternative is to generate random nonces, but this
// limits the number of messages that can be securely encrypted:
// for example, with 96-bit random nonces, you should not encrypt
// more than 2**32 messages with the same key.
// 
// Note that for both strategies, sizes are measured in blocks and
// that an ARIA block is 16 bytes.
// 
// \warning    Upon return, \p stream_block contains sensitive data. Its
// content must not be written to insecure storage and should be
// securely discarded as soon as it's no longer needed.
// 
// \param ctx              The ARIA context to use for encryption or decryption.
// This must be initialized and bound to a key.
// \param length           The length of the input data \p input in Bytes.
// \param nc_off           The offset in Bytes in the current \p stream_block,
// for resuming within the current cipher stream. The
// offset pointer should be \c 0 at the start of a
// stream. This must not be larger than \c 15 Bytes.
// \param nonce_counter    The 128-bit nonce and counter. This must point to
// a read/write buffer of length \c 16 bytes.
// \param stream_block     The saved stream block for resuming. This must
// point to a read/write buffer of length \c 16 bytes.
// This is overwritten by the function.
// \param input            The buffer holding the input data. This must
// be a readable buffer of length \p length Bytes.
// \param output           The buffer holding the output data. This must
// be a writable buffer of length \p length Bytes.
// 
// \return                 \c 0 on success.
// \return                 A negative error code on failure.
pub extern external/mbedtls-aria-crypt-ctr(^ctx1: c-pointer<mbedtls-aria-context-c>, ^length: ssize_t, ^nc-off: c-pointer<int>, ^nonce-counter: c-pointer<int>, ^stream-block: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_aria_crypt_ctr((struct mbedtls_aria_context*)#1, (size_t)#2, (size_t*)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-aria-crypt-ctr(^ctx1: c-pointer<mbedtls-aria-context-c>, ^length: int, ^nc-off: c-pointer<int>, ^nonce-counter: c-array<int>, ^stream-block: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-aria-crypt-ctr(ctx1, length.ssize_t, nc-off, nonce-counter.cextern/carray/ptr, stream-block.cextern/carray/ptr, input, output).int

// \brief          Checkup routine.
// 
// \return         \c 0 on success, or \c 1 on failure.
pub extern external/mbedtls-aria-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_aria_self_test((int)#1)"

pub inline fun ffi/mbedtls-aria-self-test(^verbose: int): <> int
  external/mbedtls-aria-self-test(verbose.int32).int

// \brief          Initialize a CAMELLIA context.
// 
// \param ctx      The CAMELLIA context to be initialized.
// This must not be \c NULL.
pub extern external/mbedtls-camellia-init(^ctx1: c-pointer<mbedtls-camellia-context-c>): ()
  c inline "(void)mbedtls_camellia_init((struct mbedtls_camellia_context*)#1)"

// \brief          Clear a CAMELLIA context.
// 
// \param ctx      The CAMELLIA context to be cleared. This may be \c NULL,
// in which case this function returns immediately. If it is not
// \c NULL, it must be initialized.
pub extern external/mbedtls-camellia-free(^ctx1: c-pointer<mbedtls-camellia-context-c>): ()
  c inline "(void)mbedtls_camellia_free((struct mbedtls_camellia_context*)#1)"

// \brief          Perform a CAMELLIA key schedule operation for encryption.
// 
// \param ctx      The CAMELLIA context to use. This must be initialized.
// \param key      The encryption key to use. This must be a readable buffer
// of size \p keybits Bits.
// \param keybits  The length of \p key in Bits. This must be either \c 128,
// \c 192 or \c 256.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-camellia-setkey-enc(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_camellia_setkey_enc((struct mbedtls_camellia_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-camellia-setkey-enc(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-camellia-setkey-enc(ctx1, key, keybits.int32).int

// \brief          Perform a CAMELLIA key schedule operation for decryption.
// 
// \param ctx      The CAMELLIA context to use. This must be initialized.
// \param key      The decryption key. This must be a readable buffer
// of size \p keybits Bits.
// \param keybits  The length of \p key in Bits. This must be either \c 128,
// \c 192 or \c 256.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-camellia-setkey-dec(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^key: c-pointer<int>, ^keybits: int32): int32
  c inline "(int)mbedtls_camellia_setkey_dec((struct mbedtls_camellia_context*)#1, (unsigned char*)#2, (unsigned int)#3)"

pub inline fun ffi/mbedtls-camellia-setkey-dec(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^key: c-pointer<int>, ^keybits: int): <> int
  external/mbedtls-camellia-setkey-dec(ctx1, key, keybits.int32).int

// \brief          Perform a CAMELLIA-ECB block encryption/decryption operation.
// 
// \param ctx      The CAMELLIA context to use. This must be initialized
// and bound to a key.
// \param mode     The mode of operation. This must be either
// #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT.
// \param input    The input block. This must be a readable buffer
// of size \c 16 Bytes.
// \param output   The output block. This must be a writable buffer
// of size \c 16 Bytes.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-camellia-crypt-ecb(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^mode: int32, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_camellia_crypt_ecb((struct mbedtls_camellia_context*)#1, (int)#2, (unsigned char*)#3, (unsigned char*)#4)"

pub inline fun ffi/mbedtls-camellia-crypt-ecb(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^mode: int, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-camellia-crypt-ecb(ctx1, mode.int32, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief          Perform a CAMELLIA-CBC buffer encryption/decryption operation.
// 
// \note           Upon exit, the content of the IV is updated so that you can
// call the function same function again on the following
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If on the other hand you need to retain the contents of the
// IV, you should either save it manually or use the cipher
// module instead.
// 
// \param ctx      The CAMELLIA context to use. This must be initialized
// and bound to a key.
// \param mode     The mode of operation. This must be either
// #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT.
// \param length   The length in Bytes of the input data \p input.
// This must be a multiple of \c 16 Bytes.
// \param iv       The initialization vector. This must be a read/write buffer
// of length \c 16 Bytes. It is updated to allow streaming
// use as explained above.
// \param input    The buffer holding the input data. This must point to a
// readable buffer of length \p length Bytes.
// \param output   The buffer holding the output data. This must point to a
// writable buffer of length \p length Bytes.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-camellia-crypt-cbc(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_camellia_crypt_cbc((struct mbedtls_camellia_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-camellia-crypt-cbc(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^mode: int, ^length: int, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-camellia-crypt-cbc(ctx1, mode.int32, length.ssize_t, iv.cextern/carray/ptr, input, output).int

// \brief          Perform a CAMELLIA-CFB128 buffer encryption/decryption
// operation.
// 
// \note           Due to the nature of CFB mode, you should use the same
// key for both encryption and decryption. In particular, calls
// to this function should be preceded by a key-schedule via
// mbedtls_camellia_setkey_enc() regardless of whether \p mode
// is #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT.
// 
// \note           Upon exit, the content of the IV is updated so that you can
// call the function same function again on the following
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If on the other hand you need to retain the contents of the
// IV, you should either save it manually or use the cipher
// module instead.
// 
// \param ctx      The CAMELLIA context to use. This must be initialized
// and bound to a key.
// \param mode     The mode of operation. This must be either
// #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT.
// \param length   The length of the input data \p input. Any value is allowed.
// \param iv_off   The current offset in the IV. This must be smaller
// than \c 16 Bytes. It is updated after this call to allow
// the aforementioned streaming usage.
// \param iv       The initialization vector. This must be a read/write buffer
// of length \c 16 Bytes. It is updated after this call to
// allow the aforementioned streaming usage.
// \param input    The buffer holding the input data. This must be a readable
// buffer of size \p length Bytes.
// \param output   The buffer to hold the output data. This must be a writable
// buffer of length \p length Bytes.
// 
// \return         \c 0 if successful.
// \return         A negative error code on failure.
pub extern external/mbedtls-camellia-crypt-cfb128(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^mode: int32, ^length: ssize_t, ^iv-off: c-pointer<int>, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_camellia_crypt_cfb128((struct mbedtls_camellia_context*)#1, (int)#2, (size_t)#3, (size_t*)#4, (unsigned char*)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-camellia-crypt-cfb128(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^mode: int, ^length: int, ^iv-off: c-pointer<int>, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-camellia-crypt-cfb128(ctx1, mode.int32, length.ssize_t, iv-off, iv.cextern/carray/ptr, input, output).int

// \brief      Perform a CAMELLIA-CTR buffer encryption/decryption operation.
// 
// *note       Due to the nature of CTR mode, you should use the same
// key for both encryption and decryption. In particular, calls
// to this function should be preceded by a key-schedule via
// mbedtls_camellia_setkey_enc() regardless of whether the mode
// is #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT.
// 
// \warning    You must never reuse a nonce value with the same key. Doing so
// would void the encryption for the two messages encrypted with
// the same nonce and key.
// 
// There are two common strategies for managing nonces with CTR:
// 
// 1. You can handle everything as a single message processed over
// successive calls to this function. In that case, you want to
// set \p nonce_counter and \p nc_off to 0 for the first call, and
// then preserve the values of \p nonce_counter, \p nc_off and \p
// stream_block across calls to this function as they will be
// updated by this function.
// 
// With this strategy, you must not encrypt more than 2**128
// blocks of data with the same key.
// 
// 2. You can encrypt separate messages by dividing the \p
// nonce_counter buffer in two areas: the first one used for a
// per-message nonce, handled by yourself, and the second one
// updated by this function internally.
// 
// For example, you might reserve the first \c 12 Bytes for the
// per-message nonce, and the last \c 4 Bytes for internal use.
// In that case, before calling this function on a new message you
// need to set the first \c 12 Bytes of \p nonce_counter to your
// chosen nonce value, the last four to \c 0, and \p nc_off to \c 0
// (which will cause \p stream_block to be ignored). That way, you
// can encrypt at most \c 2**96 messages of up to \c 2**32 blocks
// each  with the same key.
// 
// The per-message nonce (or information sufficient to reconstruct
// it) needs to be communicated with the ciphertext and must be
// unique. The recommended way to ensure uniqueness is to use a
// message counter. An alternative is to generate random nonces,
// but this limits the number of messages that can be securely
// encrypted: for example, with 96-bit random nonces, you should
// not encrypt more than 2**32 messages with the same key.
// 
// Note that for both strategies, sizes are measured in blocks and
// that a CAMELLIA block is \c 16 Bytes.
// 
// \warning    Upon return, \p stream_block contains sensitive data. Its
// content must not be written to insecure storage and should be
// securely discarded as soon as it's no longer needed.
// 
// \param ctx           The CAMELLIA context to use. This must be initialized
// and bound to a key.
// \param length        The length of the input data \p input in Bytes.
// Any value is allowed.
// \param nc_off        The offset in the current \p stream_block (for resuming
// within current cipher stream). The offset pointer to
// should be \c 0 at the start of a stream. It is updated
// at the end of this call.
// \param nonce_counter The 128-bit nonce and counter. This must be a read/write
// buffer of length \c 16 Bytes.
// \param stream_block  The saved stream-block for resuming. This must be a
// read/write buffer of length \c 16 Bytes.
// \param input         The input data stream. This must be a readable buffer of
// size \p length Bytes.
// \param output        The output data stream. This must be a writable buffer
// of size \p length Bytes.
// 
// \return              \c 0 if successful.
// \return              A negative error code on failure.
pub extern external/mbedtls-camellia-crypt-ctr(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^length: ssize_t, ^nc-off: c-pointer<int>, ^nonce-counter: c-pointer<int>, ^stream-block: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_camellia_crypt_ctr((struct mbedtls_camellia_context*)#1, (size_t)#2, (size_t*)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6, (unsigned char*)#7)"

pub inline fun ffi/mbedtls-camellia-crypt-ctr(^ctx1: c-pointer<mbedtls-camellia-context-c>, ^length: int, ^nc-off: c-pointer<int>, ^nonce-counter: c-array<int>, ^stream-block: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-camellia-crypt-ctr(ctx1, length.ssize_t, nc-off, nonce-counter.cextern/carray/ptr, stream-block.cextern/carray/ptr, input, output).int

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
pub extern external/mbedtls-camellia-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_camellia_self_test((int)#1)"

pub inline fun ffi/mbedtls-camellia-self-test(^verbose: int): <> int
  external/mbedtls-camellia-self-test(verbose.int32).int

// Constant-time buffer comparison without branches.
// 
// This is equivalent to the standard memcmp function, but is likely to be
// compiled to code using bitwise operations rather than a branch, such that
// the time taken is constant w.r.t. the data pointed to by \p a and \p b,
// and w.r.t. whether \p a and \p b are equal or not. It is not constant-time
// w.r.t. \p n .
// 
// This function can be used to write constant-time code by replacing branches
// with bit operations using masks.
// 
// \param a     Pointer to the first buffer, containing at least \p n bytes. May not be NULL.
// \param b     Pointer to the second buffer, containing at least \p n bytes. May not be NULL.
// \param n     The number of bytes to compare.
// 
// \return      Zero if the contents of the two buffers are the same,
// otherwise non-zero.
pub extern external/mbedtls-ct-memcmp(^a: c-pointer<()>, ^b: c-pointer<()>, ^n: ssize_t): int32
  c inline "(int)mbedtls_ct_memcmp((void*)#1, (void*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ct-memcmp(^a: c-pointer<()>, ^b: c-pointer<()>, ^n: int): <> int
  external/mbedtls-ct-memcmp(a, b, n.ssize_t).int

// \brief          Initialize cookie context
pub extern external/mbedtls-ssl-cookie-init(^ctx1: c-pointer<mbedtls-ssl-cookie-ctx-c>): ()
  c inline "(void)mbedtls_ssl_cookie_init((struct mbedtls_ssl_cookie_ctx*)#1)"

// \brief          Setup cookie context (generate keys)
pub extern external/mbedtls-ssl-cookie-setup(^ctx1: c-pointer<mbedtls-ssl-cookie-ctx-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): int32
  c inline "(int)mbedtls_ssl_cookie_setup((struct mbedtls_ssl_cookie_ctx*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3)"

pub inline fun ffi/mbedtls-ssl-cookie-setup(^ctx1: c-pointer<mbedtls-ssl-cookie-ctx-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>): <> int
  external/mbedtls-ssl-cookie-setup(ctx1, f-rng, p-rng).int

// \brief          Set expiration delay for cookies
// (Default MBEDTLS_SSL_COOKIE_TIMEOUT)
// 
// \param ctx      Cookie context
// \param delay    Delay, in seconds if HAVE_TIME, or in number of cookies
// issued in the meantime.
// 0 to disable expiration (NOT recommended)
pub extern external/mbedtls-ssl-cookie-set-timeout(^ctx1: c-pointer<mbedtls-ssl-cookie-ctx-c>, ^delay: int64): ()
  c inline "(void)mbedtls_ssl_cookie_set_timeout((struct mbedtls_ssl_cookie_ctx*)#1, (unsigned long)#2)"

pub inline fun ffi/mbedtls-ssl-cookie-set-timeout(^ctx1: c-pointer<mbedtls-ssl-cookie-ctx-c>, ^delay: int): <> ()
  external/mbedtls-ssl-cookie-set-timeout(ctx1, delay.int64)

// \brief          Free cookie context
pub extern external/mbedtls-ssl-cookie-free(^ctx1: c-pointer<mbedtls-ssl-cookie-ctx-c>): ()
  c inline "(void)mbedtls_ssl_cookie_free((struct mbedtls_ssl_cookie_ctx*)#1)"

// \brief          Generate cookie, see \c mbedtls_ssl_cookie_write_t
pub extern external/mbedtls-ssl-cookie-write(^arg0: c-pointer<()>, ^arg1: c-pointer<c-pointer<int>>, ^arg2: c-pointer<int>, ^arg3: c-pointer<int>, ^arg4: ssize_t): int32
  c inline "(int)mbedtls_ssl_cookie_write((void*)#1, (unsigned char**)#2, (unsigned char*)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ssl-cookie-write(^arg0: c-pointer<()>, ^arg1: c-pointer<c-pointer<int>>, ^arg2: c-pointer<int>, ^arg3: c-pointer<int>, ^arg4: int): <> int
  external/mbedtls-ssl-cookie-write(arg0, arg1, arg2, arg3, arg4.ssize_t).int

// \brief          Verify cookie, see \c mbedtls_ssl_cookie_write_t
pub extern external/mbedtls-ssl-cookie-check(^arg0: c-pointer<()>, ^arg1: c-pointer<int>, ^arg2: ssize_t, ^arg3: c-pointer<int>, ^arg4: ssize_t): int32
  c inline "(int)mbedtls_ssl_cookie_check((void*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ssl-cookie-check(^arg0: c-pointer<()>, ^arg1: c-pointer<int>, ^arg2: int, ^arg3: c-pointer<int>, ^arg4: int): <> int
  external/mbedtls-ssl-cookie-check(arg0, arg1, arg2.ssize_t, arg3, arg4.ssize_t).int

// \brief               This function initializes the CTR_DRBG context,
// and prepares it for mbedtls_ctr_drbg_seed()
// or mbedtls_ctr_drbg_free().
// 
// \note                The reseed interval is
// #MBEDTLS_CTR_DRBG_RESEED_INTERVAL by default.
// You can override it by calling
// mbedtls_ctr_drbg_set_reseed_interval().
// 
// \param ctx           The CTR_DRBG context to initialize.
pub extern external/mbedtls-ctr-drbg-init(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>): ()
  c inline "(void)mbedtls_ctr_drbg_init((struct mbedtls_ctr_drbg_context*)#1)"

// - The \p custom string.
// 
// \note                To achieve the nominal security strength permitted
// by CTR_DRBG, the entropy length must be:
// - at least 16 bytes for a 128-bit strength
// (maximum achievable strength when using AES-128);
// - at least 32 bytes for a 256-bit strength
// (maximum achievable strength when using AES-256).
// 
// In addition, if you do not pass a nonce in \p custom,
// the sum of the entropy length
// and the entropy nonce length must be:
// - at least 24 bytes for a 128-bit strength
// (maximum achievable strength when using AES-128);
// - at least 48 bytes for a 256-bit strength
// (maximum achievable strength when using AES-256).
// 
// \param ctx           The CTR_DRBG context to seed.
// It must have been initialized with
// mbedtls_ctr_drbg_init().
// After a successful call to mbedtls_ctr_drbg_seed(),
// you may not call mbedtls_ctr_drbg_seed() again on
// the same context unless you call
// mbedtls_ctr_drbg_free() and mbedtls_ctr_drbg_init()
// again first.
// After a failed call to mbedtls_ctr_drbg_seed(),
// you must call mbedtls_ctr_drbg_free().
// \param f_entropy     The entropy callback, taking as arguments the
// \p p_entropy context, the buffer to fill, and the
// length of the buffer.
// \p f_entropy is always called with a buffer size
// less than or equal to the entropy length.
// \param p_entropy     The entropy context to pass to \p f_entropy.
// \param custom        The personalization string.
// This can be \c NULL, in which case the personalization
// string is empty regardless of the value of \p len.
// \param len           The length of the personalization string.
// This must be at most
// #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT
// - #MBEDTLS_CTR_DRBG_ENTROPY_LEN.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure.
pub extern external/mbedtls-ctr-drbg-seed(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^f-entropy: c-pointer<intptr_t>, ^p-entropy: c-pointer<()>, ^custom: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ctr_drbg_seed((struct mbedtls_ctr_drbg_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ctr-drbg-seed(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^f-entropy: c-pointer<intptr_t>, ^p-entropy: c-pointer<()>, ^custom: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ctr-drbg-seed(ctx1, f-entropy, p-entropy, custom, len.ssize_t).int

// \brief               This function resets CTR_DRBG context to the state immediately
// after initial call of mbedtls_ctr_drbg_init().
// 
// \param ctx           The CTR_DRBG context to clear.
pub extern external/mbedtls-ctr-drbg-free(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>): ()
  c inline "(void)mbedtls_ctr_drbg_free((struct mbedtls_ctr_drbg_context*)#1)"

// \brief               This function turns prediction resistance on or off.
// The default value is off.
// 
// \note                If enabled, entropy is gathered at the beginning of
// every call to mbedtls_ctr_drbg_random_with_add()
// or mbedtls_ctr_drbg_random().
// Only use this if your entropy source has sufficient
// throughput.
// 
// \param ctx           The CTR_DRBG context.
// \param resistance    #MBEDTLS_CTR_DRBG_PR_ON or #MBEDTLS_CTR_DRBG_PR_OFF.
pub extern external/mbedtls-ctr-drbg-set-prediction-resistance(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^resistance: int32): ()
  c inline "(void)mbedtls_ctr_drbg_set_prediction_resistance((struct mbedtls_ctr_drbg_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ctr-drbg-set-prediction-resistance(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^resistance: int): <> ()
  external/mbedtls-ctr-drbg-set-prediction-resistance(ctx1, resistance.int32)

// \brief               This function sets the amount of entropy grabbed on each
// seed or reseed.
// 
// The default value is #MBEDTLS_CTR_DRBG_ENTROPY_LEN.
// 
// \note                The security strength of CTR_DRBG is bounded by the
// entropy length. Thus:
// - When using AES-256
// (\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is disabled,
// which is the default),
// \p len must be at least 32 (in bytes)
// to achieve a 256-bit strength.
// - When using AES-128
// (\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is enabled)
// \p len must be at least 16 (in bytes)
// to achieve a 128-bit strength.
// 
// \param ctx           The CTR_DRBG context.
// \param len           The amount of entropy to grab, in bytes.
// This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT
// and at most the maximum length accepted by the
// entropy function that is set in the context.
pub extern external/mbedtls-ctr-drbg-set-entropy-len(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^len: ssize_t): ()
  c inline "(void)mbedtls_ctr_drbg_set_entropy_len((struct mbedtls_ctr_drbg_context*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-ctr-drbg-set-entropy-len(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^len: int): <> ()
  external/mbedtls-ctr-drbg-set-entropy-len(ctx1, len.ssize_t)

// \brief               This function sets the amount of entropy grabbed
// as a nonce for the initial seeding.
// 
// Call this function before calling mbedtls_ctr_drbg_seed() to read
// a nonce from the entropy source during the initial seeding.
// 
// \param ctx           The CTR_DRBG context.
// \param len           The amount of entropy to grab for the nonce, in bytes.
// This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT
// and at most the maximum length accepted by the
// entropy function that is set in the context.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if \p len is
// more than #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.
// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED
// if the initial seeding has already taken place.
pub extern external/mbedtls-ctr-drbg-set-nonce-len(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ctr_drbg_set_nonce_len((struct mbedtls_ctr_drbg_context*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-ctr-drbg-set-nonce-len(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^len: int): <> int
  external/mbedtls-ctr-drbg-set-nonce-len(ctx1, len.ssize_t).int

// \brief               This function sets the reseed interval.
// 
// The reseed interval is the number of calls to mbedtls_ctr_drbg_random()
// or mbedtls_ctr_drbg_random_with_add() after which the entropy function
// is called again.
// 
// The default value is #MBEDTLS_CTR_DRBG_RESEED_INTERVAL.
// 
// \param ctx           The CTR_DRBG context.
// \param interval      The reseed interval.
pub extern external/mbedtls-ctr-drbg-set-reseed-interval(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^interval: int32): ()
  c inline "(void)mbedtls_ctr_drbg_set_reseed_interval((struct mbedtls_ctr_drbg_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ctr-drbg-set-reseed-interval(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^interval: int): <> ()
  external/mbedtls-ctr-drbg-set-reseed-interval(ctx1, interval.int32)

// \brief               This function reseeds the CTR_DRBG context, that is
// extracts data from the entropy source.
// 
// \note                This function is not thread-safe. It is not safe
// to call this function if another thread might be
// concurrently obtaining random numbers from the same
// context or updating or reseeding the same context.
// 
// \param ctx           The CTR_DRBG context.
// \param additional    Additional data to add to the state. Can be \c NULL.
// \param len           The length of the additional data.
// This must be less than
// #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \c entropy_len
// where \c entropy_len is the entropy length
// configured for the context.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure.
pub extern external/mbedtls-ctr-drbg-reseed(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^additional: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_ctr_drbg_reseed((struct mbedtls_ctr_drbg_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ctr-drbg-reseed(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^additional: c-pointer<int>, ^len: int): <> int
  external/mbedtls-ctr-drbg-reseed(ctx1, additional, len.ssize_t).int

// \brief              This function updates the state of the CTR_DRBG context.
// 
// \note                This function is not thread-safe. It is not safe
// to call this function if another thread might be
// concurrently obtaining random numbers from the same
// context or updating or reseeding the same context.
// 
// \param ctx          The CTR_DRBG context.
// \param additional   The data to update the state with. This must not be
// \c NULL unless \p add_len is \c 0.
// \param add_len      Length of \p additional in bytes. This must be at
// most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.
// 
// \return             \c 0 on success.
// \return             #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if
// \p add_len is more than
// #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.
// \return             An error from the underlying AES cipher on failure.
pub extern external/mbedtls-ctr-drbg-update(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^additional: c-pointer<int>, ^add-len: ssize_t): int32
  c inline "(int)mbedtls_ctr_drbg_update((struct mbedtls_ctr_drbg_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ctr-drbg-update(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^additional: c-pointer<int>, ^add-len: int): <> int
  external/mbedtls-ctr-drbg-update(ctx1, additional, add-len.ssize_t).int

// \brief   This function updates a CTR_DRBG instance with additional
// data and uses it to generate random data.
// 
// This function automatically reseeds if the reseed counter is exceeded
// or prediction resistance is enabled.
// 
// \note                This function is not thread-safe. It is not safe
// to call this function if another thread might be
// concurrently obtaining random numbers from the same
// context or updating or reseeding the same context.
// 
// \param p_rng         The CTR_DRBG context. This must be a pointer to a
// #mbedtls_ctr_drbg_context structure.
// \param output        The buffer to fill.
// \param output_len    The length of the buffer in bytes.
// \param additional    Additional data to update. Can be \c NULL, in which
// case the additional data is empty regardless of
// the value of \p add_len.
// \param add_len       The length of the additional data
// if \p additional is not \c NULL.
// This must be less than #MBEDTLS_CTR_DRBG_MAX_INPUT
// and less than
// #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \c entropy_len
// where \c entropy_len is the entropy length
// configured for the context.
// 
// \return    \c 0 on success.
// \return    #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or
// #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure.
pub extern external/mbedtls-ctr-drbg-random-with-add(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-len: ssize_t, ^additional: c-pointer<int>, ^add-len: ssize_t): int32
  c inline "(int)mbedtls_ctr_drbg_random_with_add((void*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-ctr-drbg-random-with-add(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-len: int, ^additional: c-pointer<int>, ^add-len: int): <> int
  external/mbedtls-ctr-drbg-random-with-add(p-rng, output, output-len.ssize_t, additional, add-len.ssize_t).int

// \param p_rng         The CTR_DRBG context. This must be a pointer to a
// #mbedtls_ctr_drbg_context structure.
// \param output        The buffer to fill.
// \param output_len    The length of the buffer in bytes.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or
// #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure.
pub extern external/mbedtls-ctr-drbg-random(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-len: ssize_t): int32
  c inline "(int)mbedtls_ctr_drbg_random((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ctr-drbg-random(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-len: int): <> int
  external/mbedtls-ctr-drbg-random(p-rng, output, output-len.ssize_t).int

// \brief               This function writes a seed file.
// 
// \param ctx           The CTR_DRBG context.
// \param path          The name of the file.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR on file error.
// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on reseed
// failure.
pub extern external/mbedtls-ctr-drbg-write-seed-file(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_ctr_drbg_write_seed_file((struct mbedtls_ctr_drbg_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-ctr-drbg-write-seed-file(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-ctr-drbg-write-seed-file(ctx1, path).int

// \brief               This function reads and updates a seed file. The seed
// is added to this instance.
// 
// \param ctx           The CTR_DRBG context.
// \param path          The name of the file.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR on file error.
// \return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on
// reseed failure.
// \return              #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if the existing
// seed file is too large.
pub extern external/mbedtls-ctr-drbg-update-seed-file(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_ctr_drbg_update_seed_file((struct mbedtls_ctr_drbg_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-ctr-drbg-update-seed-file(^ctx1: c-pointer<mbedtls-ctr-drbg-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-ctr-drbg-update-seed-file(ctx1, path).int

// \brief               The CTR_DRBG checkup routine.
// 
// \return              \c 0 on success.
// \return              \c 1 on failure.
pub extern external/mbedtls-ctr-drbg-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_ctr_drbg_self_test((int)#1)"

pub inline fun ffi/mbedtls-ctr-drbg-self-test(^verbose: int): <> int
  external/mbedtls-ctr-drbg-self-test(verbose.int32).int

// \brief          Initialize DES context
// 
// \param ctx      DES context to be initialized
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-init(^ctx1: c-pointer<mbedtls-des-context-c>): ()
  c inline "(void)mbedtls_des_init((struct mbedtls_des_context*)#1)"

// \brief          Clear DES context
// 
// \param ctx      DES context to be cleared
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-free(^ctx1: c-pointer<mbedtls-des-context-c>): ()
  c inline "(void)mbedtls_des_free((struct mbedtls_des_context*)#1)"

// \brief          Initialize Triple-DES context
// 
// \param ctx      DES3 context to be initialized
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-init(^ctx1: c-pointer<mbedtls-des3-context-c>): ()
  c inline "(void)mbedtls_des3_init((struct mbedtls_des3_context*)#1)"

// \brief          Clear Triple-DES context
// 
// \param ctx      DES3 context to be cleared
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-free(^ctx1: c-pointer<mbedtls-des3-context-c>): ()
  c inline "(void)mbedtls_des3_free((struct mbedtls_des3_context*)#1)"

// \brief          Set key parity on the given key to odd.
// 
// DES keys are 56 bits long, but each byte is padded with
// a parity bit to allow verification.
// 
// \param key      8-byte secret key
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-key-set-parity(^key: c-pointer<int>): ()
  c inline "(void)mbedtls_des_key_set_parity((unsigned char*)#1)"

// \brief          Check that key parity on the given key is odd.
// 
// DES keys are 56 bits long, but each byte is padded with
// a parity bit to allow verification.
// 
// \param key      8-byte secret key
// 
// \return         0 is parity was ok, 1 if parity was not correct.
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-key-check-key-parity(^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des_key_check_key_parity((unsigned char*)#1)"

pub inline fun ffi/mbedtls-des-key-check-key-parity(^key: c-array<int>): <> int
  external/mbedtls-des-key-check-key-parity(key.cextern/carray/ptr).int

// \brief          Check that key is not a weak or semi-weak DES key
// 
// \param key      8-byte secret key
// 
// \return         0 if no weak key was found, 1 if a weak key was identified.
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-key-check-weak(^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des_key_check_weak((unsigned char*)#1)"

pub inline fun ffi/mbedtls-des-key-check-weak(^key: c-array<int>): <> int
  external/mbedtls-des-key-check-weak(key.cextern/carray/ptr).int

// \brief          DES key schedule (56-bit, encryption)
// 
// \param ctx      DES context to be initialized
// \param key      8-byte secret key
// 
// \return         0
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-setkey-enc(^ctx1: c-pointer<mbedtls-des-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des_setkey_enc((struct mbedtls_des_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-des-setkey-enc(^ctx1: c-pointer<mbedtls-des-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-des-setkey-enc(ctx1, key.cextern/carray/ptr).int

// \brief          DES key schedule (56-bit, decryption)
// 
// \param ctx      DES context to be initialized
// \param key      8-byte secret key
// 
// \return         0
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-setkey-dec(^ctx1: c-pointer<mbedtls-des-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des_setkey_dec((struct mbedtls_des_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-des-setkey-dec(^ctx1: c-pointer<mbedtls-des-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-des-setkey-dec(ctx1, key.cextern/carray/ptr).int

// \brief          Triple-DES key schedule (112-bit, encryption)
// 
// \param ctx      3DES context to be initialized
// \param key      16-byte secret key
// 
// \return         0
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-set2key-enc(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des3_set2key_enc((struct mbedtls_des3_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-des3-set2key-enc(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-des3-set2key-enc(ctx1, key.cextern/carray/ptr).int

// \brief          Triple-DES key schedule (112-bit, decryption)
// 
// \param ctx      3DES context to be initialized
// \param key      16-byte secret key
// 
// \return         0
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-set2key-dec(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des3_set2key_dec((struct mbedtls_des3_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-des3-set2key-dec(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-des3-set2key-dec(ctx1, key.cextern/carray/ptr).int

// \brief          Triple-DES key schedule (168-bit, encryption)
// 
// \param ctx      3DES context to be initialized
// \param key      24-byte secret key
// 
// \return         0
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-set3key-enc(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des3_set3key_enc((struct mbedtls_des3_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-des3-set3key-enc(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-des3-set3key-enc(ctx1, key.cextern/carray/ptr).int

// \brief          Triple-DES key schedule (168-bit, decryption)
// 
// \param ctx      3DES context to be initialized
// \param key      24-byte secret key
// 
// \return         0
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-set3key-dec(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-pointer<int>): int32
  c inline "(int)mbedtls_des3_set3key_dec((struct mbedtls_des3_context*)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-des3-set3key-dec(^ctx1: c-pointer<mbedtls-des3-context-c>, ^key: c-array<int>): <> int
  external/mbedtls-des3-set3key-dec(ctx1, key.cextern/carray/ptr).int

// \brief          DES-ECB block encryption/decryption
// 
// \param ctx      DES context
// \param input    64-bit input block
// \param output   64-bit output block
// 
// \return         0 if successful
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-crypt-ecb(^ctx1: c-pointer<mbedtls-des-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_des_crypt_ecb((struct mbedtls_des_context*)#1, (unsigned char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-des-crypt-ecb(^ctx1: c-pointer<mbedtls-des-context-c>, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-des-crypt-ecb(ctx1, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief          DES-CBC buffer encryption/decryption
// 
// \note           Upon exit, the content of the IV is updated so that you can
// call the function same function again on the following
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If on the other hand you need to retain the contents of the
// IV, you should either save it manually or use the cipher
// module instead.
// 
// \param ctx      DES context
// \param mode     MBEDTLS_DES_ENCRYPT or MBEDTLS_DES_DECRYPT
// \param length   length of the input data
// \param iv       initialization vector (updated after use)
// \param input    buffer holding the input data
// \param output   buffer holding the output data
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-crypt-cbc(^ctx1: c-pointer<mbedtls-des-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_des_crypt_cbc((struct mbedtls_des_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-des-crypt-cbc(^ctx1: c-pointer<mbedtls-des-context-c>, ^mode: int, ^length: int, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-des-crypt-cbc(ctx1, mode.int32, length.ssize_t, iv.cextern/carray/ptr, input, output).int

// \brief          3DES-ECB block encryption/decryption
// 
// \param ctx      3DES context
// \param input    64-bit input block
// \param output   64-bit output block
// 
// \return         0 if successful
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-crypt-ecb(^ctx1: c-pointer<mbedtls-des3-context-c>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_des3_crypt_ecb((struct mbedtls_des3_context*)#1, (unsigned char*)#2, (unsigned char*)#3)"

pub inline fun ffi/mbedtls-des3-crypt-ecb(^ctx1: c-pointer<mbedtls-des3-context-c>, ^input: c-array<int>, ^output: c-array<int>): <> int
  external/mbedtls-des3-crypt-ecb(ctx1, input.cextern/carray/ptr, output.cextern/carray/ptr).int

// \brief          3DES-CBC buffer encryption/decryption
// 
// \note           Upon exit, the content of the IV is updated so that you can
// call the function same function again on the following
// block(s) of data and get the same result as if it was
// encrypted in one call. This allows a "streaming" usage.
// If on the other hand you need to retain the contents of the
// IV, you should either save it manually or use the cipher
// module instead.
// 
// \param ctx      3DES context
// \param mode     MBEDTLS_DES_ENCRYPT or MBEDTLS_DES_DECRYPT
// \param length   length of the input data
// \param iv       initialization vector (updated after use)
// \param input    buffer holding the input data
// \param output   buffer holding the output data
// 
// \return         0 if successful, or MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des3-crypt-cbc(^ctx1: c-pointer<mbedtls-des3-context-c>, ^mode: int32, ^length: ssize_t, ^iv: c-pointer<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): int32
  c inline "(int)mbedtls_des3_crypt_cbc((struct mbedtls_des3_context*)#1, (int)#2, (size_t)#3, (unsigned char*)#4, (unsigned char*)#5, (unsigned char*)#6)"

pub inline fun ffi/mbedtls-des3-crypt-cbc(^ctx1: c-pointer<mbedtls-des3-context-c>, ^mode: int, ^length: int, ^iv: c-array<int>, ^input: c-pointer<int>, ^output: c-pointer<int>): <> int
  external/mbedtls-des3-crypt-cbc(ctx1, mode.int32, length.ssize_t, iv.cextern/carray/ptr, input, output).int

// \brief          Internal function for key expansion.
// (Only exposed to allow overriding it,
// see MBEDTLS_DES_SETKEY_ALT)
// 
// \param SK       Round keys
// \param key      Base key
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub extern external/mbedtls-des-setkey(^sk: c-pointer<int>, ^key: c-pointer<int>): ()
  c inline "(void)mbedtls_des_setkey((int32_t*)#1, (unsigned char*)#2)"

// \brief          Checkup routine
// 
// \return         0 if successful, or 1 if the test failed
pub extern external/mbedtls-des-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_des_self_test((int)#1)"

pub inline fun ffi/mbedtls-des-self-test(^verbose: int): <> int
  external/mbedtls-des-self-test(verbose.int32).int

// \brief           Write a length field in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param len       The length value to write.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-len(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_len((unsigned char**)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-asn1-write-len(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^len: int): <> int
  external/mbedtls-asn1-write-len(p, start, len.ssize_t).int

// \brief           Write an ASN.1 tag in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param tag       The tag to write.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-tag(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^tag: int8): int32
  c inline "(int)mbedtls_asn1_write_tag((unsigned char**)#1, (unsigned char*)#2, (unsigned char)#3)"

pub inline fun ffi/mbedtls-asn1-write-tag(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^tag: int): <> int
  external/mbedtls-asn1-write-tag(p, start, tag.int8).int

// \brief           Write raw buffer data.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param buf       The data buffer to write.
// \param size      The length of the data buffer.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-raw-buffer(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_raw_buffer((unsigned char**)#1, (unsigned char*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-raw-buffer(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^size: int): <> int
  external/mbedtls-asn1-write-raw-buffer(p, start, buf, size.ssize_t).int

// \brief           Write an arbitrary-precision number (#MBEDTLS_ASN1_INTEGER)
// in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param X         The MPI to write.
// It must be non-negative.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-mpi(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^x: c-pointer<mbedtls-mpi-c>): int32
  c inline "(int)mbedtls_asn1_write_mpi((unsigned char**)#1, (unsigned char*)#2, (struct mbedtls_mpi*)#3)"

pub inline fun ffi/mbedtls-asn1-write-mpi(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^x: c-pointer<mbedtls-mpi-c>): <> int
  external/mbedtls-asn1-write-mpi(p, start, x).int

// \brief           Write a NULL tag (#MBEDTLS_ASN1_NULL) with zero data
// in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-null(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>): int32
  c inline "(int)mbedtls_asn1_write_null((unsigned char**)#1, (unsigned char*)#2)"

pub inline fun ffi/mbedtls-asn1-write-null(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>): <> int
  external/mbedtls-asn1-write-null(p, start).int

// \brief           Write an OID tag (#MBEDTLS_ASN1_OID) and data
// in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param oid       The OID to write.
// \param oid_len   The length of the OID.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-oid(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^oid: c-pointer<int>, ^oid-len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_oid((unsigned char**)#1, (unsigned char*)#2, (char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-oid(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^oid: c-pointer<int>, ^oid-len: int): <> int
  external/mbedtls-asn1-write-oid(p, start, oid, oid-len.ssize_t).int

// \brief           Write an AlgorithmIdentifier sequence in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param oid       The OID of the algorithm to write.
// \param oid_len   The length of the algorithm's OID.
// \param par_len   The length of the parameters, which must be already written.
// If 0, NULL parameters are added
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-algorithm-identifier(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^oid: c-pointer<int>, ^oid-len: ssize_t, ^par-len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_algorithm_identifier((unsigned char**)#1, (unsigned char*)#2, (char*)#3, (size_t)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-asn1-write-algorithm-identifier(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^oid: c-pointer<int>, ^oid-len: int, ^par-len: int): <> int
  external/mbedtls-asn1-write-algorithm-identifier(p, start, oid, oid-len.ssize_t, par-len.ssize_t).int

// \brief           Write an AlgorithmIdentifier sequence in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param oid       The OID of the algorithm to write.
// \param oid_len   The length of the algorithm's OID.
// \param par_len   The length of the parameters, which must be already written.
// \param has_par   If there are any parameters. If 0, par_len must be 0. If 1
// and \p par_len is 0, NULL parameters are added.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-algorithm-identifier-ext(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^oid: c-pointer<int>, ^oid-len: ssize_t, ^par-len: ssize_t, ^has-par: int32): int32
  c inline "(int)mbedtls_asn1_write_algorithm_identifier_ext((unsigned char**)#1, (unsigned char*)#2, (char*)#3, (size_t)#4, (size_t)#5, (int)#6)"

pub inline fun ffi/mbedtls-asn1-write-algorithm-identifier-ext(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^oid: c-pointer<int>, ^oid-len: int, ^par-len: int, ^has-par: int): <> int
  external/mbedtls-asn1-write-algorithm-identifier-ext(p, start, oid, oid-len.ssize_t, par-len.ssize_t, has-par.int32).int

// \brief           Write a boolean tag (#MBEDTLS_ASN1_BOOLEAN) and value
// in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param boolean   The boolean value to write, either \c 0 or \c 1.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-bool(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^boolean: int32): int32
  c inline "(int)mbedtls_asn1_write_bool((unsigned char**)#1, (unsigned char*)#2, (int)#3)"

pub inline fun ffi/mbedtls-asn1-write-bool(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^boolean: int): <> int
  external/mbedtls-asn1-write-bool(p, start, boolean.int32).int

// \brief           Write an int tag (#MBEDTLS_ASN1_INTEGER) and value
// in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param val       The integer value to write.
// It must be non-negative.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-int(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^val: int32): int32
  c inline "(int)mbedtls_asn1_write_int((unsigned char**)#1, (unsigned char*)#2, (int)#3)"

pub inline fun ffi/mbedtls-asn1-write-int(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^val: int): <> int
  external/mbedtls-asn1-write-int(p, start, val.int32).int

// \brief           Write an enum tag (#MBEDTLS_ASN1_ENUMERATED) and value
// in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param val       The integer value to write.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative \c MBEDTLS_ERR_ASN1_XXX error code on failure.
pub extern external/mbedtls-asn1-write-enum(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^val: int32): int32
  c inline "(int)mbedtls_asn1_write_enum((unsigned char**)#1, (unsigned char*)#2, (int)#3)"

pub inline fun ffi/mbedtls-asn1-write-enum(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^val: int): <> int
  external/mbedtls-asn1-write-enum(p, start, val.int32).int

// \brief           Write a string in ASN.1 format using a specific
// string encoding tag.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param tag       The string encoding tag to write, e.g.
// #MBEDTLS_ASN1_UTF8_STRING.
// \param text      The string to write.
// \param text_len  The length of \p text in bytes (which might
// be strictly larger than the number of characters).
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-tagged-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^tag: int32, ^text: c-pointer<int>, ^text-len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_tagged_string((unsigned char**)#1, (unsigned char*)#2, (int)#3, (char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-asn1-write-tagged-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^tag: int, ^text: c-pointer<int>, ^text-len: int): <> int
  external/mbedtls-asn1-write-tagged-string(p, start, tag.int32, text, text-len.ssize_t).int

// \brief           Write a string in ASN.1 format using the PrintableString
// string encoding tag (#MBEDTLS_ASN1_PRINTABLE_STRING).
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param text      The string to write.
// \param text_len  The length of \p text in bytes (which might
// be strictly larger than the number of characters).
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-printable-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^text: c-pointer<int>, ^text-len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_printable_string((unsigned char**)#1, (unsigned char*)#2, (char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-printable-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^text: c-pointer<int>, ^text-len: int): <> int
  external/mbedtls-asn1-write-printable-string(p, start, text, text-len.ssize_t).int

// \brief           Write a UTF8 string in ASN.1 format using the UTF8String
// string encoding tag (#MBEDTLS_ASN1_UTF8_STRING).
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param text      The string to write.
// \param text_len  The length of \p text in bytes (which might
// be strictly larger than the number of characters).
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-utf8-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^text: c-pointer<int>, ^text-len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_utf8_string((unsigned char**)#1, (unsigned char*)#2, (char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-utf8-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^text: c-pointer<int>, ^text-len: int): <> int
  external/mbedtls-asn1-write-utf8-string(p, start, text, text-len.ssize_t).int

// \brief           Write a string in ASN.1 format using the IA5String
// string encoding tag (#MBEDTLS_ASN1_IA5_STRING).
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param text      The string to write.
// \param text_len  The length of \p text in bytes (which might
// be strictly larger than the number of characters).
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-ia5-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^text: c-pointer<int>, ^text-len: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_ia5_string((unsigned char**)#1, (unsigned char*)#2, (char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-ia5-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^text: c-pointer<int>, ^text-len: int): <> int
  external/mbedtls-asn1-write-ia5-string(p, start, text, text-len.ssize_t).int

// \brief           Write a bitstring tag (#MBEDTLS_ASN1_BIT_STRING) and
// value in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param buf       The bitstring to write.
// \param bits      The total number of bits in the bitstring.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-bitstring(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^bits: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_bitstring((unsigned char**)#1, (unsigned char*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-bitstring(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^bits: int): <> int
  external/mbedtls-asn1-write-bitstring(p, start, buf, bits.ssize_t).int

// \brief           This function writes a named bitstring tag
// (#MBEDTLS_ASN1_BIT_STRING) and value in ASN.1 format.
// 
// As stated in RFC 5280 Appendix B, trailing zeroes are
// omitted when encoding named bitstrings in DER.
// 
// \note            This function works backwards within the data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer which is used for bounds-checking.
// \param buf       The bitstring to write.
// \param bits      The total number of bits in the bitstring.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-named-bitstring(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^bits: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_named_bitstring((unsigned char**)#1, (unsigned char*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-named-bitstring(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^bits: int): <> int
  external/mbedtls-asn1-write-named-bitstring(p, start, buf, bits.ssize_t).int

// \brief           Write an octet string tag (#MBEDTLS_ASN1_OCTET_STRING)
// and value in ASN.1 format.
// 
// \note            This function works backwards in data buffer.
// 
// \param p         The reference to the current position pointer.
// \param start     The start of the buffer, for bounds-checking.
// \param buf       The buffer holding the data to write.
// \param size      The length of the data buffer \p buf.
// 
// \return          The number of bytes written to \p p on success.
// \return          A negative error code on failure.
pub extern external/mbedtls-asn1-write-octet-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^size: ssize_t): int32
  c inline "(int)mbedtls_asn1_write_octet_string((unsigned char**)#1, (unsigned char*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-asn1-write-octet-string(^p: c-pointer<c-pointer<int>>, ^start: c-pointer<int>, ^buf: c-pointer<int>, ^size: int): <> int
  external/mbedtls-asn1-write-octet-string(p, start, buf, size.ssize_t).int

// \brief           Create or find a specific named_data entry for writing in a
// sequence or list based on the OID. If not already in there,
// a new entry is added to the head of the list.
// Warning: Destructive behaviour for the val data!
// 
// \param list      The pointer to the location of the head of the list to seek
// through (will be updated in case of a new entry).
// \param oid       The OID to look for.
// \param oid_len   The size of the OID.
// \param val       The associated data to store. If this is \c NULL,
// no data is copied to the new or existing buffer.
// \param val_len   The minimum length of the data buffer needed.
// If this is 0, do not allocate a buffer for the associated
// data.
// If the OID was already present, enlarge, shrink or free
// the existing buffer to fit \p val_len.
// 
// \return          A pointer to the new / existing entry on success.
// \return          \c NULL if there was a memory allocation error.
pub extern external/mbedtls-asn1-store-named-data(^list: c-pointer<c-pointer<mbedtls-asn1-named-data-c>>, ^oid: c-pointer<int>, ^oid-len: ssize_t, ^val: c-pointer<int>, ^val-len: ssize_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)mbedtls_asn1_store_named_data((struct mbedtls_asn1_named_data**)#1, (char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-asn1-store-named-data(^list: c-pointer<c-pointer<mbedtls-asn1-named-data-c>>, ^oid: c-pointer<int>, ^oid-len: int, ^val: c-pointer<int>, ^val-len: int): <> c-pointer<mbedtls-asn1-named-data-c>
  external/mbedtls-asn1-store-named-data(list, oid, oid-len.ssize_t, val, val-len.ssize_t)

// The random generator function for the PSA subsystem.
// 
// This function is suitable as the `f_rng` random generator function
// parameter of many `mbedtls_xxx` functions.
// 
// The implementation of this function depends on the configuration of the
// library.
// 
// \note This function may only be used if the PSA crypto subsystem is active.
// This means that you must call psa_crypto_init() before any call to
// this function, and you must not call this function after calling
// mbedtls_psa_crypto_free().
// 
// \param p_rng         This parameter is only kept for backward compatibility
// reasons with legacy `f_rng` functions and it's ignored.
// Set to #MBEDTLS_PSA_RANDOM_STATE or NULL.
// \param output        The buffer to fill. It must have room for
// \c output_size bytes.
// \param output_size   The number of bytes to write to \p output.
// This function may fail if \p output_size is too
// large. It is guaranteed to accept any output size
// requested by Mbed TLS library functions. The
// maximum request size depends on the library
// configuration.
// 
// \return              \c 0 on success.
// \return              An `MBEDTLS_ERR_ENTROPY_xxx`,
// `MBEDTLS_ERR_PLATFORM_xxx,
// `MBEDTLS_ERR_CTR_DRBG_xxx` or
// `MBEDTLS_ERR_HMAC_DRBG_xxx` on error.
pub extern external/mbedtls-psa-get-random(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-size: ssize_t): int32
  c inline "(int)mbedtls_psa_get_random((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-psa-get-random(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-size: int): <> int
  external/mbedtls-psa-get-random(p-rng, output, output-size.ssize_t).int

// Convert an ECC curve identifier from the Mbed TLS encoding to PSA.
// 
// \param grpid         An Mbed TLS elliptic curve identifier
// (`MBEDTLS_ECP_DP_xxx`).
// \param[out] bits     On success the bit size of the curve; 0 on failure.
// 
// \return              If the curve is supported in the PSA API, this function
// returns the proper PSA curve identifier
// (`PSA_ECC_FAMILY_xxx`). This holds even if the curve is
// not supported by the ECP module.
// \return              \c 0 if the curve is not supported in the PSA API.
pub extern external/mbedtls-ecc-group-to-psa(^grpid: int32, ^bits: c-pointer<int>): int8
  c inline "(psa_ecc_family_t)mbedtls_ecc_group_to_psa((int32_t)#1, (size_t*)#2)"

pub inline fun ffi/mbedtls-ecc-group-to-psa(^grpid: mbedtls-ecp-group-id, ^bits: c-pointer<int>): <exn> int
  external/mbedtls-ecc-group-to-psa(grpid.mbedtls-ecp-group-id/int, bits).int

// Convert an ECC curve identifier from the PSA encoding to Mbed TLS.
// 
// \param family        A PSA elliptic curve family identifier
// (`PSA_ECC_FAMILY_xxx`).
// \param bits          The bit-length of a private key on \p curve.
// 
// \return              If the curve is supported in the PSA API, this function
// returns the corresponding Mbed TLS elliptic curve
// identifier (`MBEDTLS_ECP_DP_xxx`).
// \return              #MBEDTLS_ECP_DP_NONE if the combination of \c curve
// and \p bits is not supported.
pub extern external/mbedtls-ecc-group-from-psa(^family: int8, ^bits: ssize_t): int32
  c inline "(int32_t)mbedtls_ecc_group_from_psa((psa_ecc_family_t)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-ecc-group-from-psa(^family: int, ^bits: int): <exn> mbedtls-ecp-group-id
  external/mbedtls-ecc-group-from-psa(family.int8, bits.ssize_t).int/mbedtls-ecp-group-id

// Convert an ECDSA signature from raw format to DER ASN.1 format.
// 
// \param       bits        Size of each coordinate in bits.
// \param       raw         Buffer that contains the signature in raw format.
// \param       raw_len     Length of \p raw in bytes. This must be
// PSA_BITS_TO_BYTES(bits) bytes.
// \param[out]  der         Buffer that will be filled with the converted DER
// output. It can overlap with raw buffer.
// \param       der_size    Size of \p der in bytes. It is enough if \p der_size
// is at least the size of the actual output. (The size
// of the output can vary depending on the presence of
// leading zeros in the data.) You can use
// #MBEDTLS_ECDSA_MAX_SIG_LEN(\p bits) to determine a
// size that is large enough for all signatures for a
// given value of \p bits.
// \param[out]  der_len     On success it contains the amount of valid data
// (in bytes) written to \p der. It's undefined
// in case of failure.
pub extern external/mbedtls-ecdsa-raw-to-der(^bits: ssize_t, ^raw: c-pointer<int>, ^raw-len: ssize_t, ^der: c-pointer<int>, ^der-size: ssize_t, ^der-len: c-pointer<int>): int32
  c inline "(int)mbedtls_ecdsa_raw_to_der((size_t)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/mbedtls-ecdsa-raw-to-der(^bits: int, ^raw: c-pointer<int>, ^raw-len: int, ^der: c-pointer<int>, ^der-size: int, ^der-len: c-pointer<int>): <> int
  external/mbedtls-ecdsa-raw-to-der(bits.ssize_t, raw, raw-len.ssize_t, der, der-size.ssize_t, der-len).int

// Convert an ECDSA signature from DER ASN.1 format to raw format.
// 
// \param       bits        Size of each coordinate in bits.
// \param       der         Buffer that contains the signature in DER format.
// \param       der_len     Size of \p der in bytes.
// \param[out]  raw         Buffer that will be filled with the converted raw
// signature. It can overlap with der buffer.
// \param       raw_size    Size of \p raw in bytes. Must be at least
// 2 * PSA_BITS_TO_BYTES(bits) bytes.
// \param[out]  raw_len     On success it is updated with the amount of valid
// data (in bytes) written to \p raw. It's undefined
// in case of failure.
pub extern external/mbedtls-ecdsa-der-to-raw(^bits: ssize_t, ^der: c-pointer<int>, ^der-len: ssize_t, ^raw: c-pointer<int>, ^raw-size: ssize_t, ^raw-len: c-pointer<int>): int32
  c inline "(int)mbedtls_ecdsa_der_to_raw((size_t)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (size_t*)#6)"

pub inline fun ffi/mbedtls-ecdsa-der-to-raw(^bits: int, ^der: c-pointer<int>, ^der-len: int, ^raw: c-pointer<int>, ^raw-size: int, ^raw-len: c-pointer<int>): <> int
  external/mbedtls-ecdsa-der-to-raw(bits.ssize_t, der, der-len.ssize_t, raw, raw-size.ssize_t, raw-len).int

// \brief               HMAC_DRBG context initialization.
// 
// This function makes the context ready for mbedtls_hmac_drbg_seed(),
// mbedtls_hmac_drbg_seed_buf() or mbedtls_hmac_drbg_free().
// 
// \note                The reseed interval is #MBEDTLS_HMAC_DRBG_RESEED_INTERVAL
// by default. Override this value by calling
// mbedtls_hmac_drbg_set_reseed_interval().
// 
// \param ctx           HMAC_DRBG context to be initialized.
pub extern external/mbedtls-hmac-drbg-init(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>): ()
  c inline "(void)mbedtls_hmac_drbg_init((struct mbedtls_hmac_drbg_context*)#1)"

// \param ctx           HMAC_DRBG context to be seeded.
// \param md_info       MD algorithm to use for HMAC_DRBG.
// \param f_entropy     The entropy callback, taking as arguments the
// \p p_entropy context, the buffer to fill, and the
// length of the buffer.
// \p f_entropy is always called with a length that is
// less than or equal to the entropy length.
// \param p_entropy     The entropy context to pass to \p f_entropy.
// \param custom        The personalization string.
// This can be \c NULL, in which case the personalization
// string is empty regardless of the value of \p len.
// \param len           The length of the personalization string.
// This must be at most #MBEDTLS_HMAC_DRBG_MAX_INPUT
// and also at most
// #MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT - \c entropy_len * 3 / 2
// where \c entropy_len is the entropy length
// described above.
// 
// \return              \c 0 if successful.
// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \p md_info is
// invalid.
// \return              #MBEDTLS_ERR_MD_ALLOC_FAILED if there was not enough
// memory to allocate context data.
// \return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED
// if the call to \p f_entropy failed.
pub extern external/mbedtls-hmac-drbg-seed(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^md-info: c-pointer<mbedtls-md-info-t-c>, ^f-entropy: c-pointer<intptr_t>, ^p-entropy: c-pointer<()>, ^custom: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_hmac_drbg_seed((struct mbedtls_hmac_drbg_context*)#1, (struct mbedtls_md_info_t*)#2, (int (*)(void*, unsigned char*, size_t))#3, (void*)#4, (unsigned char*)#5, (size_t)#6)"

pub inline fun ffi/mbedtls-hmac-drbg-seed(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^md-info: c-pointer<mbedtls-md-info-t-c>, ^f-entropy: c-pointer<intptr_t>, ^p-entropy: c-pointer<()>, ^custom: c-pointer<int>, ^len: int): <> int
  external/mbedtls-hmac-drbg-seed(ctx1, md-info, f-entropy, p-entropy, custom, len.ssize_t).int

// \param ctx           HMAC_DRBG context to be initialised.
// \param md_info       MD algorithm to use for HMAC_DRBG.
// \param data          Concatenation of the initial entropy string and
// the additional data.
// \param data_len      Length of \p data in bytes.
// 
// \return              \c 0 if successful. or
// \return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \p md_info is
// invalid.
// \return              #MBEDTLS_ERR_MD_ALLOC_FAILED if there was not enough
// memory to allocate context data.
pub extern external/mbedtls-hmac-drbg-seed-buf(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^md-info: c-pointer<mbedtls-md-info-t-c>, ^data: c-pointer<int>, ^data-len: ssize_t): int32
  c inline "(int)mbedtls_hmac_drbg_seed_buf((struct mbedtls_hmac_drbg_context*)#1, (struct mbedtls_md_info_t*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-hmac-drbg-seed-buf(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^md-info: c-pointer<mbedtls-md-info-t-c>, ^data: c-pointer<int>, ^data-len: int): <> int
  external/mbedtls-hmac-drbg-seed-buf(ctx1, md-info, data, data-len.ssize_t).int

// \brief               This function turns prediction resistance on or off.
// The default value is off.
// 
// \note                If enabled, entropy is gathered at the beginning of
// every call to mbedtls_hmac_drbg_random_with_add()
// or mbedtls_hmac_drbg_random().
// Only use this if your entropy source has sufficient
// throughput.
// 
// \param ctx           The HMAC_DRBG context.
// \param resistance    #MBEDTLS_HMAC_DRBG_PR_ON or #MBEDTLS_HMAC_DRBG_PR_OFF.
pub extern external/mbedtls-hmac-drbg-set-prediction-resistance(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^resistance: int32): ()
  c inline "(void)mbedtls_hmac_drbg_set_prediction_resistance((struct mbedtls_hmac_drbg_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-hmac-drbg-set-prediction-resistance(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^resistance: int): <> ()
  external/mbedtls-hmac-drbg-set-prediction-resistance(ctx1, resistance.int32)

// \brief               This function sets the amount of entropy grabbed on each
// seed or reseed.
// 
// See the documentation of mbedtls_hmac_drbg_seed() for the default value.
// 
// \param ctx           The HMAC_DRBG context.
// \param len           The amount of entropy to grab, in bytes.
pub extern external/mbedtls-hmac-drbg-set-entropy-len(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^len: ssize_t): ()
  c inline "(void)mbedtls_hmac_drbg_set_entropy_len((struct mbedtls_hmac_drbg_context*)#1, (size_t)#2)"

pub inline fun ffi/mbedtls-hmac-drbg-set-entropy-len(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^len: int): <> ()
  external/mbedtls-hmac-drbg-set-entropy-len(ctx1, len.ssize_t)

// \brief               Set the reseed interval.
// 
// The reseed interval is the number of calls to mbedtls_hmac_drbg_random()
// or mbedtls_hmac_drbg_random_with_add() after which the entropy function
// is called again.
// 
// The default value is #MBEDTLS_HMAC_DRBG_RESEED_INTERVAL.
// 
// \param ctx           The HMAC_DRBG context.
// \param interval      The reseed interval.
pub extern external/mbedtls-hmac-drbg-set-reseed-interval(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^interval: int32): ()
  c inline "(void)mbedtls_hmac_drbg_set_reseed_interval((struct mbedtls_hmac_drbg_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-hmac-drbg-set-reseed-interval(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^interval: int): <> ()
  external/mbedtls-hmac-drbg-set-reseed-interval(ctx1, interval.int32)

// \brief               This function updates the state of the HMAC_DRBG context.
// 
// \note                This function is not thread-safe. It is not safe
// to call this function if another thread might be
// concurrently obtaining random numbers from the same
// context or updating or reseeding the same context.
// 
// \param ctx           The HMAC_DRBG context.
// \param additional    The data to update the state with.
// If this is \c NULL, there is no additional data.
// \param add_len       Length of \p additional in bytes.
// Unused if \p additional is \c NULL.
// 
// \return              \c 0 on success, or an error from the underlying
// hash calculation.
pub extern external/mbedtls-hmac-drbg-update(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^additional: c-pointer<int>, ^add-len: ssize_t): int32
  c inline "(int)mbedtls_hmac_drbg_update((struct mbedtls_hmac_drbg_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-hmac-drbg-update(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^additional: c-pointer<int>, ^add-len: int): <> int
  external/mbedtls-hmac-drbg-update(ctx1, additional, add-len.ssize_t).int

// \brief               This function reseeds the HMAC_DRBG context, that is
// extracts data from the entropy source.
// 
// \note                This function is not thread-safe. It is not safe
// to call this function if another thread might be
// concurrently obtaining random numbers from the same
// context or updating or reseeding the same context.
// 
// \param ctx           The HMAC_DRBG context.
// \param additional    Additional data to add to the state.
// If this is \c NULL, there is no additional data
// and \p len should be \c 0.
// \param len           The length of the additional data.
// This must be at most #MBEDTLS_HMAC_DRBG_MAX_INPUT
// and also at most
// #MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT - \c entropy_len
// where \c entropy_len is the entropy length
// (see mbedtls_hmac_drbg_set_entropy_len()).
// 
// \return              \c 0 if successful.
// \return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED
// if a call to the entropy function failed.
pub extern external/mbedtls-hmac-drbg-reseed(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^additional: c-pointer<int>, ^len: ssize_t): int32
  c inline "(int)mbedtls_hmac_drbg_reseed((struct mbedtls_hmac_drbg_context*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-hmac-drbg-reseed(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^additional: c-pointer<int>, ^len: int): <> int
  external/mbedtls-hmac-drbg-reseed(ctx1, additional, len.ssize_t).int

// \brief   This function updates an HMAC_DRBG instance with additional
// data and uses it to generate random data.
// 
// This function automatically reseeds if the reseed counter is exceeded
// or prediction resistance is enabled.
// 
// \note                This function is not thread-safe. It is not safe
// to call this function if another thread might be
// concurrently obtaining random numbers from the same
// context or updating or reseeding the same context.
// 
// \param p_rng         The HMAC_DRBG context. This must be a pointer to a
// #mbedtls_hmac_drbg_context structure.
// \param output        The buffer to fill.
// \param output_len    The length of the buffer in bytes.
// This must be at most #MBEDTLS_HMAC_DRBG_MAX_REQUEST.
// \param additional    Additional data to update with.
// If this is \c NULL, there is no additional data
// and \p add_len should be \c 0.
// \param add_len       The length of the additional data.
// This must be at most #MBEDTLS_HMAC_DRBG_MAX_INPUT.
// 
// \return              \c 0 if successful.
// \return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED
// if a call to the entropy source failed.
// \return              #MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG if
// \p output_len > #MBEDTLS_HMAC_DRBG_MAX_REQUEST.
// \return              #MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG if
// \p add_len > #MBEDTLS_HMAC_DRBG_MAX_INPUT.
pub extern external/mbedtls-hmac-drbg-random-with-add(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-len: ssize_t, ^additional: c-pointer<int>, ^add-len: ssize_t): int32
  c inline "(int)mbedtls_hmac_drbg_random_with_add((void*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-hmac-drbg-random-with-add(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^output-len: int, ^additional: c-pointer<int>, ^add-len: int): <> int
  external/mbedtls-hmac-drbg-random-with-add(p-rng, output, output-len.ssize_t, additional, add-len.ssize_t).int

// \param p_rng         The HMAC_DRBG context. This must be a pointer to a
// #mbedtls_hmac_drbg_context structure.
// \param output        The buffer to fill.
// \param out_len       The length of the buffer in bytes.
// This must be at most #MBEDTLS_HMAC_DRBG_MAX_REQUEST.
// 
// \return              \c 0 if successful.
// \return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED
// if a call to the entropy source failed.
// \return              #MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG if
// \p out_len > #MBEDTLS_HMAC_DRBG_MAX_REQUEST.
pub extern external/mbedtls-hmac-drbg-random(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^out-len: ssize_t): int32
  c inline "(int)mbedtls_hmac_drbg_random((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-hmac-drbg-random(^p-rng: c-pointer<()>, ^output: c-pointer<int>, ^out-len: int): <> int
  external/mbedtls-hmac-drbg-random(p-rng, output, out-len.ssize_t).int

// \brief               This function resets HMAC_DRBG context to the state immediately
// after initial call of mbedtls_hmac_drbg_init().
// 
// \param ctx           The HMAC_DRBG context to free.
pub extern external/mbedtls-hmac-drbg-free(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>): ()
  c inline "(void)mbedtls_hmac_drbg_free((struct mbedtls_hmac_drbg_context*)#1)"

// \brief               This function writes a seed file.
// 
// \param ctx           The HMAC_DRBG context.
// \param path          The name of the file.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR on file error.
// \return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED on reseed
// failure.
pub extern external/mbedtls-hmac-drbg-write-seed-file(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_hmac_drbg_write_seed_file((struct mbedtls_hmac_drbg_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-hmac-drbg-write-seed-file(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-hmac-drbg-write-seed-file(ctx1, path).int

// \brief               This function reads and updates a seed file. The seed
// is added to this instance.
// 
// \param ctx           The HMAC_DRBG context.
// \param path          The name of the file.
// 
// \return              \c 0 on success.
// \return              #MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR on file error.
// \return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED on
// reseed failure.
// \return              #MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG if the existing
// seed file is too large.
pub extern external/mbedtls-hmac-drbg-update-seed-file(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^path: c-pointer<int>): int32
  c inline "(int)mbedtls_hmac_drbg_update_seed_file((struct mbedtls_hmac_drbg_context*)#1, (char*)#2)"

pub inline fun ffi/mbedtls-hmac-drbg-update-seed-file(^ctx1: c-pointer<mbedtls-hmac-drbg-context-c>, ^path: c-pointer<int>): <> int
  external/mbedtls-hmac-drbg-update-seed-file(ctx1, path).int

// \brief               The HMAC_DRBG Checkup routine.
// 
// \return              \c 0 if successful.
// \return              \c 1 if the test failed.
pub extern external/mbedtls-hmac-drbg-self-test(^verbose: int32): int32
  c inline "(int)mbedtls_hmac_drbg_self_test((int)#1)"

pub inline fun ffi/mbedtls-hmac-drbg-self-test(^verbose: int): <> int
  external/mbedtls-hmac-drbg-self-test(verbose.int32).int

// \brief           Initialize a ticket context.
// (Just make it ready for mbedtls_ssl_ticket_setup()
// or mbedtls_ssl_ticket_free().)
// 
// \param ctx       Context to be initialized
pub extern external/mbedtls-ssl-ticket-init(^ctx1: c-pointer<mbedtls-ssl-ticket-context-c>): ()
  c inline "(void)mbedtls_ssl_ticket_init((struct mbedtls_ssl_ticket_context*)#1)"

// \brief           Prepare context to be actually used
// 
// \param ctx       Context to be set up
// \param f_rng     RNG callback function (mandatory)
// \param p_rng     RNG callback context
// \param cipher    AEAD cipher to use for ticket protection.
// Recommended value: MBEDTLS_CIPHER_AES_256_GCM.
// \param lifetime  Tickets lifetime in seconds
// Recommended value: 86400 (one day).
// 
// \note            It is highly recommended to select a cipher that is at
// least as strong as the strongest ciphersuite
// supported. Usually that means a 256-bit key.
// 
// \note            It is recommended to pick a reasonable lifetime so as not
// to negate the benefits of forward secrecy.
// 
// \note            The TLS 1.3 specification states that ticket lifetime must
// be smaller than seven days. If ticket lifetime has been
// set to a value greater than seven days in this module then
// if the TLS 1.3 is configured to send tickets after the
// handshake it will fail the connection when trying to send
// the first ticket.
// 
// \return          0 if successful,
// or a specific MBEDTLS_ERR_XXX error code
pub extern external/mbedtls-ssl-ticket-setup(^ctx1: c-pointer<mbedtls-ssl-ticket-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^cipher: int32, ^lifetime: int32): int32
  c inline "(int)mbedtls_ssl_ticket_setup((struct mbedtls_ssl_ticket_context*)#1, (int (*)(void*, unsigned char*, size_t))#2, (void*)#3, (int32_t)#4, (int32_t)#5)"

pub inline fun ffi/mbedtls-ssl-ticket-setup(^ctx1: c-pointer<mbedtls-ssl-ticket-context-c>, ^f-rng: c-pointer<intptr_t>, ^p-rng: c-pointer<()>, ^cipher: mbedtls-cipher-type-t, ^lifetime: int): <exn> int
  external/mbedtls-ssl-ticket-setup(ctx1, f-rng, p-rng, cipher.mbedtls-cipher-type-t/int, lifetime.int32).int

// \brief           Rotate session ticket encryption key to new specified key.
// Provides for external control of session ticket encryption
// key rotation, e.g. for synchronization between different
// machines.  If this function is not used, or if not called
// before ticket lifetime expires, then a new session ticket
// encryption key is generated internally in order to avoid
// unbounded session ticket encryption key lifetimes.
// 
// \param ctx       Context to be set up
// \param name      Session ticket encryption key name
// \param nlength   Session ticket encryption key name length in bytes
// \param k         Session ticket encryption key
// \param klength   Session ticket encryption key length in bytes
// \param lifetime  Tickets lifetime in seconds
// Recommended value: 86400 (one day).
// 
// \note            \c name and \c k are recommended to be cryptographically
// random data.
// 
// \note            \c nlength must match sizeof( ctx->name )
// 
// \note            \c klength must be sufficient for use by cipher specified
// to \c mbedtls_ssl_ticket_setup
// 
// \note            It is recommended to pick a reasonable lifetime so as not
// to negate the benefits of forward secrecy.
// 
// \note            The TLS 1.3 specification states that ticket lifetime must
// be smaller than seven days. If ticket lifetime has been
// set to a value greater than seven days in this module then
// if the TLS 1.3 is configured to send tickets after the
// handshake it will fail the connection when trying to send
// the first ticket.
// 
// \return          0 if successful,
// or a specific MBEDTLS_ERR_XXX error code
pub extern external/mbedtls-ssl-ticket-rotate(^ctx1: c-pointer<mbedtls-ssl-ticket-context-c>, ^name: c-pointer<int>, ^nlength: ssize_t, ^k: c-pointer<int>, ^klength: ssize_t, ^lifetime: int32): int32
  c inline "(int)mbedtls_ssl_ticket_rotate((struct mbedtls_ssl_ticket_context*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5, (int32_t)#6)"

pub inline fun ffi/mbedtls-ssl-ticket-rotate(^ctx1: c-pointer<mbedtls-ssl-ticket-context-c>, ^name: c-pointer<int>, ^nlength: int, ^k: c-pointer<int>, ^klength: int, ^lifetime: int): <> int
  external/mbedtls-ssl-ticket-rotate(ctx1, name, nlength.ssize_t, k, klength.ssize_t, lifetime.int32).int

// \brief           Implementation of the ticket write callback
// 
// \note            See \c mbedtls_ssl_ticket_write_t for description
pub extern external/mbedtls-ssl-ticket-write(^arg0: c-pointer<()>, ^arg1: c-pointer<mbedtls-ssl-session-c>, ^arg2: c-pointer<int>, ^arg3: c-pointer<int>, ^arg4: c-pointer<int>, ^arg5: c-pointer<int>): int32
  c inline "(int)mbedtls_ssl_ticket_write((void*)#1, (struct mbedtls_ssl_session*)#2, (unsigned char*)#3, (unsigned char*)#4, (size_t*)#5, (int32_t*)#6)"

pub inline fun ffi/mbedtls-ssl-ticket-write(^arg0: c-pointer<()>, ^arg1: c-pointer<mbedtls-ssl-session-c>, ^arg2: c-pointer<int>, ^arg3: c-pointer<int>, ^arg4: c-pointer<int>, ^arg5: c-pointer<int>): <> int
  external/mbedtls-ssl-ticket-write(arg0, arg1, arg2, arg3, arg4, arg5).int

// \brief           Implementation of the ticket parse callback
// 
// \note            See \c mbedtls_ssl_ticket_parse_t for description
pub extern external/mbedtls-ssl-ticket-parse(^arg0: c-pointer<()>, ^arg1: c-pointer<mbedtls-ssl-session-c>, ^arg2: c-pointer<int>, ^arg3: ssize_t): int32
  c inline "(int)mbedtls_ssl_ticket_parse((void*)#1, (struct mbedtls_ssl_session*)#2, (unsigned char*)#3, (size_t)#4)"

pub inline fun ffi/mbedtls-ssl-ticket-parse(^arg0: c-pointer<()>, ^arg1: c-pointer<mbedtls-ssl-session-c>, ^arg2: c-pointer<int>, ^arg3: int): <> int
  external/mbedtls-ssl-ticket-parse(arg0, arg1, arg2, arg3.ssize_t).int

// \brief           Free a context's content and zeroize it.
// 
// \param ctx       Context to be cleaned up
pub extern external/mbedtls-ssl-ticket-free(^ctx1: c-pointer<mbedtls-ssl-ticket-context-c>): ()
  c inline "(void)mbedtls_ssl_ticket_free((struct mbedtls_ssl_ticket_context*)#1)"

// \brief          Initialize an SSL cache context
// 
// \param cache    SSL cache context
pub extern external/mbedtls-ssl-cache-init(^cache: c-pointer<mbedtls-ssl-cache-context-c>): ()
  c inline "(void)mbedtls_ssl_cache_init((struct mbedtls_ssl_cache_context*)#1)"

// \brief          Cache get callback implementation
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param data            The SSL cache context to use.
// \param session_id      The pointer to the buffer holding the session ID
// for the session to load.
// \param session_id_len  The length of \p session_id in bytes.
// \param session         The address at which to store the session
// associated with \p session_id, if present.
// 
// \return                \c 0 on success.
// \return                #MBEDTLS_ERR_SSL_CACHE_ENTRY_NOT_FOUND if there is
// no cache entry with specified session ID found, or
// any other negative error code for other failures.
pub extern external/mbedtls-ssl-cache-get(^data: c-pointer<()>, ^session-id: c-pointer<int>, ^session-id-len: ssize_t, ^session: c-pointer<mbedtls-ssl-session-c>): int32
  c inline "(int)mbedtls_ssl_cache_get((void*)#1, (unsigned char*)#2, (size_t)#3, (struct mbedtls_ssl_session*)#4)"

pub inline fun ffi/mbedtls-ssl-cache-get(^data: c-pointer<()>, ^session-id: c-pointer<int>, ^session-id-len: int, ^session: c-pointer<mbedtls-ssl-session-c>): <> int
  external/mbedtls-ssl-cache-get(data, session-id, session-id-len.ssize_t, session).int

// \brief          Cache set callback implementation
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param data            The SSL cache context to use.
// \param session_id      The pointer to the buffer holding the session ID
// associated to \p session.
// \param session_id_len  The length of \p session_id in bytes.
// \param session         The session to store.
// 
// \return                \c 0 on success.
// \return                A negative error code on failure.
pub extern external/mbedtls-ssl-cache-set(^data: c-pointer<()>, ^session-id: c-pointer<int>, ^session-id-len: ssize_t, ^session: c-pointer<mbedtls-ssl-session-c>): int32
  c inline "(int)mbedtls_ssl_cache_set((void*)#1, (unsigned char*)#2, (size_t)#3, (struct mbedtls_ssl_session*)#4)"

pub inline fun ffi/mbedtls-ssl-cache-set(^data: c-pointer<()>, ^session-id: c-pointer<int>, ^session-id-len: int, ^session: c-pointer<mbedtls-ssl-session-c>): <> int
  external/mbedtls-ssl-cache-set(data, session-id, session-id-len.ssize_t, session).int

// \brief          Remove the cache entry by the session ID
// (Thread-safe if MBEDTLS_THREADING_C is enabled)
// 
// \param data            The SSL cache context to use.
// \param session_id      The pointer to the buffer holding the session ID
// associated to session.
// \param session_id_len  The length of \p session_id in bytes.
// 
// \return                \c 0 on success. This indicates the cache entry for
// the session with provided ID is removed or does not
// exist.
// \return                A negative error code on failure.
pub extern external/mbedtls-ssl-cache-remove(^data: c-pointer<()>, ^session-id: c-pointer<int>, ^session-id-len: ssize_t): int32
  c inline "(int)mbedtls_ssl_cache_remove((void*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-ssl-cache-remove(^data: c-pointer<()>, ^session-id: c-pointer<int>, ^session-id-len: int): <> int
  external/mbedtls-ssl-cache-remove(data, session-id, session-id-len.ssize_t).int

// \brief          Set the cache timeout
// (Default: MBEDTLS_SSL_CACHE_DEFAULT_TIMEOUT (1 day))
// 
// A timeout of 0 indicates no timeout.
// 
// \param cache    SSL cache context
// \param timeout  cache entry timeout in seconds
pub extern external/mbedtls-ssl-cache-set-timeout(^cache: c-pointer<mbedtls-ssl-cache-context-c>, ^timeout: int32): ()
  c inline "(void)mbedtls_ssl_cache_set_timeout((struct mbedtls_ssl_cache_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-cache-set-timeout(^cache: c-pointer<mbedtls-ssl-cache-context-c>, ^timeout: int): <> ()
  external/mbedtls-ssl-cache-set-timeout(cache, timeout.int32)

// \brief          Set the maximum number of cache entries
// (Default: MBEDTLS_SSL_CACHE_DEFAULT_MAX_ENTRIES (50))
// 
// \param cache    SSL cache context
// \param max      cache entry maximum
pub extern external/mbedtls-ssl-cache-set-max-entries(^cache: c-pointer<mbedtls-ssl-cache-context-c>, ^max: int32): ()
  c inline "(void)mbedtls_ssl_cache_set_max_entries((struct mbedtls_ssl_cache_context*)#1, (int)#2)"

pub inline fun ffi/mbedtls-ssl-cache-set-max-entries(^cache: c-pointer<mbedtls-ssl-cache-context-c>, ^max: int): <> ()
  external/mbedtls-ssl-cache-set-max-entries(cache, max.int32)

// \brief          Free referenced items in a cache context and clear memory
// 
// \param cache    SSL cache context
pub extern external/mbedtls-ssl-cache-free(^cache: c-pointer<mbedtls-ssl-cache-context-c>): ()
  c inline "(void)mbedtls_ssl_cache_free((struct mbedtls_ssl_cache_context*)#1)"

// \brief   This function performs any platform-specific initialization
// operations.
// 
// \note    This function should be called before any other library functions.
// 
// Its implementation is platform-specific, and unless
// platform-specific code is provided, it does nothing.
// 
// \note    The usage and necessity of this function is dependent on the platform.
// 
// \param   ctx     The platform context.
// 
// \return  \c 0 on success.
pub extern external/mbedtls-platform-setup(^ctx1: c-pointer<mbedtls-platform-context-c>): int32
  c inline "(int)mbedtls_platform_setup((struct mbedtls_platform_context*)#1)"

pub inline fun ffi/mbedtls-platform-setup(^ctx1: c-pointer<mbedtls-platform-context-c>): <> int
  external/mbedtls-platform-setup(ctx1).int

// \brief   This function performs any platform teardown operations.
// 
// \note    This function should be called after every other Mbed TLS module
// has been correctly freed using the appropriate free function.
// 
// Its implementation is platform-specific, and unless
// platform-specific code is provided, it does nothing.
// 
// \note    The usage and necessity of this function is dependent on the platform.
// 
// \param   ctx     The platform context.
pub extern external/mbedtls-platform-teardown(^ctx1: c-pointer<mbedtls-platform-context-c>): ()
  c inline "(void)mbedtls_platform_teardown((struct mbedtls_platform_context*)#1)"

// \brief                    This function initializes an LMS public context
// 
// \param ctx                The uninitialized LMS context that will then be
// initialized.
pub extern external/mbedtls-lms-public-init(^ctx1: c-pointer<mbedtls-lms-public-t-c>): ()
  c inline "(void)mbedtls_lms_public_init((mbedtls_lms_public_t*)#1)"

// \brief                    This function uninitializes an LMS public context
// 
// \param ctx                The initialized LMS context that will then be
// uninitialized.
pub extern external/mbedtls-lms-public-free(^ctx1: c-pointer<mbedtls-lms-public-t-c>): ()
  c inline "(void)mbedtls_lms_public_free((mbedtls_lms_public_t*)#1)"

// \brief                    This function imports an LMS public key into a
// public LMS context.
// 
// \note                     Before this function is called, the context must
// have been initialized.
// 
// \note                     See IETF RFC8554 for details of the encoding of
// this public key.
// 
// \param ctx                The initialized LMS context store the key in.
// \param key                The buffer from which the key will be read.
// #MBEDTLS_LMS_PUBLIC_KEY_LEN bytes will be read from
// this.
// \param key_size           The size of the key being imported.
// 
// \return         \c 0 on success.
// \return         A non-zero error code on failure.
pub extern external/mbedtls-lms-import-public-key(^ctx1: c-pointer<mbedtls-lms-public-t-c>, ^key: c-pointer<int>, ^key-size: ssize_t): int32
  c inline "(int)mbedtls_lms_import_public_key((mbedtls_lms_public_t*)#1, (unsigned char*)#2, (size_t)#3)"

pub inline fun ffi/mbedtls-lms-import-public-key(^ctx1: c-pointer<mbedtls-lms-public-t-c>, ^key: c-pointer<int>, ^key-size: int): <> int
  external/mbedtls-lms-import-public-key(ctx1, key, key-size.ssize_t).int

// \brief                    This function exports an LMS public key from a
// LMS public context that already contains a public
// key.
// 
// \note                     Before this function is called, the context must
// have been initialized and the context must contain
// a public key.
// 
// \note                     See IETF RFC8554 for details of the encoding of
// this public key.
// 
// \param ctx                The initialized LMS public context that contains
// the public key.
// \param key                The buffer into which the key will be output. Must
// be at least #MBEDTLS_LMS_PUBLIC_KEY_LEN in size.
// \param key_size           The size of the key buffer.
// \param key_len            If not NULL, will be written with the size of the
// key.
// 
// \return         \c 0 on success.
// \return         A non-zero error code on failure.
pub extern external/mbedtls-lms-export-public-key(^ctx1: c-pointer<mbedtls-lms-public-t-c>, ^key: c-pointer<int>, ^key-size: ssize_t, ^key-len: c-pointer<int>): int32
  c inline "(int)mbedtls_lms_export_public_key((mbedtls_lms_public_t*)#1, (unsigned char*)#2, (size_t)#3, (size_t*)#4)"

pub inline fun ffi/mbedtls-lms-export-public-key(^ctx1: c-pointer<mbedtls-lms-public-t-c>, ^key: c-pointer<int>, ^key-size: int, ^key-len: c-pointer<int>): <> int
  external/mbedtls-lms-export-public-key(ctx1, key, key-size.ssize_t, key-len).int

// \brief                    This function verifies a LMS signature, using a
// LMS context that contains a public key.
// 
// \note                     Before this function is called, the context must
// have been initialized and must contain a public key
// (either by import or generation).
// 
// \param ctx                The initialized LMS public context from which the
// public key will be read.
// \param msg                The buffer from which the message will be read.
// \param msg_size           The size of the message that will be read.
// \param sig                The buf from which the signature will be read.
// #MBEDTLS_LMS_SIG_LEN bytes will be read from
// this.
// \param sig_size           The size of the signature to be verified.
// 
// \return         \c 0 on successful verification.
// \return         A non-zero error code on failure.
pub extern external/mbedtls-lms-verify(^ctx1: c-pointer<mbedtls-lms-public-t-c>, ^msg: c-pointer<int>, ^msg-size: ssize_t, ^sig: c-pointer<int>, ^sig-size: ssize_t): int32
  c inline "(int)mbedtls_lms_verify((mbedtls_lms_public_t*)#1, (unsigned char*)#2, (size_t)#3, (unsigned char*)#4, (size_t)#5)"

pub inline fun ffi/mbedtls-lms-verify(^ctx1: c-pointer<mbedtls-lms-public-t-c>, ^msg: c-pointer<int>, ^msg-size: int, ^sig: c-pointer<int>, ^sig-size: int): <> int
  external/mbedtls-lms-verify(ctx1, msg, msg-size.ssize_t, sig, sig-size.ssize_t).int

// \brief       PEM context structure
pub value struct mbedtls-pem-context
  // !< buffer for decoded data
  private-buf: c-pointer<int>
  // !< length of the buffer
  private-buflen: int
  // !< buffer for extra header information
  private-info: c-pointer<int>

pub type mbedtls-pem-context-c
pub alias mbedtls-pem-contextp = c-pointer<mbedtls-pem-context-c>
pub alias mbedtls-pem-contextc = owned-c<mbedtls-pem-context-c>
pub alias mbedtls-pem-contextcb<s::S> = borrowed-c<s,mbedtls-pem-context-c>
pub alias mbedtls-pem-contextca = owned-c<c-array<mbedtls-pem-context-c>>

pub extern mbedtls-pem-context/size-of(c: c-null<mbedtls-pem-context-c>): int32
  c inline "sizeof(struct mbedtls_pem_context)"

pub fun mbedtls-pem-contextc(): mbedtls-pem-contextc
  malloc(?size-of=mbedtls-pem-context/size-of)

pub fun mbedtls-pem-contextc-calloc(): mbedtls-pem-contextc
  malloc-c(?size-of=mbedtls-pem-context/size-of)

pub fun mbedtls-pem-contextc-array(n: int): mbedtls-pem-contextca
  malloc(n.int32, ?size-of=mbedtls-pem-context/size-of)

pub fun mbedtls-pem-contextc-array-calloc(n: int): mbedtls-pem-contextca
  malloc-c(n.int32, ?size-of=mbedtls-pem-context/size-of)

pub inline extern mbedtls-pem-context-ptrraw/private-buf(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_pem_context*)#1)->private_buf)"

pub inline fun mbedtls-pem-contextp/private-buf(s: mbedtls-pem-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-pem-context-ptrraw/private-buf

pub inline fun mbedtls-pem-contextc/private-buf(^s: mbedtls-pem-contextc): <> c-pointer<int>
  s.with-ptr(mbedtls-pem-contextp/private-buf)

pub inline fun mbedtls-pem-contextcb/private-buf(^s: mbedtls-pem-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-pem-contextp/private-buf)

pub inline extern mbedtls-pem-context-ptrraw/set-private-buf(s: intptr_t, private-buf: c-pointer<int>): ()
  c inline "((struct mbedtls_pem_context*)#1)->private_buf = (unsigned char*)#2"

pub inline fun mbedtls-pem-contextp/set-private-buf(s: mbedtls-pem-contextp, private-buf: c-pointer<int>): ()
  s.mbedtls-pem-context-ptrraw/set-private-buf(private-buf)

pub inline fun mbedtls-pem-contextc/set-private-buf(^s: mbedtls-pem-contextc, private-buf: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pem-contextp/set-private-buf(private-buf))

pub inline fun mbedtls-pem-contextcb/set-private-buf(^s: mbedtls-pem-contextcb<s::S>, private-buf: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pem-contextp/set-private-buf(private-buf))

pub inline extern mbedtls-pem-context-ptrraw/private-buflen(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_pem_context*)#1)->private_buflen)"

pub inline fun mbedtls-pem-contextp/private-buflen(s: mbedtls-pem-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-pem-context-ptrraw/private-buflen.int

pub inline fun mbedtls-pem-contextc/private-buflen(^s: mbedtls-pem-contextc): <> int
  s.with-ptr(mbedtls-pem-contextp/private-buflen)

pub inline fun mbedtls-pem-contextcb/private-buflen(^s: mbedtls-pem-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-pem-contextp/private-buflen)

pub inline extern mbedtls-pem-context-ptrraw/set-private-buflen(s: intptr_t, private-buflen: ssize_t): ()
  c inline "((struct mbedtls_pem_context*)#1)->private_buflen = (size_t)#2"

pub inline fun mbedtls-pem-contextp/set-private-buflen(s: mbedtls-pem-contextp, private-buflen: int): ()
  s.mbedtls-pem-context-ptrraw/set-private-buflen(private-buflen.ssize_t)

pub inline fun mbedtls-pem-contextc/set-private-buflen(^s: mbedtls-pem-contextc, private-buflen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pem-contextp/set-private-buflen(private-buflen))

pub inline fun mbedtls-pem-contextcb/set-private-buflen(^s: mbedtls-pem-contextcb<s::S>, private-buflen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pem-contextp/set-private-buflen(private-buflen))

pub inline extern mbedtls-pem-context-ptrraw/private-info(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_pem_context*)#1)->private_info)"

pub inline fun mbedtls-pem-contextp/private-info(s: mbedtls-pem-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-pem-context-ptrraw/private-info

pub inline fun mbedtls-pem-contextc/private-info(^s: mbedtls-pem-contextc): <> c-pointer<int>
  s.with-ptr(mbedtls-pem-contextp/private-info)

pub inline fun mbedtls-pem-contextcb/private-info(^s: mbedtls-pem-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-pem-contextp/private-info)

pub inline extern mbedtls-pem-context-ptrraw/set-private-info(s: intptr_t, private-info: c-pointer<int>): ()
  c inline "((struct mbedtls_pem_context*)#1)->private_info = (unsigned char*)#2"

pub inline fun mbedtls-pem-contextp/set-private-info(s: mbedtls-pem-contextp, private-info: c-pointer<int>): ()
  s.mbedtls-pem-context-ptrraw/set-private-info(private-info)

pub inline fun mbedtls-pem-contextc/set-private-info(^s: mbedtls-pem-contextc, private-info: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pem-contextp/set-private-info(private-info))

pub inline fun mbedtls-pem-contextcb/set-private-info(^s: mbedtls-pem-contextcb<s::S>, private-info: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pem-contextp/set-private-info(private-info))

alias mbedtls-ms-time-t = int
pub struct tm
pub type tm-c
pub alias tmp = c-pointer<tm-c>
pub alias tmc = owned-c<tm-c>
pub alias tmcb<s::S> = borrowed-c<s,tm-c>
pub alias tmca = owned-c<c-array<tm-c>>

alias mbedtls-time-t = int
alias time-t = int
alias --darwin-time-t = int
// \brief          MPI structure
pub value struct mbedtls-mpi
  // Pointer to limbs.
  // 
  // This may be \c NULL if \c n is 0.
  private-p: c-pointer<int>
  // Sign: -1 if the mpi is negative, 1 otherwise.
  // 
  // The number 0 must be represented with `s = +1`. Although many library
  // functions treat all-limbs-zero as equivalent to a valid representation
  // of 0 regardless of the sign bit, there are exceptions, so bignum
  // functions and external callers must always set \c s to +1 for the
  // number zero.
  // 
  // Note that this implies that calloc() or `... = {0}` does not create
  // a valid MPI representation. You must call mbedtls_mpi_init().
  private-s: int
  // Total number of limbs in \c p.
  private-n: int

pub type mbedtls-mpi-c
pub alias mbedtls-mpip = c-pointer<mbedtls-mpi-c>
pub alias mbedtls-mpic = owned-c<mbedtls-mpi-c>
pub alias mbedtls-mpicb<s::S> = borrowed-c<s,mbedtls-mpi-c>
pub alias mbedtls-mpica = owned-c<c-array<mbedtls-mpi-c>>

pub extern mbedtls-mpi/size-of(c: c-null<mbedtls-mpi-c>): int32
  c inline "sizeof(struct mbedtls_mpi)"

pub fun mbedtls-mpic(): mbedtls-mpic
  malloc(?size-of=mbedtls-mpi/size-of)

pub fun mbedtls-mpic-calloc(): mbedtls-mpic
  malloc-c(?size-of=mbedtls-mpi/size-of)

pub fun mbedtls-mpic-array(n: int): mbedtls-mpica
  malloc(n.int32, ?size-of=mbedtls-mpi/size-of)

pub fun mbedtls-mpic-array-calloc(n: int): mbedtls-mpica
  malloc-c(n.int32, ?size-of=mbedtls-mpi/size-of)

pub inline extern mbedtls-mpi-ptrraw/private-p(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_mpi*)#1)->private_p)"

pub inline fun mbedtls-mpip/private-p(s: mbedtls-mpip): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-mpi-ptrraw/private-p

pub inline fun mbedtls-mpic/private-p(^s: mbedtls-mpic): <> c-pointer<int>
  s.with-ptr(mbedtls-mpip/private-p)

pub inline fun mbedtls-mpicb/private-p(^s: mbedtls-mpicb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-mpip/private-p)

pub inline extern mbedtls-mpi-ptrraw/set-private-p(s: intptr_t, private-p: c-pointer<int>): ()
  c inline "((struct mbedtls_mpi*)#1)->private_p = (mbedtls_mpi_uint*)#2"

pub inline fun mbedtls-mpip/set-private-p(s: mbedtls-mpip, private-p: c-pointer<int>): ()
  s.mbedtls-mpi-ptrraw/set-private-p(private-p)

pub inline fun mbedtls-mpic/set-private-p(^s: mbedtls-mpic, private-p: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-mpip/set-private-p(private-p))

pub inline fun mbedtls-mpicb/set-private-p(^s: mbedtls-mpicb<s::S>, private-p: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-mpip/set-private-p(private-p))

pub inline extern mbedtls-mpi-ptrraw/private-s(s: intptr_t): int16
  c inline "(short)(((struct mbedtls_mpi*)#1)->private_s)"

pub inline fun mbedtls-mpip/private-s(s: mbedtls-mpip): <> int
  s.cextern/c-pointer/ptr.mbedtls-mpi-ptrraw/private-s.int

pub inline fun mbedtls-mpic/private-s(^s: mbedtls-mpic): <> int
  s.with-ptr(mbedtls-mpip/private-s)

pub inline fun mbedtls-mpicb/private-s(^s: mbedtls-mpicb<s::S>): <> int
  s.with-ptr(mbedtls-mpip/private-s)

pub inline extern mbedtls-mpi-ptrraw/set-private-s(s: intptr_t, private-s: int16): ()
  c inline "((struct mbedtls_mpi*)#1)->private_s = (short)#2"

pub inline fun mbedtls-mpip/set-private-s(s: mbedtls-mpip, private-s: int): ()
  s.mbedtls-mpi-ptrraw/set-private-s(private-s.int16)

pub inline fun mbedtls-mpic/set-private-s(^s: mbedtls-mpic, private-s: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-mpip/set-private-s(private-s))

pub inline fun mbedtls-mpicb/set-private-s(^s: mbedtls-mpicb<s::S>, private-s: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-mpip/set-private-s(private-s))

pub inline extern mbedtls-mpi-ptrraw/private-n(s: intptr_t): int16
  c inline "(unsigned short)(((struct mbedtls_mpi*)#1)->private_n)"

pub inline fun mbedtls-mpip/private-n(s: mbedtls-mpip): <> int
  s.cextern/c-pointer/ptr.mbedtls-mpi-ptrraw/private-n.int

pub inline fun mbedtls-mpic/private-n(^s: mbedtls-mpic): <> int
  s.with-ptr(mbedtls-mpip/private-n)

pub inline fun mbedtls-mpicb/private-n(^s: mbedtls-mpicb<s::S>): <> int
  s.with-ptr(mbedtls-mpip/private-n)

pub inline extern mbedtls-mpi-ptrraw/set-private-n(s: intptr_t, private-n: int16): ()
  c inline "((struct mbedtls_mpi*)#1)->private_n = (unsigned short)#2"

pub inline fun mbedtls-mpip/set-private-n(s: mbedtls-mpip, private-n: int): ()
  s.mbedtls-mpi-ptrraw/set-private-n(private-n.int16)

pub inline fun mbedtls-mpic/set-private-n(^s: mbedtls-mpic, private-n: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-mpip/set-private-n(private-n))

pub inline fun mbedtls-mpicb/set-private-n(^s: mbedtls-mpicb<s::S>, private-n: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-mpip/set-private-n(private-n))

alias mbedtls-mpi-uint = int
alias mbedtls-mpi-sint = int
alias file = --sfile-c
pub struct --sfile
pub type --sfile-c
pub alias --sfilep = c-pointer<--sfile-c>
pub alias --sfilec = owned-c<--sfile-c>
pub alias --sfilecb<s::S> = borrowed-c<s,--sfile-c>
pub alias --sfileca = owned-c<c-array<--sfile-c>>

// \brief Flags for mbedtls_mpi_gen_prime()
// 
// Each of these flags is a constraint on the result X returned by
// mbedtls_mpi_gen_prime().
type mbedtls-mpi-gen-prime-flag-t
  // < (X-1)/2 is prime too
  MBEDTLS_MPI_GEN_PRIME_FLAG_DH
  // < lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>
  MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR

pub fun mbedtls-mpi-gen-prime-flag-t/int(i: mbedtls-mpi-gen-prime-flag-t): int32
  match i
    MBEDTLS_MPI_GEN_PRIME_FLAG_DH -> 1.int32
    MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR -> 2.int32

pub fun int/mbedtls-mpi-gen-prime-flag-t(i: int32): exn mbedtls-mpi-gen-prime-flag-t
  match i.int
    1 -> MBEDTLS_MPI_GEN_PRIME_FLAG_DH
    2 -> MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR

// Type-length-value structure that allows for ASN1 using DER.
pub value struct mbedtls-asn1-buf
  // < ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING.
  tag: int
  // < ASN1 length, in octets.
  len: int
  // < ASN1 data, e.g. in ASCII.
  p: c-pointer<int>

pub type mbedtls-asn1-buf-c
pub alias mbedtls-asn1-bufp = c-pointer<mbedtls-asn1-buf-c>
pub alias mbedtls-asn1-bufc = owned-c<mbedtls-asn1-buf-c>
pub alias mbedtls-asn1-bufcb<s::S> = borrowed-c<s,mbedtls-asn1-buf-c>
pub alias mbedtls-asn1-bufca = owned-c<c-array<mbedtls-asn1-buf-c>>

pub extern mbedtls-asn1-buf/size-of(c: c-null<mbedtls-asn1-buf-c>): int32
  c inline "sizeof(struct mbedtls_asn1_buf)"

pub fun mbedtls-asn1-bufc(): mbedtls-asn1-bufc
  malloc(?size-of=mbedtls-asn1-buf/size-of)

pub fun mbedtls-asn1-bufc-calloc(): mbedtls-asn1-bufc
  malloc-c(?size-of=mbedtls-asn1-buf/size-of)

pub fun mbedtls-asn1-bufc-array(n: int): mbedtls-asn1-bufca
  malloc(n.int32, ?size-of=mbedtls-asn1-buf/size-of)

pub fun mbedtls-asn1-bufc-array-calloc(n: int): mbedtls-asn1-bufca
  malloc-c(n.int32, ?size-of=mbedtls-asn1-buf/size-of)

pub inline extern mbedtls-asn1-buf-ptrraw/tag(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_asn1_buf*)#1)->tag)"

pub inline fun mbedtls-asn1-bufp/tag(s: mbedtls-asn1-bufp): <> int
  s.cextern/c-pointer/ptr.mbedtls-asn1-buf-ptrraw/tag.int

pub inline fun mbedtls-asn1-bufc/tag(^s: mbedtls-asn1-bufc): <> int
  s.with-ptr(mbedtls-asn1-bufp/tag)

pub inline fun mbedtls-asn1-bufcb/tag(^s: mbedtls-asn1-bufcb<s::S>): <> int
  s.with-ptr(mbedtls-asn1-bufp/tag)

pub inline extern mbedtls-asn1-buf-ptrraw/set-tag(s: intptr_t, tag: int32): ()
  c inline "((struct mbedtls_asn1_buf*)#1)->tag = (int)#2"

pub inline fun mbedtls-asn1-bufp/set-tag(s: mbedtls-asn1-bufp, tag: int): ()
  s.mbedtls-asn1-buf-ptrraw/set-tag(tag.int32)

pub inline fun mbedtls-asn1-bufc/set-tag(^s: mbedtls-asn1-bufc, tag: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bufp/set-tag(tag))

pub inline fun mbedtls-asn1-bufcb/set-tag(^s: mbedtls-asn1-bufcb<s::S>, tag: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bufp/set-tag(tag))

pub inline extern mbedtls-asn1-buf-ptrraw/len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_asn1_buf*)#1)->len)"

pub inline fun mbedtls-asn1-bufp/len(s: mbedtls-asn1-bufp): <> int
  s.cextern/c-pointer/ptr.mbedtls-asn1-buf-ptrraw/len.int

pub inline fun mbedtls-asn1-bufc/len(^s: mbedtls-asn1-bufc): <> int
  s.with-ptr(mbedtls-asn1-bufp/len)

pub inline fun mbedtls-asn1-bufcb/len(^s: mbedtls-asn1-bufcb<s::S>): <> int
  s.with-ptr(mbedtls-asn1-bufp/len)

pub inline extern mbedtls-asn1-buf-ptrraw/set-len(s: intptr_t, len: ssize_t): ()
  c inline "((struct mbedtls_asn1_buf*)#1)->len = (size_t)#2"

pub inline fun mbedtls-asn1-bufp/set-len(s: mbedtls-asn1-bufp, len: int): ()
  s.mbedtls-asn1-buf-ptrraw/set-len(len.ssize_t)

pub inline fun mbedtls-asn1-bufc/set-len(^s: mbedtls-asn1-bufc, len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bufp/set-len(len))

pub inline fun mbedtls-asn1-bufcb/set-len(^s: mbedtls-asn1-bufcb<s::S>, len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bufp/set-len(len))

pub inline extern mbedtls-asn1-buf-ptrraw/p(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_asn1_buf*)#1)->p)"

pub inline fun mbedtls-asn1-bufp/p(s: mbedtls-asn1-bufp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-asn1-buf-ptrraw/p

pub inline fun mbedtls-asn1-bufc/p(^s: mbedtls-asn1-bufc): <> c-pointer<int>
  s.with-ptr(mbedtls-asn1-bufp/p)

pub inline fun mbedtls-asn1-bufcb/p(^s: mbedtls-asn1-bufcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-asn1-bufp/p)

pub inline extern mbedtls-asn1-buf-ptrraw/set-p(s: intptr_t, p: c-pointer<int>): ()
  c inline "((struct mbedtls_asn1_buf*)#1)->p = (unsigned char*)#2"

pub inline fun mbedtls-asn1-bufp/set-p(s: mbedtls-asn1-bufp, p: c-pointer<int>): ()
  s.mbedtls-asn1-buf-ptrraw/set-p(p)

pub inline fun mbedtls-asn1-bufc/set-p(^s: mbedtls-asn1-bufc, p: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bufp/set-p(p))

pub inline fun mbedtls-asn1-bufcb/set-p(^s: mbedtls-asn1-bufcb<s::S>, p: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bufp/set-p(p))

// Container for ASN1 bit strings.
pub value struct mbedtls-asn1-bitstring
  // < ASN1 length, in octets.
  len: int
  // < Number of unused bits at the end of the string
  unused-bits: int
  // < Raw ASN1 data for the bit string
  p: c-pointer<int>

pub type mbedtls-asn1-bitstring-c
pub alias mbedtls-asn1-bitstringp = c-pointer<mbedtls-asn1-bitstring-c>
pub alias mbedtls-asn1-bitstringc = owned-c<mbedtls-asn1-bitstring-c>
pub alias mbedtls-asn1-bitstringcb<s::S> = borrowed-c<s,mbedtls-asn1-bitstring-c>
pub alias mbedtls-asn1-bitstringca = owned-c<c-array<mbedtls-asn1-bitstring-c>>

pub extern mbedtls-asn1-bitstring/size-of(c: c-null<mbedtls-asn1-bitstring-c>): int32
  c inline "sizeof(struct mbedtls_asn1_bitstring)"

pub fun mbedtls-asn1-bitstringc(): mbedtls-asn1-bitstringc
  malloc(?size-of=mbedtls-asn1-bitstring/size-of)

pub fun mbedtls-asn1-bitstringc-calloc(): mbedtls-asn1-bitstringc
  malloc-c(?size-of=mbedtls-asn1-bitstring/size-of)

pub fun mbedtls-asn1-bitstringc-array(n: int): mbedtls-asn1-bitstringca
  malloc(n.int32, ?size-of=mbedtls-asn1-bitstring/size-of)

pub fun mbedtls-asn1-bitstringc-array-calloc(n: int): mbedtls-asn1-bitstringca
  malloc-c(n.int32, ?size-of=mbedtls-asn1-bitstring/size-of)

pub inline extern mbedtls-asn1-bitstring-ptrraw/len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_asn1_bitstring*)#1)->len)"

pub inline fun mbedtls-asn1-bitstringp/len(s: mbedtls-asn1-bitstringp): <> int
  s.cextern/c-pointer/ptr.mbedtls-asn1-bitstring-ptrraw/len.int

pub inline fun mbedtls-asn1-bitstringc/len(^s: mbedtls-asn1-bitstringc): <> int
  s.with-ptr(mbedtls-asn1-bitstringp/len)

pub inline fun mbedtls-asn1-bitstringcb/len(^s: mbedtls-asn1-bitstringcb<s::S>): <> int
  s.with-ptr(mbedtls-asn1-bitstringp/len)

pub inline extern mbedtls-asn1-bitstring-ptrraw/set-len(s: intptr_t, len: ssize_t): ()
  c inline "((struct mbedtls_asn1_bitstring*)#1)->len = (size_t)#2"

pub inline fun mbedtls-asn1-bitstringp/set-len(s: mbedtls-asn1-bitstringp, len: int): ()
  s.mbedtls-asn1-bitstring-ptrraw/set-len(len.ssize_t)

pub inline fun mbedtls-asn1-bitstringc/set-len(^s: mbedtls-asn1-bitstringc, len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bitstringp/set-len(len))

pub inline fun mbedtls-asn1-bitstringcb/set-len(^s: mbedtls-asn1-bitstringcb<s::S>, len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bitstringp/set-len(len))

pub inline extern mbedtls-asn1-bitstring-ptrraw/unused-bits(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_asn1_bitstring*)#1)->unused_bits)"

pub inline fun mbedtls-asn1-bitstringp/unused-bits(s: mbedtls-asn1-bitstringp): <> int
  s.cextern/c-pointer/ptr.mbedtls-asn1-bitstring-ptrraw/unused-bits.int

pub inline fun mbedtls-asn1-bitstringc/unused-bits(^s: mbedtls-asn1-bitstringc): <> int
  s.with-ptr(mbedtls-asn1-bitstringp/unused-bits)

pub inline fun mbedtls-asn1-bitstringcb/unused-bits(^s: mbedtls-asn1-bitstringcb<s::S>): <> int
  s.with-ptr(mbedtls-asn1-bitstringp/unused-bits)

pub inline extern mbedtls-asn1-bitstring-ptrraw/set-unused-bits(s: intptr_t, unused-bits: int8): ()
  c inline "((struct mbedtls_asn1_bitstring*)#1)->unused_bits = (unsigned char)#2"

pub inline fun mbedtls-asn1-bitstringp/set-unused-bits(s: mbedtls-asn1-bitstringp, unused-bits: int): ()
  s.mbedtls-asn1-bitstring-ptrraw/set-unused-bits(unused-bits.int8)

pub inline fun mbedtls-asn1-bitstringc/set-unused-bits(^s: mbedtls-asn1-bitstringc, unused-bits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bitstringp/set-unused-bits(unused-bits))

pub inline fun mbedtls-asn1-bitstringcb/set-unused-bits(^s: mbedtls-asn1-bitstringcb<s::S>, unused-bits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bitstringp/set-unused-bits(unused-bits))

pub inline extern mbedtls-asn1-bitstring-ptrraw/p(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_asn1_bitstring*)#1)->p)"

pub inline fun mbedtls-asn1-bitstringp/p(s: mbedtls-asn1-bitstringp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-asn1-bitstring-ptrraw/p

pub inline fun mbedtls-asn1-bitstringc/p(^s: mbedtls-asn1-bitstringc): <> c-pointer<int>
  s.with-ptr(mbedtls-asn1-bitstringp/p)

pub inline fun mbedtls-asn1-bitstringcb/p(^s: mbedtls-asn1-bitstringcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-asn1-bitstringp/p)

pub inline extern mbedtls-asn1-bitstring-ptrraw/set-p(s: intptr_t, p: c-pointer<int>): ()
  c inline "((struct mbedtls_asn1_bitstring*)#1)->p = (unsigned char*)#2"

pub inline fun mbedtls-asn1-bitstringp/set-p(s: mbedtls-asn1-bitstringp, p: c-pointer<int>): ()
  s.mbedtls-asn1-bitstring-ptrraw/set-p(p)

pub inline fun mbedtls-asn1-bitstringc/set-p(^s: mbedtls-asn1-bitstringc, p: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bitstringp/set-p(p))

pub inline fun mbedtls-asn1-bitstringcb/set-p(^s: mbedtls-asn1-bitstringcb<s::S>, p: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-bitstringp/set-p(p))

// Container for a sequence of ASN.1 items
pub value struct mbedtls-asn1-sequence
  // < Buffer containing the given ASN.1 item.
  buf: mbedtls-asn1-buf-c
  // The next entry in the sequence.
  // 
  // The details of memory management for sequences are not documented and
  // may change in future versions. Set this field to \p NULL when
  // initializing a structure, and do not modify it except via Mbed TLS
  // library functions.
  next: mbedtls-asn1-sequence-c

pub type mbedtls-asn1-sequence-c
pub alias mbedtls-asn1-sequencep = c-pointer<mbedtls-asn1-sequence-c>
pub alias mbedtls-asn1-sequencec = owned-c<mbedtls-asn1-sequence-c>
pub alias mbedtls-asn1-sequencecb<s::S> = borrowed-c<s,mbedtls-asn1-sequence-c>
pub alias mbedtls-asn1-sequenceca = owned-c<c-array<mbedtls-asn1-sequence-c>>

pub extern mbedtls-asn1-sequence/size-of(c: c-null<mbedtls-asn1-sequence-c>): int32
  c inline "sizeof(struct mbedtls_asn1_sequence)"

pub fun mbedtls-asn1-sequencec(): mbedtls-asn1-sequencec
  malloc(?size-of=mbedtls-asn1-sequence/size-of)

pub fun mbedtls-asn1-sequencec-calloc(): mbedtls-asn1-sequencec
  malloc-c(?size-of=mbedtls-asn1-sequence/size-of)

pub fun mbedtls-asn1-sequencec-array(n: int): mbedtls-asn1-sequenceca
  malloc(n.int32, ?size-of=mbedtls-asn1-sequence/size-of)

pub fun mbedtls-asn1-sequencec-array-calloc(n: int): mbedtls-asn1-sequenceca
  malloc-c(n.int32, ?size-of=mbedtls-asn1-sequence/size-of)

pub inline extern mbedtls-asn1-sequence-ptrraw/next(s: intptr_t): c-pointer<mbedtls-asn1-sequence-c>
  c inline "(intptr_t)(((struct mbedtls_asn1_sequence*)#1)->next)"

pub inline fun mbedtls-asn1-sequencep/next(s: mbedtls-asn1-sequencep): <> c-pointer<mbedtls-asn1-sequence-c>
  s.cextern/c-pointer/ptr.mbedtls-asn1-sequence-ptrraw/next

pub inline fun mbedtls-asn1-sequencec/next(^s: mbedtls-asn1-sequencec): <> c-pointer<mbedtls-asn1-sequence-c>
  s.with-ptr(mbedtls-asn1-sequencep/next)

pub inline fun mbedtls-asn1-sequencecb/next(^s: mbedtls-asn1-sequencecb<s::S>): <> c-pointer<mbedtls-asn1-sequence-c>
  s.with-ptr(mbedtls-asn1-sequencep/next)

pub inline extern mbedtls-asn1-sequence-ptrraw/set-next(s: intptr_t, next: c-pointer<mbedtls-asn1-sequence-c>): ()
  c inline "((struct mbedtls_asn1_sequence*)#1)->next = (struct mbedtls_asn1_sequence*)#2"

pub inline fun mbedtls-asn1-sequencep/set-next(s: mbedtls-asn1-sequencep, next: c-pointer<mbedtls-asn1-sequence-c>): ()
  s.mbedtls-asn1-sequence-ptrraw/set-next(next)

pub inline fun mbedtls-asn1-sequencec/set-next(^s: mbedtls-asn1-sequencec, next: c-pointer<mbedtls-asn1-sequence-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-sequencep/set-next(next))

pub inline fun mbedtls-asn1-sequencecb/set-next(^s: mbedtls-asn1-sequencecb<s::S>, next: c-pointer<mbedtls-asn1-sequence-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-sequencep/set-next(next))

// Container for a sequence or list of 'named' ASN.1 data items
pub struct mbedtls-asn1-named-data
  // < The object identifier.
  oid: mbedtls-asn1-buf-c
  // < The named value.
  val: mbedtls-asn1-buf-c
  // The next entry in the sequence.
  // 
  // The details of memory management for named data sequences are not
  // documented and may change in future versions. Set this field to \p NULL
  // when initializing a structure, and do not modify it except via Mbed TLS
  // library functions.
  next: mbedtls-asn1-named-data-c
  // Merge next item into the current one?
  // 
  // This field exists for the sake of Mbed TLS's X.509 certificate parsing
  // code and may change in future versions of the library.
  private-next-merged: int

pub type mbedtls-asn1-named-data-c
pub alias mbedtls-asn1-named-datap = c-pointer<mbedtls-asn1-named-data-c>
pub alias mbedtls-asn1-named-datac = owned-c<mbedtls-asn1-named-data-c>
pub alias mbedtls-asn1-named-datacb<s::S> = borrowed-c<s,mbedtls-asn1-named-data-c>
pub alias mbedtls-asn1-named-dataca = owned-c<c-array<mbedtls-asn1-named-data-c>>

pub extern mbedtls-asn1-named-data/size-of(c: c-null<mbedtls-asn1-named-data-c>): int32
  c inline "sizeof(struct mbedtls_asn1_named_data)"

pub fun mbedtls-asn1-named-datac(): mbedtls-asn1-named-datac
  malloc(?size-of=mbedtls-asn1-named-data/size-of)

pub fun mbedtls-asn1-named-datac-calloc(): mbedtls-asn1-named-datac
  malloc-c(?size-of=mbedtls-asn1-named-data/size-of)

pub fun mbedtls-asn1-named-datac-array(n: int): mbedtls-asn1-named-dataca
  malloc(n.int32, ?size-of=mbedtls-asn1-named-data/size-of)

pub fun mbedtls-asn1-named-datac-array-calloc(n: int): mbedtls-asn1-named-dataca
  malloc-c(n.int32, ?size-of=mbedtls-asn1-named-data/size-of)

pub inline extern mbedtls-asn1-named-data-ptrraw/next(s: intptr_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)(((struct mbedtls_asn1_named_data*)#1)->next)"

pub inline fun mbedtls-asn1-named-datap/next(s: mbedtls-asn1-named-datap): <> c-pointer<mbedtls-asn1-named-data-c>
  s.cextern/c-pointer/ptr.mbedtls-asn1-named-data-ptrraw/next

pub inline fun mbedtls-asn1-named-datac/next(^s: mbedtls-asn1-named-datac): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-asn1-named-datap/next)

pub inline fun mbedtls-asn1-named-datacb/next(^s: mbedtls-asn1-named-datacb<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-asn1-named-datap/next)

pub inline extern mbedtls-asn1-named-data-ptrraw/set-next(s: intptr_t, next: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "((struct mbedtls_asn1_named_data*)#1)->next = (struct mbedtls_asn1_named_data*)#2"

pub inline fun mbedtls-asn1-named-datap/set-next(s: mbedtls-asn1-named-datap, next: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.mbedtls-asn1-named-data-ptrraw/set-next(next)

pub inline fun mbedtls-asn1-named-datac/set-next(^s: mbedtls-asn1-named-datac, next: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-named-datap/set-next(next))

pub inline fun mbedtls-asn1-named-datacb/set-next(^s: mbedtls-asn1-named-datacb<s::S>, next: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-named-datap/set-next(next))

pub inline extern mbedtls-asn1-named-data-ptrraw/private-next-merged(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_asn1_named_data*)#1)->private_next_merged)"

pub inline fun mbedtls-asn1-named-datap/private-next-merged(s: mbedtls-asn1-named-datap): <> int
  s.cextern/c-pointer/ptr.mbedtls-asn1-named-data-ptrraw/private-next-merged.int

pub inline fun mbedtls-asn1-named-datac/private-next-merged(^s: mbedtls-asn1-named-datac): <> int
  s.with-ptr(mbedtls-asn1-named-datap/private-next-merged)

pub inline fun mbedtls-asn1-named-datacb/private-next-merged(^s: mbedtls-asn1-named-datacb<s::S>): <> int
  s.with-ptr(mbedtls-asn1-named-datap/private-next-merged)

pub inline extern mbedtls-asn1-named-data-ptrraw/set-private-next-merged(s: intptr_t, private-next-merged: int8): ()
  c inline "((struct mbedtls_asn1_named_data*)#1)->private_next_merged = (unsigned char)#2"

pub inline fun mbedtls-asn1-named-datap/set-private-next-merged(s: mbedtls-asn1-named-datap, private-next-merged: int): ()
  s.mbedtls-asn1-named-data-ptrraw/set-private-next-merged(private-next-merged.int8)

pub inline fun mbedtls-asn1-named-datac/set-private-next-merged(^s: mbedtls-asn1-named-datac, private-next-merged: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-named-datap/set-private-next-merged(private-next-merged))

pub inline fun mbedtls-asn1-named-datacb/set-private-next-merged(^s: mbedtls-asn1-named-datacb<s::S>, private-next-merged: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-asn1-named-datap/set-private-next-merged(private-next-merged))

// \brief     Supported message digests.
// 
// \warning   MD5 and SHA-1 are considered weak message digests and
// their use constitutes a security risk. We recommend considering
// stronger message digests instead.
type mbedtls-md-type-t
  // < None.
  MBEDTLS_MD_NONE
  // < The MD5 message digest.
  MBEDTLS_MD_MD5
  // < The RIPEMD-160 message digest.
  MBEDTLS_MD_RIPEMD160
  // < The SHA-1 message digest.
  MBEDTLS_MD_SHA1
  // < The SHA-224 message digest.
  MBEDTLS_MD_SHA224
  // < The SHA-256 message digest.
  MBEDTLS_MD_SHA256
  // < The SHA-384 message digest.
  MBEDTLS_MD_SHA384
  // < The SHA-512 message digest.
  MBEDTLS_MD_SHA512
  // < The SHA3-224 message digest.
  MBEDTLS_MD_SHA3_224
  // < The SHA3-256 message digest.
  MBEDTLS_MD_SHA3_256
  // < The SHA3-384 message digest.
  MBEDTLS_MD_SHA3_384
  // < The SHA3-512 message digest.
  MBEDTLS_MD_SHA3_512

pub fun mbedtls-md-type-t/int(i: mbedtls-md-type-t): int32
  match i
    MBEDTLS_MD_NONE -> 0.int32
    MBEDTLS_MD_MD5 -> 3.int32
    MBEDTLS_MD_RIPEMD160 -> 4.int32
    MBEDTLS_MD_SHA1 -> 5.int32
    MBEDTLS_MD_SHA224 -> 8.int32
    MBEDTLS_MD_SHA256 -> 9.int32
    MBEDTLS_MD_SHA384 -> 10.int32
    MBEDTLS_MD_SHA512 -> 11.int32
    MBEDTLS_MD_SHA3_224 -> 16.int32
    MBEDTLS_MD_SHA3_256 -> 17.int32
    MBEDTLS_MD_SHA3_384 -> 18.int32
    MBEDTLS_MD_SHA3_512 -> 19.int32

pub fun int/mbedtls-md-type-t(i: int32): exn mbedtls-md-type-t
  match i.int
    0 -> MBEDTLS_MD_NONE
    3 -> MBEDTLS_MD_MD5
    4 -> MBEDTLS_MD_RIPEMD160
    5 -> MBEDTLS_MD_SHA1
    8 -> MBEDTLS_MD_SHA224
    9 -> MBEDTLS_MD_SHA256
    10 -> MBEDTLS_MD_SHA384
    11 -> MBEDTLS_MD_SHA512
    16 -> MBEDTLS_MD_SHA3_224
    17 -> MBEDTLS_MD_SHA3_256
    18 -> MBEDTLS_MD_SHA3_384
    19 -> MBEDTLS_MD_SHA3_512

pub struct mbedtls-md-info-t
pub type mbedtls-md-info-t-c
pub alias mbedtls-md-info-tp = c-pointer<mbedtls-md-info-t-c>
pub alias mbedtls-md-info-tc = owned-c<mbedtls-md-info-t-c>
pub alias mbedtls-md-info-tcb<s::S> = borrowed-c<s,mbedtls-md-info-t-c>
pub alias mbedtls-md-info-tca = owned-c<c-array<mbedtls-md-info-t-c>>

// Used internally to indicate whether a context uses legacy or PSA.
// 
// Internal use only.
type mbedtls-md-engine-t
  MBEDTLS_MD_ENGINE_LEGACY
  MBEDTLS_MD_ENGINE_PSA

pub fun mbedtls-md-engine-t/int(i: mbedtls-md-engine-t): int32
  match i
    MBEDTLS_MD_ENGINE_LEGACY -> 0.int32
    MBEDTLS_MD_ENGINE_PSA -> 1.int32

pub fun int/mbedtls-md-engine-t(i: int32): exn mbedtls-md-engine-t
  match i.int
    0 -> MBEDTLS_MD_ENGINE_LEGACY
    1 -> MBEDTLS_MD_ENGINE_PSA

// The generic message-digest context.
pub value struct mbedtls-md-context-t
  // Information about the associated message digest.
  private-md-info: mbedtls-md-info-t-c
  // The digest-specific context (legacy) or the PSA operation.
  private-md-ctx: c-pointer<()>
  // The HMAC part of the context.
  private-hmac-ctx: c-pointer<()>

pub type mbedtls-md-context-t-c
pub alias mbedtls-md-context-tp = c-pointer<mbedtls-md-context-t-c>
pub alias mbedtls-md-context-tc = owned-c<mbedtls-md-context-t-c>
pub alias mbedtls-md-context-tcb<s::S> = borrowed-c<s,mbedtls-md-context-t-c>
pub alias mbedtls-md-context-tca = owned-c<c-array<mbedtls-md-context-t-c>>

pub extern mbedtls-md-context-t/size-of(c: c-null<mbedtls-md-context-t-c>): int32
  c inline "sizeof(struct mbedtls_md_context_t)"

pub fun mbedtls-md-context-tc(): mbedtls-md-context-tc
  malloc(?size-of=mbedtls-md-context-t/size-of)

pub fun mbedtls-md-context-tc-calloc(): mbedtls-md-context-tc
  malloc-c(?size-of=mbedtls-md-context-t/size-of)

pub fun mbedtls-md-context-tc-array(n: int): mbedtls-md-context-tca
  malloc(n.int32, ?size-of=mbedtls-md-context-t/size-of)

pub fun mbedtls-md-context-tc-array-calloc(n: int): mbedtls-md-context-tca
  malloc-c(n.int32, ?size-of=mbedtls-md-context-t/size-of)

pub inline extern mbedtls-md-context-t-ptrraw/private-md-info(s: intptr_t): c-pointer<mbedtls-md-info-t-c>
  c inline "(intptr_t)(((struct mbedtls_md_context_t*)#1)->private_md_info)"

pub inline fun mbedtls-md-context-tp/private-md-info(s: mbedtls-md-context-tp): <> c-pointer<mbedtls-md-info-t-c>
  s.cextern/c-pointer/ptr.mbedtls-md-context-t-ptrraw/private-md-info

pub inline fun mbedtls-md-context-tc/private-md-info(^s: mbedtls-md-context-tc): <> c-pointer<mbedtls-md-info-t-c>
  s.with-ptr(mbedtls-md-context-tp/private-md-info)

pub inline fun mbedtls-md-context-tcb/private-md-info(^s: mbedtls-md-context-tcb<s::S>): <> c-pointer<mbedtls-md-info-t-c>
  s.with-ptr(mbedtls-md-context-tp/private-md-info)

pub inline extern mbedtls-md-context-t-ptrraw/set-private-md-info(s: intptr_t, private-md-info: c-pointer<mbedtls-md-info-t-c>): ()
  c inline "((struct mbedtls_md_context_t*)#1)->private_md_info = (struct mbedtls_md_info_t*)#2"

pub inline fun mbedtls-md-context-tp/set-private-md-info(s: mbedtls-md-context-tp, private-md-info: c-pointer<mbedtls-md-info-t-c>): ()
  s.mbedtls-md-context-t-ptrraw/set-private-md-info(private-md-info)

pub inline fun mbedtls-md-context-tc/set-private-md-info(^s: mbedtls-md-context-tc, private-md-info: c-pointer<mbedtls-md-info-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md-context-tp/set-private-md-info(private-md-info))

pub inline fun mbedtls-md-context-tcb/set-private-md-info(^s: mbedtls-md-context-tcb<s::S>, private-md-info: c-pointer<mbedtls-md-info-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md-context-tp/set-private-md-info(private-md-info))

pub inline extern mbedtls-md-context-t-ptrraw/private-md-ctx(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_md_context_t*)#1)->private_md_ctx)"

pub inline fun mbedtls-md-context-tp/private-md-ctx(s: mbedtls-md-context-tp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-md-context-t-ptrraw/private-md-ctx

pub inline fun mbedtls-md-context-tc/private-md-ctx(^s: mbedtls-md-context-tc): <> c-pointer<()>
  s.with-ptr(mbedtls-md-context-tp/private-md-ctx)

pub inline fun mbedtls-md-context-tcb/private-md-ctx(^s: mbedtls-md-context-tcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-md-context-tp/private-md-ctx)

pub inline extern mbedtls-md-context-t-ptrraw/set-private-md-ctx(s: intptr_t, private-md-ctx: c-pointer<()>): ()
  c inline "((struct mbedtls_md_context_t*)#1)->private_md_ctx = (void*)#2"

pub inline fun mbedtls-md-context-tp/set-private-md-ctx(s: mbedtls-md-context-tp, private-md-ctx: c-pointer<()>): ()
  s.mbedtls-md-context-t-ptrraw/set-private-md-ctx(private-md-ctx)

pub inline fun mbedtls-md-context-tc/set-private-md-ctx(^s: mbedtls-md-context-tc, private-md-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md-context-tp/set-private-md-ctx(private-md-ctx))

pub inline fun mbedtls-md-context-tcb/set-private-md-ctx(^s: mbedtls-md-context-tcb<s::S>, private-md-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md-context-tp/set-private-md-ctx(private-md-ctx))

pub inline extern mbedtls-md-context-t-ptrraw/private-hmac-ctx(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_md_context_t*)#1)->private_hmac_ctx)"

pub inline fun mbedtls-md-context-tp/private-hmac-ctx(s: mbedtls-md-context-tp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-md-context-t-ptrraw/private-hmac-ctx

pub inline fun mbedtls-md-context-tc/private-hmac-ctx(^s: mbedtls-md-context-tc): <> c-pointer<()>
  s.with-ptr(mbedtls-md-context-tp/private-hmac-ctx)

pub inline fun mbedtls-md-context-tcb/private-hmac-ctx(^s: mbedtls-md-context-tcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-md-context-tp/private-hmac-ctx)

pub inline extern mbedtls-md-context-t-ptrraw/set-private-hmac-ctx(s: intptr_t, private-hmac-ctx: c-pointer<()>): ()
  c inline "((struct mbedtls_md_context_t*)#1)->private_hmac_ctx = (void*)#2"

pub inline fun mbedtls-md-context-tp/set-private-hmac-ctx(s: mbedtls-md-context-tp, private-hmac-ctx: c-pointer<()>): ()
  s.mbedtls-md-context-t-ptrraw/set-private-hmac-ctx(private-hmac-ctx)

pub inline fun mbedtls-md-context-tc/set-private-hmac-ctx(^s: mbedtls-md-context-tc, private-hmac-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md-context-tp/set-private-hmac-ctx(private-hmac-ctx))

pub inline fun mbedtls-md-context-tcb/set-private-hmac-ctx(^s: mbedtls-md-context-tcb<s::S>, private-hmac-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md-context-tp/set-private-hmac-ctx(private-hmac-ctx))

// \brief   The RSA context structure.
pub struct mbedtls-rsa-context
  // !<  Reserved for internal purposes.
  // Do not set this field in application
  // code. Its meaning might change without
  // notice.
  private-ver: int
  // !<  The size of \p N in Bytes.
  private-len: int
  // !<  The public modulus.
  private-n: mbedtls-mpi-c
  // !<  The public exponent.
  private-e: mbedtls-mpi-c
  // !<  The private exponent.
  private-d: mbedtls-mpi-c
  // !<  The first prime factor.
  private-p: mbedtls-mpi-c
  // !<  The second prime factor.
  private-q: mbedtls-mpi-c
  // !<  <code>D % (P - 1)</code>.
  private-dp: mbedtls-mpi-c
  // !<  <code>D % (Q - 1)</code>.
  private-dq: mbedtls-mpi-c
  // !<  <code>1 / (Q % P)</code>.
  private-qp: mbedtls-mpi-c
  // !<  cached <code>R^2 mod N</code>.
  private-rn: mbedtls-mpi-c
  // !<  cached <code>R^2 mod P</code>.
  private-rp: mbedtls-mpi-c
  // !<  cached <code>R^2 mod Q</code>.
  private-rq: mbedtls-mpi-c
  // !<  The cached blinding value.
  private-vi: mbedtls-mpi-c
  // !<  The cached un-blinding value.
  private-vf: mbedtls-mpi-c
  // !< Selects padding mode:
  // #MBEDTLS_RSA_PKCS_V15 for 1.5 padding and
  // #MBEDTLS_RSA_PKCS_V21 for OAEP or PSS.
  private-padding: int
  // !< Hash identifier of mbedtls_md_type_t type,
  // as specified in md.h for use in the MGF
  // mask generating function used in the
  // EME-OAEP and EMSA-PSS encodings.
  private-hash-id: int

pub type mbedtls-rsa-context-c
pub alias mbedtls-rsa-contextp = c-pointer<mbedtls-rsa-context-c>
pub alias mbedtls-rsa-contextc = owned-c<mbedtls-rsa-context-c>
pub alias mbedtls-rsa-contextcb<s::S> = borrowed-c<s,mbedtls-rsa-context-c>
pub alias mbedtls-rsa-contextca = owned-c<c-array<mbedtls-rsa-context-c>>

pub extern mbedtls-rsa-context/size-of(c: c-null<mbedtls-rsa-context-c>): int32
  c inline "sizeof(struct mbedtls_rsa_context)"

pub fun mbedtls-rsa-contextc(): mbedtls-rsa-contextc
  malloc(?size-of=mbedtls-rsa-context/size-of)

pub fun mbedtls-rsa-contextc-calloc(): mbedtls-rsa-contextc
  malloc-c(?size-of=mbedtls-rsa-context/size-of)

pub fun mbedtls-rsa-contextc-array(n: int): mbedtls-rsa-contextca
  malloc(n.int32, ?size-of=mbedtls-rsa-context/size-of)

pub fun mbedtls-rsa-contextc-array-calloc(n: int): mbedtls-rsa-contextca
  malloc-c(n.int32, ?size-of=mbedtls-rsa-context/size-of)

pub inline extern mbedtls-rsa-context-ptrraw/private-ver(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_rsa_context*)#1)->private_ver)"

pub inline fun mbedtls-rsa-contextp/private-ver(s: mbedtls-rsa-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-rsa-context-ptrraw/private-ver.int

pub inline fun mbedtls-rsa-contextc/private-ver(^s: mbedtls-rsa-contextc): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-ver)

pub inline fun mbedtls-rsa-contextcb/private-ver(^s: mbedtls-rsa-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-ver)

pub inline extern mbedtls-rsa-context-ptrraw/set-private-ver(s: intptr_t, private-ver: int32): ()
  c inline "((struct mbedtls_rsa_context*)#1)->private_ver = (int)#2"

pub inline fun mbedtls-rsa-contextp/set-private-ver(s: mbedtls-rsa-contextp, private-ver: int): ()
  s.mbedtls-rsa-context-ptrraw/set-private-ver(private-ver.int32)

pub inline fun mbedtls-rsa-contextc/set-private-ver(^s: mbedtls-rsa-contextc, private-ver: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-ver(private-ver))

pub inline fun mbedtls-rsa-contextcb/set-private-ver(^s: mbedtls-rsa-contextcb<s::S>, private-ver: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-ver(private-ver))

pub inline extern mbedtls-rsa-context-ptrraw/private-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_rsa_context*)#1)->private_len)"

pub inline fun mbedtls-rsa-contextp/private-len(s: mbedtls-rsa-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-rsa-context-ptrraw/private-len.int

pub inline fun mbedtls-rsa-contextc/private-len(^s: mbedtls-rsa-contextc): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-len)

pub inline fun mbedtls-rsa-contextcb/private-len(^s: mbedtls-rsa-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-len)

pub inline extern mbedtls-rsa-context-ptrraw/set-private-len(s: intptr_t, private-len: ssize_t): ()
  c inline "((struct mbedtls_rsa_context*)#1)->private_len = (size_t)#2"

pub inline fun mbedtls-rsa-contextp/set-private-len(s: mbedtls-rsa-contextp, private-len: int): ()
  s.mbedtls-rsa-context-ptrraw/set-private-len(private-len.ssize_t)

pub inline fun mbedtls-rsa-contextc/set-private-len(^s: mbedtls-rsa-contextc, private-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-len(private-len))

pub inline fun mbedtls-rsa-contextcb/set-private-len(^s: mbedtls-rsa-contextcb<s::S>, private-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-len(private-len))

pub inline extern mbedtls-rsa-context-ptrraw/private-padding(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_rsa_context*)#1)->private_padding)"

pub inline fun mbedtls-rsa-contextp/private-padding(s: mbedtls-rsa-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-rsa-context-ptrraw/private-padding.int

pub inline fun mbedtls-rsa-contextc/private-padding(^s: mbedtls-rsa-contextc): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-padding)

pub inline fun mbedtls-rsa-contextcb/private-padding(^s: mbedtls-rsa-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-padding)

pub inline extern mbedtls-rsa-context-ptrraw/set-private-padding(s: intptr_t, private-padding: int32): ()
  c inline "((struct mbedtls_rsa_context*)#1)->private_padding = (int)#2"

pub inline fun mbedtls-rsa-contextp/set-private-padding(s: mbedtls-rsa-contextp, private-padding: int): ()
  s.mbedtls-rsa-context-ptrraw/set-private-padding(private-padding.int32)

pub inline fun mbedtls-rsa-contextc/set-private-padding(^s: mbedtls-rsa-contextc, private-padding: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-padding(private-padding))

pub inline fun mbedtls-rsa-contextcb/set-private-padding(^s: mbedtls-rsa-contextcb<s::S>, private-padding: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-padding(private-padding))

pub inline extern mbedtls-rsa-context-ptrraw/private-hash-id(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_rsa_context*)#1)->private_hash_id)"

pub inline fun mbedtls-rsa-contextp/private-hash-id(s: mbedtls-rsa-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-rsa-context-ptrraw/private-hash-id.int

pub inline fun mbedtls-rsa-contextc/private-hash-id(^s: mbedtls-rsa-contextc): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-hash-id)

pub inline fun mbedtls-rsa-contextcb/private-hash-id(^s: mbedtls-rsa-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-rsa-contextp/private-hash-id)

pub inline extern mbedtls-rsa-context-ptrraw/set-private-hash-id(s: intptr_t, private-hash-id: int32): ()
  c inline "((struct mbedtls_rsa_context*)#1)->private_hash_id = (int)#2"

pub inline fun mbedtls-rsa-contextp/set-private-hash-id(s: mbedtls-rsa-contextp, private-hash-id: int): ()
  s.mbedtls-rsa-context-ptrraw/set-private-hash-id(private-hash-id.int32)

pub inline fun mbedtls-rsa-contextc/set-private-hash-id(^s: mbedtls-rsa-contextc, private-hash-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-hash-id(private-hash-id))

pub inline fun mbedtls-rsa-contextcb/set-private-hash-id(^s: mbedtls-rsa-contextcb<s::S>, private-hash-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-rsa-contextp/set-private-hash-id(private-hash-id))

// Domain-parameter identifiers: curve, subgroup, and generator.
// 
// \note Only curves over prime fields are supported.
// 
// \warning This library does not support validation of arbitrary domain
// parameters. Therefore, only standardized domain parameters from trusted
// sources should be used. See mbedtls_ecp_group_load().
type mbedtls-ecp-group-id
  // !< Curve not defined.
  MBEDTLS_ECP_DP_NONE
  // !< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1.
  MBEDTLS_ECP_DP_SECP192R1
  // !< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1.
  MBEDTLS_ECP_DP_SECP224R1
  // !< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1.
  MBEDTLS_ECP_DP_SECP256R1
  // !< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1.
  MBEDTLS_ECP_DP_SECP384R1
  // !< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1.
  MBEDTLS_ECP_DP_SECP521R1
  // !< Domain parameters for 256-bit Brainpool curve.
  MBEDTLS_ECP_DP_BP256R1
  // !< Domain parameters for 384-bit Brainpool curve.
  MBEDTLS_ECP_DP_BP384R1
  // !< Domain parameters for 512-bit Brainpool curve.
  MBEDTLS_ECP_DP_BP512R1
  // !< Domain parameters for Curve25519.
  MBEDTLS_ECP_DP_CURVE25519
  // !< Domain parameters for 192-bit "Koblitz" curve.
  MBEDTLS_ECP_DP_SECP192K1
  // !< Domain parameters for 224-bit "Koblitz" curve.
  MBEDTLS_ECP_DP_SECP224K1
  // !< Domain parameters for 256-bit "Koblitz" curve.
  MBEDTLS_ECP_DP_SECP256K1
  // !< Domain parameters for Curve448.
  MBEDTLS_ECP_DP_CURVE448

pub fun mbedtls-ecp-group-id/int(i: mbedtls-ecp-group-id): int32
  match i
    MBEDTLS_ECP_DP_NONE -> 0.int32
    MBEDTLS_ECP_DP_SECP192R1 -> 1.int32
    MBEDTLS_ECP_DP_SECP224R1 -> 2.int32
    MBEDTLS_ECP_DP_SECP256R1 -> 3.int32
    MBEDTLS_ECP_DP_SECP384R1 -> 4.int32
    MBEDTLS_ECP_DP_SECP521R1 -> 5.int32
    MBEDTLS_ECP_DP_BP256R1 -> 6.int32
    MBEDTLS_ECP_DP_BP384R1 -> 7.int32
    MBEDTLS_ECP_DP_BP512R1 -> 8.int32
    MBEDTLS_ECP_DP_CURVE25519 -> 9.int32
    MBEDTLS_ECP_DP_SECP192K1 -> 10.int32
    MBEDTLS_ECP_DP_SECP224K1 -> 11.int32
    MBEDTLS_ECP_DP_SECP256K1 -> 12.int32
    MBEDTLS_ECP_DP_CURVE448 -> 13.int32

pub fun int/mbedtls-ecp-group-id(i: int32): exn mbedtls-ecp-group-id
  match i.int
    0 -> MBEDTLS_ECP_DP_NONE
    1 -> MBEDTLS_ECP_DP_SECP192R1
    2 -> MBEDTLS_ECP_DP_SECP224R1
    3 -> MBEDTLS_ECP_DP_SECP256R1
    4 -> MBEDTLS_ECP_DP_SECP384R1
    5 -> MBEDTLS_ECP_DP_SECP521R1
    6 -> MBEDTLS_ECP_DP_BP256R1
    7 -> MBEDTLS_ECP_DP_BP384R1
    8 -> MBEDTLS_ECP_DP_BP512R1
    9 -> MBEDTLS_ECP_DP_CURVE25519
    10 -> MBEDTLS_ECP_DP_SECP192K1
    11 -> MBEDTLS_ECP_DP_SECP224K1
    12 -> MBEDTLS_ECP_DP_SECP256K1
    13 -> MBEDTLS_ECP_DP_CURVE448

type mbedtls-ecp-curve-type
  MBEDTLS_ECP_TYPE_NONE
  MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS
  MBEDTLS_ECP_TYPE_MONTGOMERY

pub fun mbedtls-ecp-curve-type/int(i: mbedtls-ecp-curve-type): int32
  match i
    MBEDTLS_ECP_TYPE_NONE -> 0.int32
    MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS -> 1.int32
    MBEDTLS_ECP_TYPE_MONTGOMERY -> 2.int32

pub fun int/mbedtls-ecp-curve-type(i: int32): exn mbedtls-ecp-curve-type
  match i.int
    0 -> MBEDTLS_ECP_TYPE_NONE
    1 -> MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS
    2 -> MBEDTLS_ECP_TYPE_MONTGOMERY

// Curve information, for use by other modules.
// 
// The fields of this structure are part of the public API and can be
// accessed directly by applications. Future versions of the library may
// add extra fields or reorder existing fields.
pub struct mbedtls-ecp-curve-info
  // !< An internal identifier.
  grp-id: int
  // !< The TLS NamedCurve identifier.
  tls-id: int
  // !< The curve size in bits.
  bit-size: int
  // !< A human-friendly name.
  name: c-pointer<int>

pub type mbedtls-ecp-curve-info-c
pub alias mbedtls-ecp-curve-infop = c-pointer<mbedtls-ecp-curve-info-c>
pub alias mbedtls-ecp-curve-infoc = owned-c<mbedtls-ecp-curve-info-c>
pub alias mbedtls-ecp-curve-infocb<s::S> = borrowed-c<s,mbedtls-ecp-curve-info-c>
pub alias mbedtls-ecp-curve-infoca = owned-c<c-array<mbedtls-ecp-curve-info-c>>

pub extern mbedtls-ecp-curve-info/size-of(c: c-null<mbedtls-ecp-curve-info-c>): int32
  c inline "sizeof(struct mbedtls_ecp_curve_info)"

pub fun mbedtls-ecp-curve-infoc(): mbedtls-ecp-curve-infoc
  malloc(?size-of=mbedtls-ecp-curve-info/size-of)

pub fun mbedtls-ecp-curve-infoc-calloc(): mbedtls-ecp-curve-infoc
  malloc-c(?size-of=mbedtls-ecp-curve-info/size-of)

pub fun mbedtls-ecp-curve-infoc-array(n: int): mbedtls-ecp-curve-infoca
  malloc(n.int32, ?size-of=mbedtls-ecp-curve-info/size-of)

pub fun mbedtls-ecp-curve-infoc-array-calloc(n: int): mbedtls-ecp-curve-infoca
  malloc-c(n.int32, ?size-of=mbedtls-ecp-curve-info/size-of)

pub inline extern mbedtls-ecp-curve-info-ptrraw/grp-id(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ecp_curve_info*)#1)->grp_id)"

pub inline fun mbedtls-ecp-curve-infop/grp-id(s: mbedtls-ecp-curve-infop): <exn> mbedtls-ecp-group-id
  s.cextern/c-pointer/ptr.mbedtls-ecp-curve-info-ptrraw/grp-id.int/mbedtls-ecp-group-id

pub inline fun mbedtls-ecp-curve-infoc/grp-id(^s: mbedtls-ecp-curve-infoc): <exn> mbedtls-ecp-group-id
  s.with-ptr(mbedtls-ecp-curve-infop/grp-id)

pub inline fun mbedtls-ecp-curve-infocb/grp-id(^s: mbedtls-ecp-curve-infocb<s::S>): <exn> mbedtls-ecp-group-id
  s.with-ptr(mbedtls-ecp-curve-infop/grp-id)

pub inline extern mbedtls-ecp-curve-info-ptrraw/set-grp-id(s: intptr_t, grp-id: int32): ()
  c inline "((struct mbedtls_ecp_curve_info*)#1)->grp_id = (int32_t)#2"

pub inline fun mbedtls-ecp-curve-infop/set-grp-id(s: mbedtls-ecp-curve-infop, grp-id: mbedtls-ecp-group-id): ()
  s.mbedtls-ecp-curve-info-ptrraw/set-grp-id(grp-id.mbedtls-ecp-group-id/int)

pub inline fun mbedtls-ecp-curve-infoc/set-grp-id(^s: mbedtls-ecp-curve-infoc, grp-id: mbedtls-ecp-group-id): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-grp-id(grp-id))

pub inline fun mbedtls-ecp-curve-infocb/set-grp-id(^s: mbedtls-ecp-curve-infocb<s::S>, grp-id: mbedtls-ecp-group-id): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-grp-id(grp-id))

pub inline extern mbedtls-ecp-curve-info-ptrraw/tls-id(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ecp_curve_info*)#1)->tls_id)"

pub inline fun mbedtls-ecp-curve-infop/tls-id(s: mbedtls-ecp-curve-infop): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecp-curve-info-ptrraw/tls-id.int

pub inline fun mbedtls-ecp-curve-infoc/tls-id(^s: mbedtls-ecp-curve-infoc): <> int
  s.with-ptr(mbedtls-ecp-curve-infop/tls-id)

pub inline fun mbedtls-ecp-curve-infocb/tls-id(^s: mbedtls-ecp-curve-infocb<s::S>): <> int
  s.with-ptr(mbedtls-ecp-curve-infop/tls-id)

pub inline extern mbedtls-ecp-curve-info-ptrraw/set-tls-id(s: intptr_t, tls-id: int16): ()
  c inline "((struct mbedtls_ecp_curve_info*)#1)->tls_id = (int16_t)#2"

pub inline fun mbedtls-ecp-curve-infop/set-tls-id(s: mbedtls-ecp-curve-infop, tls-id: int): ()
  s.mbedtls-ecp-curve-info-ptrraw/set-tls-id(tls-id.int16)

pub inline fun mbedtls-ecp-curve-infoc/set-tls-id(^s: mbedtls-ecp-curve-infoc, tls-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-tls-id(tls-id))

pub inline fun mbedtls-ecp-curve-infocb/set-tls-id(^s: mbedtls-ecp-curve-infocb<s::S>, tls-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-tls-id(tls-id))

pub inline extern mbedtls-ecp-curve-info-ptrraw/bit-size(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ecp_curve_info*)#1)->bit_size)"

pub inline fun mbedtls-ecp-curve-infop/bit-size(s: mbedtls-ecp-curve-infop): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecp-curve-info-ptrraw/bit-size.int

pub inline fun mbedtls-ecp-curve-infoc/bit-size(^s: mbedtls-ecp-curve-infoc): <> int
  s.with-ptr(mbedtls-ecp-curve-infop/bit-size)

pub inline fun mbedtls-ecp-curve-infocb/bit-size(^s: mbedtls-ecp-curve-infocb<s::S>): <> int
  s.with-ptr(mbedtls-ecp-curve-infop/bit-size)

pub inline extern mbedtls-ecp-curve-info-ptrraw/set-bit-size(s: intptr_t, bit-size: int16): ()
  c inline "((struct mbedtls_ecp_curve_info*)#1)->bit_size = (int16_t)#2"

pub inline fun mbedtls-ecp-curve-infop/set-bit-size(s: mbedtls-ecp-curve-infop, bit-size: int): ()
  s.mbedtls-ecp-curve-info-ptrraw/set-bit-size(bit-size.int16)

pub inline fun mbedtls-ecp-curve-infoc/set-bit-size(^s: mbedtls-ecp-curve-infoc, bit-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-bit-size(bit-size))

pub inline fun mbedtls-ecp-curve-infocb/set-bit-size(^s: mbedtls-ecp-curve-infocb<s::S>, bit-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-bit-size(bit-size))

pub inline extern mbedtls-ecp-curve-info-ptrraw/name(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ecp_curve_info*)#1)->name)"

pub inline fun mbedtls-ecp-curve-infop/name(s: mbedtls-ecp-curve-infop): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ecp-curve-info-ptrraw/name

pub inline fun mbedtls-ecp-curve-infoc/name(^s: mbedtls-ecp-curve-infoc): <> c-pointer<int>
  s.with-ptr(mbedtls-ecp-curve-infop/name)

pub inline fun mbedtls-ecp-curve-infocb/name(^s: mbedtls-ecp-curve-infocb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ecp-curve-infop/name)

pub inline extern mbedtls-ecp-curve-info-ptrraw/set-name(s: intptr_t, name: c-pointer<int>): ()
  c inline "((struct mbedtls_ecp_curve_info*)#1)->name = (char*)#2"

pub inline fun mbedtls-ecp-curve-infop/set-name(s: mbedtls-ecp-curve-infop, name: c-pointer<int>): ()
  s.mbedtls-ecp-curve-info-ptrraw/set-name(name)

pub inline fun mbedtls-ecp-curve-infoc/set-name(^s: mbedtls-ecp-curve-infoc, name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-name(name))

pub inline fun mbedtls-ecp-curve-infocb/set-name(^s: mbedtls-ecp-curve-infocb<s::S>, name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-curve-infop/set-name(name))

// \brief           The ECP point structure, in Jacobian coordinates.
// 
// \note            All functions expect and return points satisfying
// the following condition: <code>Z == 0</code> or
// <code>Z == 1</code>. Other values of \p Z are
// used only by internal functions.
// The point is zero, or "at infinity", if <code>Z == 0</code>.
// Otherwise, \p X and \p Y are its standard (affine)
// coordinates.
pub value struct mbedtls-ecp-point
  // !< The X coordinate of the ECP point.
  private-x: mbedtls-mpi-c
  // !< The Y coordinate of the ECP point.
  private-y: mbedtls-mpi-c
  // !< The Z coordinate of the ECP point.
  private-z: mbedtls-mpi-c

pub type mbedtls-ecp-point-c
pub alias mbedtls-ecp-pointp = c-pointer<mbedtls-ecp-point-c>
pub alias mbedtls-ecp-pointc = owned-c<mbedtls-ecp-point-c>
pub alias mbedtls-ecp-pointcb<s::S> = borrowed-c<s,mbedtls-ecp-point-c>
pub alias mbedtls-ecp-pointca = owned-c<c-array<mbedtls-ecp-point-c>>

pub extern mbedtls-ecp-point/size-of(c: c-null<mbedtls-ecp-point-c>): int32
  c inline "sizeof(struct mbedtls_ecp_point)"

pub fun mbedtls-ecp-pointc(): mbedtls-ecp-pointc
  malloc(?size-of=mbedtls-ecp-point/size-of)

pub fun mbedtls-ecp-pointc-calloc(): mbedtls-ecp-pointc
  malloc-c(?size-of=mbedtls-ecp-point/size-of)

pub fun mbedtls-ecp-pointc-array(n: int): mbedtls-ecp-pointca
  malloc(n.int32, ?size-of=mbedtls-ecp-point/size-of)

pub fun mbedtls-ecp-pointc-array-calloc(n: int): mbedtls-ecp-pointca
  malloc-c(n.int32, ?size-of=mbedtls-ecp-point/size-of)

// \brief           The ECP group structure.
// 
// We consider two types of curve equations:
// <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>
// (SEC1 + RFC-4492)</li>
// <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,
// Curve448)</li></ul>
// In both cases, the generator (\p G) for a prime-order subgroup is fixed.
// 
// For Short Weierstrass, this subgroup is the whole curve, and its
// cardinality is denoted by \p N. Our code requires that \p N is an
// odd prime as mbedtls_ecp_mul() requires an odd number, and
// mbedtls_ecdsa_sign() requires that it is prime for blinding purposes.
// 
// The default implementation only initializes \p A without setting it to the
// authentic value for curves with <code>A = -3</code>(SECP256R1, etc), in which
// case you need to load \p A by yourself when using domain parameters directly,
// for example:
// \code
// mbedtls_mpi_init(&A);
// mbedtls_ecp_group_init(&grp);
// CHECK_RETURN(mbedtls_ecp_group_load(&grp, grp_id));
// if (mbedtls_ecp_group_a_is_minus_3(&grp)) {
// CHECK_RETURN(mbedtls_mpi_sub_int(&A, &grp.P, 3));
// } else {
// CHECK_RETURN(mbedtls_mpi_copy(&A, &grp.A));
// }
// 
// do_something_with_a(&A);
// 
// cleanup:
// mbedtls_mpi_free(&A);
// mbedtls_ecp_group_free(&grp);
// \endcode
// 
// For Montgomery curves, we do not store \p A, but <code>(A + 2) / 4</code>,
// which is the quantity used in the formulas. Additionally, \p nbits is
// not the size of \p N but the required size for private keys.
// 
// If \p modp is NULL, reduction modulo \p P is done using a generic algorithm.
// Otherwise, \p modp must point to a function that takes an \p mbedtls_mpi in the
// range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer
// which is congruent mod \p P to the given MPI, and is close enough to \p pbits
// in size, so that it may be efficiently brought in the 0..P-1 range by a few
// additions or subtractions. Therefore, it is only an approximative modular
// reduction. It must return 0 on success and non-zero on failure.
// 
// \note        Alternative implementations of the ECP module must obey the
// following constraints.
// * Group IDs must be distinct: if two group structures have
// the same ID, then they must be identical.
// * The fields \c id, \c P, \c A, \c B, \c G, \c N,
// \c pbits and \c nbits must have the same type and semantics
// as in the built-in implementation.
// They must be available for reading, but direct modification
// of these fields does not need to be supported.
// They do not need to be at the same offset in the structure.
pub struct mbedtls-ecp-group
  // !< An internal group identifier.
  id: int
  // !< The prime modulus of the base field.
  p: mbedtls-mpi-c
  // !< For Short Weierstrass: \p A in the equation. Note that
  // \p A is not set to the authentic value in some cases.
  // Refer to detailed description of ::mbedtls_ecp_group if
  // using domain parameters in the structure.
  // For Montgomery curves: <code>(A + 2) / 4</code>.
  a: mbedtls-mpi-c
  // !< For Short Weierstrass: \p B in the equation.
  // For Montgomery curves: unused.
  b: mbedtls-mpi-c
  // !< The generator of the subgroup used.
  g: mbedtls-ecp-point-c
  // !< The order of \p G.
  n: mbedtls-mpi-c
  // !< The number of bits in \p P.
  pbits: int
  // !< For Short Weierstrass: The number of bits in \p P.
  // For Montgomery curves: the number of bits in the
  // private keys.
  nbits: int
  // !< \internal 1 if the constants are static.
  private-h: int
  // !< The function for fast pseudo-reduction
  // mod \p P (see above).
  private-modp: c-pointer<intptr_t>
  // !< Unused.
  private-t-pre: c-pointer<intptr_t>
  // !< Unused.
  private-t-post: c-pointer<intptr_t>
  // !< Unused.
  private-t-data: c-pointer<()>
  // !< Pre-computed points for ecp_mul_comb().
  private-t: mbedtls-ecp-point-c
  // !< The number of dynamic allocated pre-computed points.
  private-t-size: int

pub type mbedtls-ecp-group-c
pub alias mbedtls-ecp-groupp = c-pointer<mbedtls-ecp-group-c>
pub alias mbedtls-ecp-groupc = owned-c<mbedtls-ecp-group-c>
pub alias mbedtls-ecp-groupcb<s::S> = borrowed-c<s,mbedtls-ecp-group-c>
pub alias mbedtls-ecp-groupca = owned-c<c-array<mbedtls-ecp-group-c>>

pub extern mbedtls-ecp-group/size-of(c: c-null<mbedtls-ecp-group-c>): int32
  c inline "sizeof(struct mbedtls_ecp_group)"

pub fun mbedtls-ecp-groupc(): mbedtls-ecp-groupc
  malloc(?size-of=mbedtls-ecp-group/size-of)

pub fun mbedtls-ecp-groupc-calloc(): mbedtls-ecp-groupc
  malloc-c(?size-of=mbedtls-ecp-group/size-of)

pub fun mbedtls-ecp-groupc-array(n: int): mbedtls-ecp-groupca
  malloc(n.int32, ?size-of=mbedtls-ecp-group/size-of)

pub fun mbedtls-ecp-groupc-array-calloc(n: int): mbedtls-ecp-groupca
  malloc-c(n.int32, ?size-of=mbedtls-ecp-group/size-of)

pub inline extern mbedtls-ecp-group-ptrraw/id(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ecp_group*)#1)->id)"

pub inline fun mbedtls-ecp-groupp/id(s: mbedtls-ecp-groupp): <exn> mbedtls-ecp-group-id
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/id.int/mbedtls-ecp-group-id

pub inline fun mbedtls-ecp-groupc/id(^s: mbedtls-ecp-groupc): <exn> mbedtls-ecp-group-id
  s.with-ptr(mbedtls-ecp-groupp/id)

pub inline fun mbedtls-ecp-groupcb/id(^s: mbedtls-ecp-groupcb<s::S>): <exn> mbedtls-ecp-group-id
  s.with-ptr(mbedtls-ecp-groupp/id)

pub inline extern mbedtls-ecp-group-ptrraw/set-id(s: intptr_t, id: int32): ()
  c inline "((struct mbedtls_ecp_group*)#1)->id = (int32_t)#2"

pub inline fun mbedtls-ecp-groupp/set-id(s: mbedtls-ecp-groupp, id: mbedtls-ecp-group-id): ()
  s.mbedtls-ecp-group-ptrraw/set-id(id.mbedtls-ecp-group-id/int)

pub inline fun mbedtls-ecp-groupc/set-id(^s: mbedtls-ecp-groupc, id: mbedtls-ecp-group-id): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-id(id))

pub inline fun mbedtls-ecp-groupcb/set-id(^s: mbedtls-ecp-groupcb<s::S>, id: mbedtls-ecp-group-id): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-id(id))

pub inline extern mbedtls-ecp-group-ptrraw/pbits(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ecp_group*)#1)->pbits)"

pub inline fun mbedtls-ecp-groupp/pbits(s: mbedtls-ecp-groupp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/pbits.int

pub inline fun mbedtls-ecp-groupc/pbits(^s: mbedtls-ecp-groupc): <> int
  s.with-ptr(mbedtls-ecp-groupp/pbits)

pub inline fun mbedtls-ecp-groupcb/pbits(^s: mbedtls-ecp-groupcb<s::S>): <> int
  s.with-ptr(mbedtls-ecp-groupp/pbits)

pub inline extern mbedtls-ecp-group-ptrraw/set-pbits(s: intptr_t, pbits: ssize_t): ()
  c inline "((struct mbedtls_ecp_group*)#1)->pbits = (size_t)#2"

pub inline fun mbedtls-ecp-groupp/set-pbits(s: mbedtls-ecp-groupp, pbits: int): ()
  s.mbedtls-ecp-group-ptrraw/set-pbits(pbits.ssize_t)

pub inline fun mbedtls-ecp-groupc/set-pbits(^s: mbedtls-ecp-groupc, pbits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-pbits(pbits))

pub inline fun mbedtls-ecp-groupcb/set-pbits(^s: mbedtls-ecp-groupcb<s::S>, pbits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-pbits(pbits))

pub inline extern mbedtls-ecp-group-ptrraw/nbits(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ecp_group*)#1)->nbits)"

pub inline fun mbedtls-ecp-groupp/nbits(s: mbedtls-ecp-groupp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/nbits.int

pub inline fun mbedtls-ecp-groupc/nbits(^s: mbedtls-ecp-groupc): <> int
  s.with-ptr(mbedtls-ecp-groupp/nbits)

pub inline fun mbedtls-ecp-groupcb/nbits(^s: mbedtls-ecp-groupcb<s::S>): <> int
  s.with-ptr(mbedtls-ecp-groupp/nbits)

pub inline extern mbedtls-ecp-group-ptrraw/set-nbits(s: intptr_t, nbits: ssize_t): ()
  c inline "((struct mbedtls_ecp_group*)#1)->nbits = (size_t)#2"

pub inline fun mbedtls-ecp-groupp/set-nbits(s: mbedtls-ecp-groupp, nbits: int): ()
  s.mbedtls-ecp-group-ptrraw/set-nbits(nbits.ssize_t)

pub inline fun mbedtls-ecp-groupc/set-nbits(^s: mbedtls-ecp-groupc, nbits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-nbits(nbits))

pub inline fun mbedtls-ecp-groupcb/set-nbits(^s: mbedtls-ecp-groupcb<s::S>, nbits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-nbits(nbits))

pub inline extern mbedtls-ecp-group-ptrraw/private-h(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_ecp_group*)#1)->private_h)"

pub inline fun mbedtls-ecp-groupp/private-h(s: mbedtls-ecp-groupp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-h.int

pub inline fun mbedtls-ecp-groupc/private-h(^s: mbedtls-ecp-groupc): <> int
  s.with-ptr(mbedtls-ecp-groupp/private-h)

pub inline fun mbedtls-ecp-groupcb/private-h(^s: mbedtls-ecp-groupcb<s::S>): <> int
  s.with-ptr(mbedtls-ecp-groupp/private-h)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-h(s: intptr_t, private-h: int32): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_h = (unsigned int)#2"

pub inline fun mbedtls-ecp-groupp/set-private-h(s: mbedtls-ecp-groupp, private-h: int): ()
  s.mbedtls-ecp-group-ptrraw/set-private-h(private-h.int32)

pub inline fun mbedtls-ecp-groupc/set-private-h(^s: mbedtls-ecp-groupc, private-h: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-h(private-h))

pub inline fun mbedtls-ecp-groupcb/set-private-h(^s: mbedtls-ecp-groupcb<s::S>, private-h: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-h(private-h))

pub inline extern mbedtls-ecp-group-ptrraw/private-modp(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ecp_group*)#1)->private_modp)"

pub inline fun mbedtls-ecp-groupp/private-modp(s: mbedtls-ecp-groupp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-modp

pub inline fun mbedtls-ecp-groupc/private-modp(^s: mbedtls-ecp-groupc): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ecp-groupp/private-modp)

pub inline fun mbedtls-ecp-groupcb/private-modp(^s: mbedtls-ecp-groupcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ecp-groupp/private-modp)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-modp(s: intptr_t, private-modp: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_modp = (int (*)(struct mbedtls_mpi*))#2"

pub inline fun mbedtls-ecp-groupp/set-private-modp(s: mbedtls-ecp-groupp, private-modp: c-pointer<intptr_t>): ()
  s.mbedtls-ecp-group-ptrraw/set-private-modp(private-modp)

pub inline fun mbedtls-ecp-groupc/set-private-modp(^s: mbedtls-ecp-groupc, private-modp: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-modp(private-modp))

pub inline fun mbedtls-ecp-groupcb/set-private-modp(^s: mbedtls-ecp-groupcb<s::S>, private-modp: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-modp(private-modp))

pub inline extern mbedtls-ecp-group-ptrraw/private-t-pre(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ecp_group*)#1)->private_t_pre)"

pub inline fun mbedtls-ecp-groupp/private-t-pre(s: mbedtls-ecp-groupp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-t-pre

pub inline fun mbedtls-ecp-groupc/private-t-pre(^s: mbedtls-ecp-groupc): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ecp-groupp/private-t-pre)

pub inline fun mbedtls-ecp-groupcb/private-t-pre(^s: mbedtls-ecp-groupcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ecp-groupp/private-t-pre)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-t-pre(s: intptr_t, private-t-pre: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_t_pre = (int (*)(struct mbedtls_ecp_point*, void*))#2"

pub inline fun mbedtls-ecp-groupp/set-private-t-pre(s: mbedtls-ecp-groupp, private-t-pre: c-pointer<intptr_t>): ()
  s.mbedtls-ecp-group-ptrraw/set-private-t-pre(private-t-pre)

pub inline fun mbedtls-ecp-groupc/set-private-t-pre(^s: mbedtls-ecp-groupc, private-t-pre: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-pre(private-t-pre))

pub inline fun mbedtls-ecp-groupcb/set-private-t-pre(^s: mbedtls-ecp-groupcb<s::S>, private-t-pre: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-pre(private-t-pre))

pub inline extern mbedtls-ecp-group-ptrraw/private-t-post(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ecp_group*)#1)->private_t_post)"

pub inline fun mbedtls-ecp-groupp/private-t-post(s: mbedtls-ecp-groupp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-t-post

pub inline fun mbedtls-ecp-groupc/private-t-post(^s: mbedtls-ecp-groupc): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ecp-groupp/private-t-post)

pub inline fun mbedtls-ecp-groupcb/private-t-post(^s: mbedtls-ecp-groupcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ecp-groupp/private-t-post)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-t-post(s: intptr_t, private-t-post: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_t_post = (int (*)(struct mbedtls_ecp_point*, void*))#2"

pub inline fun mbedtls-ecp-groupp/set-private-t-post(s: mbedtls-ecp-groupp, private-t-post: c-pointer<intptr_t>): ()
  s.mbedtls-ecp-group-ptrraw/set-private-t-post(private-t-post)

pub inline fun mbedtls-ecp-groupc/set-private-t-post(^s: mbedtls-ecp-groupc, private-t-post: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-post(private-t-post))

pub inline fun mbedtls-ecp-groupcb/set-private-t-post(^s: mbedtls-ecp-groupcb<s::S>, private-t-post: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-post(private-t-post))

pub inline extern mbedtls-ecp-group-ptrraw/private-t-data(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ecp_group*)#1)->private_t_data)"

pub inline fun mbedtls-ecp-groupp/private-t-data(s: mbedtls-ecp-groupp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-t-data

pub inline fun mbedtls-ecp-groupc/private-t-data(^s: mbedtls-ecp-groupc): <> c-pointer<()>
  s.with-ptr(mbedtls-ecp-groupp/private-t-data)

pub inline fun mbedtls-ecp-groupcb/private-t-data(^s: mbedtls-ecp-groupcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ecp-groupp/private-t-data)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-t-data(s: intptr_t, private-t-data: c-pointer<()>): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_t_data = (void*)#2"

pub inline fun mbedtls-ecp-groupp/set-private-t-data(s: mbedtls-ecp-groupp, private-t-data: c-pointer<()>): ()
  s.mbedtls-ecp-group-ptrraw/set-private-t-data(private-t-data)

pub inline fun mbedtls-ecp-groupc/set-private-t-data(^s: mbedtls-ecp-groupc, private-t-data: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-data(private-t-data))

pub inline fun mbedtls-ecp-groupcb/set-private-t-data(^s: mbedtls-ecp-groupcb<s::S>, private-t-data: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-data(private-t-data))

pub inline extern mbedtls-ecp-group-ptrraw/private-t(s: intptr_t): c-pointer<mbedtls-ecp-point-c>
  c inline "(intptr_t)(((struct mbedtls_ecp_group*)#1)->private_T)"

pub inline fun mbedtls-ecp-groupp/private-t(s: mbedtls-ecp-groupp): <> c-pointer<mbedtls-ecp-point-c>
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-t

pub inline fun mbedtls-ecp-groupc/private-t(^s: mbedtls-ecp-groupc): <> c-pointer<mbedtls-ecp-point-c>
  s.with-ptr(mbedtls-ecp-groupp/private-t)

pub inline fun mbedtls-ecp-groupcb/private-t(^s: mbedtls-ecp-groupcb<s::S>): <> c-pointer<mbedtls-ecp-point-c>
  s.with-ptr(mbedtls-ecp-groupp/private-t)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-t(s: intptr_t, private-t: c-pointer<mbedtls-ecp-point-c>): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_T = (struct mbedtls_ecp_point*)#2"

pub inline fun mbedtls-ecp-groupp/set-private-t(s: mbedtls-ecp-groupp, private-t: c-pointer<mbedtls-ecp-point-c>): ()
  s.mbedtls-ecp-group-ptrraw/set-private-t(private-t)

pub inline fun mbedtls-ecp-groupc/set-private-t(^s: mbedtls-ecp-groupc, private-t: c-pointer<mbedtls-ecp-point-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t(private-t))

pub inline fun mbedtls-ecp-groupcb/set-private-t(^s: mbedtls-ecp-groupcb<s::S>, private-t: c-pointer<mbedtls-ecp-point-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t(private-t))

pub inline extern mbedtls-ecp-group-ptrraw/private-t-size(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ecp_group*)#1)->private_T_size)"

pub inline fun mbedtls-ecp-groupp/private-t-size(s: mbedtls-ecp-groupp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecp-group-ptrraw/private-t-size.int

pub inline fun mbedtls-ecp-groupc/private-t-size(^s: mbedtls-ecp-groupc): <> int
  s.with-ptr(mbedtls-ecp-groupp/private-t-size)

pub inline fun mbedtls-ecp-groupcb/private-t-size(^s: mbedtls-ecp-groupcb<s::S>): <> int
  s.with-ptr(mbedtls-ecp-groupp/private-t-size)

pub inline extern mbedtls-ecp-group-ptrraw/set-private-t-size(s: intptr_t, private-t-size: ssize_t): ()
  c inline "((struct mbedtls_ecp_group*)#1)->private_T_size = (size_t)#2"

pub inline fun mbedtls-ecp-groupp/set-private-t-size(s: mbedtls-ecp-groupp, private-t-size: int): ()
  s.mbedtls-ecp-group-ptrraw/set-private-t-size(private-t-size.ssize_t)

pub inline fun mbedtls-ecp-groupc/set-private-t-size(^s: mbedtls-ecp-groupc, private-t-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-size(private-t-size))

pub inline fun mbedtls-ecp-groupcb/set-private-t-size(^s: mbedtls-ecp-groupcb<s::S>, private-t-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecp-groupp/set-private-t-size(private-t-size))

// \brief    The ECP key-pair structure.
// 
// A generic key-pair that may be used for ECDSA and fixed ECDH, for example.
// 
// \note    Members are deliberately in the same order as in the
// ::mbedtls_ecdsa_context structure.
pub value struct mbedtls-ecp-keypair
  // !<  Elliptic curve and base point
  private-grp: mbedtls-ecp-group-c
  // !<  our secret value
  private-d: mbedtls-mpi-c
  // !<  our public value
  private-q: mbedtls-ecp-point-c

pub type mbedtls-ecp-keypair-c
pub alias mbedtls-ecp-keypairp = c-pointer<mbedtls-ecp-keypair-c>
pub alias mbedtls-ecp-keypairc = owned-c<mbedtls-ecp-keypair-c>
pub alias mbedtls-ecp-keypaircb<s::S> = borrowed-c<s,mbedtls-ecp-keypair-c>
pub alias mbedtls-ecp-keypairca = owned-c<c-array<mbedtls-ecp-keypair-c>>

pub extern mbedtls-ecp-keypair/size-of(c: c-null<mbedtls-ecp-keypair-c>): int32
  c inline "sizeof(struct mbedtls_ecp_keypair)"

pub fun mbedtls-ecp-keypairc(): mbedtls-ecp-keypairc
  malloc(?size-of=mbedtls-ecp-keypair/size-of)

pub fun mbedtls-ecp-keypairc-calloc(): mbedtls-ecp-keypairc
  malloc-c(?size-of=mbedtls-ecp-keypair/size-of)

pub fun mbedtls-ecp-keypairc-array(n: int): mbedtls-ecp-keypairca
  malloc(n.int32, ?size-of=mbedtls-ecp-keypair/size-of)

pub fun mbedtls-ecp-keypairc-array-calloc(n: int): mbedtls-ecp-keypairca
  malloc-c(n.int32, ?size-of=mbedtls-ecp-keypair/size-of)

alias mbedtls-ecp-restart-ctx = ()
alias mbedtls-ecdsa-restart-ctx = ()
// \brief           The ECDSA context structure.
// 
// \warning         Performing multiple operations concurrently on the same
// ECDSA context is not supported; objects of this type
// should not be shared between multiple threads.
// 
// \note            pk_wrap module assumes that "ecdsa_context" is identical
// to "ecp_keypair" (see for example structure
// "mbedtls_eckey_info" where ECDSA sign/verify functions
// are used also for EC key)
alias mbedtls-ecdsa-context = mbedtls-ecp-keypair-c
alias koka-mbedtls-ecdsa-context = mbedtls-ecp-keypair
pub struct psa-key-attributes-s
  private-type: int
  private-bits: int
  private-lifetime: int
  private-policy: koka-psa-key-policy-t
  private-id: int

pub type psa-key-attributes-s-c
pub alias psa-key-attributes-sp = c-pointer<psa-key-attributes-s-c>
pub alias psa-key-attributes-sc = owned-c<psa-key-attributes-s-c>
pub alias psa-key-attributes-scb<s::S> = borrowed-c<s,psa-key-attributes-s-c>
pub alias psa-key-attributes-sca = owned-c<c-array<psa-key-attributes-s-c>>

pub extern psa-key-attributes-s/size-of(c: c-null<psa-key-attributes-s-c>): int32
  c inline "sizeof(struct psa_key_attributes_s)"

pub fun psa-key-attributes-sc(): psa-key-attributes-sc
  malloc(?size-of=psa-key-attributes-s/size-of)

pub fun psa-key-attributes-sc-calloc(): psa-key-attributes-sc
  malloc-c(?size-of=psa-key-attributes-s/size-of)

pub fun psa-key-attributes-sc-array(n: int): psa-key-attributes-sca
  malloc(n.int32, ?size-of=psa-key-attributes-s/size-of)

pub fun psa-key-attributes-sc-array-calloc(n: int): psa-key-attributes-sca
  malloc-c(n.int32, ?size-of=psa-key-attributes-s/size-of)

pub inline extern psa-key-attributes-s-ptrraw/private-type(s: intptr_t): int16
  c inline "(psa_key_type_t)(((struct psa_key_attributes_s*)#1)->private_type)"

pub inline fun psa-key-attributes-sp/private-type(s: psa-key-attributes-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-attributes-s-ptrraw/private-type.int

pub inline fun psa-key-attributes-sc/private-type(^s: psa-key-attributes-sc): <> int
  s.with-ptr(psa-key-attributes-sp/private-type)

pub inline fun psa-key-attributes-scb/private-type(^s: psa-key-attributes-scb<s::S>): <> int
  s.with-ptr(psa-key-attributes-sp/private-type)

pub inline extern psa-key-attributes-s-ptrraw/set-private-type(s: intptr_t, private-type: int16): ()
  c inline "((struct psa_key_attributes_s*)#1)->private_type = (psa_key_type_t)#2"

pub inline fun psa-key-attributes-sp/set-private-type(s: psa-key-attributes-sp, private-type: int): ()
  s.psa-key-attributes-s-ptrraw/set-private-type(private-type.int16)

pub inline fun psa-key-attributes-sc/set-private-type(^s: psa-key-attributes-sc, private-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-type(private-type))

pub inline fun psa-key-attributes-scb/set-private-type(^s: psa-key-attributes-scb<s::S>, private-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-type(private-type))

pub inline extern psa-key-attributes-s-ptrraw/private-bits(s: intptr_t): int16
  c inline "(psa_key_bits_t)(((struct psa_key_attributes_s*)#1)->private_bits)"

pub inline fun psa-key-attributes-sp/private-bits(s: psa-key-attributes-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-attributes-s-ptrraw/private-bits.int

pub inline fun psa-key-attributes-sc/private-bits(^s: psa-key-attributes-sc): <> int
  s.with-ptr(psa-key-attributes-sp/private-bits)

pub inline fun psa-key-attributes-scb/private-bits(^s: psa-key-attributes-scb<s::S>): <> int
  s.with-ptr(psa-key-attributes-sp/private-bits)

pub inline extern psa-key-attributes-s-ptrraw/set-private-bits(s: intptr_t, private-bits: int16): ()
  c inline "((struct psa_key_attributes_s*)#1)->private_bits = (psa_key_bits_t)#2"

pub inline fun psa-key-attributes-sp/set-private-bits(s: psa-key-attributes-sp, private-bits: int): ()
  s.psa-key-attributes-s-ptrraw/set-private-bits(private-bits.int16)

pub inline fun psa-key-attributes-sc/set-private-bits(^s: psa-key-attributes-sc, private-bits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-bits(private-bits))

pub inline fun psa-key-attributes-scb/set-private-bits(^s: psa-key-attributes-scb<s::S>, private-bits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-bits(private-bits))

pub inline extern psa-key-attributes-s-ptrraw/private-lifetime(s: intptr_t): int32
  c inline "(psa_key_lifetime_t)(((struct psa_key_attributes_s*)#1)->private_lifetime)"

pub inline fun psa-key-attributes-sp/private-lifetime(s: psa-key-attributes-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-attributes-s-ptrraw/private-lifetime.int

pub inline fun psa-key-attributes-sc/private-lifetime(^s: psa-key-attributes-sc): <> int
  s.with-ptr(psa-key-attributes-sp/private-lifetime)

pub inline fun psa-key-attributes-scb/private-lifetime(^s: psa-key-attributes-scb<s::S>): <> int
  s.with-ptr(psa-key-attributes-sp/private-lifetime)

pub inline extern psa-key-attributes-s-ptrraw/set-private-lifetime(s: intptr_t, private-lifetime: int32): ()
  c inline "((struct psa_key_attributes_s*)#1)->private_lifetime = (psa_key_lifetime_t)#2"

pub inline fun psa-key-attributes-sp/set-private-lifetime(s: psa-key-attributes-sp, private-lifetime: int): ()
  s.psa-key-attributes-s-ptrraw/set-private-lifetime(private-lifetime.int32)

pub inline fun psa-key-attributes-sc/set-private-lifetime(^s: psa-key-attributes-sc, private-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-lifetime(private-lifetime))

pub inline fun psa-key-attributes-scb/set-private-lifetime(^s: psa-key-attributes-scb<s::S>, private-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-lifetime(private-lifetime))

pub inline extern psa-key-attributes-s-ptrraw/private-id(s: intptr_t): int32
  c inline "(mbedtls_svc_key_id_t)(((struct psa_key_attributes_s*)#1)->private_id)"

pub inline fun psa-key-attributes-sp/private-id(s: psa-key-attributes-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-attributes-s-ptrraw/private-id.int

pub inline fun psa-key-attributes-sc/private-id(^s: psa-key-attributes-sc): <> int
  s.with-ptr(psa-key-attributes-sp/private-id)

pub inline fun psa-key-attributes-scb/private-id(^s: psa-key-attributes-scb<s::S>): <> int
  s.with-ptr(psa-key-attributes-sp/private-id)

pub inline extern psa-key-attributes-s-ptrraw/set-private-id(s: intptr_t, private-id: int32): ()
  c inline "((struct psa_key_attributes_s*)#1)->private_id = (mbedtls_svc_key_id_t)#2"

pub inline fun psa-key-attributes-sp/set-private-id(s: psa-key-attributes-sp, private-id: int): ()
  s.psa-key-attributes-s-ptrraw/set-private-id(private-id.int32)

pub inline fun psa-key-attributes-sc/set-private-id(^s: psa-key-attributes-sc, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-id(private-id))

pub inline fun psa-key-attributes-scb/set-private-id(^s: psa-key-attributes-scb<s::S>, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-attributes-sp/set-private-id(private-id))

// \brief Encoding of a key type.
// 
// Values of this type are generally constructed by macros called
// `PSA_KEY_TYPE_xxx`.
// 
// \note Values of this type are encoded in the persistent key store.
// Any changes to existing values will require bumping the storage
// format version and providing a translation when reading the old
// format.
alias psa-key-type-t = int
alias psa-key-bits-t = int
// Encoding of key lifetimes.
// 
// The lifetime of a key indicates where it is stored and what system actions
// may create and destroy it.
// 
// Lifetime values have the following structure:
// - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\c lifetime)):
// persistence level. This value indicates what device management
// actions can cause it to be destroyed. In particular, it indicates
// whether the key is _volatile_ or _persistent_.
// See ::psa_key_persistence_t for more information.
// - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\c lifetime)):
// location indicator. This value indicates which part of the system
// has access to the key material and can perform operations using the key.
// See ::psa_key_location_t for more information.
// 
// Volatile keys are automatically destroyed when the application instance
// terminates or on a power reset of the device. Persistent keys are
// preserved until the application explicitly destroys them or until an
// integration-specific device management event occurs (for example,
// a factory reset).
// 
// Persistent keys have a key identifier of type #mbedtls_svc_key_id_t.
// This identifier remains valid throughout the lifetime of the key,
// even if the application instance that created the key terminates.
// The application can call psa_open_key() to open a persistent key that
// it created previously.
// 
// The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime
// #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is
// available. Other lifetime values may be supported depending on the
// library configuration.
// 
// Values of this type are generally constructed by macros called
// `PSA_KEY_LIFETIME_xxx`.
// 
// \note Values of this type are encoded in the persistent key store.
// Any changes to existing values will require bumping the storage
// format version and providing a translation when reading the old
// format.
alias psa-key-lifetime-t = int
alias psa-key-policy-t = psa-key-policy-s-c
alias koka-psa-key-policy-t = psa-key-policy-s
pub value struct psa-key-policy-s
  private-usage: int
  private-alg: int
  private-alg2: int

pub type psa-key-policy-s-c
pub alias psa-key-policy-sp = c-pointer<psa-key-policy-s-c>
pub alias psa-key-policy-sc = owned-c<psa-key-policy-s-c>
pub alias psa-key-policy-scb<s::S> = borrowed-c<s,psa-key-policy-s-c>
pub alias psa-key-policy-sca = owned-c<c-array<psa-key-policy-s-c>>

pub extern psa-key-policy-s/size-of(c: c-null<psa-key-policy-s-c>): int32
  c inline "sizeof(struct psa_key_policy_s)"

pub fun psa-key-policy-sc(): psa-key-policy-sc
  malloc(?size-of=psa-key-policy-s/size-of)

pub fun psa-key-policy-sc-calloc(): psa-key-policy-sc
  malloc-c(?size-of=psa-key-policy-s/size-of)

pub fun psa-key-policy-sc-array(n: int): psa-key-policy-sca
  malloc(n.int32, ?size-of=psa-key-policy-s/size-of)

pub fun psa-key-policy-sc-array-calloc(n: int): psa-key-policy-sca
  malloc-c(n.int32, ?size-of=psa-key-policy-s/size-of)

pub inline extern psa-key-policy-s-ptrraw/private-usage(s: intptr_t): int32
  c inline "(psa_key_usage_t)(((struct psa_key_policy_s*)#1)->private_usage)"

pub inline fun psa-key-policy-sp/private-usage(s: psa-key-policy-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-policy-s-ptrraw/private-usage.int

pub inline fun psa-key-policy-sc/private-usage(^s: psa-key-policy-sc): <> int
  s.with-ptr(psa-key-policy-sp/private-usage)

pub inline fun psa-key-policy-scb/private-usage(^s: psa-key-policy-scb<s::S>): <> int
  s.with-ptr(psa-key-policy-sp/private-usage)

pub inline extern psa-key-policy-s-ptrraw/set-private-usage(s: intptr_t, private-usage: int32): ()
  c inline "((struct psa_key_policy_s*)#1)->private_usage = (psa_key_usage_t)#2"

pub inline fun psa-key-policy-sp/set-private-usage(s: psa-key-policy-sp, private-usage: int): ()
  s.psa-key-policy-s-ptrraw/set-private-usage(private-usage.int32)

pub inline fun psa-key-policy-sc/set-private-usage(^s: psa-key-policy-sc, private-usage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-policy-sp/set-private-usage(private-usage))

pub inline fun psa-key-policy-scb/set-private-usage(^s: psa-key-policy-scb<s::S>, private-usage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-policy-sp/set-private-usage(private-usage))

pub inline extern psa-key-policy-s-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((struct psa_key_policy_s*)#1)->private_alg)"

pub inline fun psa-key-policy-sp/private-alg(s: psa-key-policy-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-policy-s-ptrraw/private-alg.int

pub inline fun psa-key-policy-sc/private-alg(^s: psa-key-policy-sc): <> int
  s.with-ptr(psa-key-policy-sp/private-alg)

pub inline fun psa-key-policy-scb/private-alg(^s: psa-key-policy-scb<s::S>): <> int
  s.with-ptr(psa-key-policy-sp/private-alg)

pub inline extern psa-key-policy-s-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((struct psa_key_policy_s*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun psa-key-policy-sp/set-private-alg(s: psa-key-policy-sp, private-alg: int): ()
  s.psa-key-policy-s-ptrraw/set-private-alg(private-alg.int32)

pub inline fun psa-key-policy-sc/set-private-alg(^s: psa-key-policy-sc, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-policy-sp/set-private-alg(private-alg))

pub inline fun psa-key-policy-scb/set-private-alg(^s: psa-key-policy-scb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-policy-sp/set-private-alg(private-alg))

pub inline extern psa-key-policy-s-ptrraw/private-alg2(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((struct psa_key_policy_s*)#1)->private_alg2)"

pub inline fun psa-key-policy-sp/private-alg2(s: psa-key-policy-sp): <> int
  s.cextern/c-pointer/ptr.psa-key-policy-s-ptrraw/private-alg2.int

pub inline fun psa-key-policy-sc/private-alg2(^s: psa-key-policy-sc): <> int
  s.with-ptr(psa-key-policy-sp/private-alg2)

pub inline fun psa-key-policy-scb/private-alg2(^s: psa-key-policy-scb<s::S>): <> int
  s.with-ptr(psa-key-policy-sp/private-alg2)

pub inline extern psa-key-policy-s-ptrraw/set-private-alg2(s: intptr_t, private-alg2: int32): ()
  c inline "((struct psa_key_policy_s*)#1)->private_alg2 = (psa_algorithm_t)#2"

pub inline fun psa-key-policy-sp/set-private-alg2(s: psa-key-policy-sp, private-alg2: int): ()
  s.psa-key-policy-s-ptrraw/set-private-alg2(private-alg2.int32)

pub inline fun psa-key-policy-sc/set-private-alg2(^s: psa-key-policy-sc, private-alg2: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-policy-sp/set-private-alg2(private-alg2))

pub inline fun psa-key-policy-scb/set-private-alg2(^s: psa-key-policy-scb<s::S>, private-alg2: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-key-policy-sp/set-private-alg2(private-alg2))

// \brief Encoding of permitted usage on a key.
// 
// Values of this type are generally constructed as bitwise-ors of macros
// called `PSA_KEY_USAGE_xxx`.
// 
// \note Values of this type are encoded in the persistent key store.
// Any changes to existing values will require bumping the storage
// format version and providing a translation when reading the old
// format.
alias psa-key-usage-t = int
// \brief Encoding of a cryptographic algorithm.
// 
// Values of this type are generally constructed by macros called
// `PSA_ALG_xxx`.
// 
// For algorithms that can be applied to multiple key types, this type
// does not encode the key type. For example, for symmetric ciphers
// based on a block cipher, #psa_algorithm_t encodes the block cipher
// mode and the padding mode while the block cipher itself is encoded
// via #psa_key_type_t.
// 
// \note Values of this type are encoded in the persistent key store.
// Any changes to existing values will require bumping the storage
// format version and providing a translation when reading the old
// format.
alias psa-algorithm-t = int
alias mbedtls-svc-key-id-t = int
// Encoding of identifiers of persistent keys.
// 
// - Applications may freely choose key identifiers in the range
// #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX.
// - The implementation may define additional key identifiers in the range
// #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX.
// - 0 is reserved as an invalid key identifier.
// - Key identifiers outside these ranges are reserved for future use.
// 
// \note Values of this type are encoded in the persistent key store.
// Any changes to how values are allocated must require careful
// consideration to allow backward compatibility.
alias psa-key-id-t = int
pub struct psa-key-production-parameters-s
pub type psa-key-production-parameters-s-c
pub alias psa-key-production-parameters-sp = c-pointer<psa-key-production-parameters-s-c>
pub alias psa-key-production-parameters-sc = owned-c<psa-key-production-parameters-s-c>
pub alias psa-key-production-parameters-scb<s::S> = borrowed-c<s,psa-key-production-parameters-s-c>
pub alias psa-key-production-parameters-sca = owned-c<c-array<psa-key-production-parameters-s-c>>

alias psa-status-t = int
// The type of a structure containing key attributes.
// 
// This is an opaque structure that can represent the metadata of a key
// object. Metadata that can be stored in attributes includes:
// - The location of the key in storage, indicated by its key identifier
// and its lifetime.
// - The key's policy, comprising usage flags and a specification of
// the permitted algorithm(s).
// - Information about the key itself: the key type and its size.
// - Additional implementation-defined attributes.
// 
// The actual key material is not considered an attribute of a key.
// Key attributes do not contain information that is generally considered
// highly confidential.
// 
// An attribute structure works like a simple data structure where each function
// `psa_set_key_xxx` sets a field and the corresponding function
// `psa_get_key_xxx` retrieves the value of the corresponding field.
// However, a future version of the library  may report values that are
// equivalent to the original one, but have a different encoding. Invalid
// values may be mapped to different, also invalid values.
// 
// An attribute structure may contain references to auxiliary resources,
// for example pointers to allocated memory or indirect references to
// pre-calculated values. In order to free such resources, the application
// must call psa_reset_key_attributes(). As an exception, calling
// psa_reset_key_attributes() on an attribute structure is optional if
// the structure has only been modified by the following functions
// since it was initialized or last reset with psa_reset_key_attributes():
// - psa_set_key_id()
// - psa_set_key_lifetime()
// - psa_set_key_type()
// - psa_set_key_bits()
// - psa_set_key_usage_flags()
// - psa_set_key_algorithm()
// 
// Before calling any function on a key attribute structure, the application
// must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_key_attributes_t attributes;
// memset(&attributes, 0, sizeof(attributes));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_key_attributes_t attributes = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,
// for example:
// \code
// psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
// \endcode
// - Assign the result of the function psa_key_attributes_init()
// to the structure, for example:
// \code
// psa_key_attributes_t attributes;
// attributes = psa_key_attributes_init();
// \endcode
// 
// A freshly initialized attribute structure contains the following
// values:
// 
// - lifetime: #PSA_KEY_LIFETIME_VOLATILE.
// - key identifier: 0 (which is not a valid key identifier).
// - type: \c 0 (meaning that the type is unspecified).
// - key size: \c 0 (meaning that the size is unspecified).
// - usage flags: \c 0 (which allows no usage except exporting a public key).
// - algorithm: \c 0 (which allows no cryptographic usage, but allows
// exporting).
// 
// A typical sequence to create a key is as follows:
// -# Create and initialize an attribute structure.
// -# If the key is persistent, call psa_set_key_id().
// Also call psa_set_key_lifetime() to place the key in a non-default
// location.
// -# Set the key policy with psa_set_key_usage_flags() and
// psa_set_key_algorithm().
// -# Set the key type with psa_set_key_type().
// Skip this step if copying an existing key with psa_copy_key().
// -# When generating a random key with psa_generate_key() or deriving a key
// with psa_key_derivation_output_key(), set the desired key size with
// psa_set_key_bits().
// -# Call a key creation function: psa_import_key(), psa_generate_key(),
// psa_key_derivation_output_key() or psa_copy_key(). This function reads
// the attribute structure, creates a key with these attributes, and
// outputs a key identifier to the newly created key.
// -# The attribute structure is now no longer necessary.
// You may call psa_reset_key_attributes(), although this is optional
// with the workflow presented here because the attributes currently
// defined in this specification do not require any additional resources
// beyond the structure itself.
// 
// A typical sequence to query a key's attributes is as follows:
// -# Call psa_get_key_attributes().
// -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that
// you are interested in.
// -# Call psa_reset_key_attributes() to free any resources that may be
// used by the attribute structure.
// 
// Once a key has been created, it is impossible to change its attributes.
alias psa-key-attributes-t = psa-key-attributes-s-c
alias koka-psa-key-attributes-t = psa-key-attributes-s
pub value struct psa-hash-operation-s
  // Unique ID indicating which driver got assigned to do the
  // operation. Since driver contexts are driver-specific, swapping
  // drivers halfway through the operation is not supported.
  // ID values are auto-generated in psa_driver_wrappers.h.
  // ID value zero means the context is not valid or not assigned to
  // any driver (i.e. the driver context is not active, in use).
  private-id: int
  private-ctx: psa-driver-hash-context-t-c

pub type psa-hash-operation-s-c
pub alias psa-hash-operation-sp = c-pointer<psa-hash-operation-s-c>
pub alias psa-hash-operation-sc = owned-c<psa-hash-operation-s-c>
pub alias psa-hash-operation-scb<s::S> = borrowed-c<s,psa-hash-operation-s-c>
pub alias psa-hash-operation-sca = owned-c<c-array<psa-hash-operation-s-c>>

pub extern psa-hash-operation-s/size-of(c: c-null<psa-hash-operation-s-c>): int32
  c inline "sizeof(struct psa_hash_operation_s)"

pub fun psa-hash-operation-sc(): psa-hash-operation-sc
  malloc(?size-of=psa-hash-operation-s/size-of)

pub fun psa-hash-operation-sc-calloc(): psa-hash-operation-sc
  malloc-c(?size-of=psa-hash-operation-s/size-of)

pub fun psa-hash-operation-sc-array(n: int): psa-hash-operation-sca
  malloc(n.int32, ?size-of=psa-hash-operation-s/size-of)

pub fun psa-hash-operation-sc-array-calloc(n: int): psa-hash-operation-sca
  malloc-c(n.int32, ?size-of=psa-hash-operation-s/size-of)

pub inline extern psa-hash-operation-s-ptrraw/private-id(s: intptr_t): int32
  c inline "(unsigned int)(((struct psa_hash_operation_s*)#1)->private_id)"

pub inline fun psa-hash-operation-sp/private-id(s: psa-hash-operation-sp): <> int
  s.cextern/c-pointer/ptr.psa-hash-operation-s-ptrraw/private-id.int

pub inline fun psa-hash-operation-sc/private-id(^s: psa-hash-operation-sc): <> int
  s.with-ptr(psa-hash-operation-sp/private-id)

pub inline fun psa-hash-operation-scb/private-id(^s: psa-hash-operation-scb<s::S>): <> int
  s.with-ptr(psa-hash-operation-sp/private-id)

pub inline extern psa-hash-operation-s-ptrraw/set-private-id(s: intptr_t, private-id: int32): ()
  c inline "((struct psa_hash_operation_s*)#1)->private_id = (unsigned int)#2"

pub inline fun psa-hash-operation-sp/set-private-id(s: psa-hash-operation-sp, private-id: int): ()
  s.psa-hash-operation-s-ptrraw/set-private-id(private-id.int32)

pub inline fun psa-hash-operation-sc/set-private-id(^s: psa-hash-operation-sc, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-hash-operation-sp/set-private-id(private-id))

pub inline fun psa-hash-operation-scb/set-private-id(^s: psa-hash-operation-scb<s::S>, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-hash-operation-sp/set-private-id(private-id))

pub struct psa-driver-hash-context-t
pub type psa-driver-hash-context-t-c
pub alias psa-driver-hash-context-tp = c-pointer<psa-driver-hash-context-t-c>
pub alias psa-driver-hash-context-tc = owned-c<psa-driver-hash-context-t-c>
pub alias psa-driver-hash-context-tcb<s::S> = borrowed-c<s,psa-driver-hash-context-t-c>
pub alias psa-driver-hash-context-tca = owned-c<c-array<psa-driver-hash-context-t-c>>

pub value struct mbedtls-psa-hash-operation-t
  private-alg: int
  private-ctx: unnamed-union1-c

pub type mbedtls-psa-hash-operation-t-c
pub alias mbedtls-psa-hash-operation-tp = c-pointer<mbedtls-psa-hash-operation-t-c>
pub alias mbedtls-psa-hash-operation-tc = owned-c<mbedtls-psa-hash-operation-t-c>
pub alias mbedtls-psa-hash-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-hash-operation-t-c>
pub alias mbedtls-psa-hash-operation-tca = owned-c<c-array<mbedtls-psa-hash-operation-t-c>>

pub extern mbedtls-psa-hash-operation-t/size-of(c: c-null<mbedtls-psa-hash-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_hash_operation_t)"

pub fun mbedtls-psa-hash-operation-tc(): mbedtls-psa-hash-operation-tc
  malloc(?size-of=mbedtls-psa-hash-operation-t/size-of)

pub fun mbedtls-psa-hash-operation-tc-calloc(): mbedtls-psa-hash-operation-tc
  malloc-c(?size-of=mbedtls-psa-hash-operation-t/size-of)

pub fun mbedtls-psa-hash-operation-tc-array(n: int): mbedtls-psa-hash-operation-tca
  malloc(n.int32, ?size-of=mbedtls-psa-hash-operation-t/size-of)

pub fun mbedtls-psa-hash-operation-tc-array-calloc(n: int): mbedtls-psa-hash-operation-tca
  malloc-c(n.int32, ?size-of=mbedtls-psa-hash-operation-t/size-of)

pub inline extern mbedtls-psa-hash-operation-t-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((mbedtls_psa_hash_operation_t*)#1)->private_alg)"

pub inline fun mbedtls-psa-hash-operation-tp/private-alg(s: mbedtls-psa-hash-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-hash-operation-t-ptrraw/private-alg.int

pub inline fun mbedtls-psa-hash-operation-tc/private-alg(^s: mbedtls-psa-hash-operation-tc): <> int
  s.with-ptr(mbedtls-psa-hash-operation-tp/private-alg)

pub inline fun mbedtls-psa-hash-operation-tcb/private-alg(^s: mbedtls-psa-hash-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-hash-operation-tp/private-alg)

pub inline extern mbedtls-psa-hash-operation-t-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((mbedtls_psa_hash_operation_t*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun mbedtls-psa-hash-operation-tp/set-private-alg(s: mbedtls-psa-hash-operation-tp, private-alg: int): ()
  s.mbedtls-psa-hash-operation-t-ptrraw/set-private-alg(private-alg.int32)

pub inline fun mbedtls-psa-hash-operation-tc/set-private-alg(^s: mbedtls-psa-hash-operation-tc, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-hash-operation-tp/set-private-alg(private-alg))

pub inline fun mbedtls-psa-hash-operation-tcb/set-private-alg(^s: mbedtls-psa-hash-operation-tcb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-hash-operation-tp/set-private-alg(private-alg))

pub struct unnamed-union1
pub type unnamed-union1-c
pub alias unnamed-union1p = c-pointer<unnamed-union1-c>
pub alias unnamed-union1c = owned-c<unnamed-union1-c>
pub alias unnamed-union1cb<s::S> = borrowed-c<s,unnamed-union1-c>
pub alias unnamed-union1ca = owned-c<c-array<unnamed-union1-c>>

// \brief          MD5 context structure
// 
// \warning        MD5 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub struct mbedtls-md5-context
pub type mbedtls-md5-context-c
pub alias mbedtls-md5-contextp = c-pointer<mbedtls-md5-context-c>
pub alias mbedtls-md5-contextc<s::S> = owned-c<mbedtls-md5-context-c>
pub alias mbedtls-md5-contextcb<s::S> = borrowed-c<s,mbedtls-md5-context-c>
pub alias mbedtls-md5-contextca<s::S> = owned-c<c-array<mbedtls-md5-context-c>>

pub extern mbedtls-md5-context/size-of(c: c-null<mbedtls-md5-context-c>): int32
  c inline "sizeof(struct mbedtls_md5_context)"

pub fun mbedtls-md5-contextc(): mbedtls-md5-contextc<s::S>
  malloc(?size-of=mbedtls-md5-context/size-of)

pub fun mbedtls-md5-contextc-calloc(): mbedtls-md5-contextc<s::S>
  malloc-c(?size-of=mbedtls-md5-context/size-of)

pub fun mbedtls-md5-contextc-array(n: int): mbedtls-md5-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-md5-context/size-of)

pub fun mbedtls-md5-contextc-array-calloc(n: int): mbedtls-md5-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-md5-context/size-of)

pub inline extern mbedtls-md5-context-ptrraw/private-total(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_md5_context*)#1)->private_total)"

pub inline fun mbedtls-md5-contextp/private-total(s: mbedtls-md5-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-md5-context-ptrraw/private-total.cextern/ptr/carray

pub inline fun mbedtls-md5-contextc/private-total(^s: mbedtls-md5-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-md5-contextp/private-total)

pub inline fun mbedtls-md5-contextcb/private-total(^s: mbedtls-md5-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-md5-contextp/private-total)

pub inline extern mbedtls-md5-context-ptrraw/set-private-total(s: intptr_t, private-total: c-pointer<int>): ()
  c inline "((struct mbedtls_md5_context*)#1)->private_total = (int32_t*)#2"

pub inline fun mbedtls-md5-contextp/set-private-total(s: mbedtls-md5-contextp, private-total: c-array<int>): ()
  s.mbedtls-md5-context-ptrraw/set-private-total(private-total.cextern/carray/ptr)

pub inline fun mbedtls-md5-contextc/set-private-total(^s: mbedtls-md5-contextc<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md5-contextp/set-private-total(private-total))

pub inline fun mbedtls-md5-contextcb/set-private-total(^s: mbedtls-md5-contextcb<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md5-contextp/set-private-total(private-total))

pub inline extern mbedtls-md5-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_md5_context*)#1)->private_state)"

pub inline fun mbedtls-md5-contextp/private-state(s: mbedtls-md5-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-md5-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-md5-contextc/private-state(^s: mbedtls-md5-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-md5-contextp/private-state)

pub inline fun mbedtls-md5-contextcb/private-state(^s: mbedtls-md5-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-md5-contextp/private-state)

pub inline extern mbedtls-md5-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_md5_context*)#1)->private_state = (int32_t*)#2"

pub inline fun mbedtls-md5-contextp/set-private-state(s: mbedtls-md5-contextp, private-state: c-array<int>): ()
  s.mbedtls-md5-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-md5-contextc/set-private-state(^s: mbedtls-md5-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md5-contextp/set-private-state(private-state))

pub inline fun mbedtls-md5-contextcb/set-private-state(^s: mbedtls-md5-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md5-contextp/set-private-state(private-state))

pub inline extern mbedtls-md5-context-ptrraw/private-buffer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_md5_context*)#1)->private_buffer)"

pub inline fun mbedtls-md5-contextp/private-buffer(s: mbedtls-md5-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-md5-context-ptrraw/private-buffer.cextern/ptr/carray

pub inline fun mbedtls-md5-contextc/private-buffer(^s: mbedtls-md5-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-md5-contextp/private-buffer)

pub inline fun mbedtls-md5-contextcb/private-buffer(^s: mbedtls-md5-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-md5-contextp/private-buffer)

pub inline extern mbedtls-md5-context-ptrraw/set-private-buffer(s: intptr_t, private-buffer: c-pointer<int>): ()
  c inline "((struct mbedtls_md5_context*)#1)->private_buffer = (unsigned char*)#2"

pub inline fun mbedtls-md5-contextp/set-private-buffer(s: mbedtls-md5-contextp, private-buffer: c-array<int>): ()
  s.mbedtls-md5-context-ptrraw/set-private-buffer(private-buffer.cextern/carray/ptr)

pub inline fun mbedtls-md5-contextc/set-private-buffer(^s: mbedtls-md5-contextc<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md5-contextp/set-private-buffer(private-buffer))

pub inline fun mbedtls-md5-contextcb/set-private-buffer(^s: mbedtls-md5-contextcb<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-md5-contextp/set-private-buffer(private-buffer))

// \brief          RIPEMD-160 context structure
pub struct mbedtls-ripemd160-context
pub type mbedtls-ripemd160-context-c
pub alias mbedtls-ripemd160-contextp = c-pointer<mbedtls-ripemd160-context-c>
pub alias mbedtls-ripemd160-contextc<s::S> = owned-c<mbedtls-ripemd160-context-c>
pub alias mbedtls-ripemd160-contextcb<s::S> = borrowed-c<s,mbedtls-ripemd160-context-c>
pub alias mbedtls-ripemd160-contextca<s::S> = owned-c<c-array<mbedtls-ripemd160-context-c>>

pub extern mbedtls-ripemd160-context/size-of(c: c-null<mbedtls-ripemd160-context-c>): int32
  c inline "sizeof(struct mbedtls_ripemd160_context)"

pub fun mbedtls-ripemd160-contextc(): mbedtls-ripemd160-contextc<s::S>
  malloc(?size-of=mbedtls-ripemd160-context/size-of)

pub fun mbedtls-ripemd160-contextc-calloc(): mbedtls-ripemd160-contextc<s::S>
  malloc-c(?size-of=mbedtls-ripemd160-context/size-of)

pub fun mbedtls-ripemd160-contextc-array(n: int): mbedtls-ripemd160-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ripemd160-context/size-of)

pub fun mbedtls-ripemd160-contextc-array-calloc(n: int): mbedtls-ripemd160-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ripemd160-context/size-of)

pub inline extern mbedtls-ripemd160-context-ptrraw/private-total(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ripemd160_context*)#1)->private_total)"

pub inline fun mbedtls-ripemd160-contextp/private-total(s: mbedtls-ripemd160-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ripemd160-context-ptrraw/private-total.cextern/ptr/carray

pub inline fun mbedtls-ripemd160-contextc/private-total(^s: mbedtls-ripemd160-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ripemd160-contextp/private-total)

pub inline fun mbedtls-ripemd160-contextcb/private-total(^s: mbedtls-ripemd160-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ripemd160-contextp/private-total)

pub inline extern mbedtls-ripemd160-context-ptrraw/set-private-total(s: intptr_t, private-total: c-pointer<int>): ()
  c inline "((struct mbedtls_ripemd160_context*)#1)->private_total = (int32_t*)#2"

pub inline fun mbedtls-ripemd160-contextp/set-private-total(s: mbedtls-ripemd160-contextp, private-total: c-array<int>): ()
  s.mbedtls-ripemd160-context-ptrraw/set-private-total(private-total.cextern/carray/ptr)

pub inline fun mbedtls-ripemd160-contextc/set-private-total(^s: mbedtls-ripemd160-contextc<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ripemd160-contextp/set-private-total(private-total))

pub inline fun mbedtls-ripemd160-contextcb/set-private-total(^s: mbedtls-ripemd160-contextcb<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ripemd160-contextp/set-private-total(private-total))

pub inline extern mbedtls-ripemd160-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ripemd160_context*)#1)->private_state)"

pub inline fun mbedtls-ripemd160-contextp/private-state(s: mbedtls-ripemd160-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ripemd160-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-ripemd160-contextc/private-state(^s: mbedtls-ripemd160-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ripemd160-contextp/private-state)

pub inline fun mbedtls-ripemd160-contextcb/private-state(^s: mbedtls-ripemd160-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ripemd160-contextp/private-state)

pub inline extern mbedtls-ripemd160-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_ripemd160_context*)#1)->private_state = (int32_t*)#2"

pub inline fun mbedtls-ripemd160-contextp/set-private-state(s: mbedtls-ripemd160-contextp, private-state: c-array<int>): ()
  s.mbedtls-ripemd160-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-ripemd160-contextc/set-private-state(^s: mbedtls-ripemd160-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ripemd160-contextp/set-private-state(private-state))

pub inline fun mbedtls-ripemd160-contextcb/set-private-state(^s: mbedtls-ripemd160-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ripemd160-contextp/set-private-state(private-state))

pub inline extern mbedtls-ripemd160-context-ptrraw/private-buffer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ripemd160_context*)#1)->private_buffer)"

pub inline fun mbedtls-ripemd160-contextp/private-buffer(s: mbedtls-ripemd160-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ripemd160-context-ptrraw/private-buffer.cextern/ptr/carray

pub inline fun mbedtls-ripemd160-contextc/private-buffer(^s: mbedtls-ripemd160-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ripemd160-contextp/private-buffer)

pub inline fun mbedtls-ripemd160-contextcb/private-buffer(^s: mbedtls-ripemd160-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ripemd160-contextp/private-buffer)

pub inline extern mbedtls-ripemd160-context-ptrraw/set-private-buffer(s: intptr_t, private-buffer: c-pointer<int>): ()
  c inline "((struct mbedtls_ripemd160_context*)#1)->private_buffer = (unsigned char*)#2"

pub inline fun mbedtls-ripemd160-contextp/set-private-buffer(s: mbedtls-ripemd160-contextp, private-buffer: c-array<int>): ()
  s.mbedtls-ripemd160-context-ptrraw/set-private-buffer(private-buffer.cextern/carray/ptr)

pub inline fun mbedtls-ripemd160-contextc/set-private-buffer(^s: mbedtls-ripemd160-contextc<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ripemd160-contextp/set-private-buffer(private-buffer))

pub inline fun mbedtls-ripemd160-contextcb/set-private-buffer(^s: mbedtls-ripemd160-contextcb<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ripemd160-contextp/set-private-buffer(private-buffer))

// \brief          The SHA-1 context structure.
// 
// \warning        SHA-1 is considered a weak message digest and its use
// constitutes a security risk. We recommend considering
// stronger message digests instead.
pub struct mbedtls-sha1-context
pub type mbedtls-sha1-context-c
pub alias mbedtls-sha1-contextp = c-pointer<mbedtls-sha1-context-c>
pub alias mbedtls-sha1-contextc<s::S> = owned-c<mbedtls-sha1-context-c>
pub alias mbedtls-sha1-contextcb<s::S> = borrowed-c<s,mbedtls-sha1-context-c>
pub alias mbedtls-sha1-contextca<s::S> = owned-c<c-array<mbedtls-sha1-context-c>>

pub extern mbedtls-sha1-context/size-of(c: c-null<mbedtls-sha1-context-c>): int32
  c inline "sizeof(struct mbedtls_sha1_context)"

pub fun mbedtls-sha1-contextc(): mbedtls-sha1-contextc<s::S>
  malloc(?size-of=mbedtls-sha1-context/size-of)

pub fun mbedtls-sha1-contextc-calloc(): mbedtls-sha1-contextc<s::S>
  malloc-c(?size-of=mbedtls-sha1-context/size-of)

pub fun mbedtls-sha1-contextc-array(n: int): mbedtls-sha1-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-sha1-context/size-of)

pub fun mbedtls-sha1-contextc-array-calloc(n: int): mbedtls-sha1-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-sha1-context/size-of)

pub inline extern mbedtls-sha1-context-ptrraw/private-total(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha1_context*)#1)->private_total)"

pub inline fun mbedtls-sha1-contextp/private-total(s: mbedtls-sha1-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha1-context-ptrraw/private-total.cextern/ptr/carray

pub inline fun mbedtls-sha1-contextc/private-total(^s: mbedtls-sha1-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha1-contextp/private-total)

pub inline fun mbedtls-sha1-contextcb/private-total(^s: mbedtls-sha1-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha1-contextp/private-total)

pub inline extern mbedtls-sha1-context-ptrraw/set-private-total(s: intptr_t, private-total: c-pointer<int>): ()
  c inline "((struct mbedtls_sha1_context*)#1)->private_total = (int32_t*)#2"

pub inline fun mbedtls-sha1-contextp/set-private-total(s: mbedtls-sha1-contextp, private-total: c-array<int>): ()
  s.mbedtls-sha1-context-ptrraw/set-private-total(private-total.cextern/carray/ptr)

pub inline fun mbedtls-sha1-contextc/set-private-total(^s: mbedtls-sha1-contextc<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha1-contextp/set-private-total(private-total))

pub inline fun mbedtls-sha1-contextcb/set-private-total(^s: mbedtls-sha1-contextcb<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha1-contextp/set-private-total(private-total))

pub inline extern mbedtls-sha1-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha1_context*)#1)->private_state)"

pub inline fun mbedtls-sha1-contextp/private-state(s: mbedtls-sha1-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha1-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-sha1-contextc/private-state(^s: mbedtls-sha1-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha1-contextp/private-state)

pub inline fun mbedtls-sha1-contextcb/private-state(^s: mbedtls-sha1-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha1-contextp/private-state)

pub inline extern mbedtls-sha1-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_sha1_context*)#1)->private_state = (int32_t*)#2"

pub inline fun mbedtls-sha1-contextp/set-private-state(s: mbedtls-sha1-contextp, private-state: c-array<int>): ()
  s.mbedtls-sha1-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-sha1-contextc/set-private-state(^s: mbedtls-sha1-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha1-contextp/set-private-state(private-state))

pub inline fun mbedtls-sha1-contextcb/set-private-state(^s: mbedtls-sha1-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha1-contextp/set-private-state(private-state))

pub inline extern mbedtls-sha1-context-ptrraw/private-buffer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha1_context*)#1)->private_buffer)"

pub inline fun mbedtls-sha1-contextp/private-buffer(s: mbedtls-sha1-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha1-context-ptrraw/private-buffer.cextern/ptr/carray

pub inline fun mbedtls-sha1-contextc/private-buffer(^s: mbedtls-sha1-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha1-contextp/private-buffer)

pub inline fun mbedtls-sha1-contextcb/private-buffer(^s: mbedtls-sha1-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha1-contextp/private-buffer)

pub inline extern mbedtls-sha1-context-ptrraw/set-private-buffer(s: intptr_t, private-buffer: c-pointer<int>): ()
  c inline "((struct mbedtls_sha1_context*)#1)->private_buffer = (unsigned char*)#2"

pub inline fun mbedtls-sha1-contextp/set-private-buffer(s: mbedtls-sha1-contextp, private-buffer: c-array<int>): ()
  s.mbedtls-sha1-context-ptrraw/set-private-buffer(private-buffer.cextern/carray/ptr)

pub inline fun mbedtls-sha1-contextc/set-private-buffer(^s: mbedtls-sha1-contextc<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha1-contextp/set-private-buffer(private-buffer))

pub inline fun mbedtls-sha1-contextcb/set-private-buffer(^s: mbedtls-sha1-contextcb<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha1-contextp/set-private-buffer(private-buffer))

// \brief          The SHA-256 context structure.
// 
// The structure is used both for SHA-256 and for SHA-224
// checksum calculations. The choice between these two is
// made in the call to mbedtls_sha256_starts().
pub struct mbedtls-sha256-context
pub type mbedtls-sha256-context-c
pub alias mbedtls-sha256-contextp = c-pointer<mbedtls-sha256-context-c>
pub alias mbedtls-sha256-contextc<s::S> = owned-c<mbedtls-sha256-context-c>
pub alias mbedtls-sha256-contextcb<s::S> = borrowed-c<s,mbedtls-sha256-context-c>
pub alias mbedtls-sha256-contextca<s::S> = owned-c<c-array<mbedtls-sha256-context-c>>

pub extern mbedtls-sha256-context/size-of(c: c-null<mbedtls-sha256-context-c>): int32
  c inline "sizeof(struct mbedtls_sha256_context)"

pub fun mbedtls-sha256-contextc(): mbedtls-sha256-contextc<s::S>
  malloc(?size-of=mbedtls-sha256-context/size-of)

pub fun mbedtls-sha256-contextc-calloc(): mbedtls-sha256-contextc<s::S>
  malloc-c(?size-of=mbedtls-sha256-context/size-of)

pub fun mbedtls-sha256-contextc-array(n: int): mbedtls-sha256-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-sha256-context/size-of)

pub fun mbedtls-sha256-contextc-array-calloc(n: int): mbedtls-sha256-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-sha256-context/size-of)

pub inline extern mbedtls-sha256-context-ptrraw/private-buffer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha256_context*)#1)->private_buffer)"

pub inline fun mbedtls-sha256-contextp/private-buffer(s: mbedtls-sha256-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha256-context-ptrraw/private-buffer.cextern/ptr/carray

pub inline fun mbedtls-sha256-contextc/private-buffer(^s: mbedtls-sha256-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha256-contextp/private-buffer)

pub inline fun mbedtls-sha256-contextcb/private-buffer(^s: mbedtls-sha256-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha256-contextp/private-buffer)

pub inline extern mbedtls-sha256-context-ptrraw/set-private-buffer(s: intptr_t, private-buffer: c-pointer<int>): ()
  c inline "((struct mbedtls_sha256_context*)#1)->private_buffer = (unsigned char*)#2"

pub inline fun mbedtls-sha256-contextp/set-private-buffer(s: mbedtls-sha256-contextp, private-buffer: c-array<int>): ()
  s.mbedtls-sha256-context-ptrraw/set-private-buffer(private-buffer.cextern/carray/ptr)

pub inline fun mbedtls-sha256-contextc/set-private-buffer(^s: mbedtls-sha256-contextc<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-buffer(private-buffer))

pub inline fun mbedtls-sha256-contextcb/set-private-buffer(^s: mbedtls-sha256-contextcb<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-buffer(private-buffer))

pub inline extern mbedtls-sha256-context-ptrraw/private-total(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha256_context*)#1)->private_total)"

pub inline fun mbedtls-sha256-contextp/private-total(s: mbedtls-sha256-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha256-context-ptrraw/private-total.cextern/ptr/carray

pub inline fun mbedtls-sha256-contextc/private-total(^s: mbedtls-sha256-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha256-contextp/private-total)

pub inline fun mbedtls-sha256-contextcb/private-total(^s: mbedtls-sha256-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha256-contextp/private-total)

pub inline extern mbedtls-sha256-context-ptrraw/set-private-total(s: intptr_t, private-total: c-pointer<int>): ()
  c inline "((struct mbedtls_sha256_context*)#1)->private_total = (int32_t*)#2"

pub inline fun mbedtls-sha256-contextp/set-private-total(s: mbedtls-sha256-contextp, private-total: c-array<int>): ()
  s.mbedtls-sha256-context-ptrraw/set-private-total(private-total.cextern/carray/ptr)

pub inline fun mbedtls-sha256-contextc/set-private-total(^s: mbedtls-sha256-contextc<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-total(private-total))

pub inline fun mbedtls-sha256-contextcb/set-private-total(^s: mbedtls-sha256-contextcb<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-total(private-total))

pub inline extern mbedtls-sha256-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha256_context*)#1)->private_state)"

pub inline fun mbedtls-sha256-contextp/private-state(s: mbedtls-sha256-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha256-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-sha256-contextc/private-state(^s: mbedtls-sha256-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha256-contextp/private-state)

pub inline fun mbedtls-sha256-contextcb/private-state(^s: mbedtls-sha256-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha256-contextp/private-state)

pub inline extern mbedtls-sha256-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_sha256_context*)#1)->private_state = (int32_t*)#2"

pub inline fun mbedtls-sha256-contextp/set-private-state(s: mbedtls-sha256-contextp, private-state: c-array<int>): ()
  s.mbedtls-sha256-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-sha256-contextc/set-private-state(^s: mbedtls-sha256-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-state(private-state))

pub inline fun mbedtls-sha256-contextcb/set-private-state(^s: mbedtls-sha256-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-state(private-state))

pub inline extern mbedtls-sha256-context-ptrraw/private-is224(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_sha256_context*)#1)->private_is224)"

pub inline fun mbedtls-sha256-contextp/private-is224(s: mbedtls-sha256-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-sha256-context-ptrraw/private-is224.int

pub inline fun mbedtls-sha256-contextc/private-is224(^s: mbedtls-sha256-contextc<s::S>): <> int
  s.with-ptr(mbedtls-sha256-contextp/private-is224)

pub inline fun mbedtls-sha256-contextcb/private-is224(^s: mbedtls-sha256-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-sha256-contextp/private-is224)

pub inline extern mbedtls-sha256-context-ptrraw/set-private-is224(s: intptr_t, private-is224: int32): ()
  c inline "((struct mbedtls_sha256_context*)#1)->private_is224 = (int)#2"

pub inline fun mbedtls-sha256-contextp/set-private-is224(s: mbedtls-sha256-contextp, private-is224: int): ()
  s.mbedtls-sha256-context-ptrraw/set-private-is224(private-is224.int32)

pub inline fun mbedtls-sha256-contextc/set-private-is224(^s: mbedtls-sha256-contextc<s::S>, private-is224: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-is224(private-is224))

pub inline fun mbedtls-sha256-contextcb/set-private-is224(^s: mbedtls-sha256-contextcb<s::S>, private-is224: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha256-contextp/set-private-is224(private-is224))

// \brief          The SHA-512 context structure.
// 
// The structure is used both for SHA-384 and for SHA-512
// checksum calculations. The choice between these two is
// made in the call to mbedtls_sha512_starts().
pub struct mbedtls-sha512-context
pub type mbedtls-sha512-context-c
pub alias mbedtls-sha512-contextp = c-pointer<mbedtls-sha512-context-c>
pub alias mbedtls-sha512-contextc<s::S> = owned-c<mbedtls-sha512-context-c>
pub alias mbedtls-sha512-contextcb<s::S> = borrowed-c<s,mbedtls-sha512-context-c>
pub alias mbedtls-sha512-contextca<s::S> = owned-c<c-array<mbedtls-sha512-context-c>>

pub extern mbedtls-sha512-context/size-of(c: c-null<mbedtls-sha512-context-c>): int32
  c inline "sizeof(struct mbedtls_sha512_context)"

pub fun mbedtls-sha512-contextc(): mbedtls-sha512-contextc<s::S>
  malloc(?size-of=mbedtls-sha512-context/size-of)

pub fun mbedtls-sha512-contextc-calloc(): mbedtls-sha512-contextc<s::S>
  malloc-c(?size-of=mbedtls-sha512-context/size-of)

pub fun mbedtls-sha512-contextc-array(n: int): mbedtls-sha512-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-sha512-context/size-of)

pub fun mbedtls-sha512-contextc-array-calloc(n: int): mbedtls-sha512-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-sha512-context/size-of)

pub inline extern mbedtls-sha512-context-ptrraw/private-total(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha512_context*)#1)->private_total)"

pub inline fun mbedtls-sha512-contextp/private-total(s: mbedtls-sha512-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha512-context-ptrraw/private-total.cextern/ptr/carray

pub inline fun mbedtls-sha512-contextc/private-total(^s: mbedtls-sha512-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha512-contextp/private-total)

pub inline fun mbedtls-sha512-contextcb/private-total(^s: mbedtls-sha512-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha512-contextp/private-total)

pub inline extern mbedtls-sha512-context-ptrraw/set-private-total(s: intptr_t, private-total: c-pointer<int>): ()
  c inline "((struct mbedtls_sha512_context*)#1)->private_total = (int64_t*)#2"

pub inline fun mbedtls-sha512-contextp/set-private-total(s: mbedtls-sha512-contextp, private-total: c-array<int>): ()
  s.mbedtls-sha512-context-ptrraw/set-private-total(private-total.cextern/carray/ptr)

pub inline fun mbedtls-sha512-contextc/set-private-total(^s: mbedtls-sha512-contextc<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-total(private-total))

pub inline fun mbedtls-sha512-contextcb/set-private-total(^s: mbedtls-sha512-contextcb<s::S>, private-total: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-total(private-total))

pub inline extern mbedtls-sha512-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha512_context*)#1)->private_state)"

pub inline fun mbedtls-sha512-contextp/private-state(s: mbedtls-sha512-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha512-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-sha512-contextc/private-state(^s: mbedtls-sha512-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha512-contextp/private-state)

pub inline fun mbedtls-sha512-contextcb/private-state(^s: mbedtls-sha512-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha512-contextp/private-state)

pub inline extern mbedtls-sha512-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_sha512_context*)#1)->private_state = (int64_t*)#2"

pub inline fun mbedtls-sha512-contextp/set-private-state(s: mbedtls-sha512-contextp, private-state: c-array<int>): ()
  s.mbedtls-sha512-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-sha512-contextc/set-private-state(^s: mbedtls-sha512-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-state(private-state))

pub inline fun mbedtls-sha512-contextcb/set-private-state(^s: mbedtls-sha512-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-state(private-state))

pub inline extern mbedtls-sha512-context-ptrraw/private-buffer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_sha512_context*)#1)->private_buffer)"

pub inline fun mbedtls-sha512-contextp/private-buffer(s: mbedtls-sha512-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha512-context-ptrraw/private-buffer.cextern/ptr/carray

pub inline fun mbedtls-sha512-contextc/private-buffer(^s: mbedtls-sha512-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha512-contextp/private-buffer)

pub inline fun mbedtls-sha512-contextcb/private-buffer(^s: mbedtls-sha512-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha512-contextp/private-buffer)

pub inline extern mbedtls-sha512-context-ptrraw/set-private-buffer(s: intptr_t, private-buffer: c-pointer<int>): ()
  c inline "((struct mbedtls_sha512_context*)#1)->private_buffer = (unsigned char*)#2"

pub inline fun mbedtls-sha512-contextp/set-private-buffer(s: mbedtls-sha512-contextp, private-buffer: c-array<int>): ()
  s.mbedtls-sha512-context-ptrraw/set-private-buffer(private-buffer.cextern/carray/ptr)

pub inline fun mbedtls-sha512-contextc/set-private-buffer(^s: mbedtls-sha512-contextc<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-buffer(private-buffer))

pub inline fun mbedtls-sha512-contextcb/set-private-buffer(^s: mbedtls-sha512-contextcb<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-buffer(private-buffer))

pub inline extern mbedtls-sha512-context-ptrraw/private-is384(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_sha512_context*)#1)->private_is384)"

pub inline fun mbedtls-sha512-contextp/private-is384(s: mbedtls-sha512-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-sha512-context-ptrraw/private-is384.int

pub inline fun mbedtls-sha512-contextc/private-is384(^s: mbedtls-sha512-contextc<s::S>): <> int
  s.with-ptr(mbedtls-sha512-contextp/private-is384)

pub inline fun mbedtls-sha512-contextcb/private-is384(^s: mbedtls-sha512-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-sha512-contextp/private-is384)

pub inline extern mbedtls-sha512-context-ptrraw/set-private-is384(s: intptr_t, private-is384: int32): ()
  c inline "((struct mbedtls_sha512_context*)#1)->private_is384 = (int)#2"

pub inline fun mbedtls-sha512-contextp/set-private-is384(s: mbedtls-sha512-contextp, private-is384: int): ()
  s.mbedtls-sha512-context-ptrraw/set-private-is384(private-is384.int32)

pub inline fun mbedtls-sha512-contextc/set-private-is384(^s: mbedtls-sha512-contextc<s::S>, private-is384: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-is384(private-is384))

pub inline fun mbedtls-sha512-contextcb/set-private-is384(^s: mbedtls-sha512-contextcb<s::S>, private-is384: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha512-contextp/set-private-is384(private-is384))

// \brief          The SHA-3 context structure.
// 
// The structure is used SHA-3 checksum calculations.
pub struct mbedtls-sha3-context
pub type mbedtls-sha3-context-c
pub alias mbedtls-sha3-contextp = c-pointer<mbedtls-sha3-context-c>
pub alias mbedtls-sha3-contextc<s::S> = owned-c<mbedtls-sha3-context-c>
pub alias mbedtls-sha3-contextcb<s::S> = borrowed-c<s,mbedtls-sha3-context-c>
pub alias mbedtls-sha3-contextca<s::S> = owned-c<c-array<mbedtls-sha3-context-c>>

pub extern mbedtls-sha3-context/size-of(c: c-null<mbedtls-sha3-context-c>): int32
  c inline "sizeof(mbedtls_sha3_context)"

pub fun mbedtls-sha3-contextc(): mbedtls-sha3-contextc<s::S>
  malloc(?size-of=mbedtls-sha3-context/size-of)

pub fun mbedtls-sha3-contextc-calloc(): mbedtls-sha3-contextc<s::S>
  malloc-c(?size-of=mbedtls-sha3-context/size-of)

pub fun mbedtls-sha3-contextc-array(n: int): mbedtls-sha3-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-sha3-context/size-of)

pub fun mbedtls-sha3-contextc-array-calloc(n: int): mbedtls-sha3-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-sha3-context/size-of)

pub inline extern mbedtls-sha3-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_sha3_context*)#1)->private_state)"

pub inline fun mbedtls-sha3-contextp/private-state(s: mbedtls-sha3-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-sha3-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-sha3-contextc/private-state(^s: mbedtls-sha3-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha3-contextp/private-state)

pub inline fun mbedtls-sha3-contextcb/private-state(^s: mbedtls-sha3-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-sha3-contextp/private-state)

pub inline extern mbedtls-sha3-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((mbedtls_sha3_context*)#1)->private_state = (int64_t*)#2"

pub inline fun mbedtls-sha3-contextp/set-private-state(s: mbedtls-sha3-contextp, private-state: c-array<int>): ()
  s.mbedtls-sha3-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-sha3-contextc/set-private-state(^s: mbedtls-sha3-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-state(private-state))

pub inline fun mbedtls-sha3-contextcb/set-private-state(^s: mbedtls-sha3-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-state(private-state))

pub inline extern mbedtls-sha3-context-ptrraw/private-index(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_sha3_context*)#1)->private_index)"

pub inline fun mbedtls-sha3-contextp/private-index(s: mbedtls-sha3-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-sha3-context-ptrraw/private-index.int

pub inline fun mbedtls-sha3-contextc/private-index(^s: mbedtls-sha3-contextc<s::S>): <> int
  s.with-ptr(mbedtls-sha3-contextp/private-index)

pub inline fun mbedtls-sha3-contextcb/private-index(^s: mbedtls-sha3-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-sha3-contextp/private-index)

pub inline extern mbedtls-sha3-context-ptrraw/set-private-index(s: intptr_t, private-index: int32): ()
  c inline "((mbedtls_sha3_context*)#1)->private_index = (int32_t)#2"

pub inline fun mbedtls-sha3-contextp/set-private-index(s: mbedtls-sha3-contextp, private-index: int): ()
  s.mbedtls-sha3-context-ptrraw/set-private-index(private-index.int32)

pub inline fun mbedtls-sha3-contextc/set-private-index(^s: mbedtls-sha3-contextc<s::S>, private-index: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-index(private-index))

pub inline fun mbedtls-sha3-contextcb/set-private-index(^s: mbedtls-sha3-contextcb<s::S>, private-index: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-index(private-index))

pub inline extern mbedtls-sha3-context-ptrraw/private-olen(s: intptr_t): int16
  c inline "(int16_t)(((mbedtls_sha3_context*)#1)->private_olen)"

pub inline fun mbedtls-sha3-contextp/private-olen(s: mbedtls-sha3-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-sha3-context-ptrraw/private-olen.int

pub inline fun mbedtls-sha3-contextc/private-olen(^s: mbedtls-sha3-contextc<s::S>): <> int
  s.with-ptr(mbedtls-sha3-contextp/private-olen)

pub inline fun mbedtls-sha3-contextcb/private-olen(^s: mbedtls-sha3-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-sha3-contextp/private-olen)

pub inline extern mbedtls-sha3-context-ptrraw/set-private-olen(s: intptr_t, private-olen: int16): ()
  c inline "((mbedtls_sha3_context*)#1)->private_olen = (int16_t)#2"

pub inline fun mbedtls-sha3-contextp/set-private-olen(s: mbedtls-sha3-contextp, private-olen: int): ()
  s.mbedtls-sha3-context-ptrraw/set-private-olen(private-olen.int16)

pub inline fun mbedtls-sha3-contextc/set-private-olen(^s: mbedtls-sha3-contextc<s::S>, private-olen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-olen(private-olen))

pub inline fun mbedtls-sha3-contextcb/set-private-olen(^s: mbedtls-sha3-contextcb<s::S>, private-olen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-olen(private-olen))

pub inline extern mbedtls-sha3-context-ptrraw/private-max-block-size(s: intptr_t): int16
  c inline "(int16_t)(((mbedtls_sha3_context*)#1)->private_max_block_size)"

pub inline fun mbedtls-sha3-contextp/private-max-block-size(s: mbedtls-sha3-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-sha3-context-ptrraw/private-max-block-size.int

pub inline fun mbedtls-sha3-contextc/private-max-block-size(^s: mbedtls-sha3-contextc<s::S>): <> int
  s.with-ptr(mbedtls-sha3-contextp/private-max-block-size)

pub inline fun mbedtls-sha3-contextcb/private-max-block-size(^s: mbedtls-sha3-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-sha3-contextp/private-max-block-size)

pub inline extern mbedtls-sha3-context-ptrraw/set-private-max-block-size(s: intptr_t, private-max-block-size: int16): ()
  c inline "((mbedtls_sha3_context*)#1)->private_max_block_size = (int16_t)#2"

pub inline fun mbedtls-sha3-contextp/set-private-max-block-size(s: mbedtls-sha3-contextp, private-max-block-size: int): ()
  s.mbedtls-sha3-context-ptrraw/set-private-max-block-size(private-max-block-size.int16)

pub inline fun mbedtls-sha3-contextc/set-private-max-block-size(^s: mbedtls-sha3-contextc<s::S>, private-max-block-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-max-block-size(private-max-block-size))

pub inline fun mbedtls-sha3-contextcb/set-private-max-block-size(^s: mbedtls-sha3-contextcb<s::S>, private-max-block-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-sha3-contextp/set-private-max-block-size(private-max-block-size))

// The type of the state data structure for multipart hash operations.
// 
// Before calling any function on a hash operation object, the application must
// initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_hash_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_hash_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,
// for example:
// \code
// psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;
// \endcode
// - Assign the result of the function psa_hash_operation_init()
// to the structure, for example:
// \code
// psa_hash_operation_t operation;
// operation = psa_hash_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-hash-operation-t = psa-hash-operation-s-c
alias koka-psa-hash-operation-t = psa-hash-operation-s
pub struct psa-mac-operation-s
pub type psa-mac-operation-s-c
pub alias psa-mac-operation-sp = c-pointer<psa-mac-operation-s-c>
pub alias psa-mac-operation-sc = owned-c<psa-mac-operation-s-c>
pub alias psa-mac-operation-scb<s::S> = borrowed-c<s,psa-mac-operation-s-c>
pub alias psa-mac-operation-sca = owned-c<c-array<psa-mac-operation-s-c>>

// The type of the state data structure for multipart MAC operations.
// 
// Before calling any function on a MAC operation object, the application must
// initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_mac_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_mac_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,
// for example:
// \code
// psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;
// \endcode
// - Assign the result of the function psa_mac_operation_init()
// to the structure, for example:
// \code
// psa_mac_operation_t operation;
// operation = psa_mac_operation_init();
// \endcode
// 
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-mac-operation-t = psa-mac-operation-s-c
pub struct psa-cipher-operation-s
pub type psa-cipher-operation-s-c
pub alias psa-cipher-operation-sp = c-pointer<psa-cipher-operation-s-c>
pub alias psa-cipher-operation-sc = owned-c<psa-cipher-operation-s-c>
pub alias psa-cipher-operation-scb<s::S> = borrowed-c<s,psa-cipher-operation-s-c>
pub alias psa-cipher-operation-sca = owned-c<c-array<psa-cipher-operation-s-c>>

// The type of the state data structure for multipart cipher operations.
// 
// Before calling any function on a cipher operation object, the application
// must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_cipher_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_cipher_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,
// for example:
// \code
// psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;
// \endcode
// - Assign the result of the function psa_cipher_operation_init()
// to the structure, for example:
// \code
// psa_cipher_operation_t operation;
// operation = psa_cipher_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-cipher-operation-t = psa-cipher-operation-s-c
pub struct psa-aead-operation-s
pub type psa-aead-operation-s-c
pub alias psa-aead-operation-sp = c-pointer<psa-aead-operation-s-c>
pub alias psa-aead-operation-sc = owned-c<psa-aead-operation-s-c>
pub alias psa-aead-operation-scb<s::S> = borrowed-c<s,psa-aead-operation-s-c>
pub alias psa-aead-operation-sca = owned-c<c-array<psa-aead-operation-s-c>>

// The type of the state data structure for multipart AEAD operations.
// 
// Before calling any function on an AEAD operation object, the application
// must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_aead_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_aead_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,
// for example:
// \code
// psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;
// \endcode
// - Assign the result of the function psa_aead_operation_init()
// to the structure, for example:
// \code
// psa_aead_operation_t operation;
// operation = psa_aead_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-aead-operation-t = psa-aead-operation-s-c
pub struct psa-key-derivation-s
pub type psa-key-derivation-s-c
pub alias psa-key-derivation-sp = c-pointer<psa-key-derivation-s-c>
pub alias psa-key-derivation-sc = owned-c<psa-key-derivation-s-c>
pub alias psa-key-derivation-scb<s::S> = borrowed-c<s,psa-key-derivation-s-c>
pub alias psa-key-derivation-sca = owned-c<c-array<psa-key-derivation-s-c>>

// The type of the state data structure for key derivation operations.
// 
// Before calling any function on a key derivation operation object, the
// application must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_key_derivation_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_key_derivation_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,
// for example:
// \code
// psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;
// \endcode
// - Assign the result of the function psa_key_derivation_operation_init()
// to the structure, for example:
// \code
// psa_key_derivation_operation_t operation;
// operation = psa_key_derivation_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-key-derivation-operation-t = psa-key-derivation-s-c
// \brief Encoding of the step of a key derivation.
// 
// Values of this type are generally constructed by macros called
// `PSA_KEY_DERIVATION_INPUT_xxx`.
alias psa-key-derivation-step-t = int
// \brief Custom parameters for key generation or key derivation.
// 
// This is a structure type with at least the following fields:
// 
// - \c flags: an unsigned integer type. 0 for the default production parameters.
// - \c data: a flexible array of bytes.
// 
// The interpretation of this structure depend on the type of the
// created key.
// 
// - #PSA_KEY_TYPE_RSA_KEY_PAIR:
// - \c flags: must be 0.
// - \c data: the public exponent, in little-endian order.
// This must be an odd integer and must not be 1.
// Implementations must support 65537, should support 3 and may
// support other values.
// When not using a driver, Mbed TLS supports values up to \c INT_MAX.
// If this is empty or if the custom production parameters are omitted
// altogether, the default value 65537 is used.
// - Other key types: reserved for future use. \c flags must be 0.
alias psa-key-production-parameters-t = psa-key-production-parameters-s-c
// \brief The context for PSA interruptible hash signing.
pub struct psa-sign-hash-interruptible-operation-s
pub type psa-sign-hash-interruptible-operation-s-c
pub alias psa-sign-hash-interruptible-operation-sp = c-pointer<psa-sign-hash-interruptible-operation-s-c>
pub alias psa-sign-hash-interruptible-operation-sc = owned-c<psa-sign-hash-interruptible-operation-s-c>
pub alias psa-sign-hash-interruptible-operation-scb<s::S> = borrowed-c<s,psa-sign-hash-interruptible-operation-s-c>
pub alias psa-sign-hash-interruptible-operation-sca = owned-c<c-array<psa-sign-hash-interruptible-operation-s-c>>

// \brief The context for PSA interruptible hash verification.
pub struct psa-verify-hash-interruptible-operation-s
pub type psa-verify-hash-interruptible-operation-s-c
pub alias psa-verify-hash-interruptible-operation-sp = c-pointer<psa-verify-hash-interruptible-operation-s-c>
pub alias psa-verify-hash-interruptible-operation-sc = owned-c<psa-verify-hash-interruptible-operation-s-c>
pub alias psa-verify-hash-interruptible-operation-scb<s::S> = borrowed-c<s,psa-verify-hash-interruptible-operation-s-c>
pub alias psa-verify-hash-interruptible-operation-sca = owned-c<c-array<psa-verify-hash-interruptible-operation-s-c>>

// The type of the state data structure for interruptible hash
// signing operations.
// 
// Before calling any function on a sign hash operation object, the
// application must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_sign_hash_interruptible_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_sign_hash_interruptible_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer
// #PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:
// \code
// psa_sign_hash_interruptible_operation_t operation =
// PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT;
// \endcode
// - Assign the result of the function
// psa_sign_hash_interruptible_operation_init() to the structure, for
// example:
// \code
// psa_sign_hash_interruptible_operation_t operation;
// operation = psa_sign_hash_interruptible_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-sign-hash-interruptible-operation-t = psa-sign-hash-interruptible-operation-s-c
// The type of the state data structure for interruptible hash
// verification operations.
// 
// Before calling any function on a sign hash operation object, the
// application must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_verify_hash_interruptible_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_verify_hash_interruptible_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer
// #PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:
// \code
// psa_verify_hash_interruptible_operation_t operation =
// PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT;
// \endcode
// - Assign the result of the function
// psa_verify_hash_interruptible_operation_init() to the structure, for
// example:
// \code
// psa_verify_hash_interruptible_operation_t operation;
// operation = psa_verify_hash_interruptible_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-verify-hash-interruptible-operation-t = psa-verify-hash-interruptible-operation-s-c
// For encrypt-decrypt functions, whether the operation is an encryption
// or a decryption.
type psa-encrypt-or-decrypt-t
  PSA_CRYPTO_DRIVER_DECRYPT
  PSA_CRYPTO_DRIVER_ENCRYPT

pub fun psa-encrypt-or-decrypt-t/int(i: psa-encrypt-or-decrypt-t): int32
  match i
    PSA_CRYPTO_DRIVER_DECRYPT -> 0.int32
    PSA_CRYPTO_DRIVER_ENCRYPT -> 1.int32

pub fun int/psa-encrypt-or-decrypt-t(i: int32): exn psa-encrypt-or-decrypt-t
  match i.int
    0 -> PSA_CRYPTO_DRIVER_DECRYPT
    1 -> PSA_CRYPTO_DRIVER_ENCRYPT

// SHA-3 family id.
// 
// It identifies the family (SHA3-256, SHA3-512, etc.)
type mbedtls-sha3-id
  // !< Operation not defined.
  MBEDTLS_SHA3_NONE
  // !< SHA3-224
  MBEDTLS_SHA3_224
  // !< SHA3-256
  MBEDTLS_SHA3_256
  // !< SHA3-384
  MBEDTLS_SHA3_384
  // !< SHA3-512
  MBEDTLS_SHA3_512

pub fun mbedtls-sha3-id/int(i: mbedtls-sha3-id): int32
  match i
    MBEDTLS_SHA3_NONE -> 0.int32
    MBEDTLS_SHA3_224 -> 1.int32
    MBEDTLS_SHA3_256 -> 2.int32
    MBEDTLS_SHA3_384 -> 3.int32
    MBEDTLS_SHA3_512 -> 4.int32

pub fun int/mbedtls-sha3-id(i: int32): exn mbedtls-sha3-id
  match i.int
    0 -> MBEDTLS_SHA3_NONE
    1 -> MBEDTLS_SHA3_224
    2 -> MBEDTLS_SHA3_256
    3 -> MBEDTLS_SHA3_384
    4 -> MBEDTLS_SHA3_512

// \brief     Supported cipher types.
// 
// \warning   DES/3DES are considered weak ciphers and their use
// constitutes a security risk. We recommend considering stronger
// ciphers instead.
type mbedtls-cipher-id-t
  // < Placeholder to mark the end of cipher ID lists.
  MBEDTLS_CIPHER_ID_NONE
  // < The identity cipher, treated as a stream cipher.
  MBEDTLS_CIPHER_ID_NULL
  // < The AES cipher.
  MBEDTLS_CIPHER_ID_AES
  // < The DES cipher. \warning DES is considered weak.
  MBEDTLS_CIPHER_ID_DES
  // < The Triple DES cipher. \warning 3DES is considered weak.
  MBEDTLS_CIPHER_ID_3DES
  // < The Camellia cipher.
  MBEDTLS_CIPHER_ID_CAMELLIA
  // < The Aria cipher.
  MBEDTLS_CIPHER_ID_ARIA
  // < The ChaCha20 cipher.
  MBEDTLS_CIPHER_ID_CHACHA20

pub fun mbedtls-cipher-id-t/int(i: mbedtls-cipher-id-t): int32
  match i
    MBEDTLS_CIPHER_ID_NONE -> 0.int32
    MBEDTLS_CIPHER_ID_NULL -> 1.int32
    MBEDTLS_CIPHER_ID_AES -> 2.int32
    MBEDTLS_CIPHER_ID_DES -> 3.int32
    MBEDTLS_CIPHER_ID_3DES -> 4.int32
    MBEDTLS_CIPHER_ID_CAMELLIA -> 5.int32
    MBEDTLS_CIPHER_ID_ARIA -> 6.int32
    MBEDTLS_CIPHER_ID_CHACHA20 -> 7.int32

pub fun int/mbedtls-cipher-id-t(i: int32): exn mbedtls-cipher-id-t
  match i.int
    0 -> MBEDTLS_CIPHER_ID_NONE
    1 -> MBEDTLS_CIPHER_ID_NULL
    2 -> MBEDTLS_CIPHER_ID_AES
    3 -> MBEDTLS_CIPHER_ID_DES
    4 -> MBEDTLS_CIPHER_ID_3DES
    5 -> MBEDTLS_CIPHER_ID_CAMELLIA
    6 -> MBEDTLS_CIPHER_ID_ARIA
    7 -> MBEDTLS_CIPHER_ID_CHACHA20

// \brief     Supported {cipher type, cipher mode} pairs.
// 
// \warning   DES/3DES are considered weak ciphers and their use
// constitutes a security risk. We recommend considering stronger
// ciphers instead.
type mbedtls-cipher-type-t
  // < Placeholder to mark the end of cipher-pair lists.
  MBEDTLS_CIPHER_NONE
  // < The identity stream cipher.
  MBEDTLS_CIPHER_NULL
  // < AES cipher with 128-bit ECB mode.
  MBEDTLS_CIPHER_AES_128_ECB
  // < AES cipher with 192-bit ECB mode.
  MBEDTLS_CIPHER_AES_192_ECB
  // < AES cipher with 256-bit ECB mode.
  MBEDTLS_CIPHER_AES_256_ECB
  // < AES cipher with 128-bit CBC mode.
  MBEDTLS_CIPHER_AES_128_CBC
  // < AES cipher with 192-bit CBC mode.
  MBEDTLS_CIPHER_AES_192_CBC
  // < AES cipher with 256-bit CBC mode.
  MBEDTLS_CIPHER_AES_256_CBC
  // < AES cipher with 128-bit CFB128 mode.
  MBEDTLS_CIPHER_AES_128_CFB128
  // < AES cipher with 192-bit CFB128 mode.
  MBEDTLS_CIPHER_AES_192_CFB128
  // < AES cipher with 256-bit CFB128 mode.
  MBEDTLS_CIPHER_AES_256_CFB128
  // < AES cipher with 128-bit CTR mode.
  MBEDTLS_CIPHER_AES_128_CTR
  // < AES cipher with 192-bit CTR mode.
  MBEDTLS_CIPHER_AES_192_CTR
  // < AES cipher with 256-bit CTR mode.
  MBEDTLS_CIPHER_AES_256_CTR
  // < AES cipher with 128-bit GCM mode.
  MBEDTLS_CIPHER_AES_128_GCM
  // < AES cipher with 192-bit GCM mode.
  MBEDTLS_CIPHER_AES_192_GCM
  // < AES cipher with 256-bit GCM mode.
  MBEDTLS_CIPHER_AES_256_GCM
  // < Camellia cipher with 128-bit ECB mode.
  MBEDTLS_CIPHER_CAMELLIA_128_ECB
  // < Camellia cipher with 192-bit ECB mode.
  MBEDTLS_CIPHER_CAMELLIA_192_ECB
  // < Camellia cipher with 256-bit ECB mode.
  MBEDTLS_CIPHER_CAMELLIA_256_ECB
  // < Camellia cipher with 128-bit CBC mode.
  MBEDTLS_CIPHER_CAMELLIA_128_CBC
  // < Camellia cipher with 192-bit CBC mode.
  MBEDTLS_CIPHER_CAMELLIA_192_CBC
  // < Camellia cipher with 256-bit CBC mode.
  MBEDTLS_CIPHER_CAMELLIA_256_CBC
  // < Camellia cipher with 128-bit CFB128 mode.
  MBEDTLS_CIPHER_CAMELLIA_128_CFB128
  // < Camellia cipher with 192-bit CFB128 mode.
  MBEDTLS_CIPHER_CAMELLIA_192_CFB128
  // < Camellia cipher with 256-bit CFB128 mode.
  MBEDTLS_CIPHER_CAMELLIA_256_CFB128
  // < Camellia cipher with 128-bit CTR mode.
  MBEDTLS_CIPHER_CAMELLIA_128_CTR
  // < Camellia cipher with 192-bit CTR mode.
  MBEDTLS_CIPHER_CAMELLIA_192_CTR
  // < Camellia cipher with 256-bit CTR mode.
  MBEDTLS_CIPHER_CAMELLIA_256_CTR
  // < Camellia cipher with 128-bit GCM mode.
  MBEDTLS_CIPHER_CAMELLIA_128_GCM
  // < Camellia cipher with 192-bit GCM mode.
  MBEDTLS_CIPHER_CAMELLIA_192_GCM
  // < Camellia cipher with 256-bit GCM mode.
  MBEDTLS_CIPHER_CAMELLIA_256_GCM
  // < DES cipher with ECB mode. \warning DES is considered weak.
  MBEDTLS_CIPHER_DES_ECB
  // < DES cipher with CBC mode. \warning DES is considered weak.
  MBEDTLS_CIPHER_DES_CBC
  // < DES cipher with EDE ECB mode. \warning 3DES is considered weak.
  MBEDTLS_CIPHER_DES_EDE_ECB
  // < DES cipher with EDE CBC mode. \warning 3DES is considered weak.
  MBEDTLS_CIPHER_DES_EDE_CBC
  // < DES cipher with EDE3 ECB mode. \warning 3DES is considered weak.
  MBEDTLS_CIPHER_DES_EDE3_ECB
  // < DES cipher with EDE3 CBC mode. \warning 3DES is considered weak.
  MBEDTLS_CIPHER_DES_EDE3_CBC
  // < AES cipher with 128-bit CCM mode.
  MBEDTLS_CIPHER_AES_128_CCM
  // < AES cipher with 192-bit CCM mode.
  MBEDTLS_CIPHER_AES_192_CCM
  // < AES cipher with 256-bit CCM mode.
  MBEDTLS_CIPHER_AES_256_CCM
  // < AES cipher with 128-bit CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG
  // < AES cipher with 192-bit CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG
  // < AES cipher with 256-bit CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG
  // < Camellia cipher with 128-bit CCM mode.
  MBEDTLS_CIPHER_CAMELLIA_128_CCM
  // < Camellia cipher with 192-bit CCM mode.
  MBEDTLS_CIPHER_CAMELLIA_192_CCM
  // < Camellia cipher with 256-bit CCM mode.
  MBEDTLS_CIPHER_CAMELLIA_256_CCM
  // < Camellia cipher with 128-bit CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG
  // < Camellia cipher with 192-bit CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG
  // < Camellia cipher with 256-bit CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG
  // < Aria cipher with 128-bit key and ECB mode.
  MBEDTLS_CIPHER_ARIA_128_ECB
  // < Aria cipher with 192-bit key and ECB mode.
  MBEDTLS_CIPHER_ARIA_192_ECB
  // < Aria cipher with 256-bit key and ECB mode.
  MBEDTLS_CIPHER_ARIA_256_ECB
  // < Aria cipher with 128-bit key and CBC mode.
  MBEDTLS_CIPHER_ARIA_128_CBC
  // < Aria cipher with 192-bit key and CBC mode.
  MBEDTLS_CIPHER_ARIA_192_CBC
  // < Aria cipher with 256-bit key and CBC mode.
  MBEDTLS_CIPHER_ARIA_256_CBC
  // < Aria cipher with 128-bit key and CFB-128 mode.
  MBEDTLS_CIPHER_ARIA_128_CFB128
  // < Aria cipher with 192-bit key and CFB-128 mode.
  MBEDTLS_CIPHER_ARIA_192_CFB128
  // < Aria cipher with 256-bit key and CFB-128 mode.
  MBEDTLS_CIPHER_ARIA_256_CFB128
  // < Aria cipher with 128-bit key and CTR mode.
  MBEDTLS_CIPHER_ARIA_128_CTR
  // < Aria cipher with 192-bit key and CTR mode.
  MBEDTLS_CIPHER_ARIA_192_CTR
  // < Aria cipher with 256-bit key and CTR mode.
  MBEDTLS_CIPHER_ARIA_256_CTR
  // < Aria cipher with 128-bit key and GCM mode.
  MBEDTLS_CIPHER_ARIA_128_GCM
  // < Aria cipher with 192-bit key and GCM mode.
  MBEDTLS_CIPHER_ARIA_192_GCM
  // < Aria cipher with 256-bit key and GCM mode.
  MBEDTLS_CIPHER_ARIA_256_GCM
  // < Aria cipher with 128-bit key and CCM mode.
  MBEDTLS_CIPHER_ARIA_128_CCM
  // < Aria cipher with 192-bit key and CCM mode.
  MBEDTLS_CIPHER_ARIA_192_CCM
  // < Aria cipher with 256-bit key and CCM mode.
  MBEDTLS_CIPHER_ARIA_256_CCM
  // < Aria cipher with 128-bit key and CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG
  // < Aria cipher with 192-bit key and CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG
  // < Aria cipher with 256-bit key and CCM_STAR_NO_TAG mode.
  MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG
  // < AES 128-bit cipher in OFB mode.
  MBEDTLS_CIPHER_AES_128_OFB
  // < AES 192-bit cipher in OFB mode.
  MBEDTLS_CIPHER_AES_192_OFB
  // < AES 256-bit cipher in OFB mode.
  MBEDTLS_CIPHER_AES_256_OFB
  // < AES 128-bit cipher in XTS block mode.
  MBEDTLS_CIPHER_AES_128_XTS
  // < AES 256-bit cipher in XTS block mode.
  MBEDTLS_CIPHER_AES_256_XTS
  // < ChaCha20 stream cipher.
  MBEDTLS_CIPHER_CHACHA20
  // < ChaCha20-Poly1305 AEAD cipher.
  MBEDTLS_CIPHER_CHACHA20_POLY1305
  // < AES cipher with 128-bit NIST KW mode.
  MBEDTLS_CIPHER_AES_128_KW
  // < AES cipher with 192-bit NIST KW mode.
  MBEDTLS_CIPHER_AES_192_KW
  // < AES cipher with 256-bit NIST KW mode.
  MBEDTLS_CIPHER_AES_256_KW
  // < AES cipher with 128-bit NIST KWP mode.
  MBEDTLS_CIPHER_AES_128_KWP
  // < AES cipher with 192-bit NIST KWP mode.
  MBEDTLS_CIPHER_AES_192_KWP
  // < AES cipher with 256-bit NIST KWP mode.
  MBEDTLS_CIPHER_AES_256_KWP

pub fun mbedtls-cipher-type-t/int(i: mbedtls-cipher-type-t): int32
  match i
    MBEDTLS_CIPHER_NONE -> 0.int32
    MBEDTLS_CIPHER_NULL -> 1.int32
    MBEDTLS_CIPHER_AES_128_ECB -> 2.int32
    MBEDTLS_CIPHER_AES_192_ECB -> 3.int32
    MBEDTLS_CIPHER_AES_256_ECB -> 4.int32
    MBEDTLS_CIPHER_AES_128_CBC -> 5.int32
    MBEDTLS_CIPHER_AES_192_CBC -> 6.int32
    MBEDTLS_CIPHER_AES_256_CBC -> 7.int32
    MBEDTLS_CIPHER_AES_128_CFB128 -> 8.int32
    MBEDTLS_CIPHER_AES_192_CFB128 -> 9.int32
    MBEDTLS_CIPHER_AES_256_CFB128 -> 10.int32
    MBEDTLS_CIPHER_AES_128_CTR -> 11.int32
    MBEDTLS_CIPHER_AES_192_CTR -> 12.int32
    MBEDTLS_CIPHER_AES_256_CTR -> 13.int32
    MBEDTLS_CIPHER_AES_128_GCM -> 14.int32
    MBEDTLS_CIPHER_AES_192_GCM -> 15.int32
    MBEDTLS_CIPHER_AES_256_GCM -> 16.int32
    MBEDTLS_CIPHER_CAMELLIA_128_ECB -> 17.int32
    MBEDTLS_CIPHER_CAMELLIA_192_ECB -> 18.int32
    MBEDTLS_CIPHER_CAMELLIA_256_ECB -> 19.int32
    MBEDTLS_CIPHER_CAMELLIA_128_CBC -> 20.int32
    MBEDTLS_CIPHER_CAMELLIA_192_CBC -> 21.int32
    MBEDTLS_CIPHER_CAMELLIA_256_CBC -> 22.int32
    MBEDTLS_CIPHER_CAMELLIA_128_CFB128 -> 23.int32
    MBEDTLS_CIPHER_CAMELLIA_192_CFB128 -> 24.int32
    MBEDTLS_CIPHER_CAMELLIA_256_CFB128 -> 25.int32
    MBEDTLS_CIPHER_CAMELLIA_128_CTR -> 26.int32
    MBEDTLS_CIPHER_CAMELLIA_192_CTR -> 27.int32
    MBEDTLS_CIPHER_CAMELLIA_256_CTR -> 28.int32
    MBEDTLS_CIPHER_CAMELLIA_128_GCM -> 29.int32
    MBEDTLS_CIPHER_CAMELLIA_192_GCM -> 30.int32
    MBEDTLS_CIPHER_CAMELLIA_256_GCM -> 31.int32
    MBEDTLS_CIPHER_DES_ECB -> 32.int32
    MBEDTLS_CIPHER_DES_CBC -> 33.int32
    MBEDTLS_CIPHER_DES_EDE_ECB -> 34.int32
    MBEDTLS_CIPHER_DES_EDE_CBC -> 35.int32
    MBEDTLS_CIPHER_DES_EDE3_ECB -> 36.int32
    MBEDTLS_CIPHER_DES_EDE3_CBC -> 37.int32
    MBEDTLS_CIPHER_AES_128_CCM -> 38.int32
    MBEDTLS_CIPHER_AES_192_CCM -> 39.int32
    MBEDTLS_CIPHER_AES_256_CCM -> 40.int32
    MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG -> 41.int32
    MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG -> 42.int32
    MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG -> 43.int32
    MBEDTLS_CIPHER_CAMELLIA_128_CCM -> 44.int32
    MBEDTLS_CIPHER_CAMELLIA_192_CCM -> 45.int32
    MBEDTLS_CIPHER_CAMELLIA_256_CCM -> 46.int32
    MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG -> 47.int32
    MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG -> 48.int32
    MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG -> 49.int32
    MBEDTLS_CIPHER_ARIA_128_ECB -> 50.int32
    MBEDTLS_CIPHER_ARIA_192_ECB -> 51.int32
    MBEDTLS_CIPHER_ARIA_256_ECB -> 52.int32
    MBEDTLS_CIPHER_ARIA_128_CBC -> 53.int32
    MBEDTLS_CIPHER_ARIA_192_CBC -> 54.int32
    MBEDTLS_CIPHER_ARIA_256_CBC -> 55.int32
    MBEDTLS_CIPHER_ARIA_128_CFB128 -> 56.int32
    MBEDTLS_CIPHER_ARIA_192_CFB128 -> 57.int32
    MBEDTLS_CIPHER_ARIA_256_CFB128 -> 58.int32
    MBEDTLS_CIPHER_ARIA_128_CTR -> 59.int32
    MBEDTLS_CIPHER_ARIA_192_CTR -> 60.int32
    MBEDTLS_CIPHER_ARIA_256_CTR -> 61.int32
    MBEDTLS_CIPHER_ARIA_128_GCM -> 62.int32
    MBEDTLS_CIPHER_ARIA_192_GCM -> 63.int32
    MBEDTLS_CIPHER_ARIA_256_GCM -> 64.int32
    MBEDTLS_CIPHER_ARIA_128_CCM -> 65.int32
    MBEDTLS_CIPHER_ARIA_192_CCM -> 66.int32
    MBEDTLS_CIPHER_ARIA_256_CCM -> 67.int32
    MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG -> 68.int32
    MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG -> 69.int32
    MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG -> 70.int32
    MBEDTLS_CIPHER_AES_128_OFB -> 71.int32
    MBEDTLS_CIPHER_AES_192_OFB -> 72.int32
    MBEDTLS_CIPHER_AES_256_OFB -> 73.int32
    MBEDTLS_CIPHER_AES_128_XTS -> 74.int32
    MBEDTLS_CIPHER_AES_256_XTS -> 75.int32
    MBEDTLS_CIPHER_CHACHA20 -> 76.int32
    MBEDTLS_CIPHER_CHACHA20_POLY1305 -> 77.int32
    MBEDTLS_CIPHER_AES_128_KW -> 78.int32
    MBEDTLS_CIPHER_AES_192_KW -> 79.int32
    MBEDTLS_CIPHER_AES_256_KW -> 80.int32
    MBEDTLS_CIPHER_AES_128_KWP -> 81.int32
    MBEDTLS_CIPHER_AES_192_KWP -> 82.int32
    MBEDTLS_CIPHER_AES_256_KWP -> 83.int32

pub fun int/mbedtls-cipher-type-t(i: int32): exn mbedtls-cipher-type-t
  match i.int
    0 -> MBEDTLS_CIPHER_NONE
    1 -> MBEDTLS_CIPHER_NULL
    2 -> MBEDTLS_CIPHER_AES_128_ECB
    3 -> MBEDTLS_CIPHER_AES_192_ECB
    4 -> MBEDTLS_CIPHER_AES_256_ECB
    5 -> MBEDTLS_CIPHER_AES_128_CBC
    6 -> MBEDTLS_CIPHER_AES_192_CBC
    7 -> MBEDTLS_CIPHER_AES_256_CBC
    8 -> MBEDTLS_CIPHER_AES_128_CFB128
    9 -> MBEDTLS_CIPHER_AES_192_CFB128
    10 -> MBEDTLS_CIPHER_AES_256_CFB128
    11 -> MBEDTLS_CIPHER_AES_128_CTR
    12 -> MBEDTLS_CIPHER_AES_192_CTR
    13 -> MBEDTLS_CIPHER_AES_256_CTR
    14 -> MBEDTLS_CIPHER_AES_128_GCM
    15 -> MBEDTLS_CIPHER_AES_192_GCM
    16 -> MBEDTLS_CIPHER_AES_256_GCM
    17 -> MBEDTLS_CIPHER_CAMELLIA_128_ECB
    18 -> MBEDTLS_CIPHER_CAMELLIA_192_ECB
    19 -> MBEDTLS_CIPHER_CAMELLIA_256_ECB
    20 -> MBEDTLS_CIPHER_CAMELLIA_128_CBC
    21 -> MBEDTLS_CIPHER_CAMELLIA_192_CBC
    22 -> MBEDTLS_CIPHER_CAMELLIA_256_CBC
    23 -> MBEDTLS_CIPHER_CAMELLIA_128_CFB128
    24 -> MBEDTLS_CIPHER_CAMELLIA_192_CFB128
    25 -> MBEDTLS_CIPHER_CAMELLIA_256_CFB128
    26 -> MBEDTLS_CIPHER_CAMELLIA_128_CTR
    27 -> MBEDTLS_CIPHER_CAMELLIA_192_CTR
    28 -> MBEDTLS_CIPHER_CAMELLIA_256_CTR
    29 -> MBEDTLS_CIPHER_CAMELLIA_128_GCM
    30 -> MBEDTLS_CIPHER_CAMELLIA_192_GCM
    31 -> MBEDTLS_CIPHER_CAMELLIA_256_GCM
    32 -> MBEDTLS_CIPHER_DES_ECB
    33 -> MBEDTLS_CIPHER_DES_CBC
    34 -> MBEDTLS_CIPHER_DES_EDE_ECB
    35 -> MBEDTLS_CIPHER_DES_EDE_CBC
    36 -> MBEDTLS_CIPHER_DES_EDE3_ECB
    37 -> MBEDTLS_CIPHER_DES_EDE3_CBC
    38 -> MBEDTLS_CIPHER_AES_128_CCM
    39 -> MBEDTLS_CIPHER_AES_192_CCM
    40 -> MBEDTLS_CIPHER_AES_256_CCM
    41 -> MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG
    42 -> MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG
    43 -> MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG
    44 -> MBEDTLS_CIPHER_CAMELLIA_128_CCM
    45 -> MBEDTLS_CIPHER_CAMELLIA_192_CCM
    46 -> MBEDTLS_CIPHER_CAMELLIA_256_CCM
    47 -> MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG
    48 -> MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG
    49 -> MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG
    50 -> MBEDTLS_CIPHER_ARIA_128_ECB
    51 -> MBEDTLS_CIPHER_ARIA_192_ECB
    52 -> MBEDTLS_CIPHER_ARIA_256_ECB
    53 -> MBEDTLS_CIPHER_ARIA_128_CBC
    54 -> MBEDTLS_CIPHER_ARIA_192_CBC
    55 -> MBEDTLS_CIPHER_ARIA_256_CBC
    56 -> MBEDTLS_CIPHER_ARIA_128_CFB128
    57 -> MBEDTLS_CIPHER_ARIA_192_CFB128
    58 -> MBEDTLS_CIPHER_ARIA_256_CFB128
    59 -> MBEDTLS_CIPHER_ARIA_128_CTR
    60 -> MBEDTLS_CIPHER_ARIA_192_CTR
    61 -> MBEDTLS_CIPHER_ARIA_256_CTR
    62 -> MBEDTLS_CIPHER_ARIA_128_GCM
    63 -> MBEDTLS_CIPHER_ARIA_192_GCM
    64 -> MBEDTLS_CIPHER_ARIA_256_GCM
    65 -> MBEDTLS_CIPHER_ARIA_128_CCM
    66 -> MBEDTLS_CIPHER_ARIA_192_CCM
    67 -> MBEDTLS_CIPHER_ARIA_256_CCM
    68 -> MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG
    69 -> MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG
    70 -> MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG
    71 -> MBEDTLS_CIPHER_AES_128_OFB
    72 -> MBEDTLS_CIPHER_AES_192_OFB
    73 -> MBEDTLS_CIPHER_AES_256_OFB
    74 -> MBEDTLS_CIPHER_AES_128_XTS
    75 -> MBEDTLS_CIPHER_AES_256_XTS
    76 -> MBEDTLS_CIPHER_CHACHA20
    77 -> MBEDTLS_CIPHER_CHACHA20_POLY1305
    78 -> MBEDTLS_CIPHER_AES_128_KW
    79 -> MBEDTLS_CIPHER_AES_192_KW
    80 -> MBEDTLS_CIPHER_AES_256_KW
    81 -> MBEDTLS_CIPHER_AES_128_KWP
    82 -> MBEDTLS_CIPHER_AES_192_KWP
    83 -> MBEDTLS_CIPHER_AES_256_KWP

// Supported cipher modes.
type mbedtls-cipher-mode-t
  // < None.
  MBEDTLS_MODE_NONE
  // < The ECB cipher mode.
  MBEDTLS_MODE_ECB
  // < The CBC cipher mode.
  MBEDTLS_MODE_CBC
  // < The CFB cipher mode.
  MBEDTLS_MODE_CFB
  // < The OFB cipher mode.
  MBEDTLS_MODE_OFB
  // < The CTR cipher mode.
  MBEDTLS_MODE_CTR
  // < The GCM cipher mode.
  MBEDTLS_MODE_GCM
  // < The stream cipher mode.
  MBEDTLS_MODE_STREAM
  // < The CCM cipher mode.
  MBEDTLS_MODE_CCM
  // < The CCM*-no-tag cipher mode.
  MBEDTLS_MODE_CCM_STAR_NO_TAG
  // < The XTS cipher mode.
  MBEDTLS_MODE_XTS
  // < The ChaCha-Poly cipher mode.
  MBEDTLS_MODE_CHACHAPOLY
  // < The SP800-38F KW mode
  MBEDTLS_MODE_KW
  // < The SP800-38F KWP mode
  MBEDTLS_MODE_KWP

pub fun mbedtls-cipher-mode-t/int(i: mbedtls-cipher-mode-t): int32
  match i
    MBEDTLS_MODE_NONE -> 0.int32
    MBEDTLS_MODE_ECB -> 1.int32
    MBEDTLS_MODE_CBC -> 2.int32
    MBEDTLS_MODE_CFB -> 3.int32
    MBEDTLS_MODE_OFB -> 4.int32
    MBEDTLS_MODE_CTR -> 5.int32
    MBEDTLS_MODE_GCM -> 6.int32
    MBEDTLS_MODE_STREAM -> 7.int32
    MBEDTLS_MODE_CCM -> 8.int32
    MBEDTLS_MODE_CCM_STAR_NO_TAG -> 9.int32
    MBEDTLS_MODE_XTS -> 10.int32
    MBEDTLS_MODE_CHACHAPOLY -> 11.int32
    MBEDTLS_MODE_KW -> 12.int32
    MBEDTLS_MODE_KWP -> 13.int32

pub fun int/mbedtls-cipher-mode-t(i: int32): exn mbedtls-cipher-mode-t
  match i.int
    0 -> MBEDTLS_MODE_NONE
    1 -> MBEDTLS_MODE_ECB
    2 -> MBEDTLS_MODE_CBC
    3 -> MBEDTLS_MODE_CFB
    4 -> MBEDTLS_MODE_OFB
    5 -> MBEDTLS_MODE_CTR
    6 -> MBEDTLS_MODE_GCM
    7 -> MBEDTLS_MODE_STREAM
    8 -> MBEDTLS_MODE_CCM
    9 -> MBEDTLS_MODE_CCM_STAR_NO_TAG
    10 -> MBEDTLS_MODE_XTS
    11 -> MBEDTLS_MODE_CHACHAPOLY
    12 -> MBEDTLS_MODE_KW
    13 -> MBEDTLS_MODE_KWP

// Supported cipher padding types.
type mbedtls-cipher-padding-t
  // < PKCS7 padding (default).
  MBEDTLS_PADDING_PKCS7
  // < ISO/IEC 7816-4 padding.
  MBEDTLS_PADDING_ONE_AND_ZEROS
  // < ANSI X.923 padding.
  MBEDTLS_PADDING_ZEROS_AND_LEN
  // < Zero padding (not reversible).
  MBEDTLS_PADDING_ZEROS
  // < Never pad (full blocks only).
  MBEDTLS_PADDING_NONE

pub fun mbedtls-cipher-padding-t/int(i: mbedtls-cipher-padding-t): int32
  match i
    MBEDTLS_PADDING_PKCS7 -> 0.int32
    MBEDTLS_PADDING_ONE_AND_ZEROS -> 1.int32
    MBEDTLS_PADDING_ZEROS_AND_LEN -> 2.int32
    MBEDTLS_PADDING_ZEROS -> 3.int32
    MBEDTLS_PADDING_NONE -> 4.int32

pub fun int/mbedtls-cipher-padding-t(i: int32): exn mbedtls-cipher-padding-t
  match i.int
    0 -> MBEDTLS_PADDING_PKCS7
    1 -> MBEDTLS_PADDING_ONE_AND_ZEROS
    2 -> MBEDTLS_PADDING_ZEROS_AND_LEN
    3 -> MBEDTLS_PADDING_ZEROS
    4 -> MBEDTLS_PADDING_NONE

// Type of operation.
type mbedtls-operation-t
  MBEDTLS_OPERATION_NONE
  MBEDTLS_DECRYPT
  MBEDTLS_ENCRYPT

pub fun mbedtls-operation-t/int(i: mbedtls-operation-t): int32
  match i
    MBEDTLS_OPERATION_NONE -> -1.int32
    MBEDTLS_DECRYPT -> 0.int32
    MBEDTLS_ENCRYPT -> 1.int32

pub fun int/mbedtls-operation-t(i: int32): exn mbedtls-operation-t
  match i.int
    -1 -> MBEDTLS_OPERATION_NONE
    0 -> MBEDTLS_DECRYPT
    1 -> MBEDTLS_ENCRYPT

pub struct mbedtls-cipher-base-t
pub type mbedtls-cipher-base-t-c
pub alias mbedtls-cipher-base-tp = c-pointer<mbedtls-cipher-base-t-c>
pub alias mbedtls-cipher-base-tc = owned-c<mbedtls-cipher-base-t-c>
pub alias mbedtls-cipher-base-tcb<s::S> = borrowed-c<s,mbedtls-cipher-base-t-c>
pub alias mbedtls-cipher-base-tca = owned-c<c-array<mbedtls-cipher-base-t-c>>

// The CMAC context structure.
pub struct mbedtls-cmac-context-t
pub type mbedtls-cmac-context-t-c
pub alias mbedtls-cmac-context-tp = c-pointer<mbedtls-cmac-context-t-c>
pub alias mbedtls-cmac-context-tc<s::S> = owned-c<mbedtls-cmac-context-t-c>
pub alias mbedtls-cmac-context-tcb<s::S> = borrowed-c<s,mbedtls-cmac-context-t-c>
pub alias mbedtls-cmac-context-tca<s::S> = owned-c<c-array<mbedtls-cmac-context-t-c>>

pub extern mbedtls-cmac-context-t/size-of(c: c-null<mbedtls-cmac-context-t-c>): int32
  c inline "sizeof(struct mbedtls_cmac_context_t)"

pub fun mbedtls-cmac-context-tc(): mbedtls-cmac-context-tc<s::S>
  malloc(?size-of=mbedtls-cmac-context-t/size-of)

pub fun mbedtls-cmac-context-tc-calloc(): mbedtls-cmac-context-tc<s::S>
  malloc-c(?size-of=mbedtls-cmac-context-t/size-of)

pub fun mbedtls-cmac-context-tc-array(n: int): mbedtls-cmac-context-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-cmac-context-t/size-of)

pub fun mbedtls-cmac-context-tc-array-calloc(n: int): mbedtls-cmac-context-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-cmac-context-t/size-of)

pub inline extern mbedtls-cmac-context-t-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_cmac_context_t*)#1)->private_state)"

pub inline fun mbedtls-cmac-context-tp/private-state(s: mbedtls-cmac-context-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-cmac-context-t-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-cmac-context-tc/private-state(^s: mbedtls-cmac-context-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cmac-context-tp/private-state)

pub inline fun mbedtls-cmac-context-tcb/private-state(^s: mbedtls-cmac-context-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cmac-context-tp/private-state)

pub inline extern mbedtls-cmac-context-t-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_cmac_context_t*)#1)->private_state = (unsigned char*)#2"

pub inline fun mbedtls-cmac-context-tp/set-private-state(s: mbedtls-cmac-context-tp, private-state: c-array<int>): ()
  s.mbedtls-cmac-context-t-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-cmac-context-tc/set-private-state(^s: mbedtls-cmac-context-tc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cmac-context-tp/set-private-state(private-state))

pub inline fun mbedtls-cmac-context-tcb/set-private-state(^s: mbedtls-cmac-context-tcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cmac-context-tp/set-private-state(private-state))

pub inline extern mbedtls-cmac-context-t-ptrraw/private-unprocessed-block(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_cmac_context_t*)#1)->private_unprocessed_block)"

pub inline fun mbedtls-cmac-context-tp/private-unprocessed-block(s: mbedtls-cmac-context-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-cmac-context-t-ptrraw/private-unprocessed-block.cextern/ptr/carray

pub inline fun mbedtls-cmac-context-tc/private-unprocessed-block(^s: mbedtls-cmac-context-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cmac-context-tp/private-unprocessed-block)

pub inline fun mbedtls-cmac-context-tcb/private-unprocessed-block(^s: mbedtls-cmac-context-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cmac-context-tp/private-unprocessed-block)

pub inline extern mbedtls-cmac-context-t-ptrraw/set-private-unprocessed-block(s: intptr_t, private-unprocessed-block: c-pointer<int>): ()
  c inline "((struct mbedtls_cmac_context_t*)#1)->private_unprocessed_block = (unsigned char*)#2"

pub inline fun mbedtls-cmac-context-tp/set-private-unprocessed-block(s: mbedtls-cmac-context-tp, private-unprocessed-block: c-array<int>): ()
  s.mbedtls-cmac-context-t-ptrraw/set-private-unprocessed-block(private-unprocessed-block.cextern/carray/ptr)

pub inline fun mbedtls-cmac-context-tc/set-private-unprocessed-block(^s: mbedtls-cmac-context-tc<s::S>, private-unprocessed-block: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cmac-context-tp/set-private-unprocessed-block(private-unprocessed-block))

pub inline fun mbedtls-cmac-context-tcb/set-private-unprocessed-block(^s: mbedtls-cmac-context-tcb<s::S>, private-unprocessed-block: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cmac-context-tp/set-private-unprocessed-block(private-unprocessed-block))

pub inline extern mbedtls-cmac-context-t-ptrraw/private-unprocessed-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_cmac_context_t*)#1)->private_unprocessed_len)"

pub inline fun mbedtls-cmac-context-tp/private-unprocessed-len(s: mbedtls-cmac-context-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-cmac-context-t-ptrraw/private-unprocessed-len.int

pub inline fun mbedtls-cmac-context-tc/private-unprocessed-len(^s: mbedtls-cmac-context-tc<s::S>): <> int
  s.with-ptr(mbedtls-cmac-context-tp/private-unprocessed-len)

pub inline fun mbedtls-cmac-context-tcb/private-unprocessed-len(^s: mbedtls-cmac-context-tcb<s::S>): <> int
  s.with-ptr(mbedtls-cmac-context-tp/private-unprocessed-len)

pub inline extern mbedtls-cmac-context-t-ptrraw/set-private-unprocessed-len(s: intptr_t, private-unprocessed-len: ssize_t): ()
  c inline "((struct mbedtls_cmac_context_t*)#1)->private_unprocessed_len = (size_t)#2"

pub inline fun mbedtls-cmac-context-tp/set-private-unprocessed-len(s: mbedtls-cmac-context-tp, private-unprocessed-len: int): ()
  s.mbedtls-cmac-context-t-ptrraw/set-private-unprocessed-len(private-unprocessed-len.ssize_t)

pub inline fun mbedtls-cmac-context-tc/set-private-unprocessed-len(^s: mbedtls-cmac-context-tc<s::S>, private-unprocessed-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cmac-context-tp/set-private-unprocessed-len(private-unprocessed-len))

pub inline fun mbedtls-cmac-context-tcb/set-private-unprocessed-len(^s: mbedtls-cmac-context-tcb<s::S>, private-unprocessed-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cmac-context-tp/set-private-unprocessed-len(private-unprocessed-len))

// Cipher information. Allows calling cipher functions
// in a generic way.
// 
// \note        The library does not support custom cipher info structures,
// only built-in structures returned by the functions
// mbedtls_cipher_info_from_string(),
// mbedtls_cipher_info_from_type(),
// mbedtls_cipher_info_from_values(),
// mbedtls_cipher_info_from_psa().
// 
// \note        Some fields store a value that has been right-shifted to save
// code-size, so should not be used directly. The accessor
// functions adjust for this and return the "natural" value.
pub struct mbedtls-cipher-info-t
pub type mbedtls-cipher-info-t-c
pub alias mbedtls-cipher-info-tp = c-pointer<mbedtls-cipher-info-t-c>
pub alias mbedtls-cipher-info-tc = owned-c<mbedtls-cipher-info-t-c>
pub alias mbedtls-cipher-info-tcb<s::S> = borrowed-c<s,mbedtls-cipher-info-t-c>
pub alias mbedtls-cipher-info-tca = owned-c<c-array<mbedtls-cipher-info-t-c>>

// Generic cipher context.
pub struct mbedtls-cipher-context-t
pub type mbedtls-cipher-context-t-c
pub alias mbedtls-cipher-context-tp = c-pointer<mbedtls-cipher-context-t-c>
pub alias mbedtls-cipher-context-tc<s::S> = owned-c<mbedtls-cipher-context-t-c>
pub alias mbedtls-cipher-context-tcb<s::S> = borrowed-c<s,mbedtls-cipher-context-t-c>
pub alias mbedtls-cipher-context-tca<s::S> = owned-c<c-array<mbedtls-cipher-context-t-c>>

pub extern mbedtls-cipher-context-t/size-of(c: c-null<mbedtls-cipher-context-t-c>): int32
  c inline "sizeof(struct mbedtls_cipher_context_t)"

pub fun mbedtls-cipher-context-tc(): mbedtls-cipher-context-tc<s::S>
  malloc(?size-of=mbedtls-cipher-context-t/size-of)

pub fun mbedtls-cipher-context-tc-calloc(): mbedtls-cipher-context-tc<s::S>
  malloc-c(?size-of=mbedtls-cipher-context-t/size-of)

pub fun mbedtls-cipher-context-tc-array(n: int): mbedtls-cipher-context-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-cipher-context-t/size-of)

pub fun mbedtls-cipher-context-tc-array-calloc(n: int): mbedtls-cipher-context-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-cipher-context-t/size-of)

pub inline extern mbedtls-cipher-context-t-ptrraw/private-cipher-info(s: intptr_t): c-pointer<mbedtls-cipher-info-t-c>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_cipher_info)"

pub inline fun mbedtls-cipher-context-tp/private-cipher-info(s: mbedtls-cipher-context-tp): <> c-pointer<mbedtls-cipher-info-t-c>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-cipher-info

pub inline fun mbedtls-cipher-context-tc/private-cipher-info(^s: mbedtls-cipher-context-tc<s::S>): <> c-pointer<mbedtls-cipher-info-t-c>
  s.with-ptr(mbedtls-cipher-context-tp/private-cipher-info)

pub inline fun mbedtls-cipher-context-tcb/private-cipher-info(^s: mbedtls-cipher-context-tcb<s::S>): <> c-pointer<mbedtls-cipher-info-t-c>
  s.with-ptr(mbedtls-cipher-context-tp/private-cipher-info)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-cipher-info(s: intptr_t, private-cipher-info: c-pointer<mbedtls-cipher-info-t-c>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_cipher_info = (struct mbedtls_cipher_info_t*)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-cipher-info(s: mbedtls-cipher-context-tp, private-cipher-info: c-pointer<mbedtls-cipher-info-t-c>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-cipher-info(private-cipher-info)

pub inline fun mbedtls-cipher-context-tc/set-private-cipher-info(^s: mbedtls-cipher-context-tc<s::S>, private-cipher-info: c-pointer<mbedtls-cipher-info-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-cipher-info(private-cipher-info))

pub inline fun mbedtls-cipher-context-tcb/set-private-cipher-info(^s: mbedtls-cipher-context-tcb<s::S>, private-cipher-info: c-pointer<mbedtls-cipher-info-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-cipher-info(private-cipher-info))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-key-bitlen(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_cipher_context_t*)#1)->private_key_bitlen)"

pub inline fun mbedtls-cipher-context-tp/private-key-bitlen(s: mbedtls-cipher-context-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-key-bitlen.int

pub inline fun mbedtls-cipher-context-tc/private-key-bitlen(^s: mbedtls-cipher-context-tc<s::S>): <> int
  s.with-ptr(mbedtls-cipher-context-tp/private-key-bitlen)

pub inline fun mbedtls-cipher-context-tcb/private-key-bitlen(^s: mbedtls-cipher-context-tcb<s::S>): <> int
  s.with-ptr(mbedtls-cipher-context-tp/private-key-bitlen)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-key-bitlen(s: intptr_t, private-key-bitlen: int32): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_key_bitlen = (int)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-key-bitlen(s: mbedtls-cipher-context-tp, private-key-bitlen: int): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-key-bitlen(private-key-bitlen.int32)

pub inline fun mbedtls-cipher-context-tc/set-private-key-bitlen(^s: mbedtls-cipher-context-tc<s::S>, private-key-bitlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-key-bitlen(private-key-bitlen))

pub inline fun mbedtls-cipher-context-tcb/set-private-key-bitlen(^s: mbedtls-cipher-context-tcb<s::S>, private-key-bitlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-key-bitlen(private-key-bitlen))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-operation(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_cipher_context_t*)#1)->private_operation)"

pub inline fun mbedtls-cipher-context-tp/private-operation(s: mbedtls-cipher-context-tp): <exn> mbedtls-operation-t
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-operation.int/mbedtls-operation-t

pub inline fun mbedtls-cipher-context-tc/private-operation(^s: mbedtls-cipher-context-tc<s::S>): <exn> mbedtls-operation-t
  s.with-ptr(mbedtls-cipher-context-tp/private-operation)

pub inline fun mbedtls-cipher-context-tcb/private-operation(^s: mbedtls-cipher-context-tcb<s::S>): <exn> mbedtls-operation-t
  s.with-ptr(mbedtls-cipher-context-tp/private-operation)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-operation(s: intptr_t, private-operation: int32): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_operation = (int32_t)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-operation(s: mbedtls-cipher-context-tp, private-operation: mbedtls-operation-t): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-operation(private-operation.mbedtls-operation-t/int)

pub inline fun mbedtls-cipher-context-tc/set-private-operation(^s: mbedtls-cipher-context-tc<s::S>, private-operation: mbedtls-operation-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-operation(private-operation))

pub inline fun mbedtls-cipher-context-tcb/set-private-operation(^s: mbedtls-cipher-context-tcb<s::S>, private-operation: mbedtls-operation-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-operation(private-operation))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-add-padding(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_add_padding)"

pub inline fun mbedtls-cipher-context-tp/private-add-padding(s: mbedtls-cipher-context-tp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-add-padding

pub inline fun mbedtls-cipher-context-tc/private-add-padding(^s: mbedtls-cipher-context-tc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-cipher-context-tp/private-add-padding)

pub inline fun mbedtls-cipher-context-tcb/private-add-padding(^s: mbedtls-cipher-context-tcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-cipher-context-tp/private-add-padding)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-add-padding(s: intptr_t, private-add-padding: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_add_padding = (void (*)(unsigned char*, size_t, size_t))#2"

pub inline fun mbedtls-cipher-context-tp/set-private-add-padding(s: mbedtls-cipher-context-tp, private-add-padding: c-pointer<intptr_t>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-add-padding(private-add-padding)

pub inline fun mbedtls-cipher-context-tc/set-private-add-padding(^s: mbedtls-cipher-context-tc<s::S>, private-add-padding: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-add-padding(private-add-padding))

pub inline fun mbedtls-cipher-context-tcb/set-private-add-padding(^s: mbedtls-cipher-context-tcb<s::S>, private-add-padding: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-add-padding(private-add-padding))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-get-padding(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_get_padding)"

pub inline fun mbedtls-cipher-context-tp/private-get-padding(s: mbedtls-cipher-context-tp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-get-padding

pub inline fun mbedtls-cipher-context-tc/private-get-padding(^s: mbedtls-cipher-context-tc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-cipher-context-tp/private-get-padding)

pub inline fun mbedtls-cipher-context-tcb/private-get-padding(^s: mbedtls-cipher-context-tcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-cipher-context-tp/private-get-padding)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-get-padding(s: intptr_t, private-get-padding: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_get_padding = (int (*)(unsigned char*, size_t, size_t*))#2"

pub inline fun mbedtls-cipher-context-tp/set-private-get-padding(s: mbedtls-cipher-context-tp, private-get-padding: c-pointer<intptr_t>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-get-padding(private-get-padding)

pub inline fun mbedtls-cipher-context-tc/set-private-get-padding(^s: mbedtls-cipher-context-tc<s::S>, private-get-padding: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-get-padding(private-get-padding))

pub inline fun mbedtls-cipher-context-tcb/set-private-get-padding(^s: mbedtls-cipher-context-tcb<s::S>, private-get-padding: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-get-padding(private-get-padding))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-unprocessed-data(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_unprocessed_data)"

pub inline fun mbedtls-cipher-context-tp/private-unprocessed-data(s: mbedtls-cipher-context-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-unprocessed-data.cextern/ptr/carray

pub inline fun mbedtls-cipher-context-tc/private-unprocessed-data(^s: mbedtls-cipher-context-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cipher-context-tp/private-unprocessed-data)

pub inline fun mbedtls-cipher-context-tcb/private-unprocessed-data(^s: mbedtls-cipher-context-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cipher-context-tp/private-unprocessed-data)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-unprocessed-data(s: intptr_t, private-unprocessed-data: c-pointer<int>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_unprocessed_data = (unsigned char*)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-unprocessed-data(s: mbedtls-cipher-context-tp, private-unprocessed-data: c-array<int>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-unprocessed-data(private-unprocessed-data.cextern/carray/ptr)

pub inline fun mbedtls-cipher-context-tc/set-private-unprocessed-data(^s: mbedtls-cipher-context-tc<s::S>, private-unprocessed-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-unprocessed-data(private-unprocessed-data))

pub inline fun mbedtls-cipher-context-tcb/set-private-unprocessed-data(^s: mbedtls-cipher-context-tcb<s::S>, private-unprocessed-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-unprocessed-data(private-unprocessed-data))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-unprocessed-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_cipher_context_t*)#1)->private_unprocessed_len)"

pub inline fun mbedtls-cipher-context-tp/private-unprocessed-len(s: mbedtls-cipher-context-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-unprocessed-len.int

pub inline fun mbedtls-cipher-context-tc/private-unprocessed-len(^s: mbedtls-cipher-context-tc<s::S>): <> int
  s.with-ptr(mbedtls-cipher-context-tp/private-unprocessed-len)

pub inline fun mbedtls-cipher-context-tcb/private-unprocessed-len(^s: mbedtls-cipher-context-tcb<s::S>): <> int
  s.with-ptr(mbedtls-cipher-context-tp/private-unprocessed-len)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-unprocessed-len(s: intptr_t, private-unprocessed-len: ssize_t): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_unprocessed_len = (size_t)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-unprocessed-len(s: mbedtls-cipher-context-tp, private-unprocessed-len: int): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-unprocessed-len(private-unprocessed-len.ssize_t)

pub inline fun mbedtls-cipher-context-tc/set-private-unprocessed-len(^s: mbedtls-cipher-context-tc<s::S>, private-unprocessed-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-unprocessed-len(private-unprocessed-len))

pub inline fun mbedtls-cipher-context-tcb/set-private-unprocessed-len(^s: mbedtls-cipher-context-tcb<s::S>, private-unprocessed-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-unprocessed-len(private-unprocessed-len))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-iv(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_iv)"

pub inline fun mbedtls-cipher-context-tp/private-iv(s: mbedtls-cipher-context-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-iv.cextern/ptr/carray

pub inline fun mbedtls-cipher-context-tc/private-iv(^s: mbedtls-cipher-context-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cipher-context-tp/private-iv)

pub inline fun mbedtls-cipher-context-tcb/private-iv(^s: mbedtls-cipher-context-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-cipher-context-tp/private-iv)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-iv(s: intptr_t, private-iv: c-pointer<int>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_iv = (unsigned char*)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-iv(s: mbedtls-cipher-context-tp, private-iv: c-array<int>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-iv(private-iv.cextern/carray/ptr)

pub inline fun mbedtls-cipher-context-tc/set-private-iv(^s: mbedtls-cipher-context-tc<s::S>, private-iv: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-iv(private-iv))

pub inline fun mbedtls-cipher-context-tcb/set-private-iv(^s: mbedtls-cipher-context-tcb<s::S>, private-iv: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-iv(private-iv))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-iv-size(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_cipher_context_t*)#1)->private_iv_size)"

pub inline fun mbedtls-cipher-context-tp/private-iv-size(s: mbedtls-cipher-context-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-iv-size.int

pub inline fun mbedtls-cipher-context-tc/private-iv-size(^s: mbedtls-cipher-context-tc<s::S>): <> int
  s.with-ptr(mbedtls-cipher-context-tp/private-iv-size)

pub inline fun mbedtls-cipher-context-tcb/private-iv-size(^s: mbedtls-cipher-context-tcb<s::S>): <> int
  s.with-ptr(mbedtls-cipher-context-tp/private-iv-size)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-iv-size(s: intptr_t, private-iv-size: ssize_t): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_iv_size = (size_t)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-iv-size(s: mbedtls-cipher-context-tp, private-iv-size: int): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-iv-size(private-iv-size.ssize_t)

pub inline fun mbedtls-cipher-context-tc/set-private-iv-size(^s: mbedtls-cipher-context-tc<s::S>, private-iv-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-iv-size(private-iv-size))

pub inline fun mbedtls-cipher-context-tcb/set-private-iv-size(^s: mbedtls-cipher-context-tcb<s::S>, private-iv-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-iv-size(private-iv-size))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-cipher-ctx(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_cipher_ctx)"

pub inline fun mbedtls-cipher-context-tp/private-cipher-ctx(s: mbedtls-cipher-context-tp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-cipher-ctx

pub inline fun mbedtls-cipher-context-tc/private-cipher-ctx(^s: mbedtls-cipher-context-tc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-cipher-context-tp/private-cipher-ctx)

pub inline fun mbedtls-cipher-context-tcb/private-cipher-ctx(^s: mbedtls-cipher-context-tcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-cipher-context-tp/private-cipher-ctx)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-cipher-ctx(s: intptr_t, private-cipher-ctx: c-pointer<()>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_cipher_ctx = (void*)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-cipher-ctx(s: mbedtls-cipher-context-tp, private-cipher-ctx: c-pointer<()>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-cipher-ctx(private-cipher-ctx)

pub inline fun mbedtls-cipher-context-tc/set-private-cipher-ctx(^s: mbedtls-cipher-context-tc<s::S>, private-cipher-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-cipher-ctx(private-cipher-ctx))

pub inline fun mbedtls-cipher-context-tcb/set-private-cipher-ctx(^s: mbedtls-cipher-context-tcb<s::S>, private-cipher-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-cipher-ctx(private-cipher-ctx))

pub inline extern mbedtls-cipher-context-t-ptrraw/private-cmac-ctx(s: intptr_t): c-pointer<mbedtls-cmac-context-t-c>
  c inline "(intptr_t)(((struct mbedtls_cipher_context_t*)#1)->private_cmac_ctx)"

pub inline fun mbedtls-cipher-context-tp/private-cmac-ctx(s: mbedtls-cipher-context-tp): <> c-pointer<mbedtls-cmac-context-t-c>
  s.cextern/c-pointer/ptr.mbedtls-cipher-context-t-ptrraw/private-cmac-ctx

pub inline fun mbedtls-cipher-context-tc/private-cmac-ctx(^s: mbedtls-cipher-context-tc<s::S>): <> c-pointer<mbedtls-cmac-context-t-c>
  s.with-ptr(mbedtls-cipher-context-tp/private-cmac-ctx)

pub inline fun mbedtls-cipher-context-tcb/private-cmac-ctx(^s: mbedtls-cipher-context-tcb<s::S>): <> c-pointer<mbedtls-cmac-context-t-c>
  s.with-ptr(mbedtls-cipher-context-tp/private-cmac-ctx)

pub inline extern mbedtls-cipher-context-t-ptrraw/set-private-cmac-ctx(s: intptr_t, private-cmac-ctx: c-pointer<mbedtls-cmac-context-t-c>): ()
  c inline "((struct mbedtls_cipher_context_t*)#1)->private_cmac_ctx = (struct mbedtls_cmac_context_t*)#2"

pub inline fun mbedtls-cipher-context-tp/set-private-cmac-ctx(s: mbedtls-cipher-context-tp, private-cmac-ctx: c-pointer<mbedtls-cmac-context-t-c>): ()
  s.mbedtls-cipher-context-t-ptrraw/set-private-cmac-ctx(private-cmac-ctx)

pub inline fun mbedtls-cipher-context-tc/set-private-cmac-ctx(^s: mbedtls-cipher-context-tc<s::S>, private-cmac-ctx: c-pointer<mbedtls-cmac-context-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-cmac-ctx(private-cmac-ctx))

pub inline fun mbedtls-cipher-context-tcb/set-private-cmac-ctx(^s: mbedtls-cipher-context-tcb<s::S>, private-cmac-ctx: c-pointer<mbedtls-cmac-context-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-cipher-context-tp/set-private-cmac-ctx(private-cmac-ctx))

pub struct mbedtls-psa-cipher-operation-t
  private-alg: int
  private-iv-length: int
  private-block-length: int
  private-ctx: unnamed-union3-c

pub type mbedtls-psa-cipher-operation-t-c
pub alias mbedtls-psa-cipher-operation-tp = c-pointer<mbedtls-psa-cipher-operation-t-c>
pub alias mbedtls-psa-cipher-operation-tc = owned-c<mbedtls-psa-cipher-operation-t-c>
pub alias mbedtls-psa-cipher-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-cipher-operation-t-c>
pub alias mbedtls-psa-cipher-operation-tca = owned-c<c-array<mbedtls-psa-cipher-operation-t-c>>

pub extern mbedtls-psa-cipher-operation-t/size-of(c: c-null<mbedtls-psa-cipher-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_cipher_operation_t)"

pub fun mbedtls-psa-cipher-operation-tc(): mbedtls-psa-cipher-operation-tc
  malloc(?size-of=mbedtls-psa-cipher-operation-t/size-of)

pub fun mbedtls-psa-cipher-operation-tc-calloc(): mbedtls-psa-cipher-operation-tc
  malloc-c(?size-of=mbedtls-psa-cipher-operation-t/size-of)

pub fun mbedtls-psa-cipher-operation-tc-array(n: int): mbedtls-psa-cipher-operation-tca
  malloc(n.int32, ?size-of=mbedtls-psa-cipher-operation-t/size-of)

pub fun mbedtls-psa-cipher-operation-tc-array-calloc(n: int): mbedtls-psa-cipher-operation-tca
  malloc-c(n.int32, ?size-of=mbedtls-psa-cipher-operation-t/size-of)

pub inline extern mbedtls-psa-cipher-operation-t-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((mbedtls_psa_cipher_operation_t*)#1)->private_alg)"

pub inline fun mbedtls-psa-cipher-operation-tp/private-alg(s: mbedtls-psa-cipher-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-cipher-operation-t-ptrraw/private-alg.int

pub inline fun mbedtls-psa-cipher-operation-tc/private-alg(^s: mbedtls-psa-cipher-operation-tc): <> int
  s.with-ptr(mbedtls-psa-cipher-operation-tp/private-alg)

pub inline fun mbedtls-psa-cipher-operation-tcb/private-alg(^s: mbedtls-psa-cipher-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-cipher-operation-tp/private-alg)

pub inline extern mbedtls-psa-cipher-operation-t-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((mbedtls_psa_cipher_operation_t*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun mbedtls-psa-cipher-operation-tp/set-private-alg(s: mbedtls-psa-cipher-operation-tp, private-alg: int): ()
  s.mbedtls-psa-cipher-operation-t-ptrraw/set-private-alg(private-alg.int32)

pub inline fun mbedtls-psa-cipher-operation-tc/set-private-alg(^s: mbedtls-psa-cipher-operation-tc, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-cipher-operation-tp/set-private-alg(private-alg))

pub inline fun mbedtls-psa-cipher-operation-tcb/set-private-alg(^s: mbedtls-psa-cipher-operation-tcb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-cipher-operation-tp/set-private-alg(private-alg))

pub inline extern mbedtls-psa-cipher-operation-t-ptrraw/private-iv-length(s: intptr_t): int8
  c inline "(uint8_t)(((mbedtls_psa_cipher_operation_t*)#1)->private_iv_length)"

pub inline fun mbedtls-psa-cipher-operation-tp/private-iv-length(s: mbedtls-psa-cipher-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-cipher-operation-t-ptrraw/private-iv-length.int

pub inline fun mbedtls-psa-cipher-operation-tc/private-iv-length(^s: mbedtls-psa-cipher-operation-tc): <> int
  s.with-ptr(mbedtls-psa-cipher-operation-tp/private-iv-length)

pub inline fun mbedtls-psa-cipher-operation-tcb/private-iv-length(^s: mbedtls-psa-cipher-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-cipher-operation-tp/private-iv-length)

pub inline extern mbedtls-psa-cipher-operation-t-ptrraw/set-private-iv-length(s: intptr_t, private-iv-length: int8): ()
  c inline "((mbedtls_psa_cipher_operation_t*)#1)->private_iv_length = (uint8_t)#2"

pub inline fun mbedtls-psa-cipher-operation-tp/set-private-iv-length(s: mbedtls-psa-cipher-operation-tp, private-iv-length: int): ()
  s.mbedtls-psa-cipher-operation-t-ptrraw/set-private-iv-length(private-iv-length.int8)

pub inline fun mbedtls-psa-cipher-operation-tc/set-private-iv-length(^s: mbedtls-psa-cipher-operation-tc, private-iv-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-cipher-operation-tp/set-private-iv-length(private-iv-length))

pub inline fun mbedtls-psa-cipher-operation-tcb/set-private-iv-length(^s: mbedtls-psa-cipher-operation-tcb<s::S>, private-iv-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-cipher-operation-tp/set-private-iv-length(private-iv-length))

pub inline extern mbedtls-psa-cipher-operation-t-ptrraw/private-block-length(s: intptr_t): int8
  c inline "(uint8_t)(((mbedtls_psa_cipher_operation_t*)#1)->private_block_length)"

pub inline fun mbedtls-psa-cipher-operation-tp/private-block-length(s: mbedtls-psa-cipher-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-cipher-operation-t-ptrraw/private-block-length.int

pub inline fun mbedtls-psa-cipher-operation-tc/private-block-length(^s: mbedtls-psa-cipher-operation-tc): <> int
  s.with-ptr(mbedtls-psa-cipher-operation-tp/private-block-length)

pub inline fun mbedtls-psa-cipher-operation-tcb/private-block-length(^s: mbedtls-psa-cipher-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-cipher-operation-tp/private-block-length)

pub inline extern mbedtls-psa-cipher-operation-t-ptrraw/set-private-block-length(s: intptr_t, private-block-length: int8): ()
  c inline "((mbedtls_psa_cipher_operation_t*)#1)->private_block_length = (uint8_t)#2"

pub inline fun mbedtls-psa-cipher-operation-tp/set-private-block-length(s: mbedtls-psa-cipher-operation-tp, private-block-length: int): ()
  s.mbedtls-psa-cipher-operation-t-ptrraw/set-private-block-length(private-block-length.int8)

pub inline fun mbedtls-psa-cipher-operation-tc/set-private-block-length(^s: mbedtls-psa-cipher-operation-tc, private-block-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-cipher-operation-tp/set-private-block-length(private-block-length))

pub inline fun mbedtls-psa-cipher-operation-tcb/set-private-block-length(^s: mbedtls-psa-cipher-operation-tcb<s::S>, private-block-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-cipher-operation-tp/set-private-block-length(private-block-length))

pub struct unnamed-union3
pub type unnamed-union3-c
pub alias unnamed-union3p = c-pointer<unnamed-union3-c>
pub alias unnamed-union3c = owned-c<unnamed-union3-c>
pub alias unnamed-union3cb<s::S> = borrowed-c<s,unnamed-union3-c>
pub alias unnamed-union3ca = owned-c<c-array<unnamed-union3-c>>

pub struct psa-driver-cipher-context-t
pub type psa-driver-cipher-context-t-c
pub alias psa-driver-cipher-context-tp = c-pointer<psa-driver-cipher-context-t-c>
pub alias psa-driver-cipher-context-tc = owned-c<psa-driver-cipher-context-t-c>
pub alias psa-driver-cipher-context-tcb<s::S> = borrowed-c<s,psa-driver-cipher-context-t-c>
pub alias psa-driver-cipher-context-tca = owned-c<c-array<psa-driver-cipher-context-t-c>>

// \brief          The GCM context structure.
pub struct mbedtls-gcm-context
pub type mbedtls-gcm-context-c
pub alias mbedtls-gcm-contextp = c-pointer<mbedtls-gcm-context-c>
pub alias mbedtls-gcm-contextc<s::S> = owned-c<mbedtls-gcm-context-c>
pub alias mbedtls-gcm-contextcb<s::S> = borrowed-c<s,mbedtls-gcm-context-c>
pub alias mbedtls-gcm-contextca<s::S> = owned-c<c-array<mbedtls-gcm-context-c>>

pub extern mbedtls-gcm-context/size-of(c: c-null<mbedtls-gcm-context-c>): int32
  c inline "sizeof(struct mbedtls_gcm_context)"

pub fun mbedtls-gcm-contextc(): mbedtls-gcm-contextc<s::S>
  malloc(?size-of=mbedtls-gcm-context/size-of)

pub fun mbedtls-gcm-contextc-calloc(): mbedtls-gcm-contextc<s::S>
  malloc-c(?size-of=mbedtls-gcm-context/size-of)

pub fun mbedtls-gcm-contextc-array(n: int): mbedtls-gcm-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-gcm-context/size-of)

pub fun mbedtls-gcm-contextc-array-calloc(n: int): mbedtls-gcm-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-gcm-context/size-of)

pub inline extern mbedtls-gcm-context-ptrraw/private-h(s: intptr_t): c-pointer<c-array<int>>
  c inline "(intptr_t)(((struct mbedtls_gcm_context*)#1)->private_H)"

pub inline fun mbedtls-gcm-contextp/private-h(s: mbedtls-gcm-contextp): <> c-array<c-array<int>>
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-h.cextern/ptr/carray

pub inline fun mbedtls-gcm-contextc/private-h(^s: mbedtls-gcm-contextc<s::S>): <> c-array<c-array<int>>
  s.with-ptr(mbedtls-gcm-contextp/private-h)

pub inline fun mbedtls-gcm-contextcb/private-h(^s: mbedtls-gcm-contextcb<s::S>): <> c-array<c-array<int>>
  s.with-ptr(mbedtls-gcm-contextp/private-h)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-h(s: intptr_t, private-h: c-pointer<c-array<int>>): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_H = (int64_t**)#2"

pub inline fun mbedtls-gcm-contextp/set-private-h(s: mbedtls-gcm-contextp, private-h: c-array<c-array<int>>): ()
  s.mbedtls-gcm-context-ptrraw/set-private-h(private-h.cextern/carray/ptr)

pub inline fun mbedtls-gcm-contextc/set-private-h(^s: mbedtls-gcm-contextc<s::S>, private-h: c-array<c-array<int>>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-h(private-h))

pub inline fun mbedtls-gcm-contextcb/set-private-h(^s: mbedtls-gcm-contextcb<s::S>, private-h: c-array<c-array<int>>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-h(private-h))

pub inline extern mbedtls-gcm-context-ptrraw/private-len(s: intptr_t): int64
  c inline "(int64_t)(((struct mbedtls_gcm_context*)#1)->private_len)"

pub inline fun mbedtls-gcm-contextp/private-len(s: mbedtls-gcm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-len.int

pub inline fun mbedtls-gcm-contextc/private-len(^s: mbedtls-gcm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-len)

pub inline fun mbedtls-gcm-contextcb/private-len(^s: mbedtls-gcm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-len)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-len(s: intptr_t, private-len: int64): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_len = (int64_t)#2"

pub inline fun mbedtls-gcm-contextp/set-private-len(s: mbedtls-gcm-contextp, private-len: int): ()
  s.mbedtls-gcm-context-ptrraw/set-private-len(private-len.int64)

pub inline fun mbedtls-gcm-contextc/set-private-len(^s: mbedtls-gcm-contextc<s::S>, private-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-len(private-len))

pub inline fun mbedtls-gcm-contextcb/set-private-len(^s: mbedtls-gcm-contextcb<s::S>, private-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-len(private-len))

pub inline extern mbedtls-gcm-context-ptrraw/private-add-len(s: intptr_t): int64
  c inline "(int64_t)(((struct mbedtls_gcm_context*)#1)->private_add_len)"

pub inline fun mbedtls-gcm-contextp/private-add-len(s: mbedtls-gcm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-add-len.int

pub inline fun mbedtls-gcm-contextc/private-add-len(^s: mbedtls-gcm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-add-len)

pub inline fun mbedtls-gcm-contextcb/private-add-len(^s: mbedtls-gcm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-add-len)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-add-len(s: intptr_t, private-add-len: int64): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_add_len = (int64_t)#2"

pub inline fun mbedtls-gcm-contextp/set-private-add-len(s: mbedtls-gcm-contextp, private-add-len: int): ()
  s.mbedtls-gcm-context-ptrraw/set-private-add-len(private-add-len.int64)

pub inline fun mbedtls-gcm-contextc/set-private-add-len(^s: mbedtls-gcm-contextc<s::S>, private-add-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-add-len(private-add-len))

pub inline fun mbedtls-gcm-contextcb/set-private-add-len(^s: mbedtls-gcm-contextcb<s::S>, private-add-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-add-len(private-add-len))

pub inline extern mbedtls-gcm-context-ptrraw/private-base-ectr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_gcm_context*)#1)->private_base_ectr)"

pub inline fun mbedtls-gcm-contextp/private-base-ectr(s: mbedtls-gcm-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-base-ectr.cextern/ptr/carray

pub inline fun mbedtls-gcm-contextc/private-base-ectr(^s: mbedtls-gcm-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-gcm-contextp/private-base-ectr)

pub inline fun mbedtls-gcm-contextcb/private-base-ectr(^s: mbedtls-gcm-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-gcm-contextp/private-base-ectr)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-base-ectr(s: intptr_t, private-base-ectr: c-pointer<int>): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_base_ectr = (unsigned char*)#2"

pub inline fun mbedtls-gcm-contextp/set-private-base-ectr(s: mbedtls-gcm-contextp, private-base-ectr: c-array<int>): ()
  s.mbedtls-gcm-context-ptrraw/set-private-base-ectr(private-base-ectr.cextern/carray/ptr)

pub inline fun mbedtls-gcm-contextc/set-private-base-ectr(^s: mbedtls-gcm-contextc<s::S>, private-base-ectr: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-base-ectr(private-base-ectr))

pub inline fun mbedtls-gcm-contextcb/set-private-base-ectr(^s: mbedtls-gcm-contextcb<s::S>, private-base-ectr: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-base-ectr(private-base-ectr))

pub inline extern mbedtls-gcm-context-ptrraw/private-y(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_gcm_context*)#1)->private_y)"

pub inline fun mbedtls-gcm-contextp/private-y(s: mbedtls-gcm-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-y.cextern/ptr/carray

pub inline fun mbedtls-gcm-contextc/private-y(^s: mbedtls-gcm-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-gcm-contextp/private-y)

pub inline fun mbedtls-gcm-contextcb/private-y(^s: mbedtls-gcm-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-gcm-contextp/private-y)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-y(s: intptr_t, private-y: c-pointer<int>): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_y = (unsigned char*)#2"

pub inline fun mbedtls-gcm-contextp/set-private-y(s: mbedtls-gcm-contextp, private-y: c-array<int>): ()
  s.mbedtls-gcm-context-ptrraw/set-private-y(private-y.cextern/carray/ptr)

pub inline fun mbedtls-gcm-contextc/set-private-y(^s: mbedtls-gcm-contextc<s::S>, private-y: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-y(private-y))

pub inline fun mbedtls-gcm-contextcb/set-private-y(^s: mbedtls-gcm-contextcb<s::S>, private-y: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-y(private-y))

pub inline extern mbedtls-gcm-context-ptrraw/private-buf(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_gcm_context*)#1)->private_buf)"

pub inline fun mbedtls-gcm-contextp/private-buf(s: mbedtls-gcm-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-buf.cextern/ptr/carray

pub inline fun mbedtls-gcm-contextc/private-buf(^s: mbedtls-gcm-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-gcm-contextp/private-buf)

pub inline fun mbedtls-gcm-contextcb/private-buf(^s: mbedtls-gcm-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-gcm-contextp/private-buf)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-buf(s: intptr_t, private-buf: c-pointer<int>): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_buf = (unsigned char*)#2"

pub inline fun mbedtls-gcm-contextp/set-private-buf(s: mbedtls-gcm-contextp, private-buf: c-array<int>): ()
  s.mbedtls-gcm-context-ptrraw/set-private-buf(private-buf.cextern/carray/ptr)

pub inline fun mbedtls-gcm-contextc/set-private-buf(^s: mbedtls-gcm-contextc<s::S>, private-buf: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-buf(private-buf))

pub inline fun mbedtls-gcm-contextcb/set-private-buf(^s: mbedtls-gcm-contextcb<s::S>, private-buf: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-buf(private-buf))

pub inline extern mbedtls-gcm-context-ptrraw/private-mode(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_gcm_context*)#1)->private_mode)"

pub inline fun mbedtls-gcm-contextp/private-mode(s: mbedtls-gcm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-mode.int

pub inline fun mbedtls-gcm-contextc/private-mode(^s: mbedtls-gcm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-mode)

pub inline fun mbedtls-gcm-contextcb/private-mode(^s: mbedtls-gcm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-mode)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-mode(s: intptr_t, private-mode: int8): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_mode = (unsigned char)#2"

pub inline fun mbedtls-gcm-contextp/set-private-mode(s: mbedtls-gcm-contextp, private-mode: int): ()
  s.mbedtls-gcm-context-ptrraw/set-private-mode(private-mode.int8)

pub inline fun mbedtls-gcm-contextc/set-private-mode(^s: mbedtls-gcm-contextc<s::S>, private-mode: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-mode(private-mode))

pub inline fun mbedtls-gcm-contextcb/set-private-mode(^s: mbedtls-gcm-contextcb<s::S>, private-mode: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-mode(private-mode))

pub inline extern mbedtls-gcm-context-ptrraw/private-acceleration(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_gcm_context*)#1)->private_acceleration)"

pub inline fun mbedtls-gcm-contextp/private-acceleration(s: mbedtls-gcm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-gcm-context-ptrraw/private-acceleration.int

pub inline fun mbedtls-gcm-contextc/private-acceleration(^s: mbedtls-gcm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-acceleration)

pub inline fun mbedtls-gcm-contextcb/private-acceleration(^s: mbedtls-gcm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-gcm-contextp/private-acceleration)

pub inline extern mbedtls-gcm-context-ptrraw/set-private-acceleration(s: intptr_t, private-acceleration: int8): ()
  c inline "((struct mbedtls_gcm_context*)#1)->private_acceleration = (unsigned char)#2"

pub inline fun mbedtls-gcm-contextp/set-private-acceleration(s: mbedtls-gcm-contextp, private-acceleration: int): ()
  s.mbedtls-gcm-context-ptrraw/set-private-acceleration(private-acceleration.int8)

pub inline fun mbedtls-gcm-contextc/set-private-acceleration(^s: mbedtls-gcm-contextc<s::S>, private-acceleration: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-acceleration(private-acceleration))

pub inline fun mbedtls-gcm-contextcb/set-private-acceleration(^s: mbedtls-gcm-contextcb<s::S>, private-acceleration: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-gcm-contextp/set-private-acceleration(private-acceleration))

// \brief    The CCM context-type definition. The CCM context is passed
// to the APIs called.
pub struct mbedtls-ccm-context
pub type mbedtls-ccm-context-c
pub alias mbedtls-ccm-contextp = c-pointer<mbedtls-ccm-context-c>
pub alias mbedtls-ccm-contextc<s::S> = owned-c<mbedtls-ccm-context-c>
pub alias mbedtls-ccm-contextcb<s::S> = borrowed-c<s,mbedtls-ccm-context-c>
pub alias mbedtls-ccm-contextca<s::S> = owned-c<c-array<mbedtls-ccm-context-c>>

pub extern mbedtls-ccm-context/size-of(c: c-null<mbedtls-ccm-context-c>): int32
  c inline "sizeof(struct mbedtls_ccm_context)"

pub fun mbedtls-ccm-contextc(): mbedtls-ccm-contextc<s::S>
  malloc(?size-of=mbedtls-ccm-context/size-of)

pub fun mbedtls-ccm-contextc-calloc(): mbedtls-ccm-contextc<s::S>
  malloc-c(?size-of=mbedtls-ccm-context/size-of)

pub fun mbedtls-ccm-contextc-array(n: int): mbedtls-ccm-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ccm-context/size-of)

pub fun mbedtls-ccm-contextc-array-calloc(n: int): mbedtls-ccm-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ccm-context/size-of)

pub inline extern mbedtls-ccm-context-ptrraw/private-y(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ccm_context*)#1)->private_y)"

pub inline fun mbedtls-ccm-contextp/private-y(s: mbedtls-ccm-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-y.cextern/ptr/carray

pub inline fun mbedtls-ccm-contextc/private-y(^s: mbedtls-ccm-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ccm-contextp/private-y)

pub inline fun mbedtls-ccm-contextcb/private-y(^s: mbedtls-ccm-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ccm-contextp/private-y)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-y(s: intptr_t, private-y: c-pointer<int>): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_y = (unsigned char*)#2"

pub inline fun mbedtls-ccm-contextp/set-private-y(s: mbedtls-ccm-contextp, private-y: c-array<int>): ()
  s.mbedtls-ccm-context-ptrraw/set-private-y(private-y.cextern/carray/ptr)

pub inline fun mbedtls-ccm-contextc/set-private-y(^s: mbedtls-ccm-contextc<s::S>, private-y: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-y(private-y))

pub inline fun mbedtls-ccm-contextcb/set-private-y(^s: mbedtls-ccm-contextcb<s::S>, private-y: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-y(private-y))

pub inline extern mbedtls-ccm-context-ptrraw/private-ctr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ccm_context*)#1)->private_ctr)"

pub inline fun mbedtls-ccm-contextp/private-ctr(s: mbedtls-ccm-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-ctr.cextern/ptr/carray

pub inline fun mbedtls-ccm-contextc/private-ctr(^s: mbedtls-ccm-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ccm-contextp/private-ctr)

pub inline fun mbedtls-ccm-contextcb/private-ctr(^s: mbedtls-ccm-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ccm-contextp/private-ctr)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-ctr(s: intptr_t, private-ctr: c-pointer<int>): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_ctr = (unsigned char*)#2"

pub inline fun mbedtls-ccm-contextp/set-private-ctr(s: mbedtls-ccm-contextp, private-ctr: c-array<int>): ()
  s.mbedtls-ccm-context-ptrraw/set-private-ctr(private-ctr.cextern/carray/ptr)

pub inline fun mbedtls-ccm-contextc/set-private-ctr(^s: mbedtls-ccm-contextc<s::S>, private-ctr: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-ctr(private-ctr))

pub inline fun mbedtls-ccm-contextcb/set-private-ctr(^s: mbedtls-ccm-contextcb<s::S>, private-ctr: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-ctr(private-ctr))

pub inline extern mbedtls-ccm-context-ptrraw/private-plaintext-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ccm_context*)#1)->private_plaintext_len)"

pub inline fun mbedtls-ccm-contextp/private-plaintext-len(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-plaintext-len.int

pub inline fun mbedtls-ccm-contextc/private-plaintext-len(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-plaintext-len)

pub inline fun mbedtls-ccm-contextcb/private-plaintext-len(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-plaintext-len)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-plaintext-len(s: intptr_t, private-plaintext-len: ssize_t): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_plaintext_len = (size_t)#2"

pub inline fun mbedtls-ccm-contextp/set-private-plaintext-len(s: mbedtls-ccm-contextp, private-plaintext-len: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-plaintext-len(private-plaintext-len.ssize_t)

pub inline fun mbedtls-ccm-contextc/set-private-plaintext-len(^s: mbedtls-ccm-contextc<s::S>, private-plaintext-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-plaintext-len(private-plaintext-len))

pub inline fun mbedtls-ccm-contextcb/set-private-plaintext-len(^s: mbedtls-ccm-contextcb<s::S>, private-plaintext-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-plaintext-len(private-plaintext-len))

pub inline extern mbedtls-ccm-context-ptrraw/private-add-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ccm_context*)#1)->private_add_len)"

pub inline fun mbedtls-ccm-contextp/private-add-len(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-add-len.int

pub inline fun mbedtls-ccm-contextc/private-add-len(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-add-len)

pub inline fun mbedtls-ccm-contextcb/private-add-len(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-add-len)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-add-len(s: intptr_t, private-add-len: ssize_t): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_add_len = (size_t)#2"

pub inline fun mbedtls-ccm-contextp/set-private-add-len(s: mbedtls-ccm-contextp, private-add-len: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-add-len(private-add-len.ssize_t)

pub inline fun mbedtls-ccm-contextc/set-private-add-len(^s: mbedtls-ccm-contextc<s::S>, private-add-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-add-len(private-add-len))

pub inline fun mbedtls-ccm-contextcb/set-private-add-len(^s: mbedtls-ccm-contextcb<s::S>, private-add-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-add-len(private-add-len))

pub inline extern mbedtls-ccm-context-ptrraw/private-tag-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ccm_context*)#1)->private_tag_len)"

pub inline fun mbedtls-ccm-contextp/private-tag-len(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-tag-len.int

pub inline fun mbedtls-ccm-contextc/private-tag-len(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-tag-len)

pub inline fun mbedtls-ccm-contextcb/private-tag-len(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-tag-len)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-tag-len(s: intptr_t, private-tag-len: ssize_t): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_tag_len = (size_t)#2"

pub inline fun mbedtls-ccm-contextp/set-private-tag-len(s: mbedtls-ccm-contextp, private-tag-len: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-tag-len(private-tag-len.ssize_t)

pub inline fun mbedtls-ccm-contextc/set-private-tag-len(^s: mbedtls-ccm-contextc<s::S>, private-tag-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-tag-len(private-tag-len))

pub inline fun mbedtls-ccm-contextcb/set-private-tag-len(^s: mbedtls-ccm-contextcb<s::S>, private-tag-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-tag-len(private-tag-len))

pub inline extern mbedtls-ccm-context-ptrraw/private-processed(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ccm_context*)#1)->private_processed)"

pub inline fun mbedtls-ccm-contextp/private-processed(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-processed.int

pub inline fun mbedtls-ccm-contextc/private-processed(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-processed)

pub inline fun mbedtls-ccm-contextcb/private-processed(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-processed)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-processed(s: intptr_t, private-processed: ssize_t): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_processed = (size_t)#2"

pub inline fun mbedtls-ccm-contextp/set-private-processed(s: mbedtls-ccm-contextp, private-processed: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-processed(private-processed.ssize_t)

pub inline fun mbedtls-ccm-contextc/set-private-processed(^s: mbedtls-ccm-contextc<s::S>, private-processed: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-processed(private-processed))

pub inline fun mbedtls-ccm-contextcb/set-private-processed(^s: mbedtls-ccm-contextcb<s::S>, private-processed: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-processed(private-processed))

pub inline extern mbedtls-ccm-context-ptrraw/private-q(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_ccm_context*)#1)->private_q)"

pub inline fun mbedtls-ccm-contextp/private-q(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-q.int

pub inline fun mbedtls-ccm-contextc/private-q(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-q)

pub inline fun mbedtls-ccm-contextcb/private-q(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-q)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-q(s: intptr_t, private-q: int32): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_q = (unsigned int)#2"

pub inline fun mbedtls-ccm-contextp/set-private-q(s: mbedtls-ccm-contextp, private-q: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-q(private-q.int32)

pub inline fun mbedtls-ccm-contextc/set-private-q(^s: mbedtls-ccm-contextc<s::S>, private-q: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-q(private-q))

pub inline fun mbedtls-ccm-contextcb/set-private-q(^s: mbedtls-ccm-contextcb<s::S>, private-q: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-q(private-q))

pub inline extern mbedtls-ccm-context-ptrraw/private-mode(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_ccm_context*)#1)->private_mode)"

pub inline fun mbedtls-ccm-contextp/private-mode(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-mode.int

pub inline fun mbedtls-ccm-contextc/private-mode(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-mode)

pub inline fun mbedtls-ccm-contextcb/private-mode(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-mode)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-mode(s: intptr_t, private-mode: int32): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_mode = (unsigned int)#2"

pub inline fun mbedtls-ccm-contextp/set-private-mode(s: mbedtls-ccm-contextp, private-mode: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-mode(private-mode.int32)

pub inline fun mbedtls-ccm-contextc/set-private-mode(^s: mbedtls-ccm-contextc<s::S>, private-mode: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-mode(private-mode))

pub inline fun mbedtls-ccm-contextcb/set-private-mode(^s: mbedtls-ccm-contextcb<s::S>, private-mode: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-mode(private-mode))

pub inline extern mbedtls-ccm-context-ptrraw/private-state(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ccm_context*)#1)->private_state)"

pub inline fun mbedtls-ccm-contextp/private-state(s: mbedtls-ccm-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ccm-context-ptrraw/private-state.int

pub inline fun mbedtls-ccm-contextc/private-state(^s: mbedtls-ccm-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-state)

pub inline fun mbedtls-ccm-contextcb/private-state(^s: mbedtls-ccm-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ccm-contextp/private-state)

pub inline extern mbedtls-ccm-context-ptrraw/set-private-state(s: intptr_t, private-state: int32): ()
  c inline "((struct mbedtls_ccm_context*)#1)->private_state = (int)#2"

pub inline fun mbedtls-ccm-contextp/set-private-state(s: mbedtls-ccm-contextp, private-state: int): ()
  s.mbedtls-ccm-context-ptrraw/set-private-state(private-state.int32)

pub inline fun mbedtls-ccm-contextc/set-private-state(^s: mbedtls-ccm-contextc<s::S>, private-state: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-state(private-state))

pub inline fun mbedtls-ccm-contextcb/set-private-state(^s: mbedtls-ccm-contextcb<s::S>, private-state: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ccm-contextp/set-private-state(private-state))

pub struct mbedtls-poly1305-context
pub type mbedtls-poly1305-context-c
pub alias mbedtls-poly1305-contextp = c-pointer<mbedtls-poly1305-context-c>
pub alias mbedtls-poly1305-contextc<s::S> = owned-c<mbedtls-poly1305-context-c>
pub alias mbedtls-poly1305-contextcb<s::S> = borrowed-c<s,mbedtls-poly1305-context-c>
pub alias mbedtls-poly1305-contextca<s::S> = owned-c<c-array<mbedtls-poly1305-context-c>>

pub extern mbedtls-poly1305-context/size-of(c: c-null<mbedtls-poly1305-context-c>): int32
  c inline "sizeof(struct mbedtls_poly1305_context)"

pub fun mbedtls-poly1305-contextc(): mbedtls-poly1305-contextc<s::S>
  malloc(?size-of=mbedtls-poly1305-context/size-of)

pub fun mbedtls-poly1305-contextc-calloc(): mbedtls-poly1305-contextc<s::S>
  malloc-c(?size-of=mbedtls-poly1305-context/size-of)

pub fun mbedtls-poly1305-contextc-array(n: int): mbedtls-poly1305-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-poly1305-context/size-of)

pub fun mbedtls-poly1305-contextc-array-calloc(n: int): mbedtls-poly1305-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-poly1305-context/size-of)

pub inline extern mbedtls-poly1305-context-ptrraw/private-r(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_poly1305_context*)#1)->private_r)"

pub inline fun mbedtls-poly1305-contextp/private-r(s: mbedtls-poly1305-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-poly1305-context-ptrraw/private-r.cextern/ptr/carray

pub inline fun mbedtls-poly1305-contextc/private-r(^s: mbedtls-poly1305-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-r)

pub inline fun mbedtls-poly1305-contextcb/private-r(^s: mbedtls-poly1305-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-r)

pub inline extern mbedtls-poly1305-context-ptrraw/set-private-r(s: intptr_t, private-r: c-pointer<int>): ()
  c inline "((struct mbedtls_poly1305_context*)#1)->private_r = (int32_t*)#2"

pub inline fun mbedtls-poly1305-contextp/set-private-r(s: mbedtls-poly1305-contextp, private-r: c-array<int>): ()
  s.mbedtls-poly1305-context-ptrraw/set-private-r(private-r.cextern/carray/ptr)

pub inline fun mbedtls-poly1305-contextc/set-private-r(^s: mbedtls-poly1305-contextc<s::S>, private-r: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-r(private-r))

pub inline fun mbedtls-poly1305-contextcb/set-private-r(^s: mbedtls-poly1305-contextcb<s::S>, private-r: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-r(private-r))

pub inline extern mbedtls-poly1305-context-ptrraw/private-s(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_poly1305_context*)#1)->private_s)"

pub inline fun mbedtls-poly1305-contextp/private-s(s: mbedtls-poly1305-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-poly1305-context-ptrraw/private-s.cextern/ptr/carray

pub inline fun mbedtls-poly1305-contextc/private-s(^s: mbedtls-poly1305-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-s)

pub inline fun mbedtls-poly1305-contextcb/private-s(^s: mbedtls-poly1305-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-s)

pub inline extern mbedtls-poly1305-context-ptrraw/set-private-s(s: intptr_t, private-s: c-pointer<int>): ()
  c inline "((struct mbedtls_poly1305_context*)#1)->private_s = (int32_t*)#2"

pub inline fun mbedtls-poly1305-contextp/set-private-s(s: mbedtls-poly1305-contextp, private-s: c-array<int>): ()
  s.mbedtls-poly1305-context-ptrraw/set-private-s(private-s.cextern/carray/ptr)

pub inline fun mbedtls-poly1305-contextc/set-private-s(^s: mbedtls-poly1305-contextc<s::S>, private-s: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-s(private-s))

pub inline fun mbedtls-poly1305-contextcb/set-private-s(^s: mbedtls-poly1305-contextcb<s::S>, private-s: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-s(private-s))

pub inline extern mbedtls-poly1305-context-ptrraw/private-acc(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_poly1305_context*)#1)->private_acc)"

pub inline fun mbedtls-poly1305-contextp/private-acc(s: mbedtls-poly1305-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-poly1305-context-ptrraw/private-acc.cextern/ptr/carray

pub inline fun mbedtls-poly1305-contextc/private-acc(^s: mbedtls-poly1305-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-acc)

pub inline fun mbedtls-poly1305-contextcb/private-acc(^s: mbedtls-poly1305-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-acc)

pub inline extern mbedtls-poly1305-context-ptrraw/set-private-acc(s: intptr_t, private-acc: c-pointer<int>): ()
  c inline "((struct mbedtls_poly1305_context*)#1)->private_acc = (int32_t*)#2"

pub inline fun mbedtls-poly1305-contextp/set-private-acc(s: mbedtls-poly1305-contextp, private-acc: c-array<int>): ()
  s.mbedtls-poly1305-context-ptrraw/set-private-acc(private-acc.cextern/carray/ptr)

pub inline fun mbedtls-poly1305-contextc/set-private-acc(^s: mbedtls-poly1305-contextc<s::S>, private-acc: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-acc(private-acc))

pub inline fun mbedtls-poly1305-contextcb/set-private-acc(^s: mbedtls-poly1305-contextcb<s::S>, private-acc: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-acc(private-acc))

pub inline extern mbedtls-poly1305-context-ptrraw/private-queue(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_poly1305_context*)#1)->private_queue)"

pub inline fun mbedtls-poly1305-contextp/private-queue(s: mbedtls-poly1305-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-poly1305-context-ptrraw/private-queue.cextern/ptr/carray

pub inline fun mbedtls-poly1305-contextc/private-queue(^s: mbedtls-poly1305-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-queue)

pub inline fun mbedtls-poly1305-contextcb/private-queue(^s: mbedtls-poly1305-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-poly1305-contextp/private-queue)

pub inline extern mbedtls-poly1305-context-ptrraw/set-private-queue(s: intptr_t, private-queue: c-pointer<int>): ()
  c inline "((struct mbedtls_poly1305_context*)#1)->private_queue = (uint8_t*)#2"

pub inline fun mbedtls-poly1305-contextp/set-private-queue(s: mbedtls-poly1305-contextp, private-queue: c-array<int>): ()
  s.mbedtls-poly1305-context-ptrraw/set-private-queue(private-queue.cextern/carray/ptr)

pub inline fun mbedtls-poly1305-contextc/set-private-queue(^s: mbedtls-poly1305-contextc<s::S>, private-queue: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-queue(private-queue))

pub inline fun mbedtls-poly1305-contextcb/set-private-queue(^s: mbedtls-poly1305-contextcb<s::S>, private-queue: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-queue(private-queue))

pub inline extern mbedtls-poly1305-context-ptrraw/private-queue-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_poly1305_context*)#1)->private_queue_len)"

pub inline fun mbedtls-poly1305-contextp/private-queue-len(s: mbedtls-poly1305-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-poly1305-context-ptrraw/private-queue-len.int

pub inline fun mbedtls-poly1305-contextc/private-queue-len(^s: mbedtls-poly1305-contextc<s::S>): <> int
  s.with-ptr(mbedtls-poly1305-contextp/private-queue-len)

pub inline fun mbedtls-poly1305-contextcb/private-queue-len(^s: mbedtls-poly1305-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-poly1305-contextp/private-queue-len)

pub inline extern mbedtls-poly1305-context-ptrraw/set-private-queue-len(s: intptr_t, private-queue-len: ssize_t): ()
  c inline "((struct mbedtls_poly1305_context*)#1)->private_queue_len = (size_t)#2"

pub inline fun mbedtls-poly1305-contextp/set-private-queue-len(s: mbedtls-poly1305-contextp, private-queue-len: int): ()
  s.mbedtls-poly1305-context-ptrraw/set-private-queue-len(private-queue-len.ssize_t)

pub inline fun mbedtls-poly1305-contextc/set-private-queue-len(^s: mbedtls-poly1305-contextc<s::S>, private-queue-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-queue-len(private-queue-len))

pub inline fun mbedtls-poly1305-contextcb/set-private-queue-len(^s: mbedtls-poly1305-contextcb<s::S>, private-queue-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-poly1305-contextp/set-private-queue-len(private-queue-len))

type mbedtls-chachapoly-mode-t
  // < The mode value for performing encryption.
  MBEDTLS_CHACHAPOLY_ENCRYPT
  // < The mode value for performing decryption.
  MBEDTLS_CHACHAPOLY_DECRYPT

pub fun mbedtls-chachapoly-mode-t/int(i: mbedtls-chachapoly-mode-t): int32
  match i
    MBEDTLS_CHACHAPOLY_ENCRYPT -> 0.int32
    MBEDTLS_CHACHAPOLY_DECRYPT -> 1.int32

pub fun int/mbedtls-chachapoly-mode-t(i: int32): exn mbedtls-chachapoly-mode-t
  match i.int
    0 -> MBEDTLS_CHACHAPOLY_ENCRYPT
    1 -> MBEDTLS_CHACHAPOLY_DECRYPT

pub struct mbedtls-chacha20-context
pub type mbedtls-chacha20-context-c
pub alias mbedtls-chacha20-contextp = c-pointer<mbedtls-chacha20-context-c>
pub alias mbedtls-chacha20-contextc<s::S> = owned-c<mbedtls-chacha20-context-c>
pub alias mbedtls-chacha20-contextcb<s::S> = borrowed-c<s,mbedtls-chacha20-context-c>
pub alias mbedtls-chacha20-contextca<s::S> = owned-c<c-array<mbedtls-chacha20-context-c>>

pub extern mbedtls-chacha20-context/size-of(c: c-null<mbedtls-chacha20-context-c>): int32
  c inline "sizeof(struct mbedtls_chacha20_context)"

pub fun mbedtls-chacha20-contextc(): mbedtls-chacha20-contextc<s::S>
  malloc(?size-of=mbedtls-chacha20-context/size-of)

pub fun mbedtls-chacha20-contextc-calloc(): mbedtls-chacha20-contextc<s::S>
  malloc-c(?size-of=mbedtls-chacha20-context/size-of)

pub fun mbedtls-chacha20-contextc-array(n: int): mbedtls-chacha20-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-chacha20-context/size-of)

pub fun mbedtls-chacha20-contextc-array-calloc(n: int): mbedtls-chacha20-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-chacha20-context/size-of)

pub inline extern mbedtls-chacha20-context-ptrraw/private-state(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_chacha20_context*)#1)->private_state)"

pub inline fun mbedtls-chacha20-contextp/private-state(s: mbedtls-chacha20-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-chacha20-context-ptrraw/private-state.cextern/ptr/carray

pub inline fun mbedtls-chacha20-contextc/private-state(^s: mbedtls-chacha20-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-chacha20-contextp/private-state)

pub inline fun mbedtls-chacha20-contextcb/private-state(^s: mbedtls-chacha20-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-chacha20-contextp/private-state)

pub inline extern mbedtls-chacha20-context-ptrraw/set-private-state(s: intptr_t, private-state: c-pointer<int>): ()
  c inline "((struct mbedtls_chacha20_context*)#1)->private_state = (int32_t*)#2"

pub inline fun mbedtls-chacha20-contextp/set-private-state(s: mbedtls-chacha20-contextp, private-state: c-array<int>): ()
  s.mbedtls-chacha20-context-ptrraw/set-private-state(private-state.cextern/carray/ptr)

pub inline fun mbedtls-chacha20-contextc/set-private-state(^s: mbedtls-chacha20-contextc<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chacha20-contextp/set-private-state(private-state))

pub inline fun mbedtls-chacha20-contextcb/set-private-state(^s: mbedtls-chacha20-contextcb<s::S>, private-state: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chacha20-contextp/set-private-state(private-state))

pub inline extern mbedtls-chacha20-context-ptrraw/private-keystream8(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_chacha20_context*)#1)->private_keystream8)"

pub inline fun mbedtls-chacha20-contextp/private-keystream8(s: mbedtls-chacha20-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-chacha20-context-ptrraw/private-keystream8.cextern/ptr/carray

pub inline fun mbedtls-chacha20-contextc/private-keystream8(^s: mbedtls-chacha20-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-chacha20-contextp/private-keystream8)

pub inline fun mbedtls-chacha20-contextcb/private-keystream8(^s: mbedtls-chacha20-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-chacha20-contextp/private-keystream8)

pub inline extern mbedtls-chacha20-context-ptrraw/set-private-keystream8(s: intptr_t, private-keystream8: c-pointer<int>): ()
  c inline "((struct mbedtls_chacha20_context*)#1)->private_keystream8 = (uint8_t*)#2"

pub inline fun mbedtls-chacha20-contextp/set-private-keystream8(s: mbedtls-chacha20-contextp, private-keystream8: c-array<int>): ()
  s.mbedtls-chacha20-context-ptrraw/set-private-keystream8(private-keystream8.cextern/carray/ptr)

pub inline fun mbedtls-chacha20-contextc/set-private-keystream8(^s: mbedtls-chacha20-contextc<s::S>, private-keystream8: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chacha20-contextp/set-private-keystream8(private-keystream8))

pub inline fun mbedtls-chacha20-contextcb/set-private-keystream8(^s: mbedtls-chacha20-contextcb<s::S>, private-keystream8: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chacha20-contextp/set-private-keystream8(private-keystream8))

pub inline extern mbedtls-chacha20-context-ptrraw/private-keystream-bytes-used(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_chacha20_context*)#1)->private_keystream_bytes_used)"

pub inline fun mbedtls-chacha20-contextp/private-keystream-bytes-used(s: mbedtls-chacha20-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-chacha20-context-ptrraw/private-keystream-bytes-used.int

pub inline fun mbedtls-chacha20-contextc/private-keystream-bytes-used(^s: mbedtls-chacha20-contextc<s::S>): <> int
  s.with-ptr(mbedtls-chacha20-contextp/private-keystream-bytes-used)

pub inline fun mbedtls-chacha20-contextcb/private-keystream-bytes-used(^s: mbedtls-chacha20-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-chacha20-contextp/private-keystream-bytes-used)

pub inline extern mbedtls-chacha20-context-ptrraw/set-private-keystream-bytes-used(s: intptr_t, private-keystream-bytes-used: ssize_t): ()
  c inline "((struct mbedtls_chacha20_context*)#1)->private_keystream_bytes_used = (size_t)#2"

pub inline fun mbedtls-chacha20-contextp/set-private-keystream-bytes-used(s: mbedtls-chacha20-contextp, private-keystream-bytes-used: int): ()
  s.mbedtls-chacha20-context-ptrraw/set-private-keystream-bytes-used(private-keystream-bytes-used.ssize_t)

pub inline fun mbedtls-chacha20-contextc/set-private-keystream-bytes-used(^s: mbedtls-chacha20-contextc<s::S>, private-keystream-bytes-used: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chacha20-contextp/set-private-keystream-bytes-used(private-keystream-bytes-used))

pub inline fun mbedtls-chacha20-contextcb/set-private-keystream-bytes-used(^s: mbedtls-chacha20-contextcb<s::S>, private-keystream-bytes-used: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chacha20-contextp/set-private-keystream-bytes-used(private-keystream-bytes-used))

pub struct mbedtls-chachapoly-context
  // < The ChaCha20 context.
  private-chacha20-ctx: mbedtls-chacha20-context-c
  // < The Poly1305 context.
  private-poly1305-ctx: mbedtls-poly1305-context-c
  // < The length (bytes) of the Additional Authenticated Data.
  private-aad-len: int
  // < The length (bytes) of the ciphertext.
  private-ciphertext-len: int
  // < The current state of the context.
  private-state: int
  // < Cipher mode (encrypt or decrypt).
  private-mode: int

pub type mbedtls-chachapoly-context-c
pub alias mbedtls-chachapoly-contextp = c-pointer<mbedtls-chachapoly-context-c>
pub alias mbedtls-chachapoly-contextc = owned-c<mbedtls-chachapoly-context-c>
pub alias mbedtls-chachapoly-contextcb<s::S> = borrowed-c<s,mbedtls-chachapoly-context-c>
pub alias mbedtls-chachapoly-contextca = owned-c<c-array<mbedtls-chachapoly-context-c>>

pub extern mbedtls-chachapoly-context/size-of(c: c-null<mbedtls-chachapoly-context-c>): int32
  c inline "sizeof(struct mbedtls_chachapoly_context)"

pub fun mbedtls-chachapoly-contextc(): mbedtls-chachapoly-contextc
  malloc(?size-of=mbedtls-chachapoly-context/size-of)

pub fun mbedtls-chachapoly-contextc-calloc(): mbedtls-chachapoly-contextc
  malloc-c(?size-of=mbedtls-chachapoly-context/size-of)

pub fun mbedtls-chachapoly-contextc-array(n: int): mbedtls-chachapoly-contextca
  malloc(n.int32, ?size-of=mbedtls-chachapoly-context/size-of)

pub fun mbedtls-chachapoly-contextc-array-calloc(n: int): mbedtls-chachapoly-contextca
  malloc-c(n.int32, ?size-of=mbedtls-chachapoly-context/size-of)

pub inline extern mbedtls-chachapoly-context-ptrraw/private-aad-len(s: intptr_t): int64
  c inline "(int64_t)(((struct mbedtls_chachapoly_context*)#1)->private_aad_len)"

pub inline fun mbedtls-chachapoly-contextp/private-aad-len(s: mbedtls-chachapoly-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-chachapoly-context-ptrraw/private-aad-len.int

pub inline fun mbedtls-chachapoly-contextc/private-aad-len(^s: mbedtls-chachapoly-contextc): <> int
  s.with-ptr(mbedtls-chachapoly-contextp/private-aad-len)

pub inline fun mbedtls-chachapoly-contextcb/private-aad-len(^s: mbedtls-chachapoly-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-chachapoly-contextp/private-aad-len)

pub inline extern mbedtls-chachapoly-context-ptrraw/set-private-aad-len(s: intptr_t, private-aad-len: int64): ()
  c inline "((struct mbedtls_chachapoly_context*)#1)->private_aad_len = (int64_t)#2"

pub inline fun mbedtls-chachapoly-contextp/set-private-aad-len(s: mbedtls-chachapoly-contextp, private-aad-len: int): ()
  s.mbedtls-chachapoly-context-ptrraw/set-private-aad-len(private-aad-len.int64)

pub inline fun mbedtls-chachapoly-contextc/set-private-aad-len(^s: mbedtls-chachapoly-contextc, private-aad-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-aad-len(private-aad-len))

pub inline fun mbedtls-chachapoly-contextcb/set-private-aad-len(^s: mbedtls-chachapoly-contextcb<s::S>, private-aad-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-aad-len(private-aad-len))

pub inline extern mbedtls-chachapoly-context-ptrraw/private-ciphertext-len(s: intptr_t): int64
  c inline "(int64_t)(((struct mbedtls_chachapoly_context*)#1)->private_ciphertext_len)"

pub inline fun mbedtls-chachapoly-contextp/private-ciphertext-len(s: mbedtls-chachapoly-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-chachapoly-context-ptrraw/private-ciphertext-len.int

pub inline fun mbedtls-chachapoly-contextc/private-ciphertext-len(^s: mbedtls-chachapoly-contextc): <> int
  s.with-ptr(mbedtls-chachapoly-contextp/private-ciphertext-len)

pub inline fun mbedtls-chachapoly-contextcb/private-ciphertext-len(^s: mbedtls-chachapoly-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-chachapoly-contextp/private-ciphertext-len)

pub inline extern mbedtls-chachapoly-context-ptrraw/set-private-ciphertext-len(s: intptr_t, private-ciphertext-len: int64): ()
  c inline "((struct mbedtls_chachapoly_context*)#1)->private_ciphertext_len = (int64_t)#2"

pub inline fun mbedtls-chachapoly-contextp/set-private-ciphertext-len(s: mbedtls-chachapoly-contextp, private-ciphertext-len: int): ()
  s.mbedtls-chachapoly-context-ptrraw/set-private-ciphertext-len(private-ciphertext-len.int64)

pub inline fun mbedtls-chachapoly-contextc/set-private-ciphertext-len(^s: mbedtls-chachapoly-contextc, private-ciphertext-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-ciphertext-len(private-ciphertext-len))

pub inline fun mbedtls-chachapoly-contextcb/set-private-ciphertext-len(^s: mbedtls-chachapoly-contextcb<s::S>, private-ciphertext-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-ciphertext-len(private-ciphertext-len))

pub inline extern mbedtls-chachapoly-context-ptrraw/private-state(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_chachapoly_context*)#1)->private_state)"

pub inline fun mbedtls-chachapoly-contextp/private-state(s: mbedtls-chachapoly-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-chachapoly-context-ptrraw/private-state.int

pub inline fun mbedtls-chachapoly-contextc/private-state(^s: mbedtls-chachapoly-contextc): <> int
  s.with-ptr(mbedtls-chachapoly-contextp/private-state)

pub inline fun mbedtls-chachapoly-contextcb/private-state(^s: mbedtls-chachapoly-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-chachapoly-contextp/private-state)

pub inline extern mbedtls-chachapoly-context-ptrraw/set-private-state(s: intptr_t, private-state: int32): ()
  c inline "((struct mbedtls_chachapoly_context*)#1)->private_state = (int)#2"

pub inline fun mbedtls-chachapoly-contextp/set-private-state(s: mbedtls-chachapoly-contextp, private-state: int): ()
  s.mbedtls-chachapoly-context-ptrraw/set-private-state(private-state.int32)

pub inline fun mbedtls-chachapoly-contextc/set-private-state(^s: mbedtls-chachapoly-contextc, private-state: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-state(private-state))

pub inline fun mbedtls-chachapoly-contextcb/set-private-state(^s: mbedtls-chachapoly-contextcb<s::S>, private-state: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-state(private-state))

pub inline extern mbedtls-chachapoly-context-ptrraw/private-mode(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_chachapoly_context*)#1)->private_mode)"

pub inline fun mbedtls-chachapoly-contextp/private-mode(s: mbedtls-chachapoly-contextp): <exn> mbedtls-chachapoly-mode-t
  s.cextern/c-pointer/ptr.mbedtls-chachapoly-context-ptrraw/private-mode.int/mbedtls-chachapoly-mode-t

pub inline fun mbedtls-chachapoly-contextc/private-mode(^s: mbedtls-chachapoly-contextc): <exn> mbedtls-chachapoly-mode-t
  s.with-ptr(mbedtls-chachapoly-contextp/private-mode)

pub inline fun mbedtls-chachapoly-contextcb/private-mode(^s: mbedtls-chachapoly-contextcb<s::S>): <exn> mbedtls-chachapoly-mode-t
  s.with-ptr(mbedtls-chachapoly-contextp/private-mode)

pub inline extern mbedtls-chachapoly-context-ptrraw/set-private-mode(s: intptr_t, private-mode: int32): ()
  c inline "((struct mbedtls_chachapoly_context*)#1)->private_mode = (int32_t)#2"

pub inline fun mbedtls-chachapoly-contextp/set-private-mode(s: mbedtls-chachapoly-contextp, private-mode: mbedtls-chachapoly-mode-t): ()
  s.mbedtls-chachapoly-context-ptrraw/set-private-mode(private-mode.mbedtls-chachapoly-mode-t/int)

pub inline fun mbedtls-chachapoly-contextc/set-private-mode(^s: mbedtls-chachapoly-contextc, private-mode: mbedtls-chachapoly-mode-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-mode(private-mode))

pub inline fun mbedtls-chachapoly-contextcb/set-private-mode(^s: mbedtls-chachapoly-contextcb<s::S>, private-mode: mbedtls-chachapoly-mode-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-chachapoly-contextp/set-private-mode(private-mode))

pub struct mbedtls-psa-hmac-operation-t
pub type mbedtls-psa-hmac-operation-t-c
pub alias mbedtls-psa-hmac-operation-tp = c-pointer<mbedtls-psa-hmac-operation-t-c>
pub alias mbedtls-psa-hmac-operation-tc<s::S> = owned-c<mbedtls-psa-hmac-operation-t-c>
pub alias mbedtls-psa-hmac-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-hmac-operation-t-c>
pub alias mbedtls-psa-hmac-operation-tca<s::S> = owned-c<c-array<mbedtls-psa-hmac-operation-t-c>>

pub extern mbedtls-psa-hmac-operation-t/size-of(c: c-null<mbedtls-psa-hmac-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_hmac_operation_t)"

pub fun mbedtls-psa-hmac-operation-tc(): mbedtls-psa-hmac-operation-tc<s::S>
  malloc(?size-of=mbedtls-psa-hmac-operation-t/size-of)

pub fun mbedtls-psa-hmac-operation-tc-calloc(): mbedtls-psa-hmac-operation-tc<s::S>
  malloc-c(?size-of=mbedtls-psa-hmac-operation-t/size-of)

pub fun mbedtls-psa-hmac-operation-tc-array(n: int): mbedtls-psa-hmac-operation-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-psa-hmac-operation-t/size-of)

pub fun mbedtls-psa-hmac-operation-tc-array-calloc(n: int): mbedtls-psa-hmac-operation-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-psa-hmac-operation-t/size-of)

pub inline extern mbedtls-psa-hmac-operation-t-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((mbedtls_psa_hmac_operation_t*)#1)->private_alg)"

pub inline fun mbedtls-psa-hmac-operation-tp/private-alg(s: mbedtls-psa-hmac-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-hmac-operation-t-ptrraw/private-alg.int

pub inline fun mbedtls-psa-hmac-operation-tc/private-alg(^s: mbedtls-psa-hmac-operation-tc<s::S>): <> int
  s.with-ptr(mbedtls-psa-hmac-operation-tp/private-alg)

pub inline fun mbedtls-psa-hmac-operation-tcb/private-alg(^s: mbedtls-psa-hmac-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-hmac-operation-tp/private-alg)

pub inline extern mbedtls-psa-hmac-operation-t-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((mbedtls_psa_hmac_operation_t*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun mbedtls-psa-hmac-operation-tp/set-private-alg(s: mbedtls-psa-hmac-operation-tp, private-alg: int): ()
  s.mbedtls-psa-hmac-operation-t-ptrraw/set-private-alg(private-alg.int32)

pub inline fun mbedtls-psa-hmac-operation-tc/set-private-alg(^s: mbedtls-psa-hmac-operation-tc<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-hmac-operation-tp/set-private-alg(private-alg))

pub inline fun mbedtls-psa-hmac-operation-tcb/set-private-alg(^s: mbedtls-psa-hmac-operation-tcb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-hmac-operation-tp/set-private-alg(private-alg))

pub inline extern mbedtls-psa-hmac-operation-t-ptrraw/private-opad(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_psa_hmac_operation_t*)#1)->private_opad)"

pub inline fun mbedtls-psa-hmac-operation-tp/private-opad(s: mbedtls-psa-hmac-operation-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-psa-hmac-operation-t-ptrraw/private-opad.cextern/ptr/carray

pub inline fun mbedtls-psa-hmac-operation-tc/private-opad(^s: mbedtls-psa-hmac-operation-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-psa-hmac-operation-tp/private-opad)

pub inline fun mbedtls-psa-hmac-operation-tcb/private-opad(^s: mbedtls-psa-hmac-operation-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-psa-hmac-operation-tp/private-opad)

pub inline extern mbedtls-psa-hmac-operation-t-ptrraw/set-private-opad(s: intptr_t, private-opad: c-pointer<int>): ()
  c inline "((mbedtls_psa_hmac_operation_t*)#1)->private_opad = (uint8_t*)#2"

pub inline fun mbedtls-psa-hmac-operation-tp/set-private-opad(s: mbedtls-psa-hmac-operation-tp, private-opad: c-array<int>): ()
  s.mbedtls-psa-hmac-operation-t-ptrraw/set-private-opad(private-opad.cextern/carray/ptr)

pub inline fun mbedtls-psa-hmac-operation-tc/set-private-opad(^s: mbedtls-psa-hmac-operation-tc<s::S>, private-opad: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-hmac-operation-tp/set-private-opad(private-opad))

pub inline fun mbedtls-psa-hmac-operation-tcb/set-private-opad(^s: mbedtls-psa-hmac-operation-tcb<s::S>, private-opad: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-hmac-operation-tp/set-private-opad(private-opad))

pub value struct mbedtls-psa-mac-operation-t
  private-alg: int
  private-ctx: unnamed-union2-c

pub type mbedtls-psa-mac-operation-t-c
pub alias mbedtls-psa-mac-operation-tp = c-pointer<mbedtls-psa-mac-operation-t-c>
pub alias mbedtls-psa-mac-operation-tc = owned-c<mbedtls-psa-mac-operation-t-c>
pub alias mbedtls-psa-mac-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-mac-operation-t-c>
pub alias mbedtls-psa-mac-operation-tca = owned-c<c-array<mbedtls-psa-mac-operation-t-c>>

pub extern mbedtls-psa-mac-operation-t/size-of(c: c-null<mbedtls-psa-mac-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_mac_operation_t)"

pub fun mbedtls-psa-mac-operation-tc(): mbedtls-psa-mac-operation-tc
  malloc(?size-of=mbedtls-psa-mac-operation-t/size-of)

pub fun mbedtls-psa-mac-operation-tc-calloc(): mbedtls-psa-mac-operation-tc
  malloc-c(?size-of=mbedtls-psa-mac-operation-t/size-of)

pub fun mbedtls-psa-mac-operation-tc-array(n: int): mbedtls-psa-mac-operation-tca
  malloc(n.int32, ?size-of=mbedtls-psa-mac-operation-t/size-of)

pub fun mbedtls-psa-mac-operation-tc-array-calloc(n: int): mbedtls-psa-mac-operation-tca
  malloc-c(n.int32, ?size-of=mbedtls-psa-mac-operation-t/size-of)

pub inline extern mbedtls-psa-mac-operation-t-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((mbedtls_psa_mac_operation_t*)#1)->private_alg)"

pub inline fun mbedtls-psa-mac-operation-tp/private-alg(s: mbedtls-psa-mac-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-mac-operation-t-ptrraw/private-alg.int

pub inline fun mbedtls-psa-mac-operation-tc/private-alg(^s: mbedtls-psa-mac-operation-tc): <> int
  s.with-ptr(mbedtls-psa-mac-operation-tp/private-alg)

pub inline fun mbedtls-psa-mac-operation-tcb/private-alg(^s: mbedtls-psa-mac-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-mac-operation-tp/private-alg)

pub inline extern mbedtls-psa-mac-operation-t-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((mbedtls_psa_mac_operation_t*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun mbedtls-psa-mac-operation-tp/set-private-alg(s: mbedtls-psa-mac-operation-tp, private-alg: int): ()
  s.mbedtls-psa-mac-operation-t-ptrraw/set-private-alg(private-alg.int32)

pub inline fun mbedtls-psa-mac-operation-tc/set-private-alg(^s: mbedtls-psa-mac-operation-tc, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-mac-operation-tp/set-private-alg(private-alg))

pub inline fun mbedtls-psa-mac-operation-tcb/set-private-alg(^s: mbedtls-psa-mac-operation-tcb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-mac-operation-tp/set-private-alg(private-alg))

pub struct unnamed-union2
pub type unnamed-union2-c
pub alias unnamed-union2p = c-pointer<unnamed-union2-c>
pub alias unnamed-union2c = owned-c<unnamed-union2-c>
pub alias unnamed-union2cb<s::S> = borrowed-c<s,unnamed-union2-c>
pub alias unnamed-union2ca = owned-c<c-array<unnamed-union2-c>>

pub struct mbedtls-psa-aead-operation-t
pub type mbedtls-psa-aead-operation-t-c
pub alias mbedtls-psa-aead-operation-tp = c-pointer<mbedtls-psa-aead-operation-t-c>
pub alias mbedtls-psa-aead-operation-tc = owned-c<mbedtls-psa-aead-operation-t-c>
pub alias mbedtls-psa-aead-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-aead-operation-t-c>
pub alias mbedtls-psa-aead-operation-tca = owned-c<c-array<mbedtls-psa-aead-operation-t-c>>

pub value struct mbedtls-psa-sign-hash-interruptible-operation-t
  private-dummy: int

pub type mbedtls-psa-sign-hash-interruptible-operation-t-c
pub alias mbedtls-psa-sign-hash-interruptible-operation-tp = c-pointer<mbedtls-psa-sign-hash-interruptible-operation-t-c>
pub alias mbedtls-psa-sign-hash-interruptible-operation-tc = owned-c<mbedtls-psa-sign-hash-interruptible-operation-t-c>
pub alias mbedtls-psa-sign-hash-interruptible-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-sign-hash-interruptible-operation-t-c>
pub alias mbedtls-psa-sign-hash-interruptible-operation-tca = owned-c<c-array<mbedtls-psa-sign-hash-interruptible-operation-t-c>>

pub extern mbedtls-psa-sign-hash-interruptible-operation-t/size-of(c: c-null<mbedtls-psa-sign-hash-interruptible-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_sign_hash_interruptible_operation_t)"

pub fun mbedtls-psa-sign-hash-interruptible-operation-tc(): mbedtls-psa-sign-hash-interruptible-operation-tc
  malloc(?size-of=mbedtls-psa-sign-hash-interruptible-operation-t/size-of)

pub fun mbedtls-psa-sign-hash-interruptible-operation-tc-calloc(): mbedtls-psa-sign-hash-interruptible-operation-tc
  malloc-c(?size-of=mbedtls-psa-sign-hash-interruptible-operation-t/size-of)

pub fun mbedtls-psa-sign-hash-interruptible-operation-tc-array(n: int): mbedtls-psa-sign-hash-interruptible-operation-tca
  malloc(n.int32, ?size-of=mbedtls-psa-sign-hash-interruptible-operation-t/size-of)

pub fun mbedtls-psa-sign-hash-interruptible-operation-tc-array-calloc(n: int): mbedtls-psa-sign-hash-interruptible-operation-tca
  malloc-c(n.int32, ?size-of=mbedtls-psa-sign-hash-interruptible-operation-t/size-of)

pub inline extern mbedtls-psa-sign-hash-interruptible-operation-t-ptrraw/private-dummy(s: intptr_t): int32
  c inline "(unsigned int)(((mbedtls_psa_sign_hash_interruptible_operation_t*)#1)->private_dummy)"

pub inline fun mbedtls-psa-sign-hash-interruptible-operation-tp/private-dummy(s: mbedtls-psa-sign-hash-interruptible-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-sign-hash-interruptible-operation-t-ptrraw/private-dummy.int

pub inline fun mbedtls-psa-sign-hash-interruptible-operation-tc/private-dummy(^s: mbedtls-psa-sign-hash-interruptible-operation-tc): <> int
  s.with-ptr(mbedtls-psa-sign-hash-interruptible-operation-tp/private-dummy)

pub inline fun mbedtls-psa-sign-hash-interruptible-operation-tcb/private-dummy(^s: mbedtls-psa-sign-hash-interruptible-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-sign-hash-interruptible-operation-tp/private-dummy)

pub inline extern mbedtls-psa-sign-hash-interruptible-operation-t-ptrraw/set-private-dummy(s: intptr_t, private-dummy: int32): ()
  c inline "((mbedtls_psa_sign_hash_interruptible_operation_t*)#1)->private_dummy = (unsigned int)#2"

pub inline fun mbedtls-psa-sign-hash-interruptible-operation-tp/set-private-dummy(s: mbedtls-psa-sign-hash-interruptible-operation-tp, private-dummy: int): ()
  s.mbedtls-psa-sign-hash-interruptible-operation-t-ptrraw/set-private-dummy(private-dummy.int32)

pub inline fun mbedtls-psa-sign-hash-interruptible-operation-tc/set-private-dummy(^s: mbedtls-psa-sign-hash-interruptible-operation-tc, private-dummy: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-sign-hash-interruptible-operation-tp/set-private-dummy(private-dummy))

pub inline fun mbedtls-psa-sign-hash-interruptible-operation-tcb/set-private-dummy(^s: mbedtls-psa-sign-hash-interruptible-operation-tcb<s::S>, private-dummy: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-sign-hash-interruptible-operation-tp/set-private-dummy(private-dummy))

pub value struct mbedtls-psa-verify-hash-interruptible-operation-t
  private-dummy: int

pub type mbedtls-psa-verify-hash-interruptible-operation-t-c
pub alias mbedtls-psa-verify-hash-interruptible-operation-tp = c-pointer<mbedtls-psa-verify-hash-interruptible-operation-t-c>
pub alias mbedtls-psa-verify-hash-interruptible-operation-tc = owned-c<mbedtls-psa-verify-hash-interruptible-operation-t-c>
pub alias mbedtls-psa-verify-hash-interruptible-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-verify-hash-interruptible-operation-t-c>
pub alias mbedtls-psa-verify-hash-interruptible-operation-tca = owned-c<c-array<mbedtls-psa-verify-hash-interruptible-operation-t-c>>

pub extern mbedtls-psa-verify-hash-interruptible-operation-t/size-of(c: c-null<mbedtls-psa-verify-hash-interruptible-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_verify_hash_interruptible_operation_t)"

pub fun mbedtls-psa-verify-hash-interruptible-operation-tc(): mbedtls-psa-verify-hash-interruptible-operation-tc
  malloc(?size-of=mbedtls-psa-verify-hash-interruptible-operation-t/size-of)

pub fun mbedtls-psa-verify-hash-interruptible-operation-tc-calloc(): mbedtls-psa-verify-hash-interruptible-operation-tc
  malloc-c(?size-of=mbedtls-psa-verify-hash-interruptible-operation-t/size-of)

pub fun mbedtls-psa-verify-hash-interruptible-operation-tc-array(n: int): mbedtls-psa-verify-hash-interruptible-operation-tca
  malloc(n.int32, ?size-of=mbedtls-psa-verify-hash-interruptible-operation-t/size-of)

pub fun mbedtls-psa-verify-hash-interruptible-operation-tc-array-calloc(n: int): mbedtls-psa-verify-hash-interruptible-operation-tca
  malloc-c(n.int32, ?size-of=mbedtls-psa-verify-hash-interruptible-operation-t/size-of)

pub inline extern mbedtls-psa-verify-hash-interruptible-operation-t-ptrraw/private-dummy(s: intptr_t): int32
  c inline "(unsigned int)(((mbedtls_psa_verify_hash_interruptible_operation_t*)#1)->private_dummy)"

pub inline fun mbedtls-psa-verify-hash-interruptible-operation-tp/private-dummy(s: mbedtls-psa-verify-hash-interruptible-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-verify-hash-interruptible-operation-t-ptrraw/private-dummy.int

pub inline fun mbedtls-psa-verify-hash-interruptible-operation-tc/private-dummy(^s: mbedtls-psa-verify-hash-interruptible-operation-tc): <> int
  s.with-ptr(mbedtls-psa-verify-hash-interruptible-operation-tp/private-dummy)

pub inline fun mbedtls-psa-verify-hash-interruptible-operation-tcb/private-dummy(^s: mbedtls-psa-verify-hash-interruptible-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-verify-hash-interruptible-operation-tp/private-dummy)

pub inline extern mbedtls-psa-verify-hash-interruptible-operation-t-ptrraw/set-private-dummy(s: intptr_t, private-dummy: int32): ()
  c inline "((mbedtls_psa_verify_hash_interruptible_operation_t*)#1)->private_dummy = (unsigned int)#2"

pub inline fun mbedtls-psa-verify-hash-interruptible-operation-tp/set-private-dummy(s: mbedtls-psa-verify-hash-interruptible-operation-tp, private-dummy: int): ()
  s.mbedtls-psa-verify-hash-interruptible-operation-t-ptrraw/set-private-dummy(private-dummy.int32)

pub inline fun mbedtls-psa-verify-hash-interruptible-operation-tc/set-private-dummy(^s: mbedtls-psa-verify-hash-interruptible-operation-tc, private-dummy: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-verify-hash-interruptible-operation-tp/set-private-dummy(private-dummy))

pub inline fun mbedtls-psa-verify-hash-interruptible-operation-tcb/set-private-dummy(^s: mbedtls-psa-verify-hash-interruptible-operation-tcb<s::S>, private-dummy: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-verify-hash-interruptible-operation-tp/set-private-dummy(private-dummy))

// Roles in the EC J-PAKE exchange
type mbedtls-ecjpake-role
  // < Client
  MBEDTLS_ECJPAKE_CLIENT
  // < Server
  MBEDTLS_ECJPAKE_SERVER
  // < Undefined
  MBEDTLS_ECJPAKE_NONE

pub fun mbedtls-ecjpake-role/int(i: mbedtls-ecjpake-role): int32
  match i
    MBEDTLS_ECJPAKE_CLIENT -> 0.int32
    MBEDTLS_ECJPAKE_SERVER -> 1.int32
    MBEDTLS_ECJPAKE_NONE -> 2.int32

pub fun int/mbedtls-ecjpake-role(i: int32): exn mbedtls-ecjpake-role
  match i.int
    0 -> MBEDTLS_ECJPAKE_CLIENT
    1 -> MBEDTLS_ECJPAKE_SERVER
    2 -> MBEDTLS_ECJPAKE_NONE

// EC J-PAKE context structure.
// 
// J-PAKE is a symmetric protocol, except for the identifiers used in
// Zero-Knowledge Proofs, and the serialization of the second message
// (KeyExchange) as defined by the Thread spec.
// 
// In order to benefit from this symmetry, we choose a different naming
// convention from the Thread v1.0 spec. Correspondence is indicated in the
// description as a pair C: client name, S: server name
pub struct mbedtls-ecjpake-context
  // < Hash to use
  private-md-type: int
  // < Elliptic curve
  private-grp: mbedtls-ecp-group-c
  // < Are we client or server?
  private-role: int
  // < Format for point export
  private-point-format: int
  // < My public key 1   C: X1, S: X3
  private-xm1: mbedtls-ecp-point-c
  // < My public key 2   C: X2, S: X4
  private-xm2: mbedtls-ecp-point-c
  // < Peer public key 1 C: X3, S: X1
  private-xp1: mbedtls-ecp-point-c
  // < Peer public key 2 C: X4, S: X2
  private-xp2: mbedtls-ecp-point-c
  // < Peer public key   C: Xs, S: Xc
  private-xp: mbedtls-ecp-point-c
  // < My private key 1  C: x1, S: x3
  private-xm11: mbedtls-mpi-c
  // < My private key 2  C: x2, S: x4
  private-xm21: mbedtls-mpi-c
  // < Pre-shared secret (passphrase)
  private-s: mbedtls-mpi-c

pub type mbedtls-ecjpake-context-c
pub alias mbedtls-ecjpake-contextp = c-pointer<mbedtls-ecjpake-context-c>
pub alias mbedtls-ecjpake-contextc = owned-c<mbedtls-ecjpake-context-c>
pub alias mbedtls-ecjpake-contextcb<s::S> = borrowed-c<s,mbedtls-ecjpake-context-c>
pub alias mbedtls-ecjpake-contextca = owned-c<c-array<mbedtls-ecjpake-context-c>>

pub extern mbedtls-ecjpake-context/size-of(c: c-null<mbedtls-ecjpake-context-c>): int32
  c inline "sizeof(struct mbedtls_ecjpake_context)"

pub fun mbedtls-ecjpake-contextc(): mbedtls-ecjpake-contextc
  malloc(?size-of=mbedtls-ecjpake-context/size-of)

pub fun mbedtls-ecjpake-contextc-calloc(): mbedtls-ecjpake-contextc
  malloc-c(?size-of=mbedtls-ecjpake-context/size-of)

pub fun mbedtls-ecjpake-contextc-array(n: int): mbedtls-ecjpake-contextca
  malloc(n.int32, ?size-of=mbedtls-ecjpake-context/size-of)

pub fun mbedtls-ecjpake-contextc-array-calloc(n: int): mbedtls-ecjpake-contextca
  malloc-c(n.int32, ?size-of=mbedtls-ecjpake-context/size-of)

pub inline extern mbedtls-ecjpake-context-ptrraw/private-md-type(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ecjpake_context*)#1)->private_md_type)"

pub inline fun mbedtls-ecjpake-contextp/private-md-type(s: mbedtls-ecjpake-contextp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-ecjpake-context-ptrraw/private-md-type.int/mbedtls-md-type-t

pub inline fun mbedtls-ecjpake-contextc/private-md-type(^s: mbedtls-ecjpake-contextc): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-ecjpake-contextp/private-md-type)

pub inline fun mbedtls-ecjpake-contextcb/private-md-type(^s: mbedtls-ecjpake-contextcb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-ecjpake-contextp/private-md-type)

pub inline extern mbedtls-ecjpake-context-ptrraw/set-private-md-type(s: intptr_t, private-md-type: int32): ()
  c inline "((struct mbedtls_ecjpake_context*)#1)->private_md_type = (int32_t)#2"

pub inline fun mbedtls-ecjpake-contextp/set-private-md-type(s: mbedtls-ecjpake-contextp, private-md-type: mbedtls-md-type-t): ()
  s.mbedtls-ecjpake-context-ptrraw/set-private-md-type(private-md-type.mbedtls-md-type-t/int)

pub inline fun mbedtls-ecjpake-contextc/set-private-md-type(^s: mbedtls-ecjpake-contextc, private-md-type: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecjpake-contextp/set-private-md-type(private-md-type))

pub inline fun mbedtls-ecjpake-contextcb/set-private-md-type(^s: mbedtls-ecjpake-contextcb<s::S>, private-md-type: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecjpake-contextp/set-private-md-type(private-md-type))

pub inline extern mbedtls-ecjpake-context-ptrraw/private-role(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ecjpake_context*)#1)->private_role)"

pub inline fun mbedtls-ecjpake-contextp/private-role(s: mbedtls-ecjpake-contextp): <exn> mbedtls-ecjpake-role
  s.cextern/c-pointer/ptr.mbedtls-ecjpake-context-ptrraw/private-role.int/mbedtls-ecjpake-role

pub inline fun mbedtls-ecjpake-contextc/private-role(^s: mbedtls-ecjpake-contextc): <exn> mbedtls-ecjpake-role
  s.with-ptr(mbedtls-ecjpake-contextp/private-role)

pub inline fun mbedtls-ecjpake-contextcb/private-role(^s: mbedtls-ecjpake-contextcb<s::S>): <exn> mbedtls-ecjpake-role
  s.with-ptr(mbedtls-ecjpake-contextp/private-role)

pub inline extern mbedtls-ecjpake-context-ptrraw/set-private-role(s: intptr_t, private-role: int32): ()
  c inline "((struct mbedtls_ecjpake_context*)#1)->private_role = (int32_t)#2"

pub inline fun mbedtls-ecjpake-contextp/set-private-role(s: mbedtls-ecjpake-contextp, private-role: mbedtls-ecjpake-role): ()
  s.mbedtls-ecjpake-context-ptrraw/set-private-role(private-role.mbedtls-ecjpake-role/int)

pub inline fun mbedtls-ecjpake-contextc/set-private-role(^s: mbedtls-ecjpake-contextc, private-role: mbedtls-ecjpake-role): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecjpake-contextp/set-private-role(private-role))

pub inline fun mbedtls-ecjpake-contextcb/set-private-role(^s: mbedtls-ecjpake-contextcb<s::S>, private-role: mbedtls-ecjpake-role): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecjpake-contextp/set-private-role(private-role))

pub inline extern mbedtls-ecjpake-context-ptrraw/private-point-format(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ecjpake_context*)#1)->private_point_format)"

pub inline fun mbedtls-ecjpake-contextp/private-point-format(s: mbedtls-ecjpake-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecjpake-context-ptrraw/private-point-format.int

pub inline fun mbedtls-ecjpake-contextc/private-point-format(^s: mbedtls-ecjpake-contextc): <> int
  s.with-ptr(mbedtls-ecjpake-contextp/private-point-format)

pub inline fun mbedtls-ecjpake-contextcb/private-point-format(^s: mbedtls-ecjpake-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ecjpake-contextp/private-point-format)

pub inline extern mbedtls-ecjpake-context-ptrraw/set-private-point-format(s: intptr_t, private-point-format: int32): ()
  c inline "((struct mbedtls_ecjpake_context*)#1)->private_point_format = (int)#2"

pub inline fun mbedtls-ecjpake-contextp/set-private-point-format(s: mbedtls-ecjpake-contextp, private-point-format: int): ()
  s.mbedtls-ecjpake-context-ptrraw/set-private-point-format(private-point-format.int32)

pub inline fun mbedtls-ecjpake-contextc/set-private-point-format(^s: mbedtls-ecjpake-contextc, private-point-format: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecjpake-contextp/set-private-point-format(private-point-format))

pub inline fun mbedtls-ecjpake-contextcb/set-private-point-format(^s: mbedtls-ecjpake-contextcb<s::S>, private-point-format: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecjpake-contextp/set-private-point-format(private-point-format))

pub struct mbedtls-psa-pake-operation-t
pub type mbedtls-psa-pake-operation-t-c
pub alias mbedtls-psa-pake-operation-tp = c-pointer<mbedtls-psa-pake-operation-t-c>
pub alias mbedtls-psa-pake-operation-tc<s::S> = owned-c<mbedtls-psa-pake-operation-t-c>
pub alias mbedtls-psa-pake-operation-tcb<s::S> = borrowed-c<s,mbedtls-psa-pake-operation-t-c>
pub alias mbedtls-psa-pake-operation-tca<s::S> = owned-c<c-array<mbedtls-psa-pake-operation-t-c>>

pub extern mbedtls-psa-pake-operation-t/size-of(c: c-null<mbedtls-psa-pake-operation-t-c>): int32
  c inline "sizeof(mbedtls_psa_pake_operation_t)"

pub fun mbedtls-psa-pake-operation-tc(): mbedtls-psa-pake-operation-tc<s::S>
  malloc(?size-of=mbedtls-psa-pake-operation-t/size-of)

pub fun mbedtls-psa-pake-operation-tc-calloc(): mbedtls-psa-pake-operation-tc<s::S>
  malloc-c(?size-of=mbedtls-psa-pake-operation-t/size-of)

pub fun mbedtls-psa-pake-operation-tc-array(n: int): mbedtls-psa-pake-operation-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-psa-pake-operation-t/size-of)

pub fun mbedtls-psa-pake-operation-tc-array-calloc(n: int): mbedtls-psa-pake-operation-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-psa-pake-operation-t/size-of)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((mbedtls_psa_pake_operation_t*)#1)->private_alg)"

pub inline fun mbedtls-psa-pake-operation-tp/private-alg(s: mbedtls-psa-pake-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-alg.int

pub inline fun mbedtls-psa-pake-operation-tc/private-alg(^s: mbedtls-psa-pake-operation-tc<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-alg)

pub inline fun mbedtls-psa-pake-operation-tcb/private-alg(^s: mbedtls-psa-pake-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-alg)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-alg(s: mbedtls-psa-pake-operation-tp, private-alg: int): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-alg(private-alg.int32)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-alg(^s: mbedtls-psa-pake-operation-tc<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-alg(private-alg))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-alg(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-alg(private-alg))

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-password(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_psa_pake_operation_t*)#1)->private_password)"

pub inline fun mbedtls-psa-pake-operation-tp/private-password(s: mbedtls-psa-pake-operation-tp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-password

pub inline fun mbedtls-psa-pake-operation-tc/private-password(^s: mbedtls-psa-pake-operation-tc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-password)

pub inline fun mbedtls-psa-pake-operation-tcb/private-password(^s: mbedtls-psa-pake-operation-tcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-password)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-password(s: intptr_t, private-password: c-pointer<int>): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_password = (uint8_t*)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-password(s: mbedtls-psa-pake-operation-tp, private-password: c-pointer<int>): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-password(private-password)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-password(^s: mbedtls-psa-pake-operation-tc<s::S>, private-password: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-password(private-password))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-password(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-password: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-password(private-password))

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-password-len(s: intptr_t): ssize_t
  c inline "(size_t)(((mbedtls_psa_pake_operation_t*)#1)->private_password_len)"

pub inline fun mbedtls-psa-pake-operation-tp/private-password-len(s: mbedtls-psa-pake-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-password-len.int

pub inline fun mbedtls-psa-pake-operation-tc/private-password-len(^s: mbedtls-psa-pake-operation-tc<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-password-len)

pub inline fun mbedtls-psa-pake-operation-tcb/private-password-len(^s: mbedtls-psa-pake-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-password-len)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-password-len(s: intptr_t, private-password-len: ssize_t): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_password_len = (size_t)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-password-len(s: mbedtls-psa-pake-operation-tp, private-password-len: int): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-password-len(private-password-len.ssize_t)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-password-len(^s: mbedtls-psa-pake-operation-tc<s::S>, private-password-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-password-len(private-password-len))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-password-len(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-password-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-password-len(private-password-len))

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-role(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_psa_pake_operation_t*)#1)->private_role)"

pub inline fun mbedtls-psa-pake-operation-tp/private-role(s: mbedtls-psa-pake-operation-tp): <exn> mbedtls-ecjpake-role
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-role.int/mbedtls-ecjpake-role

pub inline fun mbedtls-psa-pake-operation-tc/private-role(^s: mbedtls-psa-pake-operation-tc<s::S>): <exn> mbedtls-ecjpake-role
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-role)

pub inline fun mbedtls-psa-pake-operation-tcb/private-role(^s: mbedtls-psa-pake-operation-tcb<s::S>): <exn> mbedtls-ecjpake-role
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-role)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-role(s: intptr_t, private-role: int32): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_role = (int32_t)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-role(s: mbedtls-psa-pake-operation-tp, private-role: mbedtls-ecjpake-role): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-role(private-role.mbedtls-ecjpake-role/int)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-role(^s: mbedtls-psa-pake-operation-tc<s::S>, private-role: mbedtls-ecjpake-role): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-role(private-role))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-role(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-role: mbedtls-ecjpake-role): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-role(private-role))

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-buffer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_psa_pake_operation_t*)#1)->private_buffer)"

pub inline fun mbedtls-psa-pake-operation-tp/private-buffer(s: mbedtls-psa-pake-operation-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-buffer.cextern/ptr/carray

pub inline fun mbedtls-psa-pake-operation-tc/private-buffer(^s: mbedtls-psa-pake-operation-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-buffer)

pub inline fun mbedtls-psa-pake-operation-tcb/private-buffer(^s: mbedtls-psa-pake-operation-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-buffer)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-buffer(s: intptr_t, private-buffer: c-pointer<int>): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_buffer = (uint8_t*)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-buffer(s: mbedtls-psa-pake-operation-tp, private-buffer: c-array<int>): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-buffer(private-buffer.cextern/carray/ptr)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-buffer(^s: mbedtls-psa-pake-operation-tc<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-buffer(private-buffer))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-buffer(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-buffer: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-buffer(private-buffer))

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-buffer-length(s: intptr_t): ssize_t
  c inline "(size_t)(((mbedtls_psa_pake_operation_t*)#1)->private_buffer_length)"

pub inline fun mbedtls-psa-pake-operation-tp/private-buffer-length(s: mbedtls-psa-pake-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-buffer-length.int

pub inline fun mbedtls-psa-pake-operation-tc/private-buffer-length(^s: mbedtls-psa-pake-operation-tc<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-buffer-length)

pub inline fun mbedtls-psa-pake-operation-tcb/private-buffer-length(^s: mbedtls-psa-pake-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-buffer-length)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-buffer-length(s: intptr_t, private-buffer-length: ssize_t): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_buffer_length = (size_t)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-buffer-length(s: mbedtls-psa-pake-operation-tp, private-buffer-length: int): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-buffer-length(private-buffer-length.ssize_t)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-buffer-length(^s: mbedtls-psa-pake-operation-tc<s::S>, private-buffer-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-buffer-length(private-buffer-length))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-buffer-length(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-buffer-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-buffer-length(private-buffer-length))

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/private-buffer-offset(s: intptr_t): ssize_t
  c inline "(size_t)(((mbedtls_psa_pake_operation_t*)#1)->private_buffer_offset)"

pub inline fun mbedtls-psa-pake-operation-tp/private-buffer-offset(s: mbedtls-psa-pake-operation-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-pake-operation-t-ptrraw/private-buffer-offset.int

pub inline fun mbedtls-psa-pake-operation-tc/private-buffer-offset(^s: mbedtls-psa-pake-operation-tc<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-buffer-offset)

pub inline fun mbedtls-psa-pake-operation-tcb/private-buffer-offset(^s: mbedtls-psa-pake-operation-tcb<s::S>): <> int
  s.with-ptr(mbedtls-psa-pake-operation-tp/private-buffer-offset)

pub inline extern mbedtls-psa-pake-operation-t-ptrraw/set-private-buffer-offset(s: intptr_t, private-buffer-offset: ssize_t): ()
  c inline "((mbedtls_psa_pake_operation_t*)#1)->private_buffer_offset = (size_t)#2"

pub inline fun mbedtls-psa-pake-operation-tp/set-private-buffer-offset(s: mbedtls-psa-pake-operation-tp, private-buffer-offset: int): ()
  s.mbedtls-psa-pake-operation-t-ptrraw/set-private-buffer-offset(private-buffer-offset.ssize_t)

pub inline fun mbedtls-psa-pake-operation-tc/set-private-buffer-offset(^s: mbedtls-psa-pake-operation-tc<s::S>, private-buffer-offset: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-buffer-offset(private-buffer-offset))

pub inline fun mbedtls-psa-pake-operation-tcb/set-private-buffer-offset(^s: mbedtls-psa-pake-operation-tcb<s::S>, private-buffer-offset: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-pake-operation-tp/set-private-buffer-offset(private-buffer-offset))

pub struct unnamed-union5
pub type unnamed-union5-c
pub alias unnamed-union5p = c-pointer<unnamed-union5-c>
pub alias unnamed-union5c = owned-c<unnamed-union5-c>
pub alias unnamed-union5cb<s::S> = borrowed-c<s,unnamed-union5-c>
pub alias unnamed-union5ca = owned-c<c-array<unnamed-union5-c>>

pub struct psa-driver-mac-context-t
pub type psa-driver-mac-context-t-c
pub alias psa-driver-mac-context-tp = c-pointer<psa-driver-mac-context-t-c>
pub alias psa-driver-mac-context-tc = owned-c<psa-driver-mac-context-t-c>
pub alias psa-driver-mac-context-tcb<s::S> = borrowed-c<s,psa-driver-mac-context-t-c>
pub alias psa-driver-mac-context-tca = owned-c<c-array<psa-driver-mac-context-t-c>>

pub struct psa-driver-aead-context-t
pub type psa-driver-aead-context-t-c
pub alias psa-driver-aead-context-tp = c-pointer<psa-driver-aead-context-t-c>
pub alias psa-driver-aead-context-tc = owned-c<psa-driver-aead-context-t-c>
pub alias psa-driver-aead-context-tcb<s::S> = borrowed-c<s,psa-driver-aead-context-t-c>
pub alias psa-driver-aead-context-tca = owned-c<c-array<psa-driver-aead-context-t-c>>

pub struct psa-driver-sign-hash-interruptible-context-t
pub type psa-driver-sign-hash-interruptible-context-t-c
pub alias psa-driver-sign-hash-interruptible-context-tp = c-pointer<psa-driver-sign-hash-interruptible-context-t-c>
pub alias psa-driver-sign-hash-interruptible-context-tc = owned-c<psa-driver-sign-hash-interruptible-context-t-c>
pub alias psa-driver-sign-hash-interruptible-context-tcb<s::S> = borrowed-c<s,psa-driver-sign-hash-interruptible-context-t-c>
pub alias psa-driver-sign-hash-interruptible-context-tca = owned-c<c-array<psa-driver-sign-hash-interruptible-context-t-c>>

pub struct psa-driver-verify-hash-interruptible-context-t
pub type psa-driver-verify-hash-interruptible-context-t-c
pub alias psa-driver-verify-hash-interruptible-context-tp = c-pointer<psa-driver-verify-hash-interruptible-context-t-c>
pub alias psa-driver-verify-hash-interruptible-context-tc = owned-c<psa-driver-verify-hash-interruptible-context-t-c>
pub alias psa-driver-verify-hash-interruptible-context-tcb<s::S> = borrowed-c<s,psa-driver-verify-hash-interruptible-context-t-c>
pub alias psa-driver-verify-hash-interruptible-context-tca = owned-c<c-array<psa-driver-verify-hash-interruptible-context-t-c>>

pub struct psa-driver-pake-context-t
pub type psa-driver-pake-context-t-c
pub alias psa-driver-pake-context-tp = c-pointer<psa-driver-pake-context-t-c>
pub alias psa-driver-pake-context-tc = owned-c<psa-driver-pake-context-t-c>
pub alias psa-driver-pake-context-tcb<s::S> = borrowed-c<s,psa-driver-pake-context-t-c>
pub alias psa-driver-pake-context-tca = owned-c<c-array<psa-driver-pake-context-t-c>>

pub struct psa-hkdf-key-derivation-t
pub type psa-hkdf-key-derivation-t-c
pub alias psa-hkdf-key-derivation-tp = c-pointer<psa-hkdf-key-derivation-t-c>
pub alias psa-hkdf-key-derivation-tc = owned-c<psa-hkdf-key-derivation-t-c>
pub alias psa-hkdf-key-derivation-tcb<s::S> = borrowed-c<s,psa-hkdf-key-derivation-t-c>
pub alias psa-hkdf-key-derivation-tca = owned-c<c-array<psa-hkdf-key-derivation-t-c>>

pub struct psa-tls12-ecjpake-to-pms-t
pub type psa-tls12-ecjpake-to-pms-t-c
pub alias psa-tls12-ecjpake-to-pms-tp = c-pointer<psa-tls12-ecjpake-to-pms-t-c>
pub alias psa-tls12-ecjpake-to-pms-tc<s::S> = owned-c<psa-tls12-ecjpake-to-pms-t-c>
pub alias psa-tls12-ecjpake-to-pms-tcb<s::S> = borrowed-c<s,psa-tls12-ecjpake-to-pms-t-c>
pub alias psa-tls12-ecjpake-to-pms-tca<s::S> = owned-c<c-array<psa-tls12-ecjpake-to-pms-t-c>>

pub extern psa-tls12-ecjpake-to-pms-t/size-of(c: c-null<psa-tls12-ecjpake-to-pms-t-c>): int32
  c inline "sizeof(psa_tls12_ecjpake_to_pms_t)"

pub fun psa-tls12-ecjpake-to-pms-tc(): psa-tls12-ecjpake-to-pms-tc<s::S>
  malloc(?size-of=psa-tls12-ecjpake-to-pms-t/size-of)

pub fun psa-tls12-ecjpake-to-pms-tc-calloc(): psa-tls12-ecjpake-to-pms-tc<s::S>
  malloc-c(?size-of=psa-tls12-ecjpake-to-pms-t/size-of)

pub fun psa-tls12-ecjpake-to-pms-tc-array(n: int): psa-tls12-ecjpake-to-pms-tca<s::S>
  malloc(n.int32, ?size-of=psa-tls12-ecjpake-to-pms-t/size-of)

pub fun psa-tls12-ecjpake-to-pms-tc-array-calloc(n: int): psa-tls12-ecjpake-to-pms-tca<s::S>
  malloc-c(n.int32, ?size-of=psa-tls12-ecjpake-to-pms-t/size-of)

pub inline extern psa-tls12-ecjpake-to-pms-t-ptrraw/private-data(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((psa_tls12_ecjpake_to_pms_t*)#1)->private_data)"

pub inline fun psa-tls12-ecjpake-to-pms-tp/private-data(s: psa-tls12-ecjpake-to-pms-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.psa-tls12-ecjpake-to-pms-t-ptrraw/private-data.cextern/ptr/carray

pub inline fun psa-tls12-ecjpake-to-pms-tc/private-data(^s: psa-tls12-ecjpake-to-pms-tc<s::S>): <> c-array<int>
  s.with-ptr(psa-tls12-ecjpake-to-pms-tp/private-data)

pub inline fun psa-tls12-ecjpake-to-pms-tcb/private-data(^s: psa-tls12-ecjpake-to-pms-tcb<s::S>): <> c-array<int>
  s.with-ptr(psa-tls12-ecjpake-to-pms-tp/private-data)

pub inline extern psa-tls12-ecjpake-to-pms-t-ptrraw/set-private-data(s: intptr_t, private-data: c-pointer<int>): ()
  c inline "((psa_tls12_ecjpake_to_pms_t*)#1)->private_data = (uint8_t*)#2"

pub inline fun psa-tls12-ecjpake-to-pms-tp/set-private-data(s: psa-tls12-ecjpake-to-pms-tp, private-data: c-array<int>): ()
  s.psa-tls12-ecjpake-to-pms-t-ptrraw/set-private-data(private-data.cextern/carray/ptr)

pub inline fun psa-tls12-ecjpake-to-pms-tc/set-private-data(^s: psa-tls12-ecjpake-to-pms-tc<s::S>, private-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-ecjpake-to-pms-tp/set-private-data(private-data))

pub inline fun psa-tls12-ecjpake-to-pms-tcb/set-private-data(^s: psa-tls12-ecjpake-to-pms-tcb<s::S>, private-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-ecjpake-to-pms-tp/set-private-data(private-data))

type psa-tls12-prf-key-derivation-state-t
  PSA_TLS12_PRF_STATE_INIT
  PSA_TLS12_PRF_STATE_SEED_SET
  PSA_TLS12_PRF_STATE_OTHER_KEY_SET
  PSA_TLS12_PRF_STATE_KEY_SET
  PSA_TLS12_PRF_STATE_LABEL_SET
  PSA_TLS12_PRF_STATE_OUTPUT

pub fun psa-tls12-prf-key-derivation-state-t/int(i: psa-tls12-prf-key-derivation-state-t): int32
  match i
    PSA_TLS12_PRF_STATE_INIT -> 0.int32
    PSA_TLS12_PRF_STATE_SEED_SET -> 1.int32
    PSA_TLS12_PRF_STATE_OTHER_KEY_SET -> 2.int32
    PSA_TLS12_PRF_STATE_KEY_SET -> 3.int32
    PSA_TLS12_PRF_STATE_LABEL_SET -> 4.int32
    PSA_TLS12_PRF_STATE_OUTPUT -> 5.int32

pub fun int/psa-tls12-prf-key-derivation-state-t(i: int32): exn psa-tls12-prf-key-derivation-state-t
  match i.int
    0 -> PSA_TLS12_PRF_STATE_INIT
    1 -> PSA_TLS12_PRF_STATE_SEED_SET
    2 -> PSA_TLS12_PRF_STATE_OTHER_KEY_SET
    3 -> PSA_TLS12_PRF_STATE_KEY_SET
    4 -> PSA_TLS12_PRF_STATE_LABEL_SET
    5 -> PSA_TLS12_PRF_STATE_OUTPUT

pub struct psa-tls12-prf-key-derivation-s
pub type psa-tls12-prf-key-derivation-s-c
pub alias psa-tls12-prf-key-derivation-sp = c-pointer<psa-tls12-prf-key-derivation-s-c>
pub alias psa-tls12-prf-key-derivation-sc<s::S> = owned-c<psa-tls12-prf-key-derivation-s-c>
pub alias psa-tls12-prf-key-derivation-scb<s::S> = borrowed-c<s,psa-tls12-prf-key-derivation-s-c>
pub alias psa-tls12-prf-key-derivation-sca<s::S> = owned-c<c-array<psa-tls12-prf-key-derivation-s-c>>

pub extern psa-tls12-prf-key-derivation-s/size-of(c: c-null<psa-tls12-prf-key-derivation-s-c>): int32
  c inline "sizeof(struct psa_tls12_prf_key_derivation_s)"

pub fun psa-tls12-prf-key-derivation-sc(): psa-tls12-prf-key-derivation-sc<s::S>
  malloc(?size-of=psa-tls12-prf-key-derivation-s/size-of)

pub fun psa-tls12-prf-key-derivation-sc-calloc(): psa-tls12-prf-key-derivation-sc<s::S>
  malloc-c(?size-of=psa-tls12-prf-key-derivation-s/size-of)

pub fun psa-tls12-prf-key-derivation-sc-array(n: int): psa-tls12-prf-key-derivation-sca<s::S>
  malloc(n.int32, ?size-of=psa-tls12-prf-key-derivation-s/size-of)

pub fun psa-tls12-prf-key-derivation-sc-array-calloc(n: int): psa-tls12-prf-key-derivation-sca<s::S>
  malloc-c(n.int32, ?size-of=psa-tls12-prf-key-derivation-s/size-of)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-left-in-block(s: intptr_t): int8
  c inline "(uint8_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_left_in_block)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-left-in-block(s: psa-tls12-prf-key-derivation-sp): <> int
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-left-in-block.int

pub inline fun psa-tls12-prf-key-derivation-sc/private-left-in-block(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-left-in-block)

pub inline fun psa-tls12-prf-key-derivation-scb/private-left-in-block(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-left-in-block)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-left-in-block(s: intptr_t, private-left-in-block: int8): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_left_in_block = (uint8_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-left-in-block(s: psa-tls12-prf-key-derivation-sp, private-left-in-block: int): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-left-in-block(private-left-in-block.int8)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-left-in-block(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-left-in-block: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-left-in-block(private-left-in-block))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-left-in-block(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-left-in-block: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-left-in-block(private-left-in-block))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-block-number(s: intptr_t): int8
  c inline "(uint8_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_block_number)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-block-number(s: psa-tls12-prf-key-derivation-sp): <> int
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-block-number.int

pub inline fun psa-tls12-prf-key-derivation-sc/private-block-number(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-block-number)

pub inline fun psa-tls12-prf-key-derivation-scb/private-block-number(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-block-number)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-block-number(s: intptr_t, private-block-number: int8): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_block_number = (uint8_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-block-number(s: psa-tls12-prf-key-derivation-sp, private-block-number: int): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-block-number(private-block-number.int8)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-block-number(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-block-number: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-block-number(private-block-number))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-block-number(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-block-number: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-block-number(private-block-number))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-state(s: intptr_t): int32
  c inline "(int32_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_state)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-state(s: psa-tls12-prf-key-derivation-sp): <exn> psa-tls12-prf-key-derivation-state-t
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-state.int/psa-tls12-prf-key-derivation-state-t

pub inline fun psa-tls12-prf-key-derivation-sc/private-state(^s: psa-tls12-prf-key-derivation-sc<s::S>): <exn> psa-tls12-prf-key-derivation-state-t
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-state)

pub inline fun psa-tls12-prf-key-derivation-scb/private-state(^s: psa-tls12-prf-key-derivation-scb<s::S>): <exn> psa-tls12-prf-key-derivation-state-t
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-state)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-state(s: intptr_t, private-state: int32): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_state = (int32_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-state(s: psa-tls12-prf-key-derivation-sp, private-state: psa-tls12-prf-key-derivation-state-t): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-state(private-state.psa-tls12-prf-key-derivation-state-t/int)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-state(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-state: psa-tls12-prf-key-derivation-state-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-state(private-state))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-state(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-state: psa-tls12-prf-key-derivation-state-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-state(private-state))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-secret(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_secret)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-secret(s: psa-tls12-prf-key-derivation-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-secret

pub inline fun psa-tls12-prf-key-derivation-sc/private-secret(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-secret)

pub inline fun psa-tls12-prf-key-derivation-scb/private-secret(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-secret)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-secret(s: intptr_t, private-secret: c-pointer<int>): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_secret = (uint8_t*)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-secret(s: psa-tls12-prf-key-derivation-sp, private-secret: c-pointer<int>): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-secret(private-secret)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-secret(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-secret: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-secret(private-secret))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-secret(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-secret: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-secret(private-secret))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-secret-length(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_secret_length)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-secret-length(s: psa-tls12-prf-key-derivation-sp): <> int
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-secret-length.int

pub inline fun psa-tls12-prf-key-derivation-sc/private-secret-length(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-secret-length)

pub inline fun psa-tls12-prf-key-derivation-scb/private-secret-length(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-secret-length)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-secret-length(s: intptr_t, private-secret-length: ssize_t): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_secret_length = (size_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-secret-length(s: psa-tls12-prf-key-derivation-sp, private-secret-length: int): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-secret-length(private-secret-length.ssize_t)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-secret-length(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-secret-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-secret-length(private-secret-length))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-secret-length(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-secret-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-secret-length(private-secret-length))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-seed(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_seed)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-seed(s: psa-tls12-prf-key-derivation-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-seed

pub inline fun psa-tls12-prf-key-derivation-sc/private-seed(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-seed)

pub inline fun psa-tls12-prf-key-derivation-scb/private-seed(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-seed)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-seed(s: intptr_t, private-seed: c-pointer<int>): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_seed = (uint8_t*)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-seed(s: psa-tls12-prf-key-derivation-sp, private-seed: c-pointer<int>): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-seed(private-seed)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-seed(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-seed: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-seed(private-seed))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-seed(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-seed: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-seed(private-seed))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-seed-length(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_seed_length)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-seed-length(s: psa-tls12-prf-key-derivation-sp): <> int
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-seed-length.int

pub inline fun psa-tls12-prf-key-derivation-sc/private-seed-length(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-seed-length)

pub inline fun psa-tls12-prf-key-derivation-scb/private-seed-length(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-seed-length)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-seed-length(s: intptr_t, private-seed-length: ssize_t): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_seed_length = (size_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-seed-length(s: psa-tls12-prf-key-derivation-sp, private-seed-length: int): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-seed-length(private-seed-length.ssize_t)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-seed-length(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-seed-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-seed-length(private-seed-length))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-seed-length(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-seed-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-seed-length(private-seed-length))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-label(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_label)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-label(s: psa-tls12-prf-key-derivation-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-label

pub inline fun psa-tls12-prf-key-derivation-sc/private-label(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-label)

pub inline fun psa-tls12-prf-key-derivation-scb/private-label(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-label)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-label(s: intptr_t, private-label: c-pointer<int>): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_label = (uint8_t*)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-label(s: psa-tls12-prf-key-derivation-sp, private-label: c-pointer<int>): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-label(private-label)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-label(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-label: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-label(private-label))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-label(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-label: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-label(private-label))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-label-length(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_label_length)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-label-length(s: psa-tls12-prf-key-derivation-sp): <> int
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-label-length.int

pub inline fun psa-tls12-prf-key-derivation-sc/private-label-length(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-label-length)

pub inline fun psa-tls12-prf-key-derivation-scb/private-label-length(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-label-length)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-label-length(s: intptr_t, private-label-length: ssize_t): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_label_length = (size_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-label-length(s: psa-tls12-prf-key-derivation-sp, private-label-length: int): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-label-length(private-label-length.ssize_t)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-label-length(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-label-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-label-length(private-label-length))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-label-length(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-label-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-label-length(private-label-length))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-other-secret(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_other_secret)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-other-secret(s: psa-tls12-prf-key-derivation-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-other-secret

pub inline fun psa-tls12-prf-key-derivation-sc/private-other-secret(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-other-secret)

pub inline fun psa-tls12-prf-key-derivation-scb/private-other-secret(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-other-secret)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-other-secret(s: intptr_t, private-other-secret: c-pointer<int>): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_other_secret = (uint8_t*)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-other-secret(s: psa-tls12-prf-key-derivation-sp, private-other-secret: c-pointer<int>): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-other-secret(private-other-secret)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-other-secret(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-other-secret: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-other-secret(private-other-secret))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-other-secret(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-other-secret: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-other-secret(private-other-secret))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-other-secret-length(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_other_secret_length)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-other-secret-length(s: psa-tls12-prf-key-derivation-sp): <> int
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-other-secret-length.int

pub inline fun psa-tls12-prf-key-derivation-sc/private-other-secret-length(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-other-secret-length)

pub inline fun psa-tls12-prf-key-derivation-scb/private-other-secret-length(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> int
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-other-secret-length)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-other-secret-length(s: intptr_t, private-other-secret-length: ssize_t): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_other_secret_length = (size_t)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-other-secret-length(s: psa-tls12-prf-key-derivation-sp, private-other-secret-length: int): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-other-secret-length(private-other-secret-length.ssize_t)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-other-secret-length(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-other-secret-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-other-secret-length(private-other-secret-length))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-other-secret-length(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-other-secret-length: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-other-secret-length(private-other-secret-length))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-ai(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_Ai)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-ai(s: psa-tls12-prf-key-derivation-sp): <> c-array<int>
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-ai.cextern/ptr/carray

pub inline fun psa-tls12-prf-key-derivation-sc/private-ai(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> c-array<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-ai)

pub inline fun psa-tls12-prf-key-derivation-scb/private-ai(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> c-array<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-ai)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-ai(s: intptr_t, private-ai: c-pointer<int>): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_Ai = (uint8_t*)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-ai(s: psa-tls12-prf-key-derivation-sp, private-ai: c-array<int>): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-ai(private-ai.cextern/carray/ptr)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-ai(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-ai: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-ai(private-ai))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-ai(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-ai: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-ai(private-ai))

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/private-output-block(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_tls12_prf_key_derivation_s*)#1)->private_output_block)"

pub inline fun psa-tls12-prf-key-derivation-sp/private-output-block(s: psa-tls12-prf-key-derivation-sp): <> c-array<int>
  s.cextern/c-pointer/ptr.psa-tls12-prf-key-derivation-s-ptrraw/private-output-block.cextern/ptr/carray

pub inline fun psa-tls12-prf-key-derivation-sc/private-output-block(^s: psa-tls12-prf-key-derivation-sc<s::S>): <> c-array<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-output-block)

pub inline fun psa-tls12-prf-key-derivation-scb/private-output-block(^s: psa-tls12-prf-key-derivation-scb<s::S>): <> c-array<int>
  s.with-ptr(psa-tls12-prf-key-derivation-sp/private-output-block)

pub inline extern psa-tls12-prf-key-derivation-s-ptrraw/set-private-output-block(s: intptr_t, private-output-block: c-pointer<int>): ()
  c inline "((struct psa_tls12_prf_key_derivation_s*)#1)->private_output_block = (uint8_t*)#2"

pub inline fun psa-tls12-prf-key-derivation-sp/set-private-output-block(s: psa-tls12-prf-key-derivation-sp, private-output-block: c-array<int>): ()
  s.psa-tls12-prf-key-derivation-s-ptrraw/set-private-output-block(private-output-block.cextern/carray/ptr)

pub inline fun psa-tls12-prf-key-derivation-sc/set-private-output-block(^s: psa-tls12-prf-key-derivation-sc<s::S>, private-output-block: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-output-block(private-output-block))

pub inline fun psa-tls12-prf-key-derivation-scb/set-private-output-block(^s: psa-tls12-prf-key-derivation-scb<s::S>, private-output-block: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-tls12-prf-key-derivation-sp/set-private-output-block(private-output-block))

pub struct psa-driver-key-derivation-context-t
pub type psa-driver-key-derivation-context-t-c
pub alias psa-driver-key-derivation-context-tp = c-pointer<psa-driver-key-derivation-context-t-c>
pub alias psa-driver-key-derivation-context-tc = owned-c<psa-driver-key-derivation-context-t-c>
pub alias psa-driver-key-derivation-context-tcb<s::S> = borrowed-c<s,psa-driver-key-derivation-context-t-c>
pub alias psa-driver-key-derivation-context-tca = owned-c<c-array<psa-driver-key-derivation-context-t-c>>

alias psa-key-handle-t = int
// \brief Statistics about
// resource consumption related to the PSA keystore.
// 
// \note The content of this structure is not part of the stable API and ABI
// of Mbed TLS and may change arbitrarily from version to version.
pub struct mbedtls-psa-stats-s
  // Number of slots containing key material for a volatile key.
  private-volatile-slots: int
  // Number of slots containing key material for a key which is in
  // internal persistent storage.
  private-persistent-slots: int
  // Number of slots containing a reference to a key in a
  // secure element.
  private-external-slots: int
  // Number of slots which are occupied, but do not contain
  // key material yet.
  private-half-filled-slots: int
  // Number of slots that contain cache data.
  private-cache-slots: int
  // Number of slots that are not used for anything.
  private-empty-slots: int
  // Number of slots that are locked.
  private-locked-slots: int
  // Largest key id value among open keys in internal persistent storage.
  private-max-open-internal-key-id: int
  // Largest key id value among open keys in secure elements.
  private-max-open-external-key-id: int

pub type mbedtls-psa-stats-s-c
pub alias mbedtls-psa-stats-sp = c-pointer<mbedtls-psa-stats-s-c>
pub alias mbedtls-psa-stats-sc = owned-c<mbedtls-psa-stats-s-c>
pub alias mbedtls-psa-stats-scb<s::S> = borrowed-c<s,mbedtls-psa-stats-s-c>
pub alias mbedtls-psa-stats-sca = owned-c<c-array<mbedtls-psa-stats-s-c>>

pub extern mbedtls-psa-stats-s/size-of(c: c-null<mbedtls-psa-stats-s-c>): int32
  c inline "sizeof(struct mbedtls_psa_stats_s)"

pub fun mbedtls-psa-stats-sc(): mbedtls-psa-stats-sc
  malloc(?size-of=mbedtls-psa-stats-s/size-of)

pub fun mbedtls-psa-stats-sc-calloc(): mbedtls-psa-stats-sc
  malloc-c(?size-of=mbedtls-psa-stats-s/size-of)

pub fun mbedtls-psa-stats-sc-array(n: int): mbedtls-psa-stats-sca
  malloc(n.int32, ?size-of=mbedtls-psa-stats-s/size-of)

pub fun mbedtls-psa-stats-sc-array-calloc(n: int): mbedtls-psa-stats-sca
  malloc-c(n.int32, ?size-of=mbedtls-psa-stats-s/size-of)

pub inline extern mbedtls-psa-stats-s-ptrraw/private-volatile-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_volatile_slots)"

pub inline fun mbedtls-psa-stats-sp/private-volatile-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-volatile-slots.int

pub inline fun mbedtls-psa-stats-sc/private-volatile-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-volatile-slots)

pub inline fun mbedtls-psa-stats-scb/private-volatile-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-volatile-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-volatile-slots(s: intptr_t, private-volatile-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_volatile_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-volatile-slots(s: mbedtls-psa-stats-sp, private-volatile-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-volatile-slots(private-volatile-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-volatile-slots(^s: mbedtls-psa-stats-sc, private-volatile-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-volatile-slots(private-volatile-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-volatile-slots(^s: mbedtls-psa-stats-scb<s::S>, private-volatile-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-volatile-slots(private-volatile-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-persistent-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_persistent_slots)"

pub inline fun mbedtls-psa-stats-sp/private-persistent-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-persistent-slots.int

pub inline fun mbedtls-psa-stats-sc/private-persistent-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-persistent-slots)

pub inline fun mbedtls-psa-stats-scb/private-persistent-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-persistent-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-persistent-slots(s: intptr_t, private-persistent-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_persistent_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-persistent-slots(s: mbedtls-psa-stats-sp, private-persistent-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-persistent-slots(private-persistent-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-persistent-slots(^s: mbedtls-psa-stats-sc, private-persistent-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-persistent-slots(private-persistent-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-persistent-slots(^s: mbedtls-psa-stats-scb<s::S>, private-persistent-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-persistent-slots(private-persistent-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-external-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_external_slots)"

pub inline fun mbedtls-psa-stats-sp/private-external-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-external-slots.int

pub inline fun mbedtls-psa-stats-sc/private-external-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-external-slots)

pub inline fun mbedtls-psa-stats-scb/private-external-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-external-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-external-slots(s: intptr_t, private-external-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_external_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-external-slots(s: mbedtls-psa-stats-sp, private-external-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-external-slots(private-external-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-external-slots(^s: mbedtls-psa-stats-sc, private-external-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-external-slots(private-external-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-external-slots(^s: mbedtls-psa-stats-scb<s::S>, private-external-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-external-slots(private-external-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-half-filled-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_half_filled_slots)"

pub inline fun mbedtls-psa-stats-sp/private-half-filled-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-half-filled-slots.int

pub inline fun mbedtls-psa-stats-sc/private-half-filled-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-half-filled-slots)

pub inline fun mbedtls-psa-stats-scb/private-half-filled-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-half-filled-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-half-filled-slots(s: intptr_t, private-half-filled-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_half_filled_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-half-filled-slots(s: mbedtls-psa-stats-sp, private-half-filled-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-half-filled-slots(private-half-filled-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-half-filled-slots(^s: mbedtls-psa-stats-sc, private-half-filled-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-half-filled-slots(private-half-filled-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-half-filled-slots(^s: mbedtls-psa-stats-scb<s::S>, private-half-filled-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-half-filled-slots(private-half-filled-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-cache-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_cache_slots)"

pub inline fun mbedtls-psa-stats-sp/private-cache-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-cache-slots.int

pub inline fun mbedtls-psa-stats-sc/private-cache-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-cache-slots)

pub inline fun mbedtls-psa-stats-scb/private-cache-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-cache-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-cache-slots(s: intptr_t, private-cache-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_cache_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-cache-slots(s: mbedtls-psa-stats-sp, private-cache-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-cache-slots(private-cache-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-cache-slots(^s: mbedtls-psa-stats-sc, private-cache-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-cache-slots(private-cache-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-cache-slots(^s: mbedtls-psa-stats-scb<s::S>, private-cache-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-cache-slots(private-cache-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-empty-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_empty_slots)"

pub inline fun mbedtls-psa-stats-sp/private-empty-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-empty-slots.int

pub inline fun mbedtls-psa-stats-sc/private-empty-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-empty-slots)

pub inline fun mbedtls-psa-stats-scb/private-empty-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-empty-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-empty-slots(s: intptr_t, private-empty-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_empty_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-empty-slots(s: mbedtls-psa-stats-sp, private-empty-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-empty-slots(private-empty-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-empty-slots(^s: mbedtls-psa-stats-sc, private-empty-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-empty-slots(private-empty-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-empty-slots(^s: mbedtls-psa-stats-scb<s::S>, private-empty-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-empty-slots(private-empty-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-locked-slots(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_psa_stats_s*)#1)->private_locked_slots)"

pub inline fun mbedtls-psa-stats-sp/private-locked-slots(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-locked-slots.int

pub inline fun mbedtls-psa-stats-sc/private-locked-slots(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-locked-slots)

pub inline fun mbedtls-psa-stats-scb/private-locked-slots(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-locked-slots)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-locked-slots(s: intptr_t, private-locked-slots: ssize_t): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_locked_slots = (size_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-locked-slots(s: mbedtls-psa-stats-sp, private-locked-slots: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-locked-slots(private-locked-slots.ssize_t)

pub inline fun mbedtls-psa-stats-sc/set-private-locked-slots(^s: mbedtls-psa-stats-sc, private-locked-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-locked-slots(private-locked-slots))

pub inline fun mbedtls-psa-stats-scb/set-private-locked-slots(^s: mbedtls-psa-stats-scb<s::S>, private-locked-slots: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-locked-slots(private-locked-slots))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-max-open-internal-key-id(s: intptr_t): int32
  c inline "(psa_key_id_t)(((struct mbedtls_psa_stats_s*)#1)->private_max_open_internal_key_id)"

pub inline fun mbedtls-psa-stats-sp/private-max-open-internal-key-id(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-max-open-internal-key-id.int

pub inline fun mbedtls-psa-stats-sc/private-max-open-internal-key-id(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-max-open-internal-key-id)

pub inline fun mbedtls-psa-stats-scb/private-max-open-internal-key-id(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-max-open-internal-key-id)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-max-open-internal-key-id(s: intptr_t, private-max-open-internal-key-id: int32): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_max_open_internal_key_id = (psa_key_id_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-max-open-internal-key-id(s: mbedtls-psa-stats-sp, private-max-open-internal-key-id: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-max-open-internal-key-id(private-max-open-internal-key-id.int32)

pub inline fun mbedtls-psa-stats-sc/set-private-max-open-internal-key-id(^s: mbedtls-psa-stats-sc, private-max-open-internal-key-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-max-open-internal-key-id(private-max-open-internal-key-id))

pub inline fun mbedtls-psa-stats-scb/set-private-max-open-internal-key-id(^s: mbedtls-psa-stats-scb<s::S>, private-max-open-internal-key-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-max-open-internal-key-id(private-max-open-internal-key-id))

pub inline extern mbedtls-psa-stats-s-ptrraw/private-max-open-external-key-id(s: intptr_t): int32
  c inline "(psa_key_id_t)(((struct mbedtls_psa_stats_s*)#1)->private_max_open_external_key_id)"

pub inline fun mbedtls-psa-stats-sp/private-max-open-external-key-id(s: mbedtls-psa-stats-sp): <> int
  s.cextern/c-pointer/ptr.mbedtls-psa-stats-s-ptrraw/private-max-open-external-key-id.int

pub inline fun mbedtls-psa-stats-sc/private-max-open-external-key-id(^s: mbedtls-psa-stats-sc): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-max-open-external-key-id)

pub inline fun mbedtls-psa-stats-scb/private-max-open-external-key-id(^s: mbedtls-psa-stats-scb<s::S>): <> int
  s.with-ptr(mbedtls-psa-stats-sp/private-max-open-external-key-id)

pub inline extern mbedtls-psa-stats-s-ptrraw/set-private-max-open-external-key-id(s: intptr_t, private-max-open-external-key-id: int32): ()
  c inline "((struct mbedtls_psa_stats_s*)#1)->private_max_open_external_key_id = (psa_key_id_t)#2"

pub inline fun mbedtls-psa-stats-sp/set-private-max-open-external-key-id(s: mbedtls-psa-stats-sp, private-max-open-external-key-id: int): ()
  s.mbedtls-psa-stats-s-ptrraw/set-private-max-open-external-key-id(private-max-open-external-key-id.int32)

pub inline fun mbedtls-psa-stats-sc/set-private-max-open-external-key-id(^s: mbedtls-psa-stats-sc, private-max-open-external-key-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-max-open-external-key-id(private-max-open-external-key-id))

pub inline fun mbedtls-psa-stats-scb/set-private-max-open-external-key-id(^s: mbedtls-psa-stats-scb<s::S>, private-max-open-external-key-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-psa-stats-sp/set-private-max-open-external-key-id(private-max-open-external-key-id))

// \brief Statistics about
// resource consumption related to the PSA keystore.
// 
// \note The content of this structure is not part of the stable API and ABI
// of Mbed TLS and may change arbitrarily from version to version.
alias mbedtls-psa-stats-t = mbedtls-psa-stats-s-c
alias koka-mbedtls-psa-stats-t = mbedtls-psa-stats-s
pub struct psa-pake-cipher-suite-s
  algorithm: int
  type1: int
  family: int
  bits: int
  hash: int

pub type psa-pake-cipher-suite-s-c
pub alias psa-pake-cipher-suite-sp = c-pointer<psa-pake-cipher-suite-s-c>
pub alias psa-pake-cipher-suite-sc = owned-c<psa-pake-cipher-suite-s-c>
pub alias psa-pake-cipher-suite-scb<s::S> = borrowed-c<s,psa-pake-cipher-suite-s-c>
pub alias psa-pake-cipher-suite-sca = owned-c<c-array<psa-pake-cipher-suite-s-c>>

pub extern psa-pake-cipher-suite-s/size-of(c: c-null<psa-pake-cipher-suite-s-c>): int32
  c inline "sizeof(struct psa_pake_cipher_suite_s)"

pub fun psa-pake-cipher-suite-sc(): psa-pake-cipher-suite-sc
  malloc(?size-of=psa-pake-cipher-suite-s/size-of)

pub fun psa-pake-cipher-suite-sc-calloc(): psa-pake-cipher-suite-sc
  malloc-c(?size-of=psa-pake-cipher-suite-s/size-of)

pub fun psa-pake-cipher-suite-sc-array(n: int): psa-pake-cipher-suite-sca
  malloc(n.int32, ?size-of=psa-pake-cipher-suite-s/size-of)

pub fun psa-pake-cipher-suite-sc-array-calloc(n: int): psa-pake-cipher-suite-sca
  malloc-c(n.int32, ?size-of=psa-pake-cipher-suite-s/size-of)

pub inline extern psa-pake-cipher-suite-s-ptrraw/algorithm(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((struct psa_pake_cipher_suite_s*)#1)->algorithm)"

pub inline fun psa-pake-cipher-suite-sp/algorithm(s: psa-pake-cipher-suite-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-cipher-suite-s-ptrraw/algorithm.int

pub inline fun psa-pake-cipher-suite-sc/algorithm(^s: psa-pake-cipher-suite-sc): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/algorithm)

pub inline fun psa-pake-cipher-suite-scb/algorithm(^s: psa-pake-cipher-suite-scb<s::S>): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/algorithm)

pub inline extern psa-pake-cipher-suite-s-ptrraw/set-algorithm(s: intptr_t, algorithm: int32): ()
  c inline "((struct psa_pake_cipher_suite_s*)#1)->algorithm = (psa_algorithm_t)#2"

pub inline fun psa-pake-cipher-suite-sp/set-algorithm(s: psa-pake-cipher-suite-sp, algorithm: int): ()
  s.psa-pake-cipher-suite-s-ptrraw/set-algorithm(algorithm.int32)

pub inline fun psa-pake-cipher-suite-sc/set-algorithm(^s: psa-pake-cipher-suite-sc, algorithm: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-algorithm(algorithm))

pub inline fun psa-pake-cipher-suite-scb/set-algorithm(^s: psa-pake-cipher-suite-scb<s::S>, algorithm: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-algorithm(algorithm))

pub inline extern psa-pake-cipher-suite-s-ptrraw/type1(s: intptr_t): int8
  c inline "(psa_pake_primitive_type_t)(((struct psa_pake_cipher_suite_s*)#1)->type)"

pub inline fun psa-pake-cipher-suite-sp/type1(s: psa-pake-cipher-suite-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-cipher-suite-s-ptrraw/type1.int

pub inline fun psa-pake-cipher-suite-sc/type1(^s: psa-pake-cipher-suite-sc): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/type1)

pub inline fun psa-pake-cipher-suite-scb/type1(^s: psa-pake-cipher-suite-scb<s::S>): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/type1)

pub inline extern psa-pake-cipher-suite-s-ptrraw/set-type1(s: intptr_t, type1: int8): ()
  c inline "((struct psa_pake_cipher_suite_s*)#1)->type = (psa_pake_primitive_type_t)#2"

pub inline fun psa-pake-cipher-suite-sp/set-type1(s: psa-pake-cipher-suite-sp, type1: int): ()
  s.psa-pake-cipher-suite-s-ptrraw/set-type1(type1.int8)

pub inline fun psa-pake-cipher-suite-sc/set-type1(^s: psa-pake-cipher-suite-sc, type1: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-type1(type1))

pub inline fun psa-pake-cipher-suite-scb/set-type1(^s: psa-pake-cipher-suite-scb<s::S>, type1: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-type1(type1))

pub inline extern psa-pake-cipher-suite-s-ptrraw/family(s: intptr_t): int8
  c inline "(psa_pake_family_t)(((struct psa_pake_cipher_suite_s*)#1)->family)"

pub inline fun psa-pake-cipher-suite-sp/family(s: psa-pake-cipher-suite-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-cipher-suite-s-ptrraw/family.int

pub inline fun psa-pake-cipher-suite-sc/family(^s: psa-pake-cipher-suite-sc): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/family)

pub inline fun psa-pake-cipher-suite-scb/family(^s: psa-pake-cipher-suite-scb<s::S>): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/family)

pub inline extern psa-pake-cipher-suite-s-ptrraw/set-family(s: intptr_t, family: int8): ()
  c inline "((struct psa_pake_cipher_suite_s*)#1)->family = (psa_pake_family_t)#2"

pub inline fun psa-pake-cipher-suite-sp/set-family(s: psa-pake-cipher-suite-sp, family: int): ()
  s.psa-pake-cipher-suite-s-ptrraw/set-family(family.int8)

pub inline fun psa-pake-cipher-suite-sc/set-family(^s: psa-pake-cipher-suite-sc, family: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-family(family))

pub inline fun psa-pake-cipher-suite-scb/set-family(^s: psa-pake-cipher-suite-scb<s::S>, family: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-family(family))

pub inline extern psa-pake-cipher-suite-s-ptrraw/bits(s: intptr_t): int16
  c inline "(int16_t)(((struct psa_pake_cipher_suite_s*)#1)->bits)"

pub inline fun psa-pake-cipher-suite-sp/bits(s: psa-pake-cipher-suite-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-cipher-suite-s-ptrraw/bits.int

pub inline fun psa-pake-cipher-suite-sc/bits(^s: psa-pake-cipher-suite-sc): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/bits)

pub inline fun psa-pake-cipher-suite-scb/bits(^s: psa-pake-cipher-suite-scb<s::S>): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/bits)

pub inline extern psa-pake-cipher-suite-s-ptrraw/set-bits(s: intptr_t, bits: int16): ()
  c inline "((struct psa_pake_cipher_suite_s*)#1)->bits = (int16_t)#2"

pub inline fun psa-pake-cipher-suite-sp/set-bits(s: psa-pake-cipher-suite-sp, bits: int): ()
  s.psa-pake-cipher-suite-s-ptrraw/set-bits(bits.int16)

pub inline fun psa-pake-cipher-suite-sc/set-bits(^s: psa-pake-cipher-suite-sc, bits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-bits(bits))

pub inline fun psa-pake-cipher-suite-scb/set-bits(^s: psa-pake-cipher-suite-scb<s::S>, bits: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-bits(bits))

pub inline extern psa-pake-cipher-suite-s-ptrraw/hash(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((struct psa_pake_cipher_suite_s*)#1)->hash)"

pub inline fun psa-pake-cipher-suite-sp/hash(s: psa-pake-cipher-suite-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-cipher-suite-s-ptrraw/hash.int

pub inline fun psa-pake-cipher-suite-sc/hash(^s: psa-pake-cipher-suite-sc): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/hash)

pub inline fun psa-pake-cipher-suite-scb/hash(^s: psa-pake-cipher-suite-scb<s::S>): <> int
  s.with-ptr(psa-pake-cipher-suite-sp/hash)

pub inline extern psa-pake-cipher-suite-s-ptrraw/set-hash(s: intptr_t, hash: int32): ()
  c inline "((struct psa_pake_cipher_suite_s*)#1)->hash = (psa_algorithm_t)#2"

pub inline fun psa-pake-cipher-suite-sp/set-hash(s: psa-pake-cipher-suite-sp, hash: int): ()
  s.psa-pake-cipher-suite-s-ptrraw/set-hash(hash.int32)

pub inline fun psa-pake-cipher-suite-sc/set-hash(^s: psa-pake-cipher-suite-sc, hash: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-hash(hash))

pub inline fun psa-pake-cipher-suite-scb/set-hash(^s: psa-pake-cipher-suite-scb<s::S>, hash: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-cipher-suite-sp/set-hash(hash))

// Encoding of the type of the PAKE's primitive.
// 
// Values defined by this standard will never be in the range 0x80-0xff.
// Vendors who define additional types must use an encoding in this range.
// 
// For more information see the documentation of individual
// \c PSA_PAKE_PRIMITIVE_TYPE_XXX constants.
alias psa-pake-primitive-type-t = int
// \brief Encoding of the family of the primitive associated with the PAKE.
// 
// For more information see the documentation of individual
// \c PSA_PAKE_PRIMITIVE_TYPE_XXX constants.
alias psa-pake-family-t = int
// The type of the data structure for PAKE cipher suites.
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-pake-cipher-suite-t = psa-pake-cipher-suite-s-c
alias koka-psa-pake-cipher-suite-t = psa-pake-cipher-suite-s
// \brief Encoding of the primitive associated with the PAKE.
// 
// For more information see the documentation of the #PSA_PAKE_PRIMITIVE macro.
alias psa-pake-primitive-t = int
pub struct psa-pake-operation-s
  // Unique ID indicating which driver got assigned to do the
  // operation. Since driver contexts are driver-specific, swapping
  // drivers halfway through the operation is not supported.
  // ID values are auto-generated in psa_crypto_driver_wrappers.h
  // ID value zero means the context is not valid or not assigned to
  // any driver (i.e. none of the driver contexts are active).
  private-id: int
  private-alg: int
  private-primitive: int
  private-stage: int
  private-computation-stage: unnamed-union6-c
  private-data: unnamed-union7-c

pub type psa-pake-operation-s-c
pub alias psa-pake-operation-sp = c-pointer<psa-pake-operation-s-c>
pub alias psa-pake-operation-sc = owned-c<psa-pake-operation-s-c>
pub alias psa-pake-operation-scb<s::S> = borrowed-c<s,psa-pake-operation-s-c>
pub alias psa-pake-operation-sca = owned-c<c-array<psa-pake-operation-s-c>>

pub extern psa-pake-operation-s/size-of(c: c-null<psa-pake-operation-s-c>): int32
  c inline "sizeof(struct psa_pake_operation_s)"

pub fun psa-pake-operation-sc(): psa-pake-operation-sc
  malloc(?size-of=psa-pake-operation-s/size-of)

pub fun psa-pake-operation-sc-calloc(): psa-pake-operation-sc
  malloc-c(?size-of=psa-pake-operation-s/size-of)

pub fun psa-pake-operation-sc-array(n: int): psa-pake-operation-sca
  malloc(n.int32, ?size-of=psa-pake-operation-s/size-of)

pub fun psa-pake-operation-sc-array-calloc(n: int): psa-pake-operation-sca
  malloc-c(n.int32, ?size-of=psa-pake-operation-s/size-of)

pub inline extern psa-pake-operation-s-ptrraw/private-id(s: intptr_t): int32
  c inline "(unsigned int)(((struct psa_pake_operation_s*)#1)->private_id)"

pub inline fun psa-pake-operation-sp/private-id(s: psa-pake-operation-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-operation-s-ptrraw/private-id.int

pub inline fun psa-pake-operation-sc/private-id(^s: psa-pake-operation-sc): <> int
  s.with-ptr(psa-pake-operation-sp/private-id)

pub inline fun psa-pake-operation-scb/private-id(^s: psa-pake-operation-scb<s::S>): <> int
  s.with-ptr(psa-pake-operation-sp/private-id)

pub inline extern psa-pake-operation-s-ptrraw/set-private-id(s: intptr_t, private-id: int32): ()
  c inline "((struct psa_pake_operation_s*)#1)->private_id = (unsigned int)#2"

pub inline fun psa-pake-operation-sp/set-private-id(s: psa-pake-operation-sp, private-id: int): ()
  s.psa-pake-operation-s-ptrraw/set-private-id(private-id.int32)

pub inline fun psa-pake-operation-sc/set-private-id(^s: psa-pake-operation-sc, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-id(private-id))

pub inline fun psa-pake-operation-scb/set-private-id(^s: psa-pake-operation-scb<s::S>, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-id(private-id))

pub inline extern psa-pake-operation-s-ptrraw/private-alg(s: intptr_t): int32
  c inline "(psa_algorithm_t)(((struct psa_pake_operation_s*)#1)->private_alg)"

pub inline fun psa-pake-operation-sp/private-alg(s: psa-pake-operation-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-operation-s-ptrraw/private-alg.int

pub inline fun psa-pake-operation-sc/private-alg(^s: psa-pake-operation-sc): <> int
  s.with-ptr(psa-pake-operation-sp/private-alg)

pub inline fun psa-pake-operation-scb/private-alg(^s: psa-pake-operation-scb<s::S>): <> int
  s.with-ptr(psa-pake-operation-sp/private-alg)

pub inline extern psa-pake-operation-s-ptrraw/set-private-alg(s: intptr_t, private-alg: int32): ()
  c inline "((struct psa_pake_operation_s*)#1)->private_alg = (psa_algorithm_t)#2"

pub inline fun psa-pake-operation-sp/set-private-alg(s: psa-pake-operation-sp, private-alg: int): ()
  s.psa-pake-operation-s-ptrraw/set-private-alg(private-alg.int32)

pub inline fun psa-pake-operation-sc/set-private-alg(^s: psa-pake-operation-sc, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-alg(private-alg))

pub inline fun psa-pake-operation-scb/set-private-alg(^s: psa-pake-operation-scb<s::S>, private-alg: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-alg(private-alg))

pub inline extern psa-pake-operation-s-ptrraw/private-primitive(s: intptr_t): int32
  c inline "(psa_pake_primitive_t)(((struct psa_pake_operation_s*)#1)->private_primitive)"

pub inline fun psa-pake-operation-sp/private-primitive(s: psa-pake-operation-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-operation-s-ptrraw/private-primitive.int

pub inline fun psa-pake-operation-sc/private-primitive(^s: psa-pake-operation-sc): <> int
  s.with-ptr(psa-pake-operation-sp/private-primitive)

pub inline fun psa-pake-operation-scb/private-primitive(^s: psa-pake-operation-scb<s::S>): <> int
  s.with-ptr(psa-pake-operation-sp/private-primitive)

pub inline extern psa-pake-operation-s-ptrraw/set-private-primitive(s: intptr_t, private-primitive: int32): ()
  c inline "((struct psa_pake_operation_s*)#1)->private_primitive = (psa_pake_primitive_t)#2"

pub inline fun psa-pake-operation-sp/set-private-primitive(s: psa-pake-operation-sp, private-primitive: int): ()
  s.psa-pake-operation-s-ptrraw/set-private-primitive(private-primitive.int32)

pub inline fun psa-pake-operation-sc/set-private-primitive(^s: psa-pake-operation-sc, private-primitive: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-primitive(private-primitive))

pub inline fun psa-pake-operation-scb/set-private-primitive(^s: psa-pake-operation-scb<s::S>, private-primitive: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-primitive(private-primitive))

pub inline extern psa-pake-operation-s-ptrraw/private-stage(s: intptr_t): int8
  c inline "(uint8_t)(((struct psa_pake_operation_s*)#1)->private_stage)"

pub inline fun psa-pake-operation-sp/private-stage(s: psa-pake-operation-sp): <> int
  s.cextern/c-pointer/ptr.psa-pake-operation-s-ptrraw/private-stage.int

pub inline fun psa-pake-operation-sc/private-stage(^s: psa-pake-operation-sc): <> int
  s.with-ptr(psa-pake-operation-sp/private-stage)

pub inline fun psa-pake-operation-scb/private-stage(^s: psa-pake-operation-scb<s::S>): <> int
  s.with-ptr(psa-pake-operation-sp/private-stage)

pub inline extern psa-pake-operation-s-ptrraw/set-private-stage(s: intptr_t, private-stage: int8): ()
  c inline "((struct psa_pake_operation_s*)#1)->private_stage = (uint8_t)#2"

pub inline fun psa-pake-operation-sp/set-private-stage(s: psa-pake-operation-sp, private-stage: int): ()
  s.psa-pake-operation-s-ptrraw/set-private-stage(private-stage.int8)

pub inline fun psa-pake-operation-sc/set-private-stage(^s: psa-pake-operation-sc, private-stage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-stage(private-stage))

pub inline fun psa-pake-operation-scb/set-private-stage(^s: psa-pake-operation-scb<s::S>, private-stage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-pake-operation-sp/set-private-stage(private-stage))

pub struct unnamed-union6
pub type unnamed-union6-c
pub alias unnamed-union6p = c-pointer<unnamed-union6-c>
pub alias unnamed-union6c = owned-c<unnamed-union6-c>
pub alias unnamed-union6cb<s::S> = borrowed-c<s,unnamed-union6-c>
pub alias unnamed-union6ca = owned-c<c-array<unnamed-union6-c>>

// The type of computation stage for J-PAKE operations.
alias psa-jpake-computation-stage-t = psa-jpake-computation-stage-s-c
alias koka-psa-jpake-computation-stage-t = psa-jpake-computation-stage-s
pub struct psa-jpake-computation-stage-s
  private-round: int
  private-io-mode: int
  private-inputs: int
  private-outputs: int
  private-step: int

pub type psa-jpake-computation-stage-s-c
pub alias psa-jpake-computation-stage-sp = c-pointer<psa-jpake-computation-stage-s-c>
pub alias psa-jpake-computation-stage-sc = owned-c<psa-jpake-computation-stage-s-c>
pub alias psa-jpake-computation-stage-scb<s::S> = borrowed-c<s,psa-jpake-computation-stage-s-c>
pub alias psa-jpake-computation-stage-sca = owned-c<c-array<psa-jpake-computation-stage-s-c>>

pub extern psa-jpake-computation-stage-s/size-of(c: c-null<psa-jpake-computation-stage-s-c>): int32
  c inline "sizeof(struct psa_jpake_computation_stage_s)"

pub fun psa-jpake-computation-stage-sc(): psa-jpake-computation-stage-sc
  malloc(?size-of=psa-jpake-computation-stage-s/size-of)

pub fun psa-jpake-computation-stage-sc-calloc(): psa-jpake-computation-stage-sc
  malloc-c(?size-of=psa-jpake-computation-stage-s/size-of)

pub fun psa-jpake-computation-stage-sc-array(n: int): psa-jpake-computation-stage-sca
  malloc(n.int32, ?size-of=psa-jpake-computation-stage-s/size-of)

pub fun psa-jpake-computation-stage-sc-array-calloc(n: int): psa-jpake-computation-stage-sca
  malloc-c(n.int32, ?size-of=psa-jpake-computation-stage-s/size-of)

pub inline extern psa-jpake-computation-stage-s-ptrraw/private-round(s: intptr_t): int32
  c inline "(int32_t)(((struct psa_jpake_computation_stage_s*)#1)->private_round)"

pub inline fun psa-jpake-computation-stage-sp/private-round(s: psa-jpake-computation-stage-sp): <exn> psa-jpake-round
  s.cextern/c-pointer/ptr.psa-jpake-computation-stage-s-ptrraw/private-round.int/psa-jpake-round

pub inline fun psa-jpake-computation-stage-sc/private-round(^s: psa-jpake-computation-stage-sc): <exn> psa-jpake-round
  s.with-ptr(psa-jpake-computation-stage-sp/private-round)

pub inline fun psa-jpake-computation-stage-scb/private-round(^s: psa-jpake-computation-stage-scb<s::S>): <exn> psa-jpake-round
  s.with-ptr(psa-jpake-computation-stage-sp/private-round)

pub inline extern psa-jpake-computation-stage-s-ptrraw/set-private-round(s: intptr_t, private-round: int32): ()
  c inline "((struct psa_jpake_computation_stage_s*)#1)->private_round = (int32_t)#2"

pub inline fun psa-jpake-computation-stage-sp/set-private-round(s: psa-jpake-computation-stage-sp, private-round: psa-jpake-round): ()
  s.psa-jpake-computation-stage-s-ptrraw/set-private-round(private-round.psa-jpake-round/int)

pub inline fun psa-jpake-computation-stage-sc/set-private-round(^s: psa-jpake-computation-stage-sc, private-round: psa-jpake-round): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-round(private-round))

pub inline fun psa-jpake-computation-stage-scb/set-private-round(^s: psa-jpake-computation-stage-scb<s::S>, private-round: psa-jpake-round): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-round(private-round))

pub inline extern psa-jpake-computation-stage-s-ptrraw/private-io-mode(s: intptr_t): int32
  c inline "(int32_t)(((struct psa_jpake_computation_stage_s*)#1)->private_io_mode)"

pub inline fun psa-jpake-computation-stage-sp/private-io-mode(s: psa-jpake-computation-stage-sp): <exn> psa-jpake-io-mode
  s.cextern/c-pointer/ptr.psa-jpake-computation-stage-s-ptrraw/private-io-mode.int/psa-jpake-io-mode

pub inline fun psa-jpake-computation-stage-sc/private-io-mode(^s: psa-jpake-computation-stage-sc): <exn> psa-jpake-io-mode
  s.with-ptr(psa-jpake-computation-stage-sp/private-io-mode)

pub inline fun psa-jpake-computation-stage-scb/private-io-mode(^s: psa-jpake-computation-stage-scb<s::S>): <exn> psa-jpake-io-mode
  s.with-ptr(psa-jpake-computation-stage-sp/private-io-mode)

pub inline extern psa-jpake-computation-stage-s-ptrraw/set-private-io-mode(s: intptr_t, private-io-mode: int32): ()
  c inline "((struct psa_jpake_computation_stage_s*)#1)->private_io_mode = (int32_t)#2"

pub inline fun psa-jpake-computation-stage-sp/set-private-io-mode(s: psa-jpake-computation-stage-sp, private-io-mode: psa-jpake-io-mode): ()
  s.psa-jpake-computation-stage-s-ptrraw/set-private-io-mode(private-io-mode.psa-jpake-io-mode/int)

pub inline fun psa-jpake-computation-stage-sc/set-private-io-mode(^s: psa-jpake-computation-stage-sc, private-io-mode: psa-jpake-io-mode): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-io-mode(private-io-mode))

pub inline fun psa-jpake-computation-stage-scb/set-private-io-mode(^s: psa-jpake-computation-stage-scb<s::S>, private-io-mode: psa-jpake-io-mode): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-io-mode(private-io-mode))

pub inline extern psa-jpake-computation-stage-s-ptrraw/private-inputs(s: intptr_t): int8
  c inline "(uint8_t)(((struct psa_jpake_computation_stage_s*)#1)->private_inputs)"

pub inline fun psa-jpake-computation-stage-sp/private-inputs(s: psa-jpake-computation-stage-sp): <> int
  s.cextern/c-pointer/ptr.psa-jpake-computation-stage-s-ptrraw/private-inputs.int

pub inline fun psa-jpake-computation-stage-sc/private-inputs(^s: psa-jpake-computation-stage-sc): <> int
  s.with-ptr(psa-jpake-computation-stage-sp/private-inputs)

pub inline fun psa-jpake-computation-stage-scb/private-inputs(^s: psa-jpake-computation-stage-scb<s::S>): <> int
  s.with-ptr(psa-jpake-computation-stage-sp/private-inputs)

pub inline extern psa-jpake-computation-stage-s-ptrraw/set-private-inputs(s: intptr_t, private-inputs: int8): ()
  c inline "((struct psa_jpake_computation_stage_s*)#1)->private_inputs = (uint8_t)#2"

pub inline fun psa-jpake-computation-stage-sp/set-private-inputs(s: psa-jpake-computation-stage-sp, private-inputs: int): ()
  s.psa-jpake-computation-stage-s-ptrraw/set-private-inputs(private-inputs.int8)

pub inline fun psa-jpake-computation-stage-sc/set-private-inputs(^s: psa-jpake-computation-stage-sc, private-inputs: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-inputs(private-inputs))

pub inline fun psa-jpake-computation-stage-scb/set-private-inputs(^s: psa-jpake-computation-stage-scb<s::S>, private-inputs: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-inputs(private-inputs))

pub inline extern psa-jpake-computation-stage-s-ptrraw/private-outputs(s: intptr_t): int8
  c inline "(uint8_t)(((struct psa_jpake_computation_stage_s*)#1)->private_outputs)"

pub inline fun psa-jpake-computation-stage-sp/private-outputs(s: psa-jpake-computation-stage-sp): <> int
  s.cextern/c-pointer/ptr.psa-jpake-computation-stage-s-ptrraw/private-outputs.int

pub inline fun psa-jpake-computation-stage-sc/private-outputs(^s: psa-jpake-computation-stage-sc): <> int
  s.with-ptr(psa-jpake-computation-stage-sp/private-outputs)

pub inline fun psa-jpake-computation-stage-scb/private-outputs(^s: psa-jpake-computation-stage-scb<s::S>): <> int
  s.with-ptr(psa-jpake-computation-stage-sp/private-outputs)

pub inline extern psa-jpake-computation-stage-s-ptrraw/set-private-outputs(s: intptr_t, private-outputs: int8): ()
  c inline "((struct psa_jpake_computation_stage_s*)#1)->private_outputs = (uint8_t)#2"

pub inline fun psa-jpake-computation-stage-sp/set-private-outputs(s: psa-jpake-computation-stage-sp, private-outputs: int): ()
  s.psa-jpake-computation-stage-s-ptrraw/set-private-outputs(private-outputs.int8)

pub inline fun psa-jpake-computation-stage-sc/set-private-outputs(^s: psa-jpake-computation-stage-sc, private-outputs: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-outputs(private-outputs))

pub inline fun psa-jpake-computation-stage-scb/set-private-outputs(^s: psa-jpake-computation-stage-scb<s::S>, private-outputs: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-outputs(private-outputs))

pub inline extern psa-jpake-computation-stage-s-ptrraw/private-step(s: intptr_t): int8
  c inline "(psa_pake_step_t)(((struct psa_jpake_computation_stage_s*)#1)->private_step)"

pub inline fun psa-jpake-computation-stage-sp/private-step(s: psa-jpake-computation-stage-sp): <> int
  s.cextern/c-pointer/ptr.psa-jpake-computation-stage-s-ptrraw/private-step.int

pub inline fun psa-jpake-computation-stage-sc/private-step(^s: psa-jpake-computation-stage-sc): <> int
  s.with-ptr(psa-jpake-computation-stage-sp/private-step)

pub inline fun psa-jpake-computation-stage-scb/private-step(^s: psa-jpake-computation-stage-scb<s::S>): <> int
  s.with-ptr(psa-jpake-computation-stage-sp/private-step)

pub inline extern psa-jpake-computation-stage-s-ptrraw/set-private-step(s: intptr_t, private-step: int8): ()
  c inline "((struct psa_jpake_computation_stage_s*)#1)->private_step = (psa_pake_step_t)#2"

pub inline fun psa-jpake-computation-stage-sp/set-private-step(s: psa-jpake-computation-stage-sp, private-step: int): ()
  s.psa-jpake-computation-stage-s-ptrraw/set-private-step(private-step.int8)

pub inline fun psa-jpake-computation-stage-sc/set-private-step(^s: psa-jpake-computation-stage-sc, private-step: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-step(private-step))

pub inline fun psa-jpake-computation-stage-scb/set-private-step(^s: psa-jpake-computation-stage-scb<s::S>, private-step: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-jpake-computation-stage-sp/set-private-step(private-step))

type psa-jpake-round
  PSA_JPAKE_FIRST
  PSA_JPAKE_SECOND
  PSA_JPAKE_FINISHED

pub fun psa-jpake-round/int(i: psa-jpake-round): int32
  match i
    PSA_JPAKE_FIRST -> 0.int32
    PSA_JPAKE_SECOND -> 1.int32
    PSA_JPAKE_FINISHED -> 2.int32

pub fun int/psa-jpake-round(i: int32): exn psa-jpake-round
  match i.int
    0 -> PSA_JPAKE_FIRST
    1 -> PSA_JPAKE_SECOND
    2 -> PSA_JPAKE_FINISHED

type psa-jpake-io-mode
  PSA_JPAKE_INPUT
  PSA_JPAKE_OUTPUT

pub fun psa-jpake-io-mode/int(i: psa-jpake-io-mode): int32
  match i
    PSA_JPAKE_INPUT -> 0.int32
    PSA_JPAKE_OUTPUT -> 1.int32

pub fun int/psa-jpake-io-mode(i: int32): exn psa-jpake-io-mode
  match i.int
    0 -> PSA_JPAKE_INPUT
    1 -> PSA_JPAKE_OUTPUT

// Encoding of input and output indicators for PAKE.
// 
// Some PAKE algorithms need to exchange more data than just a single key share.
// This type is for encoding additional input and output data for such
// algorithms.
alias psa-pake-step-t = int
pub struct unnamed-union7
pub type unnamed-union7-c
pub alias unnamed-union7p = c-pointer<unnamed-union7-c>
pub alias unnamed-union7c = owned-c<unnamed-union7-c>
pub alias unnamed-union7cb<s::S> = borrowed-c<s,unnamed-union7-c>
pub alias unnamed-union7ca = owned-c<c-array<unnamed-union7-c>>

// The type of input values for PAKE operations.
alias psa-crypto-driver-pake-inputs-t = psa-crypto-driver-pake-inputs-s-c
alias koka-psa-crypto-driver-pake-inputs-t = psa-crypto-driver-pake-inputs-s
pub struct psa-crypto-driver-pake-inputs-s
  private-password: c-pointer<int>
  private-password-len: int
  private-user: c-pointer<int>
  private-user-len: int
  private-peer: c-pointer<int>
  private-peer-len: int
  private-attributes: koka-psa-key-attributes-t
  private-cipher-suite: koka-psa-pake-cipher-suite-t

pub type psa-crypto-driver-pake-inputs-s-c
pub alias psa-crypto-driver-pake-inputs-sp = c-pointer<psa-crypto-driver-pake-inputs-s-c>
pub alias psa-crypto-driver-pake-inputs-sc = owned-c<psa-crypto-driver-pake-inputs-s-c>
pub alias psa-crypto-driver-pake-inputs-scb<s::S> = borrowed-c<s,psa-crypto-driver-pake-inputs-s-c>
pub alias psa-crypto-driver-pake-inputs-sca = owned-c<c-array<psa-crypto-driver-pake-inputs-s-c>>

pub extern psa-crypto-driver-pake-inputs-s/size-of(c: c-null<psa-crypto-driver-pake-inputs-s-c>): int32
  c inline "sizeof(struct psa_crypto_driver_pake_inputs_s)"

pub fun psa-crypto-driver-pake-inputs-sc(): psa-crypto-driver-pake-inputs-sc
  malloc(?size-of=psa-crypto-driver-pake-inputs-s/size-of)

pub fun psa-crypto-driver-pake-inputs-sc-calloc(): psa-crypto-driver-pake-inputs-sc
  malloc-c(?size-of=psa-crypto-driver-pake-inputs-s/size-of)

pub fun psa-crypto-driver-pake-inputs-sc-array(n: int): psa-crypto-driver-pake-inputs-sca
  malloc(n.int32, ?size-of=psa-crypto-driver-pake-inputs-s/size-of)

pub fun psa-crypto-driver-pake-inputs-sc-array-calloc(n: int): psa-crypto-driver-pake-inputs-sca
  malloc-c(n.int32, ?size-of=psa-crypto-driver-pake-inputs-s/size-of)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/private-password(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_crypto_driver_pake_inputs_s*)#1)->private_password)"

pub inline fun psa-crypto-driver-pake-inputs-sp/private-password(s: psa-crypto-driver-pake-inputs-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-crypto-driver-pake-inputs-s-ptrraw/private-password

pub inline fun psa-crypto-driver-pake-inputs-sc/private-password(^s: psa-crypto-driver-pake-inputs-sc): <> c-pointer<int>
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-password)

pub inline fun psa-crypto-driver-pake-inputs-scb/private-password(^s: psa-crypto-driver-pake-inputs-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-password)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/set-private-password(s: intptr_t, private-password: c-pointer<int>): ()
  c inline "((struct psa_crypto_driver_pake_inputs_s*)#1)->private_password = (uint8_t*)#2"

pub inline fun psa-crypto-driver-pake-inputs-sp/set-private-password(s: psa-crypto-driver-pake-inputs-sp, private-password: c-pointer<int>): ()
  s.psa-crypto-driver-pake-inputs-s-ptrraw/set-private-password(private-password)

pub inline fun psa-crypto-driver-pake-inputs-sc/set-private-password(^s: psa-crypto-driver-pake-inputs-sc, private-password: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-password(private-password))

pub inline fun psa-crypto-driver-pake-inputs-scb/set-private-password(^s: psa-crypto-driver-pake-inputs-scb<s::S>, private-password: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-password(private-password))

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/private-password-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_crypto_driver_pake_inputs_s*)#1)->private_password_len)"

pub inline fun psa-crypto-driver-pake-inputs-sp/private-password-len(s: psa-crypto-driver-pake-inputs-sp): <> int
  s.cextern/c-pointer/ptr.psa-crypto-driver-pake-inputs-s-ptrraw/private-password-len.int

pub inline fun psa-crypto-driver-pake-inputs-sc/private-password-len(^s: psa-crypto-driver-pake-inputs-sc): <> int
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-password-len)

pub inline fun psa-crypto-driver-pake-inputs-scb/private-password-len(^s: psa-crypto-driver-pake-inputs-scb<s::S>): <> int
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-password-len)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/set-private-password-len(s: intptr_t, private-password-len: ssize_t): ()
  c inline "((struct psa_crypto_driver_pake_inputs_s*)#1)->private_password_len = (size_t)#2"

pub inline fun psa-crypto-driver-pake-inputs-sp/set-private-password-len(s: psa-crypto-driver-pake-inputs-sp, private-password-len: int): ()
  s.psa-crypto-driver-pake-inputs-s-ptrraw/set-private-password-len(private-password-len.ssize_t)

pub inline fun psa-crypto-driver-pake-inputs-sc/set-private-password-len(^s: psa-crypto-driver-pake-inputs-sc, private-password-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-password-len(private-password-len))

pub inline fun psa-crypto-driver-pake-inputs-scb/set-private-password-len(^s: psa-crypto-driver-pake-inputs-scb<s::S>, private-password-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-password-len(private-password-len))

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/private-user(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_crypto_driver_pake_inputs_s*)#1)->private_user)"

pub inline fun psa-crypto-driver-pake-inputs-sp/private-user(s: psa-crypto-driver-pake-inputs-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-crypto-driver-pake-inputs-s-ptrraw/private-user

pub inline fun psa-crypto-driver-pake-inputs-sc/private-user(^s: psa-crypto-driver-pake-inputs-sc): <> c-pointer<int>
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-user)

pub inline fun psa-crypto-driver-pake-inputs-scb/private-user(^s: psa-crypto-driver-pake-inputs-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-user)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/set-private-user(s: intptr_t, private-user: c-pointer<int>): ()
  c inline "((struct psa_crypto_driver_pake_inputs_s*)#1)->private_user = (uint8_t*)#2"

pub inline fun psa-crypto-driver-pake-inputs-sp/set-private-user(s: psa-crypto-driver-pake-inputs-sp, private-user: c-pointer<int>): ()
  s.psa-crypto-driver-pake-inputs-s-ptrraw/set-private-user(private-user)

pub inline fun psa-crypto-driver-pake-inputs-sc/set-private-user(^s: psa-crypto-driver-pake-inputs-sc, private-user: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-user(private-user))

pub inline fun psa-crypto-driver-pake-inputs-scb/set-private-user(^s: psa-crypto-driver-pake-inputs-scb<s::S>, private-user: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-user(private-user))

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/private-user-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_crypto_driver_pake_inputs_s*)#1)->private_user_len)"

pub inline fun psa-crypto-driver-pake-inputs-sp/private-user-len(s: psa-crypto-driver-pake-inputs-sp): <> int
  s.cextern/c-pointer/ptr.psa-crypto-driver-pake-inputs-s-ptrraw/private-user-len.int

pub inline fun psa-crypto-driver-pake-inputs-sc/private-user-len(^s: psa-crypto-driver-pake-inputs-sc): <> int
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-user-len)

pub inline fun psa-crypto-driver-pake-inputs-scb/private-user-len(^s: psa-crypto-driver-pake-inputs-scb<s::S>): <> int
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-user-len)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/set-private-user-len(s: intptr_t, private-user-len: ssize_t): ()
  c inline "((struct psa_crypto_driver_pake_inputs_s*)#1)->private_user_len = (size_t)#2"

pub inline fun psa-crypto-driver-pake-inputs-sp/set-private-user-len(s: psa-crypto-driver-pake-inputs-sp, private-user-len: int): ()
  s.psa-crypto-driver-pake-inputs-s-ptrraw/set-private-user-len(private-user-len.ssize_t)

pub inline fun psa-crypto-driver-pake-inputs-sc/set-private-user-len(^s: psa-crypto-driver-pake-inputs-sc, private-user-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-user-len(private-user-len))

pub inline fun psa-crypto-driver-pake-inputs-scb/set-private-user-len(^s: psa-crypto-driver-pake-inputs-scb<s::S>, private-user-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-user-len(private-user-len))

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/private-peer(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct psa_crypto_driver_pake_inputs_s*)#1)->private_peer)"

pub inline fun psa-crypto-driver-pake-inputs-sp/private-peer(s: psa-crypto-driver-pake-inputs-sp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.psa-crypto-driver-pake-inputs-s-ptrraw/private-peer

pub inline fun psa-crypto-driver-pake-inputs-sc/private-peer(^s: psa-crypto-driver-pake-inputs-sc): <> c-pointer<int>
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-peer)

pub inline fun psa-crypto-driver-pake-inputs-scb/private-peer(^s: psa-crypto-driver-pake-inputs-scb<s::S>): <> c-pointer<int>
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-peer)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/set-private-peer(s: intptr_t, private-peer: c-pointer<int>): ()
  c inline "((struct psa_crypto_driver_pake_inputs_s*)#1)->private_peer = (uint8_t*)#2"

pub inline fun psa-crypto-driver-pake-inputs-sp/set-private-peer(s: psa-crypto-driver-pake-inputs-sp, private-peer: c-pointer<int>): ()
  s.psa-crypto-driver-pake-inputs-s-ptrraw/set-private-peer(private-peer)

pub inline fun psa-crypto-driver-pake-inputs-sc/set-private-peer(^s: psa-crypto-driver-pake-inputs-sc, private-peer: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-peer(private-peer))

pub inline fun psa-crypto-driver-pake-inputs-scb/set-private-peer(^s: psa-crypto-driver-pake-inputs-scb<s::S>, private-peer: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-peer(private-peer))

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/private-peer-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct psa_crypto_driver_pake_inputs_s*)#1)->private_peer_len)"

pub inline fun psa-crypto-driver-pake-inputs-sp/private-peer-len(s: psa-crypto-driver-pake-inputs-sp): <> int
  s.cextern/c-pointer/ptr.psa-crypto-driver-pake-inputs-s-ptrraw/private-peer-len.int

pub inline fun psa-crypto-driver-pake-inputs-sc/private-peer-len(^s: psa-crypto-driver-pake-inputs-sc): <> int
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-peer-len)

pub inline fun psa-crypto-driver-pake-inputs-scb/private-peer-len(^s: psa-crypto-driver-pake-inputs-scb<s::S>): <> int
  s.with-ptr(psa-crypto-driver-pake-inputs-sp/private-peer-len)

pub inline extern psa-crypto-driver-pake-inputs-s-ptrraw/set-private-peer-len(s: intptr_t, private-peer-len: ssize_t): ()
  c inline "((struct psa_crypto_driver_pake_inputs_s*)#1)->private_peer_len = (size_t)#2"

pub inline fun psa-crypto-driver-pake-inputs-sp/set-private-peer-len(s: psa-crypto-driver-pake-inputs-sp, private-peer-len: int): ()
  s.psa-crypto-driver-pake-inputs-s-ptrraw/set-private-peer-len(private-peer-len.ssize_t)

pub inline fun psa-crypto-driver-pake-inputs-sc/set-private-peer-len(^s: psa-crypto-driver-pake-inputs-sc, private-peer-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-peer-len(private-peer-len))

pub inline fun psa-crypto-driver-pake-inputs-scb/set-private-peer-len(^s: psa-crypto-driver-pake-inputs-scb<s::S>, private-peer-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.psa-crypto-driver-pake-inputs-sp/set-private-peer-len(private-peer-len))

// The type of the state data structure for PAKE operations.
// 
// Before calling any function on a PAKE operation object, the application
// must initialize it by any of the following means:
// - Set the structure to all-bits-zero, for example:
// \code
// psa_pake_operation_t operation;
// memset(&operation, 0, sizeof(operation));
// \endcode
// - Initialize the structure to logical zero values, for example:
// \code
// psa_pake_operation_t operation = {0};
// \endcode
// - Initialize the structure to the initializer #PSA_PAKE_OPERATION_INIT,
// for example:
// \code
// psa_pake_operation_t operation = PSA_PAKE_OPERATION_INIT;
// \endcode
// - Assign the result of the function psa_pake_operation_init()
// to the structure, for example:
// \code
// psa_pake_operation_t operation;
// operation = psa_pake_operation_init();
// \endcode
// 
// This is an implementation-defined \c struct. Applications should not
// make any assumptions about the content of this structure.
// Implementation details can change in future versions without notice.
alias psa-pake-operation-t = psa-pake-operation-s-c
alias koka-psa-pake-operation-t = psa-pake-operation-s
// \brief Encoding of the application role of PAKE
// 
// Encodes the application's role in the algorithm is being executed. For more
// information see the documentation of individual \c PSA_PAKE_ROLE_XXX
// constants.
alias psa-pake-role-t = int
type psa-crypto-driver-pake-step
  PSA_JPAKE_STEP_INVALID
  PSA_JPAKE_X1_STEP_KEY_SHARE
  PSA_JPAKE_X1_STEP_ZK_PUBLIC
  PSA_JPAKE_X1_STEP_ZK_PROOF
  PSA_JPAKE_X2_STEP_KEY_SHARE
  PSA_JPAKE_X2_STEP_ZK_PUBLIC
  PSA_JPAKE_X2_STEP_ZK_PROOF
  PSA_JPAKE_X2S_STEP_KEY_SHARE
  PSA_JPAKE_X2S_STEP_ZK_PUBLIC
  PSA_JPAKE_X2S_STEP_ZK_PROOF
  PSA_JPAKE_X4S_STEP_KEY_SHARE
  PSA_JPAKE_X4S_STEP_ZK_PUBLIC
  PSA_JPAKE_X4S_STEP_ZK_PROOF

pub fun psa-crypto-driver-pake-step/int(i: psa-crypto-driver-pake-step): int32
  match i
    PSA_JPAKE_STEP_INVALID -> 0.int32
    PSA_JPAKE_X1_STEP_KEY_SHARE -> 1.int32
    PSA_JPAKE_X1_STEP_ZK_PUBLIC -> 2.int32
    PSA_JPAKE_X1_STEP_ZK_PROOF -> 3.int32
    PSA_JPAKE_X2_STEP_KEY_SHARE -> 4.int32
    PSA_JPAKE_X2_STEP_ZK_PUBLIC -> 5.int32
    PSA_JPAKE_X2_STEP_ZK_PROOF -> 6.int32
    PSA_JPAKE_X2S_STEP_KEY_SHARE -> 7.int32
    PSA_JPAKE_X2S_STEP_ZK_PUBLIC -> 8.int32
    PSA_JPAKE_X2S_STEP_ZK_PROOF -> 9.int32
    PSA_JPAKE_X4S_STEP_KEY_SHARE -> 10.int32
    PSA_JPAKE_X4S_STEP_ZK_PUBLIC -> 11.int32
    PSA_JPAKE_X4S_STEP_ZK_PROOF -> 12.int32

pub fun int/psa-crypto-driver-pake-step(i: int32): exn psa-crypto-driver-pake-step
  match i.int
    0 -> PSA_JPAKE_STEP_INVALID
    1 -> PSA_JPAKE_X1_STEP_KEY_SHARE
    2 -> PSA_JPAKE_X1_STEP_ZK_PUBLIC
    3 -> PSA_JPAKE_X1_STEP_ZK_PROOF
    4 -> PSA_JPAKE_X2_STEP_KEY_SHARE
    5 -> PSA_JPAKE_X2_STEP_ZK_PUBLIC
    6 -> PSA_JPAKE_X2_STEP_ZK_PROOF
    7 -> PSA_JPAKE_X2S_STEP_KEY_SHARE
    8 -> PSA_JPAKE_X2S_STEP_ZK_PUBLIC
    9 -> PSA_JPAKE_X2S_STEP_ZK_PROOF
    10 -> PSA_JPAKE_X4S_STEP_KEY_SHARE
    11 -> PSA_JPAKE_X4S_STEP_ZK_PUBLIC
    12 -> PSA_JPAKE_X4S_STEP_ZK_PROOF

// \brief          Public key types
type mbedtls-pk-type-t
  MBEDTLS_PK_NONE
  MBEDTLS_PK_RSA
  MBEDTLS_PK_ECKEY
  MBEDTLS_PK_ECKEY_DH
  MBEDTLS_PK_ECDSA
  MBEDTLS_PK_RSA_ALT
  MBEDTLS_PK_RSASSA_PSS
  MBEDTLS_PK_OPAQUE

pub fun mbedtls-pk-type-t/int(i: mbedtls-pk-type-t): int32
  match i
    MBEDTLS_PK_NONE -> 0.int32
    MBEDTLS_PK_RSA -> 1.int32
    MBEDTLS_PK_ECKEY -> 2.int32
    MBEDTLS_PK_ECKEY_DH -> 3.int32
    MBEDTLS_PK_ECDSA -> 4.int32
    MBEDTLS_PK_RSA_ALT -> 5.int32
    MBEDTLS_PK_RSASSA_PSS -> 6.int32
    MBEDTLS_PK_OPAQUE -> 7.int32

pub fun int/mbedtls-pk-type-t(i: int32): exn mbedtls-pk-type-t
  match i.int
    0 -> MBEDTLS_PK_NONE
    1 -> MBEDTLS_PK_RSA
    2 -> MBEDTLS_PK_ECKEY
    3 -> MBEDTLS_PK_ECKEY_DH
    4 -> MBEDTLS_PK_ECDSA
    5 -> MBEDTLS_PK_RSA_ALT
    6 -> MBEDTLS_PK_RSASSA_PSS
    7 -> MBEDTLS_PK_OPAQUE

// \brief           Options for RSASSA-PSS signature verification.
// See \c mbedtls_rsa_rsassa_pss_verify_ext()
pub value struct mbedtls-pk-rsassa-pss-options
  // The digest to use for MGF1 in PSS.
  // 
  // \note When #MBEDTLS_USE_PSA_CRYPTO is enabled and #MBEDTLS_RSA_C is
  // disabled, this must be equal to the \c md_alg argument passed
  // to mbedtls_pk_verify_ext(). In a future version of the library,
  // this constraint may apply whenever #MBEDTLS_USE_PSA_CRYPTO is
  // enabled regardless of the status of #MBEDTLS_RSA_C.
  mgf1-hash-id: int
  // The expected length of the salt, in bytes. This may be
  // #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.
  // 
  // \note When #MBEDTLS_USE_PSA_CRYPTO is enabled, only
  // #MBEDTLS_RSA_SALT_LEN_ANY is valid. Any other value may be
  // ignored (allowing any salt length).
  expected-salt-len: int

pub type mbedtls-pk-rsassa-pss-options-c
pub alias mbedtls-pk-rsassa-pss-optionsp = c-pointer<mbedtls-pk-rsassa-pss-options-c>
pub alias mbedtls-pk-rsassa-pss-optionsc = owned-c<mbedtls-pk-rsassa-pss-options-c>
pub alias mbedtls-pk-rsassa-pss-optionscb<s::S> = borrowed-c<s,mbedtls-pk-rsassa-pss-options-c>
pub alias mbedtls-pk-rsassa-pss-optionsca = owned-c<c-array<mbedtls-pk-rsassa-pss-options-c>>

pub extern mbedtls-pk-rsassa-pss-options/size-of(c: c-null<mbedtls-pk-rsassa-pss-options-c>): int32
  c inline "sizeof(struct mbedtls_pk_rsassa_pss_options)"

pub fun mbedtls-pk-rsassa-pss-optionsc(): mbedtls-pk-rsassa-pss-optionsc
  malloc(?size-of=mbedtls-pk-rsassa-pss-options/size-of)

pub fun mbedtls-pk-rsassa-pss-optionsc-calloc(): mbedtls-pk-rsassa-pss-optionsc
  malloc-c(?size-of=mbedtls-pk-rsassa-pss-options/size-of)

pub fun mbedtls-pk-rsassa-pss-optionsc-array(n: int): mbedtls-pk-rsassa-pss-optionsca
  malloc(n.int32, ?size-of=mbedtls-pk-rsassa-pss-options/size-of)

pub fun mbedtls-pk-rsassa-pss-optionsc-array-calloc(n: int): mbedtls-pk-rsassa-pss-optionsca
  malloc-c(n.int32, ?size-of=mbedtls-pk-rsassa-pss-options/size-of)

pub inline extern mbedtls-pk-rsassa-pss-options-ptrraw/mgf1-hash-id(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_pk_rsassa_pss_options*)#1)->mgf1_hash_id)"

pub inline fun mbedtls-pk-rsassa-pss-optionsp/mgf1-hash-id(s: mbedtls-pk-rsassa-pss-optionsp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-pk-rsassa-pss-options-ptrraw/mgf1-hash-id.int/mbedtls-md-type-t

pub inline fun mbedtls-pk-rsassa-pss-optionsc/mgf1-hash-id(^s: mbedtls-pk-rsassa-pss-optionsc): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-pk-rsassa-pss-optionsp/mgf1-hash-id)

pub inline fun mbedtls-pk-rsassa-pss-optionscb/mgf1-hash-id(^s: mbedtls-pk-rsassa-pss-optionscb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-pk-rsassa-pss-optionsp/mgf1-hash-id)

pub inline extern mbedtls-pk-rsassa-pss-options-ptrraw/set-mgf1-hash-id(s: intptr_t, mgf1-hash-id: int32): ()
  c inline "((struct mbedtls_pk_rsassa_pss_options*)#1)->mgf1_hash_id = (int32_t)#2"

pub inline fun mbedtls-pk-rsassa-pss-optionsp/set-mgf1-hash-id(s: mbedtls-pk-rsassa-pss-optionsp, mgf1-hash-id: mbedtls-md-type-t): ()
  s.mbedtls-pk-rsassa-pss-options-ptrraw/set-mgf1-hash-id(mgf1-hash-id.mbedtls-md-type-t/int)

pub inline fun mbedtls-pk-rsassa-pss-optionsc/set-mgf1-hash-id(^s: mbedtls-pk-rsassa-pss-optionsc, mgf1-hash-id: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-rsassa-pss-optionsp/set-mgf1-hash-id(mgf1-hash-id))

pub inline fun mbedtls-pk-rsassa-pss-optionscb/set-mgf1-hash-id(^s: mbedtls-pk-rsassa-pss-optionscb<s::S>, mgf1-hash-id: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-rsassa-pss-optionsp/set-mgf1-hash-id(mgf1-hash-id))

pub inline extern mbedtls-pk-rsassa-pss-options-ptrraw/expected-salt-len(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_pk_rsassa_pss_options*)#1)->expected_salt_len)"

pub inline fun mbedtls-pk-rsassa-pss-optionsp/expected-salt-len(s: mbedtls-pk-rsassa-pss-optionsp): <> int
  s.cextern/c-pointer/ptr.mbedtls-pk-rsassa-pss-options-ptrraw/expected-salt-len.int

pub inline fun mbedtls-pk-rsassa-pss-optionsc/expected-salt-len(^s: mbedtls-pk-rsassa-pss-optionsc): <> int
  s.with-ptr(mbedtls-pk-rsassa-pss-optionsp/expected-salt-len)

pub inline fun mbedtls-pk-rsassa-pss-optionscb/expected-salt-len(^s: mbedtls-pk-rsassa-pss-optionscb<s::S>): <> int
  s.with-ptr(mbedtls-pk-rsassa-pss-optionsp/expected-salt-len)

pub inline extern mbedtls-pk-rsassa-pss-options-ptrraw/set-expected-salt-len(s: intptr_t, expected-salt-len: int32): ()
  c inline "((struct mbedtls_pk_rsassa_pss_options*)#1)->expected_salt_len = (int)#2"

pub inline fun mbedtls-pk-rsassa-pss-optionsp/set-expected-salt-len(s: mbedtls-pk-rsassa-pss-optionsp, expected-salt-len: int): ()
  s.mbedtls-pk-rsassa-pss-options-ptrraw/set-expected-salt-len(expected-salt-len.int32)

pub inline fun mbedtls-pk-rsassa-pss-optionsc/set-expected-salt-len(^s: mbedtls-pk-rsassa-pss-optionsc, expected-salt-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-rsassa-pss-optionsp/set-expected-salt-len(expected-salt-len))

pub inline fun mbedtls-pk-rsassa-pss-optionscb/set-expected-salt-len(^s: mbedtls-pk-rsassa-pss-optionscb<s::S>, expected-salt-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-rsassa-pss-optionsp/set-expected-salt-len(expected-salt-len))

// \brief           Types for interfacing with the debug module
type mbedtls-pk-debug-type
  MBEDTLS_PK_DEBUG_NONE
  MBEDTLS_PK_DEBUG_MPI
  MBEDTLS_PK_DEBUG_ECP
  MBEDTLS_PK_DEBUG_PSA_EC

pub fun mbedtls-pk-debug-type/int(i: mbedtls-pk-debug-type): int32
  match i
    MBEDTLS_PK_DEBUG_NONE -> 0.int32
    MBEDTLS_PK_DEBUG_MPI -> 1.int32
    MBEDTLS_PK_DEBUG_ECP -> 2.int32
    MBEDTLS_PK_DEBUG_PSA_EC -> 3.int32

pub fun int/mbedtls-pk-debug-type(i: int32): exn mbedtls-pk-debug-type
  match i.int
    0 -> MBEDTLS_PK_DEBUG_NONE
    1 -> MBEDTLS_PK_DEBUG_MPI
    2 -> MBEDTLS_PK_DEBUG_ECP
    3 -> MBEDTLS_PK_DEBUG_PSA_EC

// \brief           Item to send to the debug module
pub value struct mbedtls-pk-debug-item
  private-type: int
  private-name: c-pointer<int>
  private-value: c-pointer<()>

pub type mbedtls-pk-debug-item-c
pub alias mbedtls-pk-debug-itemp = c-pointer<mbedtls-pk-debug-item-c>
pub alias mbedtls-pk-debug-itemc = owned-c<mbedtls-pk-debug-item-c>
pub alias mbedtls-pk-debug-itemcb<s::S> = borrowed-c<s,mbedtls-pk-debug-item-c>
pub alias mbedtls-pk-debug-itemca = owned-c<c-array<mbedtls-pk-debug-item-c>>

pub extern mbedtls-pk-debug-item/size-of(c: c-null<mbedtls-pk-debug-item-c>): int32
  c inline "sizeof(struct mbedtls_pk_debug_item)"

pub fun mbedtls-pk-debug-itemc(): mbedtls-pk-debug-itemc
  malloc(?size-of=mbedtls-pk-debug-item/size-of)

pub fun mbedtls-pk-debug-itemc-calloc(): mbedtls-pk-debug-itemc
  malloc-c(?size-of=mbedtls-pk-debug-item/size-of)

pub fun mbedtls-pk-debug-itemc-array(n: int): mbedtls-pk-debug-itemca
  malloc(n.int32, ?size-of=mbedtls-pk-debug-item/size-of)

pub fun mbedtls-pk-debug-itemc-array-calloc(n: int): mbedtls-pk-debug-itemca
  malloc-c(n.int32, ?size-of=mbedtls-pk-debug-item/size-of)

pub inline extern mbedtls-pk-debug-item-ptrraw/private-type(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_pk_debug_item*)#1)->private_type)"

pub inline fun mbedtls-pk-debug-itemp/private-type(s: mbedtls-pk-debug-itemp): <exn> mbedtls-pk-debug-type
  s.cextern/c-pointer/ptr.mbedtls-pk-debug-item-ptrraw/private-type.int/mbedtls-pk-debug-type

pub inline fun mbedtls-pk-debug-itemc/private-type(^s: mbedtls-pk-debug-itemc): <exn> mbedtls-pk-debug-type
  s.with-ptr(mbedtls-pk-debug-itemp/private-type)

pub inline fun mbedtls-pk-debug-itemcb/private-type(^s: mbedtls-pk-debug-itemcb<s::S>): <exn> mbedtls-pk-debug-type
  s.with-ptr(mbedtls-pk-debug-itemp/private-type)

pub inline extern mbedtls-pk-debug-item-ptrraw/set-private-type(s: intptr_t, private-type: int32): ()
  c inline "((struct mbedtls_pk_debug_item*)#1)->private_type = (int32_t)#2"

pub inline fun mbedtls-pk-debug-itemp/set-private-type(s: mbedtls-pk-debug-itemp, private-type: mbedtls-pk-debug-type): ()
  s.mbedtls-pk-debug-item-ptrraw/set-private-type(private-type.mbedtls-pk-debug-type/int)

pub inline fun mbedtls-pk-debug-itemc/set-private-type(^s: mbedtls-pk-debug-itemc, private-type: mbedtls-pk-debug-type): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-debug-itemp/set-private-type(private-type))

pub inline fun mbedtls-pk-debug-itemcb/set-private-type(^s: mbedtls-pk-debug-itemcb<s::S>, private-type: mbedtls-pk-debug-type): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-debug-itemp/set-private-type(private-type))

pub inline extern mbedtls-pk-debug-item-ptrraw/private-name(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_pk_debug_item*)#1)->private_name)"

pub inline fun mbedtls-pk-debug-itemp/private-name(s: mbedtls-pk-debug-itemp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-pk-debug-item-ptrraw/private-name

pub inline fun mbedtls-pk-debug-itemc/private-name(^s: mbedtls-pk-debug-itemc): <> c-pointer<int>
  s.with-ptr(mbedtls-pk-debug-itemp/private-name)

pub inline fun mbedtls-pk-debug-itemcb/private-name(^s: mbedtls-pk-debug-itemcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-pk-debug-itemp/private-name)

pub inline extern mbedtls-pk-debug-item-ptrraw/set-private-name(s: intptr_t, private-name: c-pointer<int>): ()
  c inline "((struct mbedtls_pk_debug_item*)#1)->private_name = (char*)#2"

pub inline fun mbedtls-pk-debug-itemp/set-private-name(s: mbedtls-pk-debug-itemp, private-name: c-pointer<int>): ()
  s.mbedtls-pk-debug-item-ptrraw/set-private-name(private-name)

pub inline fun mbedtls-pk-debug-itemc/set-private-name(^s: mbedtls-pk-debug-itemc, private-name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-debug-itemp/set-private-name(private-name))

pub inline fun mbedtls-pk-debug-itemcb/set-private-name(^s: mbedtls-pk-debug-itemcb<s::S>, private-name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-debug-itemp/set-private-name(private-name))

pub inline extern mbedtls-pk-debug-item-ptrraw/private-value(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_pk_debug_item*)#1)->private_value)"

pub inline fun mbedtls-pk-debug-itemp/private-value(s: mbedtls-pk-debug-itemp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-pk-debug-item-ptrraw/private-value

pub inline fun mbedtls-pk-debug-itemc/private-value(^s: mbedtls-pk-debug-itemc): <> c-pointer<()>
  s.with-ptr(mbedtls-pk-debug-itemp/private-value)

pub inline fun mbedtls-pk-debug-itemcb/private-value(^s: mbedtls-pk-debug-itemcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-pk-debug-itemp/private-value)

pub inline extern mbedtls-pk-debug-item-ptrraw/set-private-value(s: intptr_t, private-value: c-pointer<()>): ()
  c inline "((struct mbedtls_pk_debug_item*)#1)->private_value = (void*)#2"

pub inline fun mbedtls-pk-debug-itemp/set-private-value(s: mbedtls-pk-debug-itemp, private-value: c-pointer<()>): ()
  s.mbedtls-pk-debug-item-ptrraw/set-private-value(private-value)

pub inline fun mbedtls-pk-debug-itemc/set-private-value(^s: mbedtls-pk-debug-itemc, private-value: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-debug-itemp/set-private-value(private-value))

pub inline fun mbedtls-pk-debug-itemcb/set-private-value(^s: mbedtls-pk-debug-itemcb<s::S>, private-value: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-debug-itemp/set-private-value(private-value))

pub struct mbedtls-pk-info-t
pub type mbedtls-pk-info-t-c
pub alias mbedtls-pk-info-tp = c-pointer<mbedtls-pk-info-t-c>
pub alias mbedtls-pk-info-tc = owned-c<mbedtls-pk-info-t-c>
pub alias mbedtls-pk-info-tcb<s::S> = borrowed-c<s,mbedtls-pk-info-t-c>
pub alias mbedtls-pk-info-tca = owned-c<c-array<mbedtls-pk-info-t-c>>

// \brief           Public key container
pub value struct mbedtls-pk-context
  // < Public key information
  private-pk-info: mbedtls-pk-info-t-c
  // < Underlying public key context
  private-pk-ctx: c-pointer<()>

pub type mbedtls-pk-context-c
pub alias mbedtls-pk-contextp = c-pointer<mbedtls-pk-context-c>
pub alias mbedtls-pk-contextc = owned-c<mbedtls-pk-context-c>
pub alias mbedtls-pk-contextcb<s::S> = borrowed-c<s,mbedtls-pk-context-c>
pub alias mbedtls-pk-contextca = owned-c<c-array<mbedtls-pk-context-c>>

pub extern mbedtls-pk-context/size-of(c: c-null<mbedtls-pk-context-c>): int32
  c inline "sizeof(struct mbedtls_pk_context)"

pub fun mbedtls-pk-contextc(): mbedtls-pk-contextc
  malloc(?size-of=mbedtls-pk-context/size-of)

pub fun mbedtls-pk-contextc-calloc(): mbedtls-pk-contextc
  malloc-c(?size-of=mbedtls-pk-context/size-of)

pub fun mbedtls-pk-contextc-array(n: int): mbedtls-pk-contextca
  malloc(n.int32, ?size-of=mbedtls-pk-context/size-of)

pub fun mbedtls-pk-contextc-array-calloc(n: int): mbedtls-pk-contextca
  malloc-c(n.int32, ?size-of=mbedtls-pk-context/size-of)

pub inline extern mbedtls-pk-context-ptrraw/private-pk-info(s: intptr_t): c-pointer<mbedtls-pk-info-t-c>
  c inline "(intptr_t)(((struct mbedtls_pk_context*)#1)->private_pk_info)"

pub inline fun mbedtls-pk-contextp/private-pk-info(s: mbedtls-pk-contextp): <> c-pointer<mbedtls-pk-info-t-c>
  s.cextern/c-pointer/ptr.mbedtls-pk-context-ptrraw/private-pk-info

pub inline fun mbedtls-pk-contextc/private-pk-info(^s: mbedtls-pk-contextc): <> c-pointer<mbedtls-pk-info-t-c>
  s.with-ptr(mbedtls-pk-contextp/private-pk-info)

pub inline fun mbedtls-pk-contextcb/private-pk-info(^s: mbedtls-pk-contextcb<s::S>): <> c-pointer<mbedtls-pk-info-t-c>
  s.with-ptr(mbedtls-pk-contextp/private-pk-info)

pub inline extern mbedtls-pk-context-ptrraw/set-private-pk-info(s: intptr_t, private-pk-info: c-pointer<mbedtls-pk-info-t-c>): ()
  c inline "((struct mbedtls_pk_context*)#1)->private_pk_info = (struct mbedtls_pk_info_t*)#2"

pub inline fun mbedtls-pk-contextp/set-private-pk-info(s: mbedtls-pk-contextp, private-pk-info: c-pointer<mbedtls-pk-info-t-c>): ()
  s.mbedtls-pk-context-ptrraw/set-private-pk-info(private-pk-info)

pub inline fun mbedtls-pk-contextc/set-private-pk-info(^s: mbedtls-pk-contextc, private-pk-info: c-pointer<mbedtls-pk-info-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-contextp/set-private-pk-info(private-pk-info))

pub inline fun mbedtls-pk-contextcb/set-private-pk-info(^s: mbedtls-pk-contextcb<s::S>, private-pk-info: c-pointer<mbedtls-pk-info-t-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-contextp/set-private-pk-info(private-pk-info))

pub inline extern mbedtls-pk-context-ptrraw/private-pk-ctx(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_pk_context*)#1)->private_pk_ctx)"

pub inline fun mbedtls-pk-contextp/private-pk-ctx(s: mbedtls-pk-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-pk-context-ptrraw/private-pk-ctx

pub inline fun mbedtls-pk-contextc/private-pk-ctx(^s: mbedtls-pk-contextc): <> c-pointer<()>
  s.with-ptr(mbedtls-pk-contextp/private-pk-ctx)

pub inline fun mbedtls-pk-contextcb/private-pk-ctx(^s: mbedtls-pk-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-pk-contextp/private-pk-ctx)

pub inline extern mbedtls-pk-context-ptrraw/set-private-pk-ctx(s: intptr_t, private-pk-ctx: c-pointer<()>): ()
  c inline "((struct mbedtls_pk_context*)#1)->private_pk_ctx = (void*)#2"

pub inline fun mbedtls-pk-contextp/set-private-pk-ctx(s: mbedtls-pk-contextp, private-pk-ctx: c-pointer<()>): ()
  s.mbedtls-pk-context-ptrraw/set-private-pk-ctx(private-pk-ctx)

pub inline fun mbedtls-pk-contextc/set-private-pk-ctx(^s: mbedtls-pk-contextc, private-pk-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-contextp/set-private-pk-ctx(private-pk-ctx))

pub inline fun mbedtls-pk-contextcb/set-private-pk-ctx(^s: mbedtls-pk-contextcb<s::S>, private-pk-ctx: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pk-contextp/set-private-pk-ctx(private-pk-ctx))

// \brief           Types for RSA-alt abstraction
alias mbedtls-pk-rsa-alt-decrypt-func = c-pointer<intptr_t>
alias mbedtls-pk-rsa-alt-decrypt-funcfn = ((ctx1 : c-pointer<()>, olen : c-pointer<int>, input : c-pointer<int>, output : c-pointer<int>, output_max_len : int) -> int)
alias mbedtls-pk-rsa-alt-sign-func = c-pointer<intptr_t>
alias mbedtls-pk-rsa-alt-sign-funcfn = ((ctx1 : c-pointer<()>, f_rng : c-pointer<intptr_t>, p_rng : c-pointer<()>, md_alg : mbedtls-md-type-t, hashlen : int, hash : c-pointer<int>, sig : c-pointer<int>) -> int)
alias mbedtls-pk-rsa-alt-key-len-func = c-pointer<intptr_t>
alias mbedtls-pk-rsa-alt-key-len-funcfn = ((ctx1 : c-pointer<()>) -> int)
alias mbedtls-pk-restart-ctx = ()
// \brief Base OID descriptor structure
pub struct mbedtls-oid-descriptor-t
  // !< OID ASN.1 representation
  private-asn1: c-pointer<int>
  // !< length of asn1
  private-asn1-len: int
  // !< official name (e.g. from RFC)
  private-name: c-pointer<int>
  // !< human friendly description
  private-description: c-pointer<int>

pub type mbedtls-oid-descriptor-t-c
pub alias mbedtls-oid-descriptor-tp = c-pointer<mbedtls-oid-descriptor-t-c>
pub alias mbedtls-oid-descriptor-tc = owned-c<mbedtls-oid-descriptor-t-c>
pub alias mbedtls-oid-descriptor-tcb<s::S> = borrowed-c<s,mbedtls-oid-descriptor-t-c>
pub alias mbedtls-oid-descriptor-tca = owned-c<c-array<mbedtls-oid-descriptor-t-c>>

pub extern mbedtls-oid-descriptor-t/size-of(c: c-null<mbedtls-oid-descriptor-t-c>): int32
  c inline "sizeof(struct mbedtls_oid_descriptor_t)"

pub fun mbedtls-oid-descriptor-tc(): mbedtls-oid-descriptor-tc
  malloc(?size-of=mbedtls-oid-descriptor-t/size-of)

pub fun mbedtls-oid-descriptor-tc-calloc(): mbedtls-oid-descriptor-tc
  malloc-c(?size-of=mbedtls-oid-descriptor-t/size-of)

pub fun mbedtls-oid-descriptor-tc-array(n: int): mbedtls-oid-descriptor-tca
  malloc(n.int32, ?size-of=mbedtls-oid-descriptor-t/size-of)

pub fun mbedtls-oid-descriptor-tc-array-calloc(n: int): mbedtls-oid-descriptor-tca
  malloc-c(n.int32, ?size-of=mbedtls-oid-descriptor-t/size-of)

pub inline extern mbedtls-oid-descriptor-t-ptrraw/private-asn1(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_oid_descriptor_t*)#1)->private_asn1)"

pub inline fun mbedtls-oid-descriptor-tp/private-asn1(s: mbedtls-oid-descriptor-tp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-oid-descriptor-t-ptrraw/private-asn1

pub inline fun mbedtls-oid-descriptor-tc/private-asn1(^s: mbedtls-oid-descriptor-tc): <> c-pointer<int>
  s.with-ptr(mbedtls-oid-descriptor-tp/private-asn1)

pub inline fun mbedtls-oid-descriptor-tcb/private-asn1(^s: mbedtls-oid-descriptor-tcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-oid-descriptor-tp/private-asn1)

pub inline extern mbedtls-oid-descriptor-t-ptrraw/set-private-asn1(s: intptr_t, private-asn1: c-pointer<int>): ()
  c inline "((struct mbedtls_oid_descriptor_t*)#1)->private_asn1 = (char*)#2"

pub inline fun mbedtls-oid-descriptor-tp/set-private-asn1(s: mbedtls-oid-descriptor-tp, private-asn1: c-pointer<int>): ()
  s.mbedtls-oid-descriptor-t-ptrraw/set-private-asn1(private-asn1)

pub inline fun mbedtls-oid-descriptor-tc/set-private-asn1(^s: mbedtls-oid-descriptor-tc, private-asn1: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-asn1(private-asn1))

pub inline fun mbedtls-oid-descriptor-tcb/set-private-asn1(^s: mbedtls-oid-descriptor-tcb<s::S>, private-asn1: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-asn1(private-asn1))

pub inline extern mbedtls-oid-descriptor-t-ptrraw/private-asn1-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_oid_descriptor_t*)#1)->private_asn1_len)"

pub inline fun mbedtls-oid-descriptor-tp/private-asn1-len(s: mbedtls-oid-descriptor-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-oid-descriptor-t-ptrraw/private-asn1-len.int

pub inline fun mbedtls-oid-descriptor-tc/private-asn1-len(^s: mbedtls-oid-descriptor-tc): <> int
  s.with-ptr(mbedtls-oid-descriptor-tp/private-asn1-len)

pub inline fun mbedtls-oid-descriptor-tcb/private-asn1-len(^s: mbedtls-oid-descriptor-tcb<s::S>): <> int
  s.with-ptr(mbedtls-oid-descriptor-tp/private-asn1-len)

pub inline extern mbedtls-oid-descriptor-t-ptrraw/set-private-asn1-len(s: intptr_t, private-asn1-len: ssize_t): ()
  c inline "((struct mbedtls_oid_descriptor_t*)#1)->private_asn1_len = (size_t)#2"

pub inline fun mbedtls-oid-descriptor-tp/set-private-asn1-len(s: mbedtls-oid-descriptor-tp, private-asn1-len: int): ()
  s.mbedtls-oid-descriptor-t-ptrraw/set-private-asn1-len(private-asn1-len.ssize_t)

pub inline fun mbedtls-oid-descriptor-tc/set-private-asn1-len(^s: mbedtls-oid-descriptor-tc, private-asn1-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-asn1-len(private-asn1-len))

pub inline fun mbedtls-oid-descriptor-tcb/set-private-asn1-len(^s: mbedtls-oid-descriptor-tcb<s::S>, private-asn1-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-asn1-len(private-asn1-len))

pub inline extern mbedtls-oid-descriptor-t-ptrraw/private-name(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_oid_descriptor_t*)#1)->private_name)"

pub inline fun mbedtls-oid-descriptor-tp/private-name(s: mbedtls-oid-descriptor-tp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-oid-descriptor-t-ptrraw/private-name

pub inline fun mbedtls-oid-descriptor-tc/private-name(^s: mbedtls-oid-descriptor-tc): <> c-pointer<int>
  s.with-ptr(mbedtls-oid-descriptor-tp/private-name)

pub inline fun mbedtls-oid-descriptor-tcb/private-name(^s: mbedtls-oid-descriptor-tcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-oid-descriptor-tp/private-name)

pub inline extern mbedtls-oid-descriptor-t-ptrraw/set-private-name(s: intptr_t, private-name: c-pointer<int>): ()
  c inline "((struct mbedtls_oid_descriptor_t*)#1)->private_name = (char*)#2"

pub inline fun mbedtls-oid-descriptor-tp/set-private-name(s: mbedtls-oid-descriptor-tp, private-name: c-pointer<int>): ()
  s.mbedtls-oid-descriptor-t-ptrraw/set-private-name(private-name)

pub inline fun mbedtls-oid-descriptor-tc/set-private-name(^s: mbedtls-oid-descriptor-tc, private-name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-name(private-name))

pub inline fun mbedtls-oid-descriptor-tcb/set-private-name(^s: mbedtls-oid-descriptor-tcb<s::S>, private-name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-name(private-name))

pub inline extern mbedtls-oid-descriptor-t-ptrraw/private-description(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_oid_descriptor_t*)#1)->private_description)"

pub inline fun mbedtls-oid-descriptor-tp/private-description(s: mbedtls-oid-descriptor-tp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-oid-descriptor-t-ptrraw/private-description

pub inline fun mbedtls-oid-descriptor-tc/private-description(^s: mbedtls-oid-descriptor-tc): <> c-pointer<int>
  s.with-ptr(mbedtls-oid-descriptor-tp/private-description)

pub inline fun mbedtls-oid-descriptor-tcb/private-description(^s: mbedtls-oid-descriptor-tcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-oid-descriptor-tp/private-description)

pub inline extern mbedtls-oid-descriptor-t-ptrraw/set-private-description(s: intptr_t, private-description: c-pointer<int>): ()
  c inline "((struct mbedtls_oid_descriptor_t*)#1)->private_description = (char*)#2"

pub inline fun mbedtls-oid-descriptor-tp/set-private-description(s: mbedtls-oid-descriptor-tp, private-description: c-pointer<int>): ()
  s.mbedtls-oid-descriptor-t-ptrraw/set-private-description(private-description)

pub inline fun mbedtls-oid-descriptor-tc/set-private-description(^s: mbedtls-oid-descriptor-tc, private-description: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-description(private-description))

pub inline fun mbedtls-oid-descriptor-tcb/set-private-description(^s: mbedtls-oid-descriptor-tcb<s::S>, private-description: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-oid-descriptor-tp/set-private-description(private-description))

type mbedtls-key-exchange-type-t
  MBEDTLS_KEY_EXCHANGE_NONE
  MBEDTLS_KEY_EXCHANGE_RSA
  MBEDTLS_KEY_EXCHANGE_DHE_RSA
  MBEDTLS_KEY_EXCHANGE_ECDHE_RSA
  MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA
  MBEDTLS_KEY_EXCHANGE_PSK
  MBEDTLS_KEY_EXCHANGE_DHE_PSK
  MBEDTLS_KEY_EXCHANGE_RSA_PSK
  MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
  MBEDTLS_KEY_EXCHANGE_ECDH_RSA
  MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA
  MBEDTLS_KEY_EXCHANGE_ECJPAKE

pub fun mbedtls-key-exchange-type-t/int(i: mbedtls-key-exchange-type-t): int32
  match i
    MBEDTLS_KEY_EXCHANGE_NONE -> 0.int32
    MBEDTLS_KEY_EXCHANGE_RSA -> 1.int32
    MBEDTLS_KEY_EXCHANGE_DHE_RSA -> 2.int32
    MBEDTLS_KEY_EXCHANGE_ECDHE_RSA -> 3.int32
    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA -> 4.int32
    MBEDTLS_KEY_EXCHANGE_PSK -> 5.int32
    MBEDTLS_KEY_EXCHANGE_DHE_PSK -> 6.int32
    MBEDTLS_KEY_EXCHANGE_RSA_PSK -> 7.int32
    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK -> 8.int32
    MBEDTLS_KEY_EXCHANGE_ECDH_RSA -> 9.int32
    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA -> 10.int32
    MBEDTLS_KEY_EXCHANGE_ECJPAKE -> 11.int32

pub fun int/mbedtls-key-exchange-type-t(i: int32): exn mbedtls-key-exchange-type-t
  match i.int
    0 -> MBEDTLS_KEY_EXCHANGE_NONE
    1 -> MBEDTLS_KEY_EXCHANGE_RSA
    2 -> MBEDTLS_KEY_EXCHANGE_DHE_RSA
    3 -> MBEDTLS_KEY_EXCHANGE_ECDHE_RSA
    4 -> MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA
    5 -> MBEDTLS_KEY_EXCHANGE_PSK
    6 -> MBEDTLS_KEY_EXCHANGE_DHE_PSK
    7 -> MBEDTLS_KEY_EXCHANGE_RSA_PSK
    8 -> MBEDTLS_KEY_EXCHANGE_ECDHE_PSK
    9 -> MBEDTLS_KEY_EXCHANGE_ECDH_RSA
    10 -> MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA
    11 -> MBEDTLS_KEY_EXCHANGE_ECJPAKE

// \brief   This structure is used for storing ciphersuite information
// 
// \note    members are defined using integral types instead of enums
// in order to pack structure and reduce memory usage by internal
// \c ciphersuite_definitions[]
pub struct mbedtls-ssl-ciphersuite-t
  private-id: int
  private-name: c-pointer<int>
  private-cipher: int
  private-mac: int
  private-key-exchange: int
  private-flags: int
  private-min-tls-version: int
  private-max-tls-version: int

pub type mbedtls-ssl-ciphersuite-t-c
pub alias mbedtls-ssl-ciphersuite-tp = c-pointer<mbedtls-ssl-ciphersuite-t-c>
pub alias mbedtls-ssl-ciphersuite-tc = owned-c<mbedtls-ssl-ciphersuite-t-c>
pub alias mbedtls-ssl-ciphersuite-tcb<s::S> = borrowed-c<s,mbedtls-ssl-ciphersuite-t-c>
pub alias mbedtls-ssl-ciphersuite-tca = owned-c<c-array<mbedtls-ssl-ciphersuite-t-c>>

pub extern mbedtls-ssl-ciphersuite-t/size-of(c: c-null<mbedtls-ssl-ciphersuite-t-c>): int32
  c inline "sizeof(struct mbedtls_ssl_ciphersuite_t)"

pub fun mbedtls-ssl-ciphersuite-tc(): mbedtls-ssl-ciphersuite-tc
  malloc(?size-of=mbedtls-ssl-ciphersuite-t/size-of)

pub fun mbedtls-ssl-ciphersuite-tc-calloc(): mbedtls-ssl-ciphersuite-tc
  malloc-c(?size-of=mbedtls-ssl-ciphersuite-t/size-of)

pub fun mbedtls-ssl-ciphersuite-tc-array(n: int): mbedtls-ssl-ciphersuite-tca
  malloc(n.int32, ?size-of=mbedtls-ssl-ciphersuite-t/size-of)

pub fun mbedtls-ssl-ciphersuite-tc-array-calloc(n: int): mbedtls-ssl-ciphersuite-tca
  malloc-c(n.int32, ?size-of=mbedtls-ssl-ciphersuite-t/size-of)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-id(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_id)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-id(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-id.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-id(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-id)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-id(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-id)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-id(s: intptr_t, private-id: int32): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_id = (int)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-id(s: mbedtls-ssl-ciphersuite-tp, private-id: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-id(private-id.int32)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-id(^s: mbedtls-ssl-ciphersuite-tc, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-id(private-id))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-id(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-id: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-id(private-id))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-name(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_name)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-name(s: mbedtls-ssl-ciphersuite-tp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-name

pub inline fun mbedtls-ssl-ciphersuite-tc/private-name(^s: mbedtls-ssl-ciphersuite-tc): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-name)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-name(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-name)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-name(s: intptr_t, private-name: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_name = (char*)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-name(s: mbedtls-ssl-ciphersuite-tp, private-name: c-pointer<int>): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-name(private-name)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-name(^s: mbedtls-ssl-ciphersuite-tc, private-name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-name(private-name))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-name(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-name: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-name(private-name))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-cipher(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_cipher)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-cipher(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-cipher.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-cipher(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-cipher)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-cipher(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-cipher)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-cipher(s: intptr_t, private-cipher: int8): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_cipher = (uint8_t)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-cipher(s: mbedtls-ssl-ciphersuite-tp, private-cipher: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-cipher(private-cipher.int8)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-cipher(^s: mbedtls-ssl-ciphersuite-tc, private-cipher: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-cipher(private-cipher))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-cipher(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-cipher: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-cipher(private-cipher))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-mac(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_mac)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-mac(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-mac.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-mac(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-mac)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-mac(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-mac)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-mac(s: intptr_t, private-mac: int8): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_mac = (uint8_t)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-mac(s: mbedtls-ssl-ciphersuite-tp, private-mac: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-mac(private-mac.int8)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-mac(^s: mbedtls-ssl-ciphersuite-tc, private-mac: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-mac(private-mac))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-mac(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-mac: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-mac(private-mac))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-key-exchange(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_key_exchange)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-key-exchange(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-key-exchange.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-key-exchange(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-key-exchange)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-key-exchange(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-key-exchange)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-key-exchange(s: intptr_t, private-key-exchange: int8): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_key_exchange = (uint8_t)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-key-exchange(s: mbedtls-ssl-ciphersuite-tp, private-key-exchange: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-key-exchange(private-key-exchange.int8)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-key-exchange(^s: mbedtls-ssl-ciphersuite-tc, private-key-exchange: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-key-exchange(private-key-exchange))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-key-exchange(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-key-exchange: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-key-exchange(private-key-exchange))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-flags(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_flags)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-flags(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-flags.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-flags(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-flags)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-flags(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-flags)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-flags(s: intptr_t, private-flags: int8): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_flags = (uint8_t)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-flags(s: mbedtls-ssl-ciphersuite-tp, private-flags: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-flags(private-flags.int8)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-flags(^s: mbedtls-ssl-ciphersuite-tc, private-flags: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-flags(private-flags))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-flags(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-flags: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-flags(private-flags))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-min-tls-version(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_min_tls_version)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-min-tls-version(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-min-tls-version.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-min-tls-version(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-min-tls-version)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-min-tls-version(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-min-tls-version)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-min-tls-version(s: intptr_t, private-min-tls-version: int16): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_min_tls_version = (int16_t)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-min-tls-version(s: mbedtls-ssl-ciphersuite-tp, private-min-tls-version: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-min-tls-version(private-min-tls-version.int16)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-min-tls-version(^s: mbedtls-ssl-ciphersuite-tc, private-min-tls-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-min-tls-version(private-min-tls-version))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-min-tls-version(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-min-tls-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-min-tls-version(private-min-tls-version))

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/private-max-tls-version(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ssl_ciphersuite_t*)#1)->private_max_tls_version)"

pub inline fun mbedtls-ssl-ciphersuite-tp/private-max-tls-version(s: mbedtls-ssl-ciphersuite-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ciphersuite-t-ptrraw/private-max-tls-version.int

pub inline fun mbedtls-ssl-ciphersuite-tc/private-max-tls-version(^s: mbedtls-ssl-ciphersuite-tc): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-max-tls-version)

pub inline fun mbedtls-ssl-ciphersuite-tcb/private-max-tls-version(^s: mbedtls-ssl-ciphersuite-tcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ciphersuite-tp/private-max-tls-version)

pub inline extern mbedtls-ssl-ciphersuite-t-ptrraw/set-private-max-tls-version(s: intptr_t, private-max-tls-version: int16): ()
  c inline "((struct mbedtls_ssl_ciphersuite_t*)#1)->private_max_tls_version = (int16_t)#2"

pub inline fun mbedtls-ssl-ciphersuite-tp/set-private-max-tls-version(s: mbedtls-ssl-ciphersuite-tp, private-max-tls-version: int): ()
  s.mbedtls-ssl-ciphersuite-t-ptrraw/set-private-max-tls-version(private-max-tls-version.int16)

pub inline fun mbedtls-ssl-ciphersuite-tc/set-private-max-tls-version(^s: mbedtls-ssl-ciphersuite-tc, private-max-tls-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-max-tls-version(private-max-tls-version))

pub inline fun mbedtls-ssl-ciphersuite-tcb/set-private-max-tls-version(^s: mbedtls-ssl-ciphersuite-tcb<s::S>, private-max-tls-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ciphersuite-tp/set-private-max-tls-version(private-max-tls-version))

pub struct mbedtls-x509-authority
  keyidentifier: koka-mbedtls-x509-buf
  authoritycertissuer: koka-mbedtls-x509-sequence
  authoritycertserialnumber: koka-mbedtls-x509-buf
  raw: koka-mbedtls-x509-buf

pub type mbedtls-x509-authority-c
pub alias mbedtls-x509-authorityp = c-pointer<mbedtls-x509-authority-c>
pub alias mbedtls-x509-authorityc = owned-c<mbedtls-x509-authority-c>
pub alias mbedtls-x509-authoritycb<s::S> = borrowed-c<s,mbedtls-x509-authority-c>
pub alias mbedtls-x509-authorityca = owned-c<c-array<mbedtls-x509-authority-c>>

pub extern mbedtls-x509-authority/size-of(c: c-null<mbedtls-x509-authority-c>): int32
  c inline "sizeof(struct mbedtls_x509_authority)"

pub fun mbedtls-x509-authorityc(): mbedtls-x509-authorityc
  malloc(?size-of=mbedtls-x509-authority/size-of)

pub fun mbedtls-x509-authorityc-calloc(): mbedtls-x509-authorityc
  malloc-c(?size-of=mbedtls-x509-authority/size-of)

pub fun mbedtls-x509-authorityc-array(n: int): mbedtls-x509-authorityca
  malloc(n.int32, ?size-of=mbedtls-x509-authority/size-of)

pub fun mbedtls-x509-authorityc-array-calloc(n: int): mbedtls-x509-authorityca
  malloc-c(n.int32, ?size-of=mbedtls-x509-authority/size-of)

// Type-length-value structure that allows for ASN1 using DER.
alias mbedtls-x509-buf = mbedtls-asn1-buf-c
alias koka-mbedtls-x509-buf = mbedtls-asn1-buf
// Container for a sequence of ASN.1 items
alias mbedtls-x509-sequence = mbedtls-asn1-sequence-c
alias koka-mbedtls-x509-sequence = mbedtls-asn1-sequence
// Container for date and time (precision in seconds).
pub struct mbedtls-x509-time
  // < Date.
  year: int
  mon: int
  day: int
  // < Time.
  hour: int
  min: int
  sec: int

pub type mbedtls-x509-time-c
pub alias mbedtls-x509-timep = c-pointer<mbedtls-x509-time-c>
pub alias mbedtls-x509-timec = owned-c<mbedtls-x509-time-c>
pub alias mbedtls-x509-timecb<s::S> = borrowed-c<s,mbedtls-x509-time-c>
pub alias mbedtls-x509-timeca = owned-c<c-array<mbedtls-x509-time-c>>

pub extern mbedtls-x509-time/size-of(c: c-null<mbedtls-x509-time-c>): int32
  c inline "sizeof(struct mbedtls_x509_time)"

pub fun mbedtls-x509-timec(): mbedtls-x509-timec
  malloc(?size-of=mbedtls-x509-time/size-of)

pub fun mbedtls-x509-timec-calloc(): mbedtls-x509-timec
  malloc-c(?size-of=mbedtls-x509-time/size-of)

pub fun mbedtls-x509-timec-array(n: int): mbedtls-x509-timeca
  malloc(n.int32, ?size-of=mbedtls-x509-time/size-of)

pub fun mbedtls-x509-timec-array-calloc(n: int): mbedtls-x509-timeca
  malloc-c(n.int32, ?size-of=mbedtls-x509-time/size-of)

pub inline extern mbedtls-x509-time-ptrraw/year(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_time*)#1)->year)"

pub inline fun mbedtls-x509-timep/year(s: mbedtls-x509-timep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-time-ptrraw/year.int

pub inline fun mbedtls-x509-timec/year(^s: mbedtls-x509-timec): <> int
  s.with-ptr(mbedtls-x509-timep/year)

pub inline fun mbedtls-x509-timecb/year(^s: mbedtls-x509-timecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-timep/year)

pub inline extern mbedtls-x509-time-ptrraw/set-year(s: intptr_t, year: int32): ()
  c inline "((struct mbedtls_x509_time*)#1)->year = (int)#2"

pub inline fun mbedtls-x509-timep/set-year(s: mbedtls-x509-timep, year: int): ()
  s.mbedtls-x509-time-ptrraw/set-year(year.int32)

pub inline fun mbedtls-x509-timec/set-year(^s: mbedtls-x509-timec, year: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-year(year))

pub inline fun mbedtls-x509-timecb/set-year(^s: mbedtls-x509-timecb<s::S>, year: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-year(year))

pub inline extern mbedtls-x509-time-ptrraw/mon(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_time*)#1)->mon)"

pub inline fun mbedtls-x509-timep/mon(s: mbedtls-x509-timep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-time-ptrraw/mon.int

pub inline fun mbedtls-x509-timec/mon(^s: mbedtls-x509-timec): <> int
  s.with-ptr(mbedtls-x509-timep/mon)

pub inline fun mbedtls-x509-timecb/mon(^s: mbedtls-x509-timecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-timep/mon)

pub inline extern mbedtls-x509-time-ptrraw/set-mon(s: intptr_t, mon: int32): ()
  c inline "((struct mbedtls_x509_time*)#1)->mon = (int)#2"

pub inline fun mbedtls-x509-timep/set-mon(s: mbedtls-x509-timep, mon: int): ()
  s.mbedtls-x509-time-ptrraw/set-mon(mon.int32)

pub inline fun mbedtls-x509-timec/set-mon(^s: mbedtls-x509-timec, mon: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-mon(mon))

pub inline fun mbedtls-x509-timecb/set-mon(^s: mbedtls-x509-timecb<s::S>, mon: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-mon(mon))

pub inline extern mbedtls-x509-time-ptrraw/day(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_time*)#1)->day)"

pub inline fun mbedtls-x509-timep/day(s: mbedtls-x509-timep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-time-ptrraw/day.int

pub inline fun mbedtls-x509-timec/day(^s: mbedtls-x509-timec): <> int
  s.with-ptr(mbedtls-x509-timep/day)

pub inline fun mbedtls-x509-timecb/day(^s: mbedtls-x509-timecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-timep/day)

pub inline extern mbedtls-x509-time-ptrraw/set-day(s: intptr_t, day: int32): ()
  c inline "((struct mbedtls_x509_time*)#1)->day = (int)#2"

pub inline fun mbedtls-x509-timep/set-day(s: mbedtls-x509-timep, day: int): ()
  s.mbedtls-x509-time-ptrraw/set-day(day.int32)

pub inline fun mbedtls-x509-timec/set-day(^s: mbedtls-x509-timec, day: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-day(day))

pub inline fun mbedtls-x509-timecb/set-day(^s: mbedtls-x509-timecb<s::S>, day: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-day(day))

pub inline extern mbedtls-x509-time-ptrraw/hour(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_time*)#1)->hour)"

pub inline fun mbedtls-x509-timep/hour(s: mbedtls-x509-timep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-time-ptrraw/hour.int

pub inline fun mbedtls-x509-timec/hour(^s: mbedtls-x509-timec): <> int
  s.with-ptr(mbedtls-x509-timep/hour)

pub inline fun mbedtls-x509-timecb/hour(^s: mbedtls-x509-timecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-timep/hour)

pub inline extern mbedtls-x509-time-ptrraw/set-hour(s: intptr_t, hour: int32): ()
  c inline "((struct mbedtls_x509_time*)#1)->hour = (int)#2"

pub inline fun mbedtls-x509-timep/set-hour(s: mbedtls-x509-timep, hour: int): ()
  s.mbedtls-x509-time-ptrraw/set-hour(hour.int32)

pub inline fun mbedtls-x509-timec/set-hour(^s: mbedtls-x509-timec, hour: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-hour(hour))

pub inline fun mbedtls-x509-timecb/set-hour(^s: mbedtls-x509-timecb<s::S>, hour: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-hour(hour))

pub inline extern mbedtls-x509-time-ptrraw/min(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_time*)#1)->min)"

pub inline fun mbedtls-x509-timep/min(s: mbedtls-x509-timep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-time-ptrraw/min.int

pub inline fun mbedtls-x509-timec/min(^s: mbedtls-x509-timec): <> int
  s.with-ptr(mbedtls-x509-timep/min)

pub inline fun mbedtls-x509-timecb/min(^s: mbedtls-x509-timecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-timep/min)

pub inline extern mbedtls-x509-time-ptrraw/set-min(s: intptr_t, min: int32): ()
  c inline "((struct mbedtls_x509_time*)#1)->min = (int)#2"

pub inline fun mbedtls-x509-timep/set-min(s: mbedtls-x509-timep, min: int): ()
  s.mbedtls-x509-time-ptrraw/set-min(min.int32)

pub inline fun mbedtls-x509-timec/set-min(^s: mbedtls-x509-timec, min: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-min(min))

pub inline fun mbedtls-x509-timecb/set-min(^s: mbedtls-x509-timecb<s::S>, min: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-min(min))

pub inline extern mbedtls-x509-time-ptrraw/sec(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_time*)#1)->sec)"

pub inline fun mbedtls-x509-timep/sec(s: mbedtls-x509-timep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-time-ptrraw/sec.int

pub inline fun mbedtls-x509-timec/sec(^s: mbedtls-x509-timec): <> int
  s.with-ptr(mbedtls-x509-timep/sec)

pub inline fun mbedtls-x509-timecb/sec(^s: mbedtls-x509-timecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-timep/sec)

pub inline extern mbedtls-x509-time-ptrraw/set-sec(s: intptr_t, sec: int32): ()
  c inline "((struct mbedtls_x509_time*)#1)->sec = (int)#2"

pub inline fun mbedtls-x509-timep/set-sec(s: mbedtls-x509-timep, sec: int): ()
  s.mbedtls-x509-time-ptrraw/set-sec(sec.int32)

pub inline fun mbedtls-x509-timec/set-sec(^s: mbedtls-x509-timec, sec: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-sec(sec))

pub inline fun mbedtls-x509-timecb/set-sec(^s: mbedtls-x509-timecb<s::S>, sec: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-timep/set-sec(sec))

// From RFC 5280 section 4.2.1.6:
// OtherName ::= SEQUENCE {
// type-id    OBJECT IDENTIFIER,
// value      [0] EXPLICIT ANY DEFINED BY type-id }
// 
// Future versions of the library may add new fields to this structure or
// to its embedded union and structure.
pub value struct mbedtls-x509-san-other-name
  // < The type id.
  type-id: koka-mbedtls-x509-buf
  value: unnamed-union8-c

pub type mbedtls-x509-san-other-name-c
pub alias mbedtls-x509-san-other-namep = c-pointer<mbedtls-x509-san-other-name-c>
pub alias mbedtls-x509-san-other-namec = owned-c<mbedtls-x509-san-other-name-c>
pub alias mbedtls-x509-san-other-namecb<s::S> = borrowed-c<s,mbedtls-x509-san-other-name-c>
pub alias mbedtls-x509-san-other-nameca = owned-c<c-array<mbedtls-x509-san-other-name-c>>

pub extern mbedtls-x509-san-other-name/size-of(c: c-null<mbedtls-x509-san-other-name-c>): int32
  c inline "sizeof(struct mbedtls_x509_san_other_name)"

pub fun mbedtls-x509-san-other-namec(): mbedtls-x509-san-other-namec
  malloc(?size-of=mbedtls-x509-san-other-name/size-of)

pub fun mbedtls-x509-san-other-namec-calloc(): mbedtls-x509-san-other-namec
  malloc-c(?size-of=mbedtls-x509-san-other-name/size-of)

pub fun mbedtls-x509-san-other-namec-array(n: int): mbedtls-x509-san-other-nameca
  malloc(n.int32, ?size-of=mbedtls-x509-san-other-name/size-of)

pub fun mbedtls-x509-san-other-namec-array-calloc(n: int): mbedtls-x509-san-other-nameca
  malloc-c(n.int32, ?size-of=mbedtls-x509-san-other-name/size-of)

pub struct unnamed-union8
pub type unnamed-union8-c
pub alias unnamed-union8p = c-pointer<unnamed-union8-c>
pub alias unnamed-union8c = owned-c<unnamed-union8-c>
pub alias unnamed-union8cb<s::S> = borrowed-c<s,unnamed-union8-c>
pub alias unnamed-union8ca = owned-c<c-array<unnamed-union8-c>>

// From RFC 4108 section 5:
// HardwareModuleName ::= SEQUENCE {
// hwType OBJECT IDENTIFIER,
// hwSerialNum OCTET STRING }
pub value struct unnamed-struct1
  // < The object identifier.
  oid: koka-mbedtls-x509-buf
  // < The named value.
  val: koka-mbedtls-x509-buf

pub type unnamed-struct1-c
pub alias unnamed-struct1p = c-pointer<unnamed-struct1-c>
pub alias unnamed-struct1c = owned-c<unnamed-struct1-c>
pub alias unnamed-struct1cb<s::S> = borrowed-c<s,unnamed-struct1-c>
pub alias unnamed-struct1ca = owned-c<c-array<unnamed-struct1-c>>

// A structure for holding the parsed Subject Alternative Name,
// according to type.
// 
// Future versions of the library may add new fields to this structure or
// to its embedded union and structure.
pub value struct mbedtls-x509-subject-alternative-name
  // < The SAN type, value of MBEDTLS_X509_SAN_XXX.
  type1: int
  // < A union of the supported SAN types
  san: unnamed-union9-c

pub type mbedtls-x509-subject-alternative-name-c
pub alias mbedtls-x509-subject-alternative-namep = c-pointer<mbedtls-x509-subject-alternative-name-c>
pub alias mbedtls-x509-subject-alternative-namec = owned-c<mbedtls-x509-subject-alternative-name-c>
pub alias mbedtls-x509-subject-alternative-namecb<s::S> = borrowed-c<s,mbedtls-x509-subject-alternative-name-c>
pub alias mbedtls-x509-subject-alternative-nameca = owned-c<c-array<mbedtls-x509-subject-alternative-name-c>>

pub extern mbedtls-x509-subject-alternative-name/size-of(c: c-null<mbedtls-x509-subject-alternative-name-c>): int32
  c inline "sizeof(struct mbedtls_x509_subject_alternative_name)"

pub fun mbedtls-x509-subject-alternative-namec(): mbedtls-x509-subject-alternative-namec
  malloc(?size-of=mbedtls-x509-subject-alternative-name/size-of)

pub fun mbedtls-x509-subject-alternative-namec-calloc(): mbedtls-x509-subject-alternative-namec
  malloc-c(?size-of=mbedtls-x509-subject-alternative-name/size-of)

pub fun mbedtls-x509-subject-alternative-namec-array(n: int): mbedtls-x509-subject-alternative-nameca
  malloc(n.int32, ?size-of=mbedtls-x509-subject-alternative-name/size-of)

pub fun mbedtls-x509-subject-alternative-namec-array-calloc(n: int): mbedtls-x509-subject-alternative-nameca
  malloc-c(n.int32, ?size-of=mbedtls-x509-subject-alternative-name/size-of)

pub inline extern mbedtls-x509-subject-alternative-name-ptrraw/type1(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_subject_alternative_name*)#1)->type)"

pub inline fun mbedtls-x509-subject-alternative-namep/type1(s: mbedtls-x509-subject-alternative-namep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-subject-alternative-name-ptrraw/type1.int

pub inline fun mbedtls-x509-subject-alternative-namec/type1(^s: mbedtls-x509-subject-alternative-namec): <> int
  s.with-ptr(mbedtls-x509-subject-alternative-namep/type1)

pub inline fun mbedtls-x509-subject-alternative-namecb/type1(^s: mbedtls-x509-subject-alternative-namecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-subject-alternative-namep/type1)

pub inline extern mbedtls-x509-subject-alternative-name-ptrraw/set-type1(s: intptr_t, type1: int32): ()
  c inline "((struct mbedtls_x509_subject_alternative_name*)#1)->type = (int)#2"

pub inline fun mbedtls-x509-subject-alternative-namep/set-type1(s: mbedtls-x509-subject-alternative-namep, type1: int): ()
  s.mbedtls-x509-subject-alternative-name-ptrraw/set-type1(type1.int32)

pub inline fun mbedtls-x509-subject-alternative-namec/set-type1(^s: mbedtls-x509-subject-alternative-namec, type1: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-subject-alternative-namep/set-type1(type1))

pub inline fun mbedtls-x509-subject-alternative-namecb/set-type1(^s: mbedtls-x509-subject-alternative-namecb<s::S>, type1: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-subject-alternative-namep/set-type1(type1))

pub struct unnamed-union9
pub type unnamed-union9-c
pub alias unnamed-union9p = c-pointer<unnamed-union9-c>
pub alias unnamed-union9c = owned-c<unnamed-union9-c>
pub alias unnamed-union9cb<s::S> = borrowed-c<s,unnamed-union9-c>
pub alias unnamed-union9ca = owned-c<c-array<unnamed-union9-c>>

// Container for ASN1 named information objects.
// It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.).
alias mbedtls-x509-name = mbedtls-asn1-named-data-c
alias koka-mbedtls-x509-name = mbedtls-asn1-named-data
pub value struct mbedtls-x509-san-list
  node: mbedtls-x509-subject-alternative-name-c
  next: mbedtls-x509-san-list-c

pub type mbedtls-x509-san-list-c
pub alias mbedtls-x509-san-listp = c-pointer<mbedtls-x509-san-list-c>
pub alias mbedtls-x509-san-listc = owned-c<mbedtls-x509-san-list-c>
pub alias mbedtls-x509-san-listcb<s::S> = borrowed-c<s,mbedtls-x509-san-list-c>
pub alias mbedtls-x509-san-listca = owned-c<c-array<mbedtls-x509-san-list-c>>

pub extern mbedtls-x509-san-list/size-of(c: c-null<mbedtls-x509-san-list-c>): int32
  c inline "sizeof(struct mbedtls_x509_san_list)"

pub fun mbedtls-x509-san-listc(): mbedtls-x509-san-listc
  malloc(?size-of=mbedtls-x509-san-list/size-of)

pub fun mbedtls-x509-san-listc-calloc(): mbedtls-x509-san-listc
  malloc-c(?size-of=mbedtls-x509-san-list/size-of)

pub fun mbedtls-x509-san-listc-array(n: int): mbedtls-x509-san-listca
  malloc(n.int32, ?size-of=mbedtls-x509-san-list/size-of)

pub fun mbedtls-x509-san-listc-array-calloc(n: int): mbedtls-x509-san-listca
  malloc-c(n.int32, ?size-of=mbedtls-x509-san-list/size-of)

pub inline extern mbedtls-x509-san-list-ptrraw/next(s: intptr_t): c-pointer<mbedtls-x509-san-list-c>
  c inline "(intptr_t)(((struct mbedtls_x509_san_list*)#1)->next)"

pub inline fun mbedtls-x509-san-listp/next(s: mbedtls-x509-san-listp): <> c-pointer<mbedtls-x509-san-list-c>
  s.cextern/c-pointer/ptr.mbedtls-x509-san-list-ptrraw/next

pub inline fun mbedtls-x509-san-listc/next(^s: mbedtls-x509-san-listc): <> c-pointer<mbedtls-x509-san-list-c>
  s.with-ptr(mbedtls-x509-san-listp/next)

pub inline fun mbedtls-x509-san-listcb/next(^s: mbedtls-x509-san-listcb<s::S>): <> c-pointer<mbedtls-x509-san-list-c>
  s.with-ptr(mbedtls-x509-san-listp/next)

pub inline extern mbedtls-x509-san-list-ptrraw/set-next(s: intptr_t, next: c-pointer<mbedtls-x509-san-list-c>): ()
  c inline "((struct mbedtls_x509_san_list*)#1)->next = (struct mbedtls_x509_san_list*)#2"

pub inline fun mbedtls-x509-san-listp/set-next(s: mbedtls-x509-san-listp, next: c-pointer<mbedtls-x509-san-list-c>): ()
  s.mbedtls-x509-san-list-ptrraw/set-next(next)

pub inline fun mbedtls-x509-san-listc/set-next(^s: mbedtls-x509-san-listc, next: c-pointer<mbedtls-x509-san-list-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-san-listp/set-next(next))

pub inline fun mbedtls-x509-san-listcb/set-next(^s: mbedtls-x509-san-listcb<s::S>, next: c-pointer<mbedtls-x509-san-list-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-san-listp/set-next(next))

// Certificate revocation list entry.
// Contains the CA-specific serial numbers and revocation dates.
// 
// Some fields of this structure are publicly readable. Do not modify
// them except via Mbed TLS library functions: the effect of modifying
// those fields or the data that those fields points to is unspecified.
pub struct mbedtls-x509-crl-entry
  // Direct access to the whole entry inside the containing buffer.
  raw: koka-mbedtls-x509-buf
  // The serial number of the revoked certificate.
  serial: koka-mbedtls-x509-buf
  // The revocation date of this entry.
  revocation-date: mbedtls-x509-time-c
  // Direct access to the list of CRL entry extensions
  // (an ASN.1 constructed sequence).
  // 
  // If there are no extensions, `entry_ext.len == 0` and
  // `entry_ext.p == NULL`.
  entry-ext: koka-mbedtls-x509-buf
  // Next element in the linked list of entries.
  // \p NULL indicates the end of the list.
  // Do not modify this field directly.
  next: mbedtls-x509-crl-entry-c

pub type mbedtls-x509-crl-entry-c
pub alias mbedtls-x509-crl-entryp = c-pointer<mbedtls-x509-crl-entry-c>
pub alias mbedtls-x509-crl-entryc = owned-c<mbedtls-x509-crl-entry-c>
pub alias mbedtls-x509-crl-entrycb<s::S> = borrowed-c<s,mbedtls-x509-crl-entry-c>
pub alias mbedtls-x509-crl-entryca = owned-c<c-array<mbedtls-x509-crl-entry-c>>

pub extern mbedtls-x509-crl-entry/size-of(c: c-null<mbedtls-x509-crl-entry-c>): int32
  c inline "sizeof(struct mbedtls_x509_crl_entry)"

pub fun mbedtls-x509-crl-entryc(): mbedtls-x509-crl-entryc
  malloc(?size-of=mbedtls-x509-crl-entry/size-of)

pub fun mbedtls-x509-crl-entryc-calloc(): mbedtls-x509-crl-entryc
  malloc-c(?size-of=mbedtls-x509-crl-entry/size-of)

pub fun mbedtls-x509-crl-entryc-array(n: int): mbedtls-x509-crl-entryca
  malloc(n.int32, ?size-of=mbedtls-x509-crl-entry/size-of)

pub fun mbedtls-x509-crl-entryc-array-calloc(n: int): mbedtls-x509-crl-entryca
  malloc-c(n.int32, ?size-of=mbedtls-x509-crl-entry/size-of)

pub inline extern mbedtls-x509-crl-entry-ptrraw/next(s: intptr_t): c-pointer<mbedtls-x509-crl-entry-c>
  c inline "(intptr_t)(((struct mbedtls_x509_crl_entry*)#1)->next)"

pub inline fun mbedtls-x509-crl-entryp/next(s: mbedtls-x509-crl-entryp): <> c-pointer<mbedtls-x509-crl-entry-c>
  s.cextern/c-pointer/ptr.mbedtls-x509-crl-entry-ptrraw/next

pub inline fun mbedtls-x509-crl-entryc/next(^s: mbedtls-x509-crl-entryc): <> c-pointer<mbedtls-x509-crl-entry-c>
  s.with-ptr(mbedtls-x509-crl-entryp/next)

pub inline fun mbedtls-x509-crl-entrycb/next(^s: mbedtls-x509-crl-entrycb<s::S>): <> c-pointer<mbedtls-x509-crl-entry-c>
  s.with-ptr(mbedtls-x509-crl-entryp/next)

pub inline extern mbedtls-x509-crl-entry-ptrraw/set-next(s: intptr_t, next: c-pointer<mbedtls-x509-crl-entry-c>): ()
  c inline "((struct mbedtls_x509_crl_entry*)#1)->next = (struct mbedtls_x509_crl_entry*)#2"

pub inline fun mbedtls-x509-crl-entryp/set-next(s: mbedtls-x509-crl-entryp, next: c-pointer<mbedtls-x509-crl-entry-c>): ()
  s.mbedtls-x509-crl-entry-ptrraw/set-next(next)

pub inline fun mbedtls-x509-crl-entryc/set-next(^s: mbedtls-x509-crl-entryc, next: c-pointer<mbedtls-x509-crl-entry-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crl-entryp/set-next(next))

pub inline fun mbedtls-x509-crl-entrycb/set-next(^s: mbedtls-x509-crl-entrycb<s::S>, next: c-pointer<mbedtls-x509-crl-entry-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crl-entryp/set-next(next))

// Certificate revocation list structure.
// Every CRL may have multiple entries.
pub struct mbedtls-x509-crl
  // < The raw certificate data (DER).
  raw: koka-mbedtls-x509-buf
  // < The raw certificate body (DER). The part that is To Be Signed.
  tbs: koka-mbedtls-x509-buf
  // < CRL version (1=v1, 2=v2)
  version: int
  // < CRL signature type identifier
  sig-oid: koka-mbedtls-x509-buf
  // < The raw issuer data (DER).
  issuer-raw: koka-mbedtls-x509-buf
  // < The parsed issuer data (named information object).
  issuer: koka-mbedtls-x509-name
  this-update: mbedtls-x509-time-c
  next-update: mbedtls-x509-time-c
  // < The CRL entries containing the certificate revocation times for this CA.
  entry: mbedtls-x509-crl-entry-c
  crl-ext: koka-mbedtls-x509-buf
  private-sig-oid2: koka-mbedtls-x509-buf
  private-sig: koka-mbedtls-x509-buf
  // < Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256
  private-sig-md: int
  // < Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA
  private-sig-pk: int
  // < Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS
  private-sig-opts: c-pointer<()>
  // Next element in the linked list of CRL.
  // \p NULL indicates the end of the list.
  // Do not modify this field directly.
  next: mbedtls-x509-crl-c

pub type mbedtls-x509-crl-c
pub alias mbedtls-x509-crlp = c-pointer<mbedtls-x509-crl-c>
pub alias mbedtls-x509-crlc = owned-c<mbedtls-x509-crl-c>
pub alias mbedtls-x509-crlcb<s::S> = borrowed-c<s,mbedtls-x509-crl-c>
pub alias mbedtls-x509-crlca = owned-c<c-array<mbedtls-x509-crl-c>>

pub extern mbedtls-x509-crl/size-of(c: c-null<mbedtls-x509-crl-c>): int32
  c inline "sizeof(struct mbedtls_x509_crl)"

pub fun mbedtls-x509-crlc(): mbedtls-x509-crlc
  malloc(?size-of=mbedtls-x509-crl/size-of)

pub fun mbedtls-x509-crlc-calloc(): mbedtls-x509-crlc
  malloc-c(?size-of=mbedtls-x509-crl/size-of)

pub fun mbedtls-x509-crlc-array(n: int): mbedtls-x509-crlca
  malloc(n.int32, ?size-of=mbedtls-x509-crl/size-of)

pub fun mbedtls-x509-crlc-array-calloc(n: int): mbedtls-x509-crlca
  malloc-c(n.int32, ?size-of=mbedtls-x509-crl/size-of)

pub inline extern mbedtls-x509-crl-ptrraw/version(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_crl*)#1)->version)"

pub inline fun mbedtls-x509-crlp/version(s: mbedtls-x509-crlp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crl-ptrraw/version.int

pub inline fun mbedtls-x509-crlc/version(^s: mbedtls-x509-crlc): <> int
  s.with-ptr(mbedtls-x509-crlp/version)

pub inline fun mbedtls-x509-crlcb/version(^s: mbedtls-x509-crlcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crlp/version)

pub inline extern mbedtls-x509-crl-ptrraw/set-version(s: intptr_t, version: int32): ()
  c inline "((struct mbedtls_x509_crl*)#1)->version = (int)#2"

pub inline fun mbedtls-x509-crlp/set-version(s: mbedtls-x509-crlp, version: int): ()
  s.mbedtls-x509-crl-ptrraw/set-version(version.int32)

pub inline fun mbedtls-x509-crlc/set-version(^s: mbedtls-x509-crlc, version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-version(version))

pub inline fun mbedtls-x509-crlcb/set-version(^s: mbedtls-x509-crlcb<s::S>, version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-version(version))

pub inline extern mbedtls-x509-crl-ptrraw/private-sig-md(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crl*)#1)->private_sig_md)"

pub inline fun mbedtls-x509-crlp/private-sig-md(s: mbedtls-x509-crlp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509-crl-ptrraw/private-sig-md.int/mbedtls-md-type-t

pub inline fun mbedtls-x509-crlc/private-sig-md(^s: mbedtls-x509-crlc): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509-crlp/private-sig-md)

pub inline fun mbedtls-x509-crlcb/private-sig-md(^s: mbedtls-x509-crlcb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509-crlp/private-sig-md)

pub inline extern mbedtls-x509-crl-ptrraw/set-private-sig-md(s: intptr_t, private-sig-md: int32): ()
  c inline "((struct mbedtls_x509_crl*)#1)->private_sig_md = (int32_t)#2"

pub inline fun mbedtls-x509-crlp/set-private-sig-md(s: mbedtls-x509-crlp, private-sig-md: mbedtls-md-type-t): ()
  s.mbedtls-x509-crl-ptrraw/set-private-sig-md(private-sig-md.mbedtls-md-type-t/int)

pub inline fun mbedtls-x509-crlc/set-private-sig-md(^s: mbedtls-x509-crlc, private-sig-md: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-private-sig-md(private-sig-md))

pub inline fun mbedtls-x509-crlcb/set-private-sig-md(^s: mbedtls-x509-crlcb<s::S>, private-sig-md: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-private-sig-md(private-sig-md))

pub inline extern mbedtls-x509-crl-ptrraw/private-sig-pk(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crl*)#1)->private_sig_pk)"

pub inline fun mbedtls-x509-crlp/private-sig-pk(s: mbedtls-x509-crlp): <exn> mbedtls-pk-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509-crl-ptrraw/private-sig-pk.int/mbedtls-pk-type-t

pub inline fun mbedtls-x509-crlc/private-sig-pk(^s: mbedtls-x509-crlc): <exn> mbedtls-pk-type-t
  s.with-ptr(mbedtls-x509-crlp/private-sig-pk)

pub inline fun mbedtls-x509-crlcb/private-sig-pk(^s: mbedtls-x509-crlcb<s::S>): <exn> mbedtls-pk-type-t
  s.with-ptr(mbedtls-x509-crlp/private-sig-pk)

pub inline extern mbedtls-x509-crl-ptrraw/set-private-sig-pk(s: intptr_t, private-sig-pk: int32): ()
  c inline "((struct mbedtls_x509_crl*)#1)->private_sig_pk = (int32_t)#2"

pub inline fun mbedtls-x509-crlp/set-private-sig-pk(s: mbedtls-x509-crlp, private-sig-pk: mbedtls-pk-type-t): ()
  s.mbedtls-x509-crl-ptrraw/set-private-sig-pk(private-sig-pk.mbedtls-pk-type-t/int)

pub inline fun mbedtls-x509-crlc/set-private-sig-pk(^s: mbedtls-x509-crlc, private-sig-pk: mbedtls-pk-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-private-sig-pk(private-sig-pk))

pub inline fun mbedtls-x509-crlcb/set-private-sig-pk(^s: mbedtls-x509-crlcb<s::S>, private-sig-pk: mbedtls-pk-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-private-sig-pk(private-sig-pk))

pub inline extern mbedtls-x509-crl-ptrraw/private-sig-opts(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_x509_crl*)#1)->private_sig_opts)"

pub inline fun mbedtls-x509-crlp/private-sig-opts(s: mbedtls-x509-crlp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-x509-crl-ptrraw/private-sig-opts

pub inline fun mbedtls-x509-crlc/private-sig-opts(^s: mbedtls-x509-crlc): <> c-pointer<()>
  s.with-ptr(mbedtls-x509-crlp/private-sig-opts)

pub inline fun mbedtls-x509-crlcb/private-sig-opts(^s: mbedtls-x509-crlcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-x509-crlp/private-sig-opts)

pub inline extern mbedtls-x509-crl-ptrraw/set-private-sig-opts(s: intptr_t, private-sig-opts: c-pointer<()>): ()
  c inline "((struct mbedtls_x509_crl*)#1)->private_sig_opts = (void*)#2"

pub inline fun mbedtls-x509-crlp/set-private-sig-opts(s: mbedtls-x509-crlp, private-sig-opts: c-pointer<()>): ()
  s.mbedtls-x509-crl-ptrraw/set-private-sig-opts(private-sig-opts)

pub inline fun mbedtls-x509-crlc/set-private-sig-opts(^s: mbedtls-x509-crlc, private-sig-opts: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-private-sig-opts(private-sig-opts))

pub inline fun mbedtls-x509-crlcb/set-private-sig-opts(^s: mbedtls-x509-crlcb<s::S>, private-sig-opts: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-private-sig-opts(private-sig-opts))

pub inline extern mbedtls-x509-crl-ptrraw/next(s: intptr_t): c-pointer<mbedtls-x509-crl-c>
  c inline "(intptr_t)(((struct mbedtls_x509_crl*)#1)->next)"

pub inline fun mbedtls-x509-crlp/next(s: mbedtls-x509-crlp): <> c-pointer<mbedtls-x509-crl-c>
  s.cextern/c-pointer/ptr.mbedtls-x509-crl-ptrraw/next

pub inline fun mbedtls-x509-crlc/next(^s: mbedtls-x509-crlc): <> c-pointer<mbedtls-x509-crl-c>
  s.with-ptr(mbedtls-x509-crlp/next)

pub inline fun mbedtls-x509-crlcb/next(^s: mbedtls-x509-crlcb<s::S>): <> c-pointer<mbedtls-x509-crl-c>
  s.with-ptr(mbedtls-x509-crlp/next)

pub inline extern mbedtls-x509-crl-ptrraw/set-next(s: intptr_t, next: c-pointer<mbedtls-x509-crl-c>): ()
  c inline "((struct mbedtls_x509_crl*)#1)->next = (struct mbedtls_x509_crl*)#2"

pub inline fun mbedtls-x509-crlp/set-next(s: mbedtls-x509-crlp, next: c-pointer<mbedtls-x509-crl-c>): ()
  s.mbedtls-x509-crl-ptrraw/set-next(next)

pub inline fun mbedtls-x509-crlc/set-next(^s: mbedtls-x509-crlc, next: c-pointer<mbedtls-x509-crl-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-next(next))

pub inline fun mbedtls-x509-crlcb/set-next(^s: mbedtls-x509-crlcb<s::S>, next: c-pointer<mbedtls-x509-crl-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crlp/set-next(next))

// Container for an X.509 certificate. The certificate may be chained.
// 
// Some fields of this structure are publicly readable. Do not modify
// them except via Mbed TLS library functions: the effect of modifying
// those fields or the data that those fields points to is unspecified.
pub struct mbedtls-x509-crt
  // < Indicates if \c raw is owned
  // by the structure or not.
  private-own-buffer: int
  // < The raw certificate data (DER).
  raw: koka-mbedtls-x509-buf
  // < The raw certificate body (DER). The part that is To Be Signed.
  tbs: koka-mbedtls-x509-buf
  // < The X.509 version. (1=v1, 2=v2, 3=v3)
  version: int
  // < Unique id for certificate issued by a specific CA.
  serial: koka-mbedtls-x509-buf
  // < Signature algorithm, e.g. sha1RSA
  sig-oid: koka-mbedtls-x509-buf
  // < The raw issuer data (DER). Used for quick comparison.
  issuer-raw: koka-mbedtls-x509-buf
  // < The raw subject data (DER). Used for quick comparison.
  subject-raw: koka-mbedtls-x509-buf
  // < The parsed issuer data (named information object).
  issuer: koka-mbedtls-x509-name
  // < The parsed subject data (named information object).
  subject: koka-mbedtls-x509-name
  // < Start time of certificate validity.
  valid-from: mbedtls-x509-time-c
  // < End time of certificate validity.
  valid-to: mbedtls-x509-time-c
  pk-raw: koka-mbedtls-x509-buf
  // < Container for the public key context.
  pk: mbedtls-pk-context-c
  // < Optional X.509 v2/v3 issuer unique identifier.
  issuer-id: koka-mbedtls-x509-buf
  // < Optional X.509 v2/v3 subject unique identifier.
  subject-id: koka-mbedtls-x509-buf
  // < Optional X.509 v3 extensions.
  v3-ext: koka-mbedtls-x509-buf
  // < Optional list of raw entries of Subject Alternative Names extension. These can be later parsed by mbedtls_x509_parse_subject_alt_name.
  subject-alt-names: koka-mbedtls-x509-sequence
  // < Optional X.509 v3 extension subject key identifier.
  subject-key-id: koka-mbedtls-x509-buf
  // < Optional X.509 v3 extension authority key identifier.
  authority-key-id: mbedtls-x509-authority-c
  // < Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed).
  certificate-policies: koka-mbedtls-x509-sequence
  // < Bit string containing detected and parsed extensions
  private-ext-types: int
  // < Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise.
  private-ca-istrue: int
  // < Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+
  private-max-pathlen: int
  // < Optional key usage extension value: See the values in x509.h
  private-key-usage: int
  // < Optional list of extended key usage OIDs.
  ext-key-usage: koka-mbedtls-x509-sequence
  // < Optional Netscape certificate type extension value: See the values in x509.h
  private-ns-cert-type: int
  // < Signature: hash of the tbs part signed with the private key.
  private-sig: koka-mbedtls-x509-buf
  // < Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256
  private-sig-md: int
  // < Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA
  private-sig-pk: int
  // < Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS
  private-sig-opts: c-pointer<()>
  // Next certificate in the linked list that constitutes the CA chain.
  // \p NULL indicates the end of the list.
  // Do not modify this field directly.
  next: mbedtls-x509-crt-c

pub type mbedtls-x509-crt-c
pub alias mbedtls-x509-crtp = c-pointer<mbedtls-x509-crt-c>
pub alias mbedtls-x509-crtc = owned-c<mbedtls-x509-crt-c>
pub alias mbedtls-x509-crtcb<s::S> = borrowed-c<s,mbedtls-x509-crt-c>
pub alias mbedtls-x509-crtca = owned-c<c-array<mbedtls-x509-crt-c>>

pub extern mbedtls-x509-crt/size-of(c: c-null<mbedtls-x509-crt-c>): int32
  c inline "sizeof(struct mbedtls_x509_crt)"

pub fun mbedtls-x509-crtc(): mbedtls-x509-crtc
  malloc(?size-of=mbedtls-x509-crt/size-of)

pub fun mbedtls-x509-crtc-calloc(): mbedtls-x509-crtc
  malloc-c(?size-of=mbedtls-x509-crt/size-of)

pub fun mbedtls-x509-crtc-array(n: int): mbedtls-x509-crtca
  malloc(n.int32, ?size-of=mbedtls-x509-crt/size-of)

pub fun mbedtls-x509-crtc-array-calloc(n: int): mbedtls-x509-crtca
  malloc-c(n.int32, ?size-of=mbedtls-x509-crt/size-of)

pub inline extern mbedtls-x509-crt-ptrraw/private-own-buffer(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_crt*)#1)->private_own_buffer)"

pub inline fun mbedtls-x509-crtp/private-own-buffer(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-own-buffer.int

pub inline fun mbedtls-x509-crtc/private-own-buffer(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/private-own-buffer)

pub inline fun mbedtls-x509-crtcb/private-own-buffer(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/private-own-buffer)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-own-buffer(s: intptr_t, private-own-buffer: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_own_buffer = (int)#2"

pub inline fun mbedtls-x509-crtp/set-private-own-buffer(s: mbedtls-x509-crtp, private-own-buffer: int): ()
  s.mbedtls-x509-crt-ptrraw/set-private-own-buffer(private-own-buffer.int32)

pub inline fun mbedtls-x509-crtc/set-private-own-buffer(^s: mbedtls-x509-crtc, private-own-buffer: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-own-buffer(private-own-buffer))

pub inline fun mbedtls-x509-crtcb/set-private-own-buffer(^s: mbedtls-x509-crtcb<s::S>, private-own-buffer: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-own-buffer(private-own-buffer))

pub inline extern mbedtls-x509-crt-ptrraw/version(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_crt*)#1)->version)"

pub inline fun mbedtls-x509-crtp/version(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/version.int

pub inline fun mbedtls-x509-crtc/version(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/version)

pub inline fun mbedtls-x509-crtcb/version(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/version)

pub inline extern mbedtls-x509-crt-ptrraw/set-version(s: intptr_t, version: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->version = (int)#2"

pub inline fun mbedtls-x509-crtp/set-version(s: mbedtls-x509-crtp, version: int): ()
  s.mbedtls-x509-crt-ptrraw/set-version(version.int32)

pub inline fun mbedtls-x509-crtc/set-version(^s: mbedtls-x509-crtc, version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-version(version))

pub inline fun mbedtls-x509-crtcb/set-version(^s: mbedtls-x509-crtcb<s::S>, version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-version(version))

pub inline extern mbedtls-x509-crt-ptrraw/private-ext-types(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_crt*)#1)->private_ext_types)"

pub inline fun mbedtls-x509-crtp/private-ext-types(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-ext-types.int

pub inline fun mbedtls-x509-crtc/private-ext-types(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/private-ext-types)

pub inline fun mbedtls-x509-crtcb/private-ext-types(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/private-ext-types)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-ext-types(s: intptr_t, private-ext-types: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_ext_types = (int)#2"

pub inline fun mbedtls-x509-crtp/set-private-ext-types(s: mbedtls-x509-crtp, private-ext-types: int): ()
  s.mbedtls-x509-crt-ptrraw/set-private-ext-types(private-ext-types.int32)

pub inline fun mbedtls-x509-crtc/set-private-ext-types(^s: mbedtls-x509-crtc, private-ext-types: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-ext-types(private-ext-types))

pub inline fun mbedtls-x509-crtcb/set-private-ext-types(^s: mbedtls-x509-crtcb<s::S>, private-ext-types: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-ext-types(private-ext-types))

pub inline extern mbedtls-x509-crt-ptrraw/private-ca-istrue(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_crt*)#1)->private_ca_istrue)"

pub inline fun mbedtls-x509-crtp/private-ca-istrue(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-ca-istrue.int

pub inline fun mbedtls-x509-crtc/private-ca-istrue(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/private-ca-istrue)

pub inline fun mbedtls-x509-crtcb/private-ca-istrue(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/private-ca-istrue)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-ca-istrue(s: intptr_t, private-ca-istrue: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_ca_istrue = (int)#2"

pub inline fun mbedtls-x509-crtp/set-private-ca-istrue(s: mbedtls-x509-crtp, private-ca-istrue: int): ()
  s.mbedtls-x509-crt-ptrraw/set-private-ca-istrue(private-ca-istrue.int32)

pub inline fun mbedtls-x509-crtc/set-private-ca-istrue(^s: mbedtls-x509-crtc, private-ca-istrue: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-ca-istrue(private-ca-istrue))

pub inline fun mbedtls-x509-crtcb/set-private-ca-istrue(^s: mbedtls-x509-crtcb<s::S>, private-ca-istrue: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-ca-istrue(private-ca-istrue))

pub inline extern mbedtls-x509-crt-ptrraw/private-max-pathlen(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_crt*)#1)->private_max_pathlen)"

pub inline fun mbedtls-x509-crtp/private-max-pathlen(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-max-pathlen.int

pub inline fun mbedtls-x509-crtc/private-max-pathlen(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/private-max-pathlen)

pub inline fun mbedtls-x509-crtcb/private-max-pathlen(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/private-max-pathlen)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-max-pathlen(s: intptr_t, private-max-pathlen: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_max_pathlen = (int)#2"

pub inline fun mbedtls-x509-crtp/set-private-max-pathlen(s: mbedtls-x509-crtp, private-max-pathlen: int): ()
  s.mbedtls-x509-crt-ptrraw/set-private-max-pathlen(private-max-pathlen.int32)

pub inline fun mbedtls-x509-crtc/set-private-max-pathlen(^s: mbedtls-x509-crtc, private-max-pathlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-max-pathlen(private-max-pathlen))

pub inline fun mbedtls-x509-crtcb/set-private-max-pathlen(^s: mbedtls-x509-crtcb<s::S>, private-max-pathlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-max-pathlen(private-max-pathlen))

pub inline extern mbedtls-x509-crt-ptrraw/private-key-usage(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_x509_crt*)#1)->private_key_usage)"

pub inline fun mbedtls-x509-crtp/private-key-usage(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-key-usage.int

pub inline fun mbedtls-x509-crtc/private-key-usage(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/private-key-usage)

pub inline fun mbedtls-x509-crtcb/private-key-usage(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/private-key-usage)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-key-usage(s: intptr_t, private-key-usage: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_key_usage = (unsigned int)#2"

pub inline fun mbedtls-x509-crtp/set-private-key-usage(s: mbedtls-x509-crtp, private-key-usage: int): ()
  s.mbedtls-x509-crt-ptrraw/set-private-key-usage(private-key-usage.int32)

pub inline fun mbedtls-x509-crtc/set-private-key-usage(^s: mbedtls-x509-crtc, private-key-usage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-key-usage(private-key-usage))

pub inline fun mbedtls-x509-crtcb/set-private-key-usage(^s: mbedtls-x509-crtcb<s::S>, private-key-usage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-key-usage(private-key-usage))

pub inline extern mbedtls-x509-crt-ptrraw/private-ns-cert-type(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_x509_crt*)#1)->private_ns_cert_type)"

pub inline fun mbedtls-x509-crtp/private-ns-cert-type(s: mbedtls-x509-crtp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-ns-cert-type.int

pub inline fun mbedtls-x509-crtc/private-ns-cert-type(^s: mbedtls-x509-crtc): <> int
  s.with-ptr(mbedtls-x509-crtp/private-ns-cert-type)

pub inline fun mbedtls-x509-crtcb/private-ns-cert-type(^s: mbedtls-x509-crtcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crtp/private-ns-cert-type)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-ns-cert-type(s: intptr_t, private-ns-cert-type: int8): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_ns_cert_type = (unsigned char)#2"

pub inline fun mbedtls-x509-crtp/set-private-ns-cert-type(s: mbedtls-x509-crtp, private-ns-cert-type: int): ()
  s.mbedtls-x509-crt-ptrraw/set-private-ns-cert-type(private-ns-cert-type.int8)

pub inline fun mbedtls-x509-crtc/set-private-ns-cert-type(^s: mbedtls-x509-crtc, private-ns-cert-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-ns-cert-type(private-ns-cert-type))

pub inline fun mbedtls-x509-crtcb/set-private-ns-cert-type(^s: mbedtls-x509-crtcb<s::S>, private-ns-cert-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-ns-cert-type(private-ns-cert-type))

pub inline extern mbedtls-x509-crt-ptrraw/private-sig-md(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crt*)#1)->private_sig_md)"

pub inline fun mbedtls-x509-crtp/private-sig-md(s: mbedtls-x509-crtp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-sig-md.int/mbedtls-md-type-t

pub inline fun mbedtls-x509-crtc/private-sig-md(^s: mbedtls-x509-crtc): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509-crtp/private-sig-md)

pub inline fun mbedtls-x509-crtcb/private-sig-md(^s: mbedtls-x509-crtcb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509-crtp/private-sig-md)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-sig-md(s: intptr_t, private-sig-md: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_sig_md = (int32_t)#2"

pub inline fun mbedtls-x509-crtp/set-private-sig-md(s: mbedtls-x509-crtp, private-sig-md: mbedtls-md-type-t): ()
  s.mbedtls-x509-crt-ptrraw/set-private-sig-md(private-sig-md.mbedtls-md-type-t/int)

pub inline fun mbedtls-x509-crtc/set-private-sig-md(^s: mbedtls-x509-crtc, private-sig-md: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-sig-md(private-sig-md))

pub inline fun mbedtls-x509-crtcb/set-private-sig-md(^s: mbedtls-x509-crtcb<s::S>, private-sig-md: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-sig-md(private-sig-md))

pub inline extern mbedtls-x509-crt-ptrraw/private-sig-pk(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crt*)#1)->private_sig_pk)"

pub inline fun mbedtls-x509-crtp/private-sig-pk(s: mbedtls-x509-crtp): <exn> mbedtls-pk-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-sig-pk.int/mbedtls-pk-type-t

pub inline fun mbedtls-x509-crtc/private-sig-pk(^s: mbedtls-x509-crtc): <exn> mbedtls-pk-type-t
  s.with-ptr(mbedtls-x509-crtp/private-sig-pk)

pub inline fun mbedtls-x509-crtcb/private-sig-pk(^s: mbedtls-x509-crtcb<s::S>): <exn> mbedtls-pk-type-t
  s.with-ptr(mbedtls-x509-crtp/private-sig-pk)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-sig-pk(s: intptr_t, private-sig-pk: int32): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_sig_pk = (int32_t)#2"

pub inline fun mbedtls-x509-crtp/set-private-sig-pk(s: mbedtls-x509-crtp, private-sig-pk: mbedtls-pk-type-t): ()
  s.mbedtls-x509-crt-ptrraw/set-private-sig-pk(private-sig-pk.mbedtls-pk-type-t/int)

pub inline fun mbedtls-x509-crtc/set-private-sig-pk(^s: mbedtls-x509-crtc, private-sig-pk: mbedtls-pk-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-sig-pk(private-sig-pk))

pub inline fun mbedtls-x509-crtcb/set-private-sig-pk(^s: mbedtls-x509-crtcb<s::S>, private-sig-pk: mbedtls-pk-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-sig-pk(private-sig-pk))

pub inline extern mbedtls-x509-crt-ptrraw/private-sig-opts(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_x509_crt*)#1)->private_sig_opts)"

pub inline fun mbedtls-x509-crtp/private-sig-opts(s: mbedtls-x509-crtp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/private-sig-opts

pub inline fun mbedtls-x509-crtc/private-sig-opts(^s: mbedtls-x509-crtc): <> c-pointer<()>
  s.with-ptr(mbedtls-x509-crtp/private-sig-opts)

pub inline fun mbedtls-x509-crtcb/private-sig-opts(^s: mbedtls-x509-crtcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-x509-crtp/private-sig-opts)

pub inline extern mbedtls-x509-crt-ptrraw/set-private-sig-opts(s: intptr_t, private-sig-opts: c-pointer<()>): ()
  c inline "((struct mbedtls_x509_crt*)#1)->private_sig_opts = (void*)#2"

pub inline fun mbedtls-x509-crtp/set-private-sig-opts(s: mbedtls-x509-crtp, private-sig-opts: c-pointer<()>): ()
  s.mbedtls-x509-crt-ptrraw/set-private-sig-opts(private-sig-opts)

pub inline fun mbedtls-x509-crtc/set-private-sig-opts(^s: mbedtls-x509-crtc, private-sig-opts: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-sig-opts(private-sig-opts))

pub inline fun mbedtls-x509-crtcb/set-private-sig-opts(^s: mbedtls-x509-crtcb<s::S>, private-sig-opts: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-private-sig-opts(private-sig-opts))

pub inline extern mbedtls-x509-crt-ptrraw/next(s: intptr_t): c-pointer<mbedtls-x509-crt-c>
  c inline "(intptr_t)(((struct mbedtls_x509_crt*)#1)->next)"

pub inline fun mbedtls-x509-crtp/next(s: mbedtls-x509-crtp): <> c-pointer<mbedtls-x509-crt-c>
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-ptrraw/next

pub inline fun mbedtls-x509-crtc/next(^s: mbedtls-x509-crtc): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-x509-crtp/next)

pub inline fun mbedtls-x509-crtcb/next(^s: mbedtls-x509-crtcb<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-x509-crtp/next)

pub inline extern mbedtls-x509-crt-ptrraw/set-next(s: intptr_t, next: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "((struct mbedtls_x509_crt*)#1)->next = (struct mbedtls_x509_crt*)#2"

pub inline fun mbedtls-x509-crtp/set-next(s: mbedtls-x509-crtp, next: c-pointer<mbedtls-x509-crt-c>): ()
  s.mbedtls-x509-crt-ptrraw/set-next(next)

pub inline fun mbedtls-x509-crtc/set-next(^s: mbedtls-x509-crtc, next: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-next(next))

pub inline fun mbedtls-x509-crtcb/set-next(^s: mbedtls-x509-crtcb<s::S>, next: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crtp/set-next(next))

// Security profile for certificate verification.
// 
// All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG().
// 
// The fields of this structure are part of the public API and can be
// manipulated directly by applications. Future versions of the library may
// add extra fields or reorder existing fields.
// 
// You can create custom profiles by starting from a copy of
// an existing profile, such as mbedtls_x509_crt_profile_default or
// mbedtls_x509_ctr_profile_none and then tune it to your needs.
// 
// For example to allow SHA-224 in addition to the default:
// 
// mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_default;
// my_profile.allowed_mds |= MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 );
// 
// Or to allow only RSA-3072+ with SHA-256:
// 
// mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_none;
// my_profile.allowed_mds = MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 );
// my_profile.allowed_pks = MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_RSA );
// my_profile.rsa_min_bitlen = 3072;
pub struct mbedtls-x509-crt-profile
  // < MDs for signatures
  allowed-mds: int
  // < PK algs for public keys;
  // this applies to all certificates
  // in the provided chain.
  allowed-pks: int
  // < Elliptic curves for ECDSA
  allowed-curves: int
  // < Minimum size for RSA keys
  rsa-min-bitlen: int

pub type mbedtls-x509-crt-profile-c
pub alias mbedtls-x509-crt-profilep = c-pointer<mbedtls-x509-crt-profile-c>
pub alias mbedtls-x509-crt-profilec = owned-c<mbedtls-x509-crt-profile-c>
pub alias mbedtls-x509-crt-profilecb<s::S> = borrowed-c<s,mbedtls-x509-crt-profile-c>
pub alias mbedtls-x509-crt-profileca = owned-c<c-array<mbedtls-x509-crt-profile-c>>

pub extern mbedtls-x509-crt-profile/size-of(c: c-null<mbedtls-x509-crt-profile-c>): int32
  c inline "sizeof(struct mbedtls_x509_crt_profile)"

pub fun mbedtls-x509-crt-profilec(): mbedtls-x509-crt-profilec
  malloc(?size-of=mbedtls-x509-crt-profile/size-of)

pub fun mbedtls-x509-crt-profilec-calloc(): mbedtls-x509-crt-profilec
  malloc-c(?size-of=mbedtls-x509-crt-profile/size-of)

pub fun mbedtls-x509-crt-profilec-array(n: int): mbedtls-x509-crt-profileca
  malloc(n.int32, ?size-of=mbedtls-x509-crt-profile/size-of)

pub fun mbedtls-x509-crt-profilec-array-calloc(n: int): mbedtls-x509-crt-profileca
  malloc-c(n.int32, ?size-of=mbedtls-x509-crt-profile/size-of)

pub inline extern mbedtls-x509-crt-profile-ptrraw/allowed-mds(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crt_profile*)#1)->allowed_mds)"

pub inline fun mbedtls-x509-crt-profilep/allowed-mds(s: mbedtls-x509-crt-profilep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-profile-ptrraw/allowed-mds.int

pub inline fun mbedtls-x509-crt-profilec/allowed-mds(^s: mbedtls-x509-crt-profilec): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/allowed-mds)

pub inline fun mbedtls-x509-crt-profilecb/allowed-mds(^s: mbedtls-x509-crt-profilecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/allowed-mds)

pub inline extern mbedtls-x509-crt-profile-ptrraw/set-allowed-mds(s: intptr_t, allowed-mds: int32): ()
  c inline "((struct mbedtls_x509_crt_profile*)#1)->allowed_mds = (int32_t)#2"

pub inline fun mbedtls-x509-crt-profilep/set-allowed-mds(s: mbedtls-x509-crt-profilep, allowed-mds: int): ()
  s.mbedtls-x509-crt-profile-ptrraw/set-allowed-mds(allowed-mds.int32)

pub inline fun mbedtls-x509-crt-profilec/set-allowed-mds(^s: mbedtls-x509-crt-profilec, allowed-mds: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-allowed-mds(allowed-mds))

pub inline fun mbedtls-x509-crt-profilecb/set-allowed-mds(^s: mbedtls-x509-crt-profilecb<s::S>, allowed-mds: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-allowed-mds(allowed-mds))

pub inline extern mbedtls-x509-crt-profile-ptrraw/allowed-pks(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crt_profile*)#1)->allowed_pks)"

pub inline fun mbedtls-x509-crt-profilep/allowed-pks(s: mbedtls-x509-crt-profilep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-profile-ptrraw/allowed-pks.int

pub inline fun mbedtls-x509-crt-profilec/allowed-pks(^s: mbedtls-x509-crt-profilec): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/allowed-pks)

pub inline fun mbedtls-x509-crt-profilecb/allowed-pks(^s: mbedtls-x509-crt-profilecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/allowed-pks)

pub inline extern mbedtls-x509-crt-profile-ptrraw/set-allowed-pks(s: intptr_t, allowed-pks: int32): ()
  c inline "((struct mbedtls_x509_crt_profile*)#1)->allowed_pks = (int32_t)#2"

pub inline fun mbedtls-x509-crt-profilep/set-allowed-pks(s: mbedtls-x509-crt-profilep, allowed-pks: int): ()
  s.mbedtls-x509-crt-profile-ptrraw/set-allowed-pks(allowed-pks.int32)

pub inline fun mbedtls-x509-crt-profilec/set-allowed-pks(^s: mbedtls-x509-crt-profilec, allowed-pks: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-allowed-pks(allowed-pks))

pub inline fun mbedtls-x509-crt-profilecb/set-allowed-pks(^s: mbedtls-x509-crt-profilecb<s::S>, allowed-pks: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-allowed-pks(allowed-pks))

pub inline extern mbedtls-x509-crt-profile-ptrraw/allowed-curves(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crt_profile*)#1)->allowed_curves)"

pub inline fun mbedtls-x509-crt-profilep/allowed-curves(s: mbedtls-x509-crt-profilep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-profile-ptrraw/allowed-curves.int

pub inline fun mbedtls-x509-crt-profilec/allowed-curves(^s: mbedtls-x509-crt-profilec): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/allowed-curves)

pub inline fun mbedtls-x509-crt-profilecb/allowed-curves(^s: mbedtls-x509-crt-profilecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/allowed-curves)

pub inline extern mbedtls-x509-crt-profile-ptrraw/set-allowed-curves(s: intptr_t, allowed-curves: int32): ()
  c inline "((struct mbedtls_x509_crt_profile*)#1)->allowed_curves = (int32_t)#2"

pub inline fun mbedtls-x509-crt-profilep/set-allowed-curves(s: mbedtls-x509-crt-profilep, allowed-curves: int): ()
  s.mbedtls-x509-crt-profile-ptrraw/set-allowed-curves(allowed-curves.int32)

pub inline fun mbedtls-x509-crt-profilec/set-allowed-curves(^s: mbedtls-x509-crt-profilec, allowed-curves: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-allowed-curves(allowed-curves))

pub inline fun mbedtls-x509-crt-profilecb/set-allowed-curves(^s: mbedtls-x509-crt-profilecb<s::S>, allowed-curves: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-allowed-curves(allowed-curves))

pub inline extern mbedtls-x509-crt-profile-ptrraw/rsa-min-bitlen(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_crt_profile*)#1)->rsa_min_bitlen)"

pub inline fun mbedtls-x509-crt-profilep/rsa-min-bitlen(s: mbedtls-x509-crt-profilep): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-profile-ptrraw/rsa-min-bitlen.int

pub inline fun mbedtls-x509-crt-profilec/rsa-min-bitlen(^s: mbedtls-x509-crt-profilec): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/rsa-min-bitlen)

pub inline fun mbedtls-x509-crt-profilecb/rsa-min-bitlen(^s: mbedtls-x509-crt-profilecb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-profilep/rsa-min-bitlen)

pub inline extern mbedtls-x509-crt-profile-ptrraw/set-rsa-min-bitlen(s: intptr_t, rsa-min-bitlen: int32): ()
  c inline "((struct mbedtls_x509_crt_profile*)#1)->rsa_min_bitlen = (int32_t)#2"

pub inline fun mbedtls-x509-crt-profilep/set-rsa-min-bitlen(s: mbedtls-x509-crt-profilep, rsa-min-bitlen: int): ()
  s.mbedtls-x509-crt-profile-ptrraw/set-rsa-min-bitlen(rsa-min-bitlen.int32)

pub inline fun mbedtls-x509-crt-profilec/set-rsa-min-bitlen(^s: mbedtls-x509-crt-profilec, rsa-min-bitlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-rsa-min-bitlen(rsa-min-bitlen))

pub inline fun mbedtls-x509-crt-profilecb/set-rsa-min-bitlen(^s: mbedtls-x509-crt-profilecb<s::S>, rsa-min-bitlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-profilep/set-rsa-min-bitlen(rsa-min-bitlen))

// Container for writing a certificate (CRT)
pub struct mbedtls-x509write-cert
pub type mbedtls-x509write-cert-c
pub alias mbedtls-x509write-certp = c-pointer<mbedtls-x509write-cert-c>
pub alias mbedtls-x509write-certc<s::S> = owned-c<mbedtls-x509write-cert-c>
pub alias mbedtls-x509write-certcb<s::S> = borrowed-c<s,mbedtls-x509write-cert-c>
pub alias mbedtls-x509write-certca<s::S> = owned-c<c-array<mbedtls-x509write-cert-c>>

pub extern mbedtls-x509write-cert/size-of(c: c-null<mbedtls-x509write-cert-c>): int32
  c inline "sizeof(struct mbedtls_x509write_cert)"

pub fun mbedtls-x509write-certc(): mbedtls-x509write-certc<s::S>
  malloc(?size-of=mbedtls-x509write-cert/size-of)

pub fun mbedtls-x509write-certc-calloc(): mbedtls-x509write-certc<s::S>
  malloc-c(?size-of=mbedtls-x509write-cert/size-of)

pub fun mbedtls-x509write-certc-array(n: int): mbedtls-x509write-certca<s::S>
  malloc(n.int32, ?size-of=mbedtls-x509write-cert/size-of)

pub fun mbedtls-x509write-certc-array-calloc(n: int): mbedtls-x509write-certca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-x509write-cert/size-of)

pub inline extern mbedtls-x509write-cert-ptrraw/private-version(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509write_cert*)#1)->private_version)"

pub inline fun mbedtls-x509write-certp/private-version(s: mbedtls-x509write-certp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-version.int

pub inline fun mbedtls-x509write-certc/private-version(^s: mbedtls-x509write-certc<s::S>): <> int
  s.with-ptr(mbedtls-x509write-certp/private-version)

pub inline fun mbedtls-x509write-certcb/private-version(^s: mbedtls-x509write-certcb<s::S>): <> int
  s.with-ptr(mbedtls-x509write-certp/private-version)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-version(s: intptr_t, private-version: int32): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_version = (int)#2"

pub inline fun mbedtls-x509write-certp/set-private-version(s: mbedtls-x509write-certp, private-version: int): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-version(private-version.int32)

pub inline fun mbedtls-x509write-certc/set-private-version(^s: mbedtls-x509write-certc<s::S>, private-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-version(private-version))

pub inline fun mbedtls-x509write-certcb/set-private-version(^s: mbedtls-x509write-certcb<s::S>, private-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-version(private-version))

pub inline extern mbedtls-x509write-cert-ptrraw/private-serial(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_serial)"

pub inline fun mbedtls-x509write-certp/private-serial(s: mbedtls-x509write-certp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-serial.cextern/ptr/carray

pub inline fun mbedtls-x509write-certc/private-serial(^s: mbedtls-x509write-certc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-x509write-certp/private-serial)

pub inline fun mbedtls-x509write-certcb/private-serial(^s: mbedtls-x509write-certcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-x509write-certp/private-serial)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-serial(s: intptr_t, private-serial: c-pointer<int>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_serial = (unsigned char*)#2"

pub inline fun mbedtls-x509write-certp/set-private-serial(s: mbedtls-x509write-certp, private-serial: c-array<int>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-serial(private-serial.cextern/carray/ptr)

pub inline fun mbedtls-x509write-certc/set-private-serial(^s: mbedtls-x509write-certc<s::S>, private-serial: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-serial(private-serial))

pub inline fun mbedtls-x509write-certcb/set-private-serial(^s: mbedtls-x509write-certcb<s::S>, private-serial: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-serial(private-serial))

pub inline extern mbedtls-x509write-cert-ptrraw/private-serial-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_x509write_cert*)#1)->private_serial_len)"

pub inline fun mbedtls-x509write-certp/private-serial-len(s: mbedtls-x509write-certp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-serial-len.int

pub inline fun mbedtls-x509write-certc/private-serial-len(^s: mbedtls-x509write-certc<s::S>): <> int
  s.with-ptr(mbedtls-x509write-certp/private-serial-len)

pub inline fun mbedtls-x509write-certcb/private-serial-len(^s: mbedtls-x509write-certcb<s::S>): <> int
  s.with-ptr(mbedtls-x509write-certp/private-serial-len)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-serial-len(s: intptr_t, private-serial-len: ssize_t): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_serial_len = (size_t)#2"

pub inline fun mbedtls-x509write-certp/set-private-serial-len(s: mbedtls-x509write-certp, private-serial-len: int): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-serial-len(private-serial-len.ssize_t)

pub inline fun mbedtls-x509write-certc/set-private-serial-len(^s: mbedtls-x509write-certc<s::S>, private-serial-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-serial-len(private-serial-len))

pub inline fun mbedtls-x509write-certcb/set-private-serial-len(^s: mbedtls-x509write-certcb<s::S>, private-serial-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-serial-len(private-serial-len))

pub inline extern mbedtls-x509write-cert-ptrraw/private-subject-key(s: intptr_t): c-pointer<mbedtls-pk-context-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_subject_key)"

pub inline fun mbedtls-x509write-certp/private-subject-key(s: mbedtls-x509write-certp): <> c-pointer<mbedtls-pk-context-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-subject-key

pub inline fun mbedtls-x509write-certc/private-subject-key(^s: mbedtls-x509write-certc<s::S>): <> c-pointer<mbedtls-pk-context-c>
  s.with-ptr(mbedtls-x509write-certp/private-subject-key)

pub inline fun mbedtls-x509write-certcb/private-subject-key(^s: mbedtls-x509write-certcb<s::S>): <> c-pointer<mbedtls-pk-context-c>
  s.with-ptr(mbedtls-x509write-certp/private-subject-key)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-subject-key(s: intptr_t, private-subject-key: c-pointer<mbedtls-pk-context-c>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_subject_key = (struct mbedtls_pk_context*)#2"

pub inline fun mbedtls-x509write-certp/set-private-subject-key(s: mbedtls-x509write-certp, private-subject-key: c-pointer<mbedtls-pk-context-c>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-subject-key(private-subject-key)

pub inline fun mbedtls-x509write-certc/set-private-subject-key(^s: mbedtls-x509write-certc<s::S>, private-subject-key: c-pointer<mbedtls-pk-context-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-subject-key(private-subject-key))

pub inline fun mbedtls-x509write-certcb/set-private-subject-key(^s: mbedtls-x509write-certcb<s::S>, private-subject-key: c-pointer<mbedtls-pk-context-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-subject-key(private-subject-key))

pub inline extern mbedtls-x509write-cert-ptrraw/private-issuer-key(s: intptr_t): c-pointer<mbedtls-pk-context-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_issuer_key)"

pub inline fun mbedtls-x509write-certp/private-issuer-key(s: mbedtls-x509write-certp): <> c-pointer<mbedtls-pk-context-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-issuer-key

pub inline fun mbedtls-x509write-certc/private-issuer-key(^s: mbedtls-x509write-certc<s::S>): <> c-pointer<mbedtls-pk-context-c>
  s.with-ptr(mbedtls-x509write-certp/private-issuer-key)

pub inline fun mbedtls-x509write-certcb/private-issuer-key(^s: mbedtls-x509write-certcb<s::S>): <> c-pointer<mbedtls-pk-context-c>
  s.with-ptr(mbedtls-x509write-certp/private-issuer-key)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-issuer-key(s: intptr_t, private-issuer-key: c-pointer<mbedtls-pk-context-c>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_issuer_key = (struct mbedtls_pk_context*)#2"

pub inline fun mbedtls-x509write-certp/set-private-issuer-key(s: mbedtls-x509write-certp, private-issuer-key: c-pointer<mbedtls-pk-context-c>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-issuer-key(private-issuer-key)

pub inline fun mbedtls-x509write-certc/set-private-issuer-key(^s: mbedtls-x509write-certc<s::S>, private-issuer-key: c-pointer<mbedtls-pk-context-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-issuer-key(private-issuer-key))

pub inline fun mbedtls-x509write-certcb/set-private-issuer-key(^s: mbedtls-x509write-certcb<s::S>, private-issuer-key: c-pointer<mbedtls-pk-context-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-issuer-key(private-issuer-key))

pub inline extern mbedtls-x509write-cert-ptrraw/private-subject(s: intptr_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_subject)"

pub inline fun mbedtls-x509write-certp/private-subject(s: mbedtls-x509write-certp): <> c-pointer<mbedtls-asn1-named-data-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-subject

pub inline fun mbedtls-x509write-certc/private-subject(^s: mbedtls-x509write-certc<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-certp/private-subject)

pub inline fun mbedtls-x509write-certcb/private-subject(^s: mbedtls-x509write-certcb<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-certp/private-subject)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-subject(s: intptr_t, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_subject = (struct mbedtls_asn1_named_data*)#2"

pub inline fun mbedtls-x509write-certp/set-private-subject(s: mbedtls-x509write-certp, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-subject(private-subject)

pub inline fun mbedtls-x509write-certc/set-private-subject(^s: mbedtls-x509write-certc<s::S>, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-subject(private-subject))

pub inline fun mbedtls-x509write-certcb/set-private-subject(^s: mbedtls-x509write-certcb<s::S>, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-subject(private-subject))

pub inline extern mbedtls-x509write-cert-ptrraw/private-issuer(s: intptr_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_issuer)"

pub inline fun mbedtls-x509write-certp/private-issuer(s: mbedtls-x509write-certp): <> c-pointer<mbedtls-asn1-named-data-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-issuer

pub inline fun mbedtls-x509write-certc/private-issuer(^s: mbedtls-x509write-certc<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-certp/private-issuer)

pub inline fun mbedtls-x509write-certcb/private-issuer(^s: mbedtls-x509write-certcb<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-certp/private-issuer)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-issuer(s: intptr_t, private-issuer: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_issuer = (struct mbedtls_asn1_named_data*)#2"

pub inline fun mbedtls-x509write-certp/set-private-issuer(s: mbedtls-x509write-certp, private-issuer: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-issuer(private-issuer)

pub inline fun mbedtls-x509write-certc/set-private-issuer(^s: mbedtls-x509write-certc<s::S>, private-issuer: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-issuer(private-issuer))

pub inline fun mbedtls-x509write-certcb/set-private-issuer(^s: mbedtls-x509write-certcb<s::S>, private-issuer: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-issuer(private-issuer))

pub inline extern mbedtls-x509write-cert-ptrraw/private-md-alg(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509write_cert*)#1)->private_md_alg)"

pub inline fun mbedtls-x509write-certp/private-md-alg(s: mbedtls-x509write-certp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-md-alg.int/mbedtls-md-type-t

pub inline fun mbedtls-x509write-certc/private-md-alg(^s: mbedtls-x509write-certc<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509write-certp/private-md-alg)

pub inline fun mbedtls-x509write-certcb/private-md-alg(^s: mbedtls-x509write-certcb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509write-certp/private-md-alg)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-md-alg(s: intptr_t, private-md-alg: int32): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_md_alg = (int32_t)#2"

pub inline fun mbedtls-x509write-certp/set-private-md-alg(s: mbedtls-x509write-certp, private-md-alg: mbedtls-md-type-t): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-md-alg(private-md-alg.mbedtls-md-type-t/int)

pub inline fun mbedtls-x509write-certc/set-private-md-alg(^s: mbedtls-x509write-certc<s::S>, private-md-alg: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-md-alg(private-md-alg))

pub inline fun mbedtls-x509write-certcb/set-private-md-alg(^s: mbedtls-x509write-certcb<s::S>, private-md-alg: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-md-alg(private-md-alg))

pub inline extern mbedtls-x509write-cert-ptrraw/private-not-before(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_not_before)"

pub inline fun mbedtls-x509write-certp/private-not-before(s: mbedtls-x509write-certp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-not-before.cextern/ptr/carray

pub inline fun mbedtls-x509write-certc/private-not-before(^s: mbedtls-x509write-certc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-x509write-certp/private-not-before)

pub inline fun mbedtls-x509write-certcb/private-not-before(^s: mbedtls-x509write-certcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-x509write-certp/private-not-before)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-not-before(s: intptr_t, private-not-before: c-pointer<int>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_not_before = (char*)#2"

pub inline fun mbedtls-x509write-certp/set-private-not-before(s: mbedtls-x509write-certp, private-not-before: c-array<int>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-not-before(private-not-before.cextern/carray/ptr)

pub inline fun mbedtls-x509write-certc/set-private-not-before(^s: mbedtls-x509write-certc<s::S>, private-not-before: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-not-before(private-not-before))

pub inline fun mbedtls-x509write-certcb/set-private-not-before(^s: mbedtls-x509write-certcb<s::S>, private-not-before: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-not-before(private-not-before))

pub inline extern mbedtls-x509write-cert-ptrraw/private-not-after(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_not_after)"

pub inline fun mbedtls-x509write-certp/private-not-after(s: mbedtls-x509write-certp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-not-after.cextern/ptr/carray

pub inline fun mbedtls-x509write-certc/private-not-after(^s: mbedtls-x509write-certc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-x509write-certp/private-not-after)

pub inline fun mbedtls-x509write-certcb/private-not-after(^s: mbedtls-x509write-certcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-x509write-certp/private-not-after)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-not-after(s: intptr_t, private-not-after: c-pointer<int>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_not_after = (char*)#2"

pub inline fun mbedtls-x509write-certp/set-private-not-after(s: mbedtls-x509write-certp, private-not-after: c-array<int>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-not-after(private-not-after.cextern/carray/ptr)

pub inline fun mbedtls-x509write-certc/set-private-not-after(^s: mbedtls-x509write-certc<s::S>, private-not-after: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-not-after(private-not-after))

pub inline fun mbedtls-x509write-certcb/set-private-not-after(^s: mbedtls-x509write-certcb<s::S>, private-not-after: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-not-after(private-not-after))

pub inline extern mbedtls-x509write-cert-ptrraw/private-extensions(s: intptr_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_cert*)#1)->private_extensions)"

pub inline fun mbedtls-x509write-certp/private-extensions(s: mbedtls-x509write-certp): <> c-pointer<mbedtls-asn1-named-data-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-cert-ptrraw/private-extensions

pub inline fun mbedtls-x509write-certc/private-extensions(^s: mbedtls-x509write-certc<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-certp/private-extensions)

pub inline fun mbedtls-x509write-certcb/private-extensions(^s: mbedtls-x509write-certcb<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-certp/private-extensions)

pub inline extern mbedtls-x509write-cert-ptrraw/set-private-extensions(s: intptr_t, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "((struct mbedtls_x509write_cert*)#1)->private_extensions = (struct mbedtls_asn1_named_data*)#2"

pub inline fun mbedtls-x509write-certp/set-private-extensions(s: mbedtls-x509write-certp, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.mbedtls-x509write-cert-ptrraw/set-private-extensions(private-extensions)

pub inline fun mbedtls-x509write-certc/set-private-extensions(^s: mbedtls-x509write-certc<s::S>, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-extensions(private-extensions))

pub inline fun mbedtls-x509write-certcb/set-private-extensions(^s: mbedtls-x509write-certcb<s::S>, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-certp/set-private-extensions(private-extensions))

// Item in a verification chain: cert and flags for it
pub value struct mbedtls-x509-crt-verify-chain-item
  private-crt: mbedtls-x509-crt-c
  private-flags: int

pub type mbedtls-x509-crt-verify-chain-item-c
pub alias mbedtls-x509-crt-verify-chain-itemp = c-pointer<mbedtls-x509-crt-verify-chain-item-c>
pub alias mbedtls-x509-crt-verify-chain-itemc = owned-c<mbedtls-x509-crt-verify-chain-item-c>
pub alias mbedtls-x509-crt-verify-chain-itemcb<s::S> = borrowed-c<s,mbedtls-x509-crt-verify-chain-item-c>
pub alias mbedtls-x509-crt-verify-chain-itemca = owned-c<c-array<mbedtls-x509-crt-verify-chain-item-c>>

pub extern mbedtls-x509-crt-verify-chain-item/size-of(c: c-null<mbedtls-x509-crt-verify-chain-item-c>): int32
  c inline "sizeof(mbedtls_x509_crt_verify_chain_item)"

pub fun mbedtls-x509-crt-verify-chain-itemc(): mbedtls-x509-crt-verify-chain-itemc
  malloc(?size-of=mbedtls-x509-crt-verify-chain-item/size-of)

pub fun mbedtls-x509-crt-verify-chain-itemc-calloc(): mbedtls-x509-crt-verify-chain-itemc
  malloc-c(?size-of=mbedtls-x509-crt-verify-chain-item/size-of)

pub fun mbedtls-x509-crt-verify-chain-itemc-array(n: int): mbedtls-x509-crt-verify-chain-itemca
  malloc(n.int32, ?size-of=mbedtls-x509-crt-verify-chain-item/size-of)

pub fun mbedtls-x509-crt-verify-chain-itemc-array-calloc(n: int): mbedtls-x509-crt-verify-chain-itemca
  malloc-c(n.int32, ?size-of=mbedtls-x509-crt-verify-chain-item/size-of)

pub inline extern mbedtls-x509-crt-verify-chain-item-ptrraw/private-crt(s: intptr_t): c-pointer<mbedtls-x509-crt-c>
  c inline "(intptr_t)(((mbedtls_x509_crt_verify_chain_item*)#1)->private_crt)"

pub inline fun mbedtls-x509-crt-verify-chain-itemp/private-crt(s: mbedtls-x509-crt-verify-chain-itemp): <> c-pointer<mbedtls-x509-crt-c>
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-verify-chain-item-ptrraw/private-crt

pub inline fun mbedtls-x509-crt-verify-chain-itemc/private-crt(^s: mbedtls-x509-crt-verify-chain-itemc): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-x509-crt-verify-chain-itemp/private-crt)

pub inline fun mbedtls-x509-crt-verify-chain-itemcb/private-crt(^s: mbedtls-x509-crt-verify-chain-itemcb<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-x509-crt-verify-chain-itemp/private-crt)

pub inline extern mbedtls-x509-crt-verify-chain-item-ptrraw/set-private-crt(s: intptr_t, private-crt: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "((mbedtls_x509_crt_verify_chain_item*)#1)->private_crt = (struct mbedtls_x509_crt*)#2"

pub inline fun mbedtls-x509-crt-verify-chain-itemp/set-private-crt(s: mbedtls-x509-crt-verify-chain-itemp, private-crt: c-pointer<mbedtls-x509-crt-c>): ()
  s.mbedtls-x509-crt-verify-chain-item-ptrraw/set-private-crt(private-crt)

pub inline fun mbedtls-x509-crt-verify-chain-itemc/set-private-crt(^s: mbedtls-x509-crt-verify-chain-itemc, private-crt: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chain-itemp/set-private-crt(private-crt))

pub inline fun mbedtls-x509-crt-verify-chain-itemcb/set-private-crt(^s: mbedtls-x509-crt-verify-chain-itemcb<s::S>, private-crt: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chain-itemp/set-private-crt(private-crt))

pub inline extern mbedtls-x509-crt-verify-chain-item-ptrraw/private-flags(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_x509_crt_verify_chain_item*)#1)->private_flags)"

pub inline fun mbedtls-x509-crt-verify-chain-itemp/private-flags(s: mbedtls-x509-crt-verify-chain-itemp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-verify-chain-item-ptrraw/private-flags.int

pub inline fun mbedtls-x509-crt-verify-chain-itemc/private-flags(^s: mbedtls-x509-crt-verify-chain-itemc): <> int
  s.with-ptr(mbedtls-x509-crt-verify-chain-itemp/private-flags)

pub inline fun mbedtls-x509-crt-verify-chain-itemcb/private-flags(^s: mbedtls-x509-crt-verify-chain-itemcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-verify-chain-itemp/private-flags)

pub inline extern mbedtls-x509-crt-verify-chain-item-ptrraw/set-private-flags(s: intptr_t, private-flags: int32): ()
  c inline "((mbedtls_x509_crt_verify_chain_item*)#1)->private_flags = (int32_t)#2"

pub inline fun mbedtls-x509-crt-verify-chain-itemp/set-private-flags(s: mbedtls-x509-crt-verify-chain-itemp, private-flags: int): ()
  s.mbedtls-x509-crt-verify-chain-item-ptrraw/set-private-flags(private-flags.int32)

pub inline fun mbedtls-x509-crt-verify-chain-itemc/set-private-flags(^s: mbedtls-x509-crt-verify-chain-itemc, private-flags: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chain-itemp/set-private-flags(private-flags))

pub inline fun mbedtls-x509-crt-verify-chain-itemcb/set-private-flags(^s: mbedtls-x509-crt-verify-chain-itemcb<s::S>, private-flags: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chain-itemp/set-private-flags(private-flags))

// Verification chain as built by \c mbedtls_crt_verify_chain()
pub struct mbedtls-x509-crt-verify-chain
pub type mbedtls-x509-crt-verify-chain-c
pub alias mbedtls-x509-crt-verify-chainp = c-pointer<mbedtls-x509-crt-verify-chain-c>
pub alias mbedtls-x509-crt-verify-chainc<s::S> = owned-c<mbedtls-x509-crt-verify-chain-c>
pub alias mbedtls-x509-crt-verify-chaincb<s::S> = borrowed-c<s,mbedtls-x509-crt-verify-chain-c>
pub alias mbedtls-x509-crt-verify-chainca<s::S> = owned-c<c-array<mbedtls-x509-crt-verify-chain-c>>

pub extern mbedtls-x509-crt-verify-chain/size-of(c: c-null<mbedtls-x509-crt-verify-chain-c>): int32
  c inline "sizeof(mbedtls_x509_crt_verify_chain)"

pub fun mbedtls-x509-crt-verify-chainc(): mbedtls-x509-crt-verify-chainc<s::S>
  malloc(?size-of=mbedtls-x509-crt-verify-chain/size-of)

pub fun mbedtls-x509-crt-verify-chainc-calloc(): mbedtls-x509-crt-verify-chainc<s::S>
  malloc-c(?size-of=mbedtls-x509-crt-verify-chain/size-of)

pub fun mbedtls-x509-crt-verify-chainc-array(n: int): mbedtls-x509-crt-verify-chainca<s::S>
  malloc(n.int32, ?size-of=mbedtls-x509-crt-verify-chain/size-of)

pub fun mbedtls-x509-crt-verify-chainc-array-calloc(n: int): mbedtls-x509-crt-verify-chainca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-x509-crt-verify-chain/size-of)

pub inline extern mbedtls-x509-crt-verify-chain-ptrraw/private-items(s: intptr_t): c-pointer<mbedtls-x509-crt-verify-chain-item-c>
  c inline "(intptr_t)(((mbedtls_x509_crt_verify_chain*)#1)->private_items)"

pub inline fun mbedtls-x509-crt-verify-chainp/private-items(s: mbedtls-x509-crt-verify-chainp): <> c-array<mbedtls-x509-crt-verify-chain-item-c>
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-verify-chain-ptrraw/private-items.cextern/ptr/carray

pub inline fun mbedtls-x509-crt-verify-chainc/private-items(^s: mbedtls-x509-crt-verify-chainc<s::S>): <> c-array<mbedtls-x509-crt-verify-chain-item-c>
  s.with-ptr(mbedtls-x509-crt-verify-chainp/private-items)

pub inline fun mbedtls-x509-crt-verify-chaincb/private-items(^s: mbedtls-x509-crt-verify-chaincb<s::S>): <> c-array<mbedtls-x509-crt-verify-chain-item-c>
  s.with-ptr(mbedtls-x509-crt-verify-chainp/private-items)

pub inline extern mbedtls-x509-crt-verify-chain-ptrraw/set-private-items(s: intptr_t, private-items: c-pointer<mbedtls-x509-crt-verify-chain-item-c>): ()
  c inline "((mbedtls_x509_crt_verify_chain*)#1)->private_items = (mbedtls_x509_crt_verify_chain_item*)#2"

pub inline fun mbedtls-x509-crt-verify-chainp/set-private-items(s: mbedtls-x509-crt-verify-chainp, private-items: c-array<mbedtls-x509-crt-verify-chain-item-c>): ()
  s.mbedtls-x509-crt-verify-chain-ptrraw/set-private-items(private-items.cextern/carray/ptr)

pub inline fun mbedtls-x509-crt-verify-chainc/set-private-items(^s: mbedtls-x509-crt-verify-chainc<s::S>, private-items: c-array<mbedtls-x509-crt-verify-chain-item-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chainp/set-private-items(private-items))

pub inline fun mbedtls-x509-crt-verify-chaincb/set-private-items(^s: mbedtls-x509-crt-verify-chaincb<s::S>, private-items: c-array<mbedtls-x509-crt-verify-chain-item-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chainp/set-private-items(private-items))

pub inline extern mbedtls-x509-crt-verify-chain-ptrraw/private-len(s: intptr_t): int32
  c inline "(unsigned int)(((mbedtls_x509_crt_verify_chain*)#1)->private_len)"

pub inline fun mbedtls-x509-crt-verify-chainp/private-len(s: mbedtls-x509-crt-verify-chainp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-crt-verify-chain-ptrraw/private-len.int

pub inline fun mbedtls-x509-crt-verify-chainc/private-len(^s: mbedtls-x509-crt-verify-chainc<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-verify-chainp/private-len)

pub inline fun mbedtls-x509-crt-verify-chaincb/private-len(^s: mbedtls-x509-crt-verify-chaincb<s::S>): <> int
  s.with-ptr(mbedtls-x509-crt-verify-chainp/private-len)

pub inline extern mbedtls-x509-crt-verify-chain-ptrraw/set-private-len(s: intptr_t, private-len: int32): ()
  c inline "((mbedtls_x509_crt_verify_chain*)#1)->private_len = (unsigned int)#2"

pub inline fun mbedtls-x509-crt-verify-chainp/set-private-len(s: mbedtls-x509-crt-verify-chainp, private-len: int): ()
  s.mbedtls-x509-crt-verify-chain-ptrraw/set-private-len(private-len.int32)

pub inline fun mbedtls-x509-crt-verify-chainc/set-private-len(^s: mbedtls-x509-crt-verify-chainc<s::S>, private-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chainp/set-private-len(private-len))

pub inline fun mbedtls-x509-crt-verify-chaincb/set-private-len(^s: mbedtls-x509-crt-verify-chaincb<s::S>, private-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-crt-verify-chainp/set-private-len(private-len))

// \brief          The type of certificate extension callbacks.
// 
// Callbacks of this type are passed to and used by the
// mbedtls_x509_crt_parse_der_with_ext_cb() routine when
// it encounters either an unsupported extension or a
// "certificate policies" extension containing any
// unsupported certificate policies.
// Future versions of the library may invoke the callback
// in other cases, if and when the need arises.
// 
// \param p_ctx    An opaque context passed to the callback.
// \param crt      The certificate being parsed.
// \param oid      The OID of the extension.
// \param critical Whether the extension is critical.
// \param p        Pointer to the start of the extension value
// (the content of the OCTET STRING).
// \param end      End of extension value.
// 
// \note           The callback must fail and return a negative error code
// if it can not parse or does not support the extension.
// When the callback fails to parse a critical extension
// mbedtls_x509_crt_parse_der_with_ext_cb() also fails.
// When the callback fails to parse a non critical extension
// mbedtls_x509_crt_parse_der_with_ext_cb() simply skips
// the extension and continues parsing.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
alias mbedtls-x509-crt-ext-cb-t = c-pointer<intptr_t>
alias mbedtls-x509-crt-ext-cb-tfn = ((p_ctx : c-pointer<()>, crt : c-pointer<mbedtls-x509-crt-c>, oid : c-pointer<mbedtls-asn1-buf-c>, critical : int, p : c-pointer<int>, end : c-pointer<int>) -> int)
alias mbedtls-x509-crt-restart-ctx = ()
// Which parameter to access in mbedtls_dhm_get_value().
type mbedtls-dhm-parameter
  // !<  The prime modulus.
  MBEDTLS_DHM_PARAM_P
  // !<  The generator.
  MBEDTLS_DHM_PARAM_G
  // !<  Our secret value.
  MBEDTLS_DHM_PARAM_X
  // !<  Our public key = \c G^X mod \c P.
  MBEDTLS_DHM_PARAM_GX
  // !<  The public key of the peer = \c G^Y mod \c P.
  MBEDTLS_DHM_PARAM_GY
  // !<  The shared secret = \c G^(XY) mod \c P.
  MBEDTLS_DHM_PARAM_K

pub fun mbedtls-dhm-parameter/int(i: mbedtls-dhm-parameter): int32
  match i
    MBEDTLS_DHM_PARAM_P -> 0.int32
    MBEDTLS_DHM_PARAM_G -> 1.int32
    MBEDTLS_DHM_PARAM_X -> 2.int32
    MBEDTLS_DHM_PARAM_GX -> 3.int32
    MBEDTLS_DHM_PARAM_GY -> 4.int32
    MBEDTLS_DHM_PARAM_K -> 5.int32

pub fun int/mbedtls-dhm-parameter(i: int32): exn mbedtls-dhm-parameter
  match i.int
    0 -> MBEDTLS_DHM_PARAM_P
    1 -> MBEDTLS_DHM_PARAM_G
    2 -> MBEDTLS_DHM_PARAM_X
    3 -> MBEDTLS_DHM_PARAM_GX
    4 -> MBEDTLS_DHM_PARAM_GY
    5 -> MBEDTLS_DHM_PARAM_K

// \brief          The DHM context structure.
pub struct mbedtls-dhm-context
  // !<  The prime modulus.
  private-p: mbedtls-mpi-c
  // !<  The generator.
  private-g: mbedtls-mpi-c
  // !<  Our secret value.
  private-x: mbedtls-mpi-c
  // !<  Our public key = \c G^X mod \c P.
  private-gx: mbedtls-mpi-c
  // !<  The public key of the peer = \c G^Y mod \c P.
  private-gy: mbedtls-mpi-c
  // !<  The shared secret = \c G^(XY) mod \c P.
  private-k: mbedtls-mpi-c
  // !<  The cached value = \c R^2 mod \c P.
  private-rp: mbedtls-mpi-c
  // !<  The blinding value.
  private-vi: mbedtls-mpi-c
  // !<  The unblinding value.
  private-vf: mbedtls-mpi-c
  // !<  The previous \c X.
  private-px: mbedtls-mpi-c

pub type mbedtls-dhm-context-c
pub alias mbedtls-dhm-contextp = c-pointer<mbedtls-dhm-context-c>
pub alias mbedtls-dhm-contextc = owned-c<mbedtls-dhm-context-c>
pub alias mbedtls-dhm-contextcb<s::S> = borrowed-c<s,mbedtls-dhm-context-c>
pub alias mbedtls-dhm-contextca = owned-c<c-array<mbedtls-dhm-context-c>>

pub extern mbedtls-dhm-context/size-of(c: c-null<mbedtls-dhm-context-c>): int32
  c inline "sizeof(struct mbedtls_dhm_context)"

pub fun mbedtls-dhm-contextc(): mbedtls-dhm-contextc
  malloc(?size-of=mbedtls-dhm-context/size-of)

pub fun mbedtls-dhm-contextc-calloc(): mbedtls-dhm-contextc
  malloc-c(?size-of=mbedtls-dhm-context/size-of)

pub fun mbedtls-dhm-contextc-array(n: int): mbedtls-dhm-contextca
  malloc(n.int32, ?size-of=mbedtls-dhm-context/size-of)

pub fun mbedtls-dhm-contextc-array-calloc(n: int): mbedtls-dhm-contextca
  malloc-c(n.int32, ?size-of=mbedtls-dhm-context/size-of)

// Defines the source of the imported EC key.
type mbedtls-ecdh-side
  // < Our key.
  MBEDTLS_ECDH_OURS
  // < The key of the peer.
  MBEDTLS_ECDH_THEIRS

pub fun mbedtls-ecdh-side/int(i: mbedtls-ecdh-side): int32
  match i
    MBEDTLS_ECDH_OURS -> 0.int32
    MBEDTLS_ECDH_THEIRS -> 1.int32

pub fun int/mbedtls-ecdh-side(i: int32): exn mbedtls-ecdh-side
  match i.int
    0 -> MBEDTLS_ECDH_OURS
    1 -> MBEDTLS_ECDH_THEIRS

// Defines the ECDH implementation used.
// 
// Later versions of the library may add new variants, therefore users should
// not make any assumptions about them.
type mbedtls-ecdh-variant
  // !< Implementation not defined.
  MBEDTLS_ECDH_VARIANT_NONE
  // !< The default Mbed TLS implementation
  MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0

pub fun mbedtls-ecdh-variant/int(i: mbedtls-ecdh-variant): int32
  match i
    MBEDTLS_ECDH_VARIANT_NONE -> 0.int32
    MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0 -> 1.int32

pub fun int/mbedtls-ecdh-variant(i: int32): exn mbedtls-ecdh-variant
  match i.int
    0 -> MBEDTLS_ECDH_VARIANT_NONE
    1 -> MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0

// The context used by the default ECDH implementation.
// 
// Later versions might change the structure of this context, therefore users
// should not make any assumptions about the structure of
// mbedtls_ecdh_context_mbed.
pub struct mbedtls-ecdh-context-mbed
  // !< The elliptic curve used.
  private-grp: mbedtls-ecp-group-c
  // !< The private key.
  private-d: mbedtls-mpi-c
  // !< The public key.
  private-q: mbedtls-ecp-point-c
  // !< The value of the public key of the peer.
  private-qp: mbedtls-ecp-point-c
  // !< The shared secret.
  private-z: mbedtls-mpi-c

pub type mbedtls-ecdh-context-mbed-c
pub alias mbedtls-ecdh-context-mbedp = c-pointer<mbedtls-ecdh-context-mbed-c>
pub alias mbedtls-ecdh-context-mbedc = owned-c<mbedtls-ecdh-context-mbed-c>
pub alias mbedtls-ecdh-context-mbedcb<s::S> = borrowed-c<s,mbedtls-ecdh-context-mbed-c>
pub alias mbedtls-ecdh-context-mbedca = owned-c<c-array<mbedtls-ecdh-context-mbed-c>>

pub extern mbedtls-ecdh-context-mbed/size-of(c: c-null<mbedtls-ecdh-context-mbed-c>): int32
  c inline "sizeof(struct mbedtls_ecdh_context_mbed)"

pub fun mbedtls-ecdh-context-mbedc(): mbedtls-ecdh-context-mbedc
  malloc(?size-of=mbedtls-ecdh-context-mbed/size-of)

pub fun mbedtls-ecdh-context-mbedc-calloc(): mbedtls-ecdh-context-mbedc
  malloc-c(?size-of=mbedtls-ecdh-context-mbed/size-of)

pub fun mbedtls-ecdh-context-mbedc-array(n: int): mbedtls-ecdh-context-mbedca
  malloc(n.int32, ?size-of=mbedtls-ecdh-context-mbed/size-of)

pub fun mbedtls-ecdh-context-mbedc-array-calloc(n: int): mbedtls-ecdh-context-mbedca
  malloc-c(n.int32, ?size-of=mbedtls-ecdh-context-mbed/size-of)

// \warning         Performing multiple operations concurrently on the same
// ECDSA context is not supported; objects of this type
// should not be shared between multiple threads.
// \brief           The ECDH context structure.
pub struct mbedtls-ecdh-context
  // !< The format of point export in TLS messages
  // as defined in RFC 4492.
  private-point-format: int
  // !< The elliptic curve used.
  private-grp-id: int
  // !< The ECDH implementation/structure used.
  private-var: int
  // !< Implementation-specific context. The
  // context in use is specified by the \c var
  // field.
  private-ctx: unnamed-union10-c

pub type mbedtls-ecdh-context-c
pub alias mbedtls-ecdh-contextp = c-pointer<mbedtls-ecdh-context-c>
pub alias mbedtls-ecdh-contextc = owned-c<mbedtls-ecdh-context-c>
pub alias mbedtls-ecdh-contextcb<s::S> = borrowed-c<s,mbedtls-ecdh-context-c>
pub alias mbedtls-ecdh-contextca = owned-c<c-array<mbedtls-ecdh-context-c>>

pub extern mbedtls-ecdh-context/size-of(c: c-null<mbedtls-ecdh-context-c>): int32
  c inline "sizeof(struct mbedtls_ecdh_context)"

pub fun mbedtls-ecdh-contextc(): mbedtls-ecdh-contextc
  malloc(?size-of=mbedtls-ecdh-context/size-of)

pub fun mbedtls-ecdh-contextc-calloc(): mbedtls-ecdh-contextc
  malloc-c(?size-of=mbedtls-ecdh-context/size-of)

pub fun mbedtls-ecdh-contextc-array(n: int): mbedtls-ecdh-contextca
  malloc(n.int32, ?size-of=mbedtls-ecdh-context/size-of)

pub fun mbedtls-ecdh-contextc-array-calloc(n: int): mbedtls-ecdh-contextca
  malloc-c(n.int32, ?size-of=mbedtls-ecdh-context/size-of)

pub inline extern mbedtls-ecdh-context-ptrraw/private-point-format(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ecdh_context*)#1)->private_point_format)"

pub inline fun mbedtls-ecdh-contextp/private-point-format(s: mbedtls-ecdh-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ecdh-context-ptrraw/private-point-format.int

pub inline fun mbedtls-ecdh-contextc/private-point-format(^s: mbedtls-ecdh-contextc): <> int
  s.with-ptr(mbedtls-ecdh-contextp/private-point-format)

pub inline fun mbedtls-ecdh-contextcb/private-point-format(^s: mbedtls-ecdh-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ecdh-contextp/private-point-format)

pub inline extern mbedtls-ecdh-context-ptrraw/set-private-point-format(s: intptr_t, private-point-format: int8): ()
  c inline "((struct mbedtls_ecdh_context*)#1)->private_point_format = (uint8_t)#2"

pub inline fun mbedtls-ecdh-contextp/set-private-point-format(s: mbedtls-ecdh-contextp, private-point-format: int): ()
  s.mbedtls-ecdh-context-ptrraw/set-private-point-format(private-point-format.int8)

pub inline fun mbedtls-ecdh-contextc/set-private-point-format(^s: mbedtls-ecdh-contextc, private-point-format: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecdh-contextp/set-private-point-format(private-point-format))

pub inline fun mbedtls-ecdh-contextcb/set-private-point-format(^s: mbedtls-ecdh-contextcb<s::S>, private-point-format: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecdh-contextp/set-private-point-format(private-point-format))

pub inline extern mbedtls-ecdh-context-ptrraw/private-grp-id(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ecdh_context*)#1)->private_grp_id)"

pub inline fun mbedtls-ecdh-contextp/private-grp-id(s: mbedtls-ecdh-contextp): <exn> mbedtls-ecp-group-id
  s.cextern/c-pointer/ptr.mbedtls-ecdh-context-ptrraw/private-grp-id.int/mbedtls-ecp-group-id

pub inline fun mbedtls-ecdh-contextc/private-grp-id(^s: mbedtls-ecdh-contextc): <exn> mbedtls-ecp-group-id
  s.with-ptr(mbedtls-ecdh-contextp/private-grp-id)

pub inline fun mbedtls-ecdh-contextcb/private-grp-id(^s: mbedtls-ecdh-contextcb<s::S>): <exn> mbedtls-ecp-group-id
  s.with-ptr(mbedtls-ecdh-contextp/private-grp-id)

pub inline extern mbedtls-ecdh-context-ptrraw/set-private-grp-id(s: intptr_t, private-grp-id: int32): ()
  c inline "((struct mbedtls_ecdh_context*)#1)->private_grp_id = (int32_t)#2"

pub inline fun mbedtls-ecdh-contextp/set-private-grp-id(s: mbedtls-ecdh-contextp, private-grp-id: mbedtls-ecp-group-id): ()
  s.mbedtls-ecdh-context-ptrraw/set-private-grp-id(private-grp-id.mbedtls-ecp-group-id/int)

pub inline fun mbedtls-ecdh-contextc/set-private-grp-id(^s: mbedtls-ecdh-contextc, private-grp-id: mbedtls-ecp-group-id): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecdh-contextp/set-private-grp-id(private-grp-id))

pub inline fun mbedtls-ecdh-contextcb/set-private-grp-id(^s: mbedtls-ecdh-contextcb<s::S>, private-grp-id: mbedtls-ecp-group-id): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecdh-contextp/set-private-grp-id(private-grp-id))

pub inline extern mbedtls-ecdh-context-ptrraw/private-var(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ecdh_context*)#1)->private_var)"

pub inline fun mbedtls-ecdh-contextp/private-var(s: mbedtls-ecdh-contextp): <exn> mbedtls-ecdh-variant
  s.cextern/c-pointer/ptr.mbedtls-ecdh-context-ptrraw/private-var.int/mbedtls-ecdh-variant

pub inline fun mbedtls-ecdh-contextc/private-var(^s: mbedtls-ecdh-contextc): <exn> mbedtls-ecdh-variant
  s.with-ptr(mbedtls-ecdh-contextp/private-var)

pub inline fun mbedtls-ecdh-contextcb/private-var(^s: mbedtls-ecdh-contextcb<s::S>): <exn> mbedtls-ecdh-variant
  s.with-ptr(mbedtls-ecdh-contextp/private-var)

pub inline extern mbedtls-ecdh-context-ptrraw/set-private-var(s: intptr_t, private-var: int32): ()
  c inline "((struct mbedtls_ecdh_context*)#1)->private_var = (int32_t)#2"

pub inline fun mbedtls-ecdh-contextp/set-private-var(s: mbedtls-ecdh-contextp, private-var: mbedtls-ecdh-variant): ()
  s.mbedtls-ecdh-context-ptrraw/set-private-var(private-var.mbedtls-ecdh-variant/int)

pub inline fun mbedtls-ecdh-contextc/set-private-var(^s: mbedtls-ecdh-contextc, private-var: mbedtls-ecdh-variant): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecdh-contextp/set-private-var(private-var))

pub inline fun mbedtls-ecdh-contextcb/set-private-var(^s: mbedtls-ecdh-contextcb<s::S>, private-var: mbedtls-ecdh-variant): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ecdh-contextp/set-private-var(private-var))

pub struct unnamed-union10
pub type unnamed-union10-c
pub alias unnamed-union10p = c-pointer<unnamed-union10-c>
pub alias unnamed-union10c = owned-c<unnamed-union10-c>
pub alias unnamed-union10cb<s::S> = borrowed-c<s,unnamed-union10-c>
pub alias unnamed-union10ca = owned-c<c-array<unnamed-union10-c>>

pub struct mbedtls-ssl-premaster-secret
pub type mbedtls-ssl-premaster-secret-c
pub alias mbedtls-ssl-premaster-secretp = c-pointer<mbedtls-ssl-premaster-secret-c>
pub alias mbedtls-ssl-premaster-secretc<s::S> = owned-c<mbedtls-ssl-premaster-secret-c>
pub alias mbedtls-ssl-premaster-secretcb<s::S> = borrowed-c<s,mbedtls-ssl-premaster-secret-c>
pub alias mbedtls-ssl-premaster-secretca<s::S> = owned-c<c-array<mbedtls-ssl-premaster-secret-c>>

type mbedtls-ssl-states
  MBEDTLS_SSL_HELLO_REQUEST
  MBEDTLS_SSL_CLIENT_HELLO
  MBEDTLS_SSL_SERVER_HELLO
  MBEDTLS_SSL_SERVER_CERTIFICATE
  MBEDTLS_SSL_SERVER_KEY_EXCHANGE
  MBEDTLS_SSL_CERTIFICATE_REQUEST
  MBEDTLS_SSL_SERVER_HELLO_DONE
  MBEDTLS_SSL_CLIENT_CERTIFICATE
  MBEDTLS_SSL_CLIENT_KEY_EXCHANGE
  MBEDTLS_SSL_CERTIFICATE_VERIFY
  MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC
  MBEDTLS_SSL_CLIENT_FINISHED
  MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC
  MBEDTLS_SSL_SERVER_FINISHED
  MBEDTLS_SSL_FLUSH_BUFFERS
  MBEDTLS_SSL_HANDSHAKE_WRAPUP
  MBEDTLS_SSL_NEW_SESSION_TICKET
  MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT
  MBEDTLS_SSL_HELLO_RETRY_REQUEST
  MBEDTLS_SSL_ENCRYPTED_EXTENSIONS
  MBEDTLS_SSL_END_OF_EARLY_DATA
  MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY
  MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED
  MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO
  MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO
  MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO
  MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST
  MBEDTLS_SSL_HANDSHAKE_OVER
  MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET
  MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH

pub fun mbedtls-ssl-states/int(i: mbedtls-ssl-states): int32
  match i
    MBEDTLS_SSL_HELLO_REQUEST -> 0.int32
    MBEDTLS_SSL_CLIENT_HELLO -> 1.int32
    MBEDTLS_SSL_SERVER_HELLO -> 2.int32
    MBEDTLS_SSL_SERVER_CERTIFICATE -> 3.int32
    MBEDTLS_SSL_SERVER_KEY_EXCHANGE -> 4.int32
    MBEDTLS_SSL_CERTIFICATE_REQUEST -> 5.int32
    MBEDTLS_SSL_SERVER_HELLO_DONE -> 6.int32
    MBEDTLS_SSL_CLIENT_CERTIFICATE -> 7.int32
    MBEDTLS_SSL_CLIENT_KEY_EXCHANGE -> 8.int32
    MBEDTLS_SSL_CERTIFICATE_VERIFY -> 9.int32
    MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC -> 10.int32
    MBEDTLS_SSL_CLIENT_FINISHED -> 11.int32
    MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC -> 12.int32
    MBEDTLS_SSL_SERVER_FINISHED -> 13.int32
    MBEDTLS_SSL_FLUSH_BUFFERS -> 14.int32
    MBEDTLS_SSL_HANDSHAKE_WRAPUP -> 15.int32
    MBEDTLS_SSL_NEW_SESSION_TICKET -> 16.int32
    MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT -> 17.int32
    MBEDTLS_SSL_HELLO_RETRY_REQUEST -> 18.int32
    MBEDTLS_SSL_ENCRYPTED_EXTENSIONS -> 19.int32
    MBEDTLS_SSL_END_OF_EARLY_DATA -> 20.int32
    MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY -> 21.int32
    MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED -> 22.int32
    MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO -> 23.int32
    MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO -> 24.int32
    MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO -> 25.int32
    MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST -> 26.int32
    MBEDTLS_SSL_HANDSHAKE_OVER -> 27.int32
    MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET -> 28.int32
    MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH -> 29.int32

pub fun int/mbedtls-ssl-states(i: int32): exn mbedtls-ssl-states
  match i.int
    0 -> MBEDTLS_SSL_HELLO_REQUEST
    1 -> MBEDTLS_SSL_CLIENT_HELLO
    2 -> MBEDTLS_SSL_SERVER_HELLO
    3 -> MBEDTLS_SSL_SERVER_CERTIFICATE
    4 -> MBEDTLS_SSL_SERVER_KEY_EXCHANGE
    5 -> MBEDTLS_SSL_CERTIFICATE_REQUEST
    6 -> MBEDTLS_SSL_SERVER_HELLO_DONE
    7 -> MBEDTLS_SSL_CLIENT_CERTIFICATE
    8 -> MBEDTLS_SSL_CLIENT_KEY_EXCHANGE
    9 -> MBEDTLS_SSL_CERTIFICATE_VERIFY
    10 -> MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC
    11 -> MBEDTLS_SSL_CLIENT_FINISHED
    12 -> MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC
    13 -> MBEDTLS_SSL_SERVER_FINISHED
    14 -> MBEDTLS_SSL_FLUSH_BUFFERS
    15 -> MBEDTLS_SSL_HANDSHAKE_WRAPUP
    16 -> MBEDTLS_SSL_NEW_SESSION_TICKET
    17 -> MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT
    18 -> MBEDTLS_SSL_HELLO_RETRY_REQUEST
    19 -> MBEDTLS_SSL_ENCRYPTED_EXTENSIONS
    20 -> MBEDTLS_SSL_END_OF_EARLY_DATA
    21 -> MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY
    22 -> MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED
    23 -> MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO
    24 -> MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO
    25 -> MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO
    26 -> MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST
    27 -> MBEDTLS_SSL_HANDSHAKE_OVER
    28 -> MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET
    29 -> MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH

pub struct mbedtls-ssl-session
pub type mbedtls-ssl-session-c
pub alias mbedtls-ssl-sessionp = c-pointer<mbedtls-ssl-session-c>
pub alias mbedtls-ssl-sessionc<s::S> = owned-c<mbedtls-ssl-session-c>
pub alias mbedtls-ssl-sessioncb<s::S> = borrowed-c<s,mbedtls-ssl-session-c>
pub alias mbedtls-ssl-sessionca<s::S> = owned-c<c-array<mbedtls-ssl-session-c>>

pub extern mbedtls-ssl-session/size-of(c: c-null<mbedtls-ssl-session-c>): int32
  c inline "sizeof(struct mbedtls_ssl_session)"

pub fun mbedtls-ssl-sessionc(): mbedtls-ssl-sessionc<s::S>
  malloc(?size-of=mbedtls-ssl-session/size-of)

pub fun mbedtls-ssl-sessionc-calloc(): mbedtls-ssl-sessionc<s::S>
  malloc-c(?size-of=mbedtls-ssl-session/size-of)

pub fun mbedtls-ssl-sessionc-array(n: int): mbedtls-ssl-sessionca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-session/size-of)

pub fun mbedtls-ssl-sessionc-array-calloc(n: int): mbedtls-ssl-sessionca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-session/size-of)

pub inline extern mbedtls-ssl-session-ptrraw/private-mfl-code(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_ssl_session*)#1)->private_mfl_code)"

pub inline fun mbedtls-ssl-sessionp/private-mfl-code(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-mfl-code.int

pub inline fun mbedtls-ssl-sessionc/private-mfl-code(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-mfl-code)

pub inline fun mbedtls-ssl-sessioncb/private-mfl-code(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-mfl-code)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-mfl-code(s: intptr_t, private-mfl-code: int8): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_mfl_code = (unsigned char)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-mfl-code(s: mbedtls-ssl-sessionp, private-mfl-code: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-mfl-code(private-mfl-code.int8)

pub inline fun mbedtls-ssl-sessionc/set-private-mfl-code(^s: mbedtls-ssl-sessionc<s::S>, private-mfl-code: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-mfl-code(private-mfl-code))

pub inline fun mbedtls-ssl-sessioncb/set-private-mfl-code(^s: mbedtls-ssl-sessioncb<s::S>, private-mfl-code: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-mfl-code(private-mfl-code))

pub inline extern mbedtls-ssl-session-ptrraw/private-exported(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_ssl_session*)#1)->private_exported)"

pub inline fun mbedtls-ssl-sessionp/private-exported(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-exported.int

pub inline fun mbedtls-ssl-sessionc/private-exported(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-exported)

pub inline fun mbedtls-ssl-sessioncb/private-exported(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-exported)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-exported(s: intptr_t, private-exported: int8): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_exported = (unsigned char)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-exported(s: mbedtls-ssl-sessionp, private-exported: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-exported(private-exported.int8)

pub inline fun mbedtls-ssl-sessionc/set-private-exported(^s: mbedtls-ssl-sessionc<s::S>, private-exported: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-exported(private-exported))

pub inline fun mbedtls-ssl-sessioncb/set-private-exported(^s: mbedtls-ssl-sessioncb<s::S>, private-exported: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-exported(private-exported))

pub inline extern mbedtls-ssl-session-ptrraw/private-endpoint(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_session*)#1)->private_endpoint)"

pub inline fun mbedtls-ssl-sessionp/private-endpoint(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-endpoint.int

pub inline fun mbedtls-ssl-sessionc/private-endpoint(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-endpoint)

pub inline fun mbedtls-ssl-sessioncb/private-endpoint(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-endpoint)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-endpoint(s: intptr_t, private-endpoint: int8): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_endpoint = (uint8_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-endpoint(s: mbedtls-ssl-sessionp, private-endpoint: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-endpoint(private-endpoint.int8)

pub inline fun mbedtls-ssl-sessionc/set-private-endpoint(^s: mbedtls-ssl-sessionc<s::S>, private-endpoint: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-endpoint(private-endpoint))

pub inline fun mbedtls-ssl-sessioncb/set-private-endpoint(^s: mbedtls-ssl-sessioncb<s::S>, private-endpoint: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-endpoint(private-endpoint))

pub inline extern mbedtls-ssl-session-ptrraw/private-tls-version(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_session*)#1)->private_tls_version)"

pub inline fun mbedtls-ssl-sessionp/private-tls-version(s: mbedtls-ssl-sessionp): <exn> mbedtls-ssl-protocol-version
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-tls-version.int/mbedtls-ssl-protocol-version

pub inline fun mbedtls-ssl-sessionc/private-tls-version(^s: mbedtls-ssl-sessionc<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-sessionp/private-tls-version)

pub inline fun mbedtls-ssl-sessioncb/private-tls-version(^s: mbedtls-ssl-sessioncb<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-sessionp/private-tls-version)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-tls-version(s: intptr_t, private-tls-version: int32): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_tls_version = (int32_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-tls-version(s: mbedtls-ssl-sessionp, private-tls-version: mbedtls-ssl-protocol-version): ()
  s.mbedtls-ssl-session-ptrraw/set-private-tls-version(private-tls-version.mbedtls-ssl-protocol-version/int)

pub inline fun mbedtls-ssl-sessionc/set-private-tls-version(^s: mbedtls-ssl-sessionc<s::S>, private-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-tls-version(private-tls-version))

pub inline fun mbedtls-ssl-sessioncb/set-private-tls-version(^s: mbedtls-ssl-sessioncb<s::S>, private-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-tls-version(private-tls-version))

pub inline extern mbedtls-ssl-session-ptrraw/private-start(s: intptr_t): int64
  c inline "(mbedtls_time_t)(((struct mbedtls_ssl_session*)#1)->private_start)"

pub inline fun mbedtls-ssl-sessionp/private-start(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-start.int

pub inline fun mbedtls-ssl-sessionc/private-start(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-start)

pub inline fun mbedtls-ssl-sessioncb/private-start(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-start)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-start(s: intptr_t, private-start: int64): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_start = (mbedtls_time_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-start(s: mbedtls-ssl-sessionp, private-start: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-start(private-start.int64)

pub inline fun mbedtls-ssl-sessionc/set-private-start(^s: mbedtls-ssl-sessionc<s::S>, private-start: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-start(private-start))

pub inline fun mbedtls-ssl-sessioncb/set-private-start(^s: mbedtls-ssl-sessioncb<s::S>, private-start: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-start(private-start))

pub inline extern mbedtls-ssl-session-ptrraw/private-ciphersuite(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_session*)#1)->private_ciphersuite)"

pub inline fun mbedtls-ssl-sessionp/private-ciphersuite(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ciphersuite.int

pub inline fun mbedtls-ssl-sessionc/private-ciphersuite(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ciphersuite)

pub inline fun mbedtls-ssl-sessioncb/private-ciphersuite(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ciphersuite)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ciphersuite(s: intptr_t, private-ciphersuite: int32): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ciphersuite = (int)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ciphersuite(s: mbedtls-ssl-sessionp, private-ciphersuite: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ciphersuite(private-ciphersuite.int32)

pub inline fun mbedtls-ssl-sessionc/set-private-ciphersuite(^s: mbedtls-ssl-sessionc<s::S>, private-ciphersuite: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ciphersuite(private-ciphersuite))

pub inline fun mbedtls-ssl-sessioncb/set-private-ciphersuite(^s: mbedtls-ssl-sessioncb<s::S>, private-ciphersuite: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ciphersuite(private-ciphersuite))

pub inline extern mbedtls-ssl-session-ptrraw/private-id-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_session*)#1)->private_id_len)"

pub inline fun mbedtls-ssl-sessionp/private-id-len(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-id-len.int

pub inline fun mbedtls-ssl-sessionc/private-id-len(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-id-len)

pub inline fun mbedtls-ssl-sessioncb/private-id-len(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-id-len)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-id-len(s: intptr_t, private-id-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_id_len = (size_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-id-len(s: mbedtls-ssl-sessionp, private-id-len: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-id-len(private-id-len.ssize_t)

pub inline fun mbedtls-ssl-sessionc/set-private-id-len(^s: mbedtls-ssl-sessionc<s::S>, private-id-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-id-len(private-id-len))

pub inline fun mbedtls-ssl-sessioncb/set-private-id-len(^s: mbedtls-ssl-sessioncb<s::S>, private-id-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-id-len(private-id-len))

pub inline extern mbedtls-ssl-session-ptrraw/private-id(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_session*)#1)->private_id)"

pub inline fun mbedtls-ssl-sessionp/private-id(s: mbedtls-ssl-sessionp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-id.cextern/ptr/carray

pub inline fun mbedtls-ssl-sessionc/private-id(^s: mbedtls-ssl-sessionc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-id)

pub inline fun mbedtls-ssl-sessioncb/private-id(^s: mbedtls-ssl-sessioncb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-id)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-id(s: intptr_t, private-id: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_id = (unsigned char*)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-id(s: mbedtls-ssl-sessionp, private-id: c-array<int>): ()
  s.mbedtls-ssl-session-ptrraw/set-private-id(private-id.cextern/carray/ptr)

pub inline fun mbedtls-ssl-sessionc/set-private-id(^s: mbedtls-ssl-sessionc<s::S>, private-id: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-id(private-id))

pub inline fun mbedtls-ssl-sessioncb/set-private-id(^s: mbedtls-ssl-sessioncb<s::S>, private-id: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-id(private-id))

pub inline extern mbedtls-ssl-session-ptrraw/private-master(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_session*)#1)->private_master)"

pub inline fun mbedtls-ssl-sessionp/private-master(s: mbedtls-ssl-sessionp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-master.cextern/ptr/carray

pub inline fun mbedtls-ssl-sessionc/private-master(^s: mbedtls-ssl-sessionc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-master)

pub inline fun mbedtls-ssl-sessioncb/private-master(^s: mbedtls-ssl-sessioncb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-master)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-master(s: intptr_t, private-master: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_master = (unsigned char*)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-master(s: mbedtls-ssl-sessionp, private-master: c-array<int>): ()
  s.mbedtls-ssl-session-ptrraw/set-private-master(private-master.cextern/carray/ptr)

pub inline fun mbedtls-ssl-sessionc/set-private-master(^s: mbedtls-ssl-sessionc<s::S>, private-master: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-master(private-master))

pub inline fun mbedtls-ssl-sessioncb/set-private-master(^s: mbedtls-ssl-sessioncb<s::S>, private-master: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-master(private-master))

pub inline extern mbedtls-ssl-session-ptrraw/private-peer-cert(s: intptr_t): c-pointer<mbedtls-x509-crt-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_session*)#1)->private_peer_cert)"

pub inline fun mbedtls-ssl-sessionp/private-peer-cert(s: mbedtls-ssl-sessionp): <> c-pointer<mbedtls-x509-crt-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-peer-cert

pub inline fun mbedtls-ssl-sessionc/private-peer-cert(^s: mbedtls-ssl-sessionc<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-ssl-sessionp/private-peer-cert)

pub inline fun mbedtls-ssl-sessioncb/private-peer-cert(^s: mbedtls-ssl-sessioncb<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-ssl-sessionp/private-peer-cert)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-peer-cert(s: intptr_t, private-peer-cert: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_peer_cert = (struct mbedtls_x509_crt*)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-peer-cert(s: mbedtls-ssl-sessionp, private-peer-cert: c-pointer<mbedtls-x509-crt-c>): ()
  s.mbedtls-ssl-session-ptrraw/set-private-peer-cert(private-peer-cert)

pub inline fun mbedtls-ssl-sessionc/set-private-peer-cert(^s: mbedtls-ssl-sessionc<s::S>, private-peer-cert: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-peer-cert(private-peer-cert))

pub inline fun mbedtls-ssl-sessioncb/set-private-peer-cert(^s: mbedtls-ssl-sessioncb<s::S>, private-peer-cert: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-peer-cert(private-peer-cert))

pub inline extern mbedtls-ssl-session-ptrraw/private-verify-result(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_session*)#1)->private_verify_result)"

pub inline fun mbedtls-ssl-sessionp/private-verify-result(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-verify-result.int

pub inline fun mbedtls-ssl-sessionc/private-verify-result(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-verify-result)

pub inline fun mbedtls-ssl-sessioncb/private-verify-result(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-verify-result)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-verify-result(s: intptr_t, private-verify-result: int32): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_verify_result = (int32_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-verify-result(s: mbedtls-ssl-sessionp, private-verify-result: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-verify-result(private-verify-result.int32)

pub inline fun mbedtls-ssl-sessionc/set-private-verify-result(^s: mbedtls-ssl-sessionc<s::S>, private-verify-result: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-verify-result(private-verify-result))

pub inline fun mbedtls-ssl-sessioncb/set-private-verify-result(^s: mbedtls-ssl-sessioncb<s::S>, private-verify-result: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-verify-result(private-verify-result))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_session*)#1)->private_ticket)"

pub inline fun mbedtls-ssl-sessionp/private-ticket(s: mbedtls-ssl-sessionp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket

pub inline fun mbedtls-ssl-sessionc/private-ticket(^s: mbedtls-ssl-sessionc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket)

pub inline fun mbedtls-ssl-sessioncb/private-ticket(^s: mbedtls-ssl-sessioncb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket(s: intptr_t, private-ticket: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket = (unsigned char*)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket(s: mbedtls-ssl-sessionp, private-ticket: c-pointer<int>): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket(private-ticket)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket(^s: mbedtls-ssl-sessionc<s::S>, private-ticket: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket(private-ticket))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket(private-ticket))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_session*)#1)->private_ticket_len)"

pub inline fun mbedtls-ssl-sessionp/private-ticket-len(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket-len.int

pub inline fun mbedtls-ssl-sessionc/private-ticket-len(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-len)

pub inline fun mbedtls-ssl-sessioncb/private-ticket-len(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-len)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket-len(s: intptr_t, private-ticket-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket_len = (size_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket-len(s: mbedtls-ssl-sessionp, private-ticket-len: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket-len(private-ticket-len.ssize_t)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket-len(^s: mbedtls-ssl-sessionc<s::S>, private-ticket-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-len(private-ticket-len))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket-len(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-len(private-ticket-len))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket-lifetime(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_session*)#1)->private_ticket_lifetime)"

pub inline fun mbedtls-ssl-sessionp/private-ticket-lifetime(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket-lifetime.int

pub inline fun mbedtls-ssl-sessionc/private-ticket-lifetime(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-lifetime)

pub inline fun mbedtls-ssl-sessioncb/private-ticket-lifetime(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-lifetime)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket-lifetime(s: intptr_t, private-ticket-lifetime: int32): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket_lifetime = (int32_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket-lifetime(s: mbedtls-ssl-sessionp, private-ticket-lifetime: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket-lifetime(private-ticket-lifetime.int32)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket-lifetime(^s: mbedtls-ssl-sessionc<s::S>, private-ticket-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-lifetime(private-ticket-lifetime))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket-lifetime(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-lifetime(private-ticket-lifetime))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket-creation-time(s: intptr_t): int64
  c inline "(mbedtls_ms_time_t)(((struct mbedtls_ssl_session*)#1)->private_ticket_creation_time)"

pub inline fun mbedtls-ssl-sessionp/private-ticket-creation-time(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket-creation-time.int

pub inline fun mbedtls-ssl-sessionc/private-ticket-creation-time(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-creation-time)

pub inline fun mbedtls-ssl-sessioncb/private-ticket-creation-time(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-creation-time)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket-creation-time(s: intptr_t, private-ticket-creation-time: int64): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket_creation_time = (mbedtls_ms_time_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket-creation-time(s: mbedtls-ssl-sessionp, private-ticket-creation-time: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket-creation-time(private-ticket-creation-time.int64)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket-creation-time(^s: mbedtls-ssl-sessionc<s::S>, private-ticket-creation-time: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-creation-time(private-ticket-creation-time))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket-creation-time(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket-creation-time: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-creation-time(private-ticket-creation-time))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket-age-add(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_session*)#1)->private_ticket_age_add)"

pub inline fun mbedtls-ssl-sessionp/private-ticket-age-add(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket-age-add.int

pub inline fun mbedtls-ssl-sessionc/private-ticket-age-add(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-age-add)

pub inline fun mbedtls-ssl-sessioncb/private-ticket-age-add(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-age-add)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket-age-add(s: intptr_t, private-ticket-age-add: int32): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket_age_add = (int32_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket-age-add(s: mbedtls-ssl-sessionp, private-ticket-age-add: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket-age-add(private-ticket-age-add.int32)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket-age-add(^s: mbedtls-ssl-sessionc<s::S>, private-ticket-age-add: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-age-add(private-ticket-age-add))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket-age-add(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket-age-add: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-age-add(private-ticket-age-add))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket-flags(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_session*)#1)->private_ticket_flags)"

pub inline fun mbedtls-ssl-sessionp/private-ticket-flags(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket-flags.int

pub inline fun mbedtls-ssl-sessionc/private-ticket-flags(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-flags)

pub inline fun mbedtls-ssl-sessioncb/private-ticket-flags(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-flags)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket-flags(s: intptr_t, private-ticket-flags: int8): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket_flags = (uint8_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket-flags(s: mbedtls-ssl-sessionp, private-ticket-flags: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket-flags(private-ticket-flags.int8)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket-flags(^s: mbedtls-ssl-sessionc<s::S>, private-ticket-flags: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-flags(private-ticket-flags))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket-flags(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket-flags: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-flags(private-ticket-flags))

pub inline extern mbedtls-ssl-session-ptrraw/private-resumption-key-len(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_session*)#1)->private_resumption_key_len)"

pub inline fun mbedtls-ssl-sessionp/private-resumption-key-len(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-resumption-key-len.int

pub inline fun mbedtls-ssl-sessionc/private-resumption-key-len(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-resumption-key-len)

pub inline fun mbedtls-ssl-sessioncb/private-resumption-key-len(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-resumption-key-len)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-resumption-key-len(s: intptr_t, private-resumption-key-len: int8): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_resumption_key_len = (uint8_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-resumption-key-len(s: mbedtls-ssl-sessionp, private-resumption-key-len: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-resumption-key-len(private-resumption-key-len.int8)

pub inline fun mbedtls-ssl-sessionc/set-private-resumption-key-len(^s: mbedtls-ssl-sessionc<s::S>, private-resumption-key-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-resumption-key-len(private-resumption-key-len))

pub inline fun mbedtls-ssl-sessioncb/set-private-resumption-key-len(^s: mbedtls-ssl-sessioncb<s::S>, private-resumption-key-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-resumption-key-len(private-resumption-key-len))

pub inline extern mbedtls-ssl-session-ptrraw/private-resumption-key(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_session*)#1)->private_resumption_key)"

pub inline fun mbedtls-ssl-sessionp/private-resumption-key(s: mbedtls-ssl-sessionp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-resumption-key.cextern/ptr/carray

pub inline fun mbedtls-ssl-sessionc/private-resumption-key(^s: mbedtls-ssl-sessionc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-resumption-key)

pub inline fun mbedtls-ssl-sessioncb/private-resumption-key(^s: mbedtls-ssl-sessioncb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-resumption-key)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-resumption-key(s: intptr_t, private-resumption-key: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_resumption_key = (unsigned char*)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-resumption-key(s: mbedtls-ssl-sessionp, private-resumption-key: c-array<int>): ()
  s.mbedtls-ssl-session-ptrraw/set-private-resumption-key(private-resumption-key.cextern/carray/ptr)

pub inline fun mbedtls-ssl-sessionc/set-private-resumption-key(^s: mbedtls-ssl-sessionc<s::S>, private-resumption-key: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-resumption-key(private-resumption-key))

pub inline fun mbedtls-ssl-sessioncb/set-private-resumption-key(^s: mbedtls-ssl-sessioncb<s::S>, private-resumption-key: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-resumption-key(private-resumption-key))

pub inline extern mbedtls-ssl-session-ptrraw/private-hostname(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_session*)#1)->private_hostname)"

pub inline fun mbedtls-ssl-sessionp/private-hostname(s: mbedtls-ssl-sessionp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-hostname

pub inline fun mbedtls-ssl-sessionc/private-hostname(^s: mbedtls-ssl-sessionc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-hostname)

pub inline fun mbedtls-ssl-sessioncb/private-hostname(^s: mbedtls-ssl-sessioncb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-sessionp/private-hostname)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-hostname(s: intptr_t, private-hostname: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_hostname = (char*)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-hostname(s: mbedtls-ssl-sessionp, private-hostname: c-pointer<int>): ()
  s.mbedtls-ssl-session-ptrraw/set-private-hostname(private-hostname)

pub inline fun mbedtls-ssl-sessionc/set-private-hostname(^s: mbedtls-ssl-sessionc<s::S>, private-hostname: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-hostname(private-hostname))

pub inline fun mbedtls-ssl-sessioncb/set-private-hostname(^s: mbedtls-ssl-sessioncb<s::S>, private-hostname: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-hostname(private-hostname))

pub inline extern mbedtls-ssl-session-ptrraw/private-ticket-reception-time(s: intptr_t): int64
  c inline "(mbedtls_ms_time_t)(((struct mbedtls_ssl_session*)#1)->private_ticket_reception_time)"

pub inline fun mbedtls-ssl-sessionp/private-ticket-reception-time(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-ticket-reception-time.int

pub inline fun mbedtls-ssl-sessionc/private-ticket-reception-time(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-reception-time)

pub inline fun mbedtls-ssl-sessioncb/private-ticket-reception-time(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-ticket-reception-time)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-ticket-reception-time(s: intptr_t, private-ticket-reception-time: int64): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_ticket_reception_time = (mbedtls_ms_time_t)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-ticket-reception-time(s: mbedtls-ssl-sessionp, private-ticket-reception-time: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-ticket-reception-time(private-ticket-reception-time.int64)

pub inline fun mbedtls-ssl-sessionc/set-private-ticket-reception-time(^s: mbedtls-ssl-sessionc<s::S>, private-ticket-reception-time: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-reception-time(private-ticket-reception-time))

pub inline fun mbedtls-ssl-sessioncb/set-private-ticket-reception-time(^s: mbedtls-ssl-sessioncb<s::S>, private-ticket-reception-time: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-ticket-reception-time(private-ticket-reception-time))

pub inline extern mbedtls-ssl-session-ptrraw/private-encrypt-then-mac(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_session*)#1)->private_encrypt_then_mac)"

pub inline fun mbedtls-ssl-sessionp/private-encrypt-then-mac(s: mbedtls-ssl-sessionp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-session-ptrraw/private-encrypt-then-mac.int

pub inline fun mbedtls-ssl-sessionc/private-encrypt-then-mac(^s: mbedtls-ssl-sessionc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-encrypt-then-mac)

pub inline fun mbedtls-ssl-sessioncb/private-encrypt-then-mac(^s: mbedtls-ssl-sessioncb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-sessionp/private-encrypt-then-mac)

pub inline extern mbedtls-ssl-session-ptrraw/set-private-encrypt-then-mac(s: intptr_t, private-encrypt-then-mac: int32): ()
  c inline "((struct mbedtls_ssl_session*)#1)->private_encrypt_then_mac = (int)#2"

pub inline fun mbedtls-ssl-sessionp/set-private-encrypt-then-mac(s: mbedtls-ssl-sessionp, private-encrypt-then-mac: int): ()
  s.mbedtls-ssl-session-ptrraw/set-private-encrypt-then-mac(private-encrypt-then-mac.int32)

pub inline fun mbedtls-ssl-sessionc/set-private-encrypt-then-mac(^s: mbedtls-ssl-sessionc<s::S>, private-encrypt-then-mac: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-encrypt-then-mac(private-encrypt-then-mac))

pub inline fun mbedtls-ssl-sessioncb/set-private-encrypt-then-mac(^s: mbedtls-ssl-sessioncb<s::S>, private-encrypt-then-mac: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-sessionp/set-private-encrypt-then-mac(private-encrypt-then-mac))

// Human-friendly representation of the (D)TLS protocol version.
type mbedtls-ssl-protocol-version
  // !< Context not in use or version not yet negotiated.
  MBEDTLS_SSL_VERSION_UNKNOWN
  // !< (D)TLS 1.2
  MBEDTLS_SSL_VERSION_TLS1_2
  // !< (D)TLS 1.3
  MBEDTLS_SSL_VERSION_TLS1_3

pub fun mbedtls-ssl-protocol-version/int(i: mbedtls-ssl-protocol-version): int32
  match i
    MBEDTLS_SSL_VERSION_UNKNOWN -> 0.int32
    MBEDTLS_SSL_VERSION_TLS1_2 -> 771.int32
    MBEDTLS_SSL_VERSION_TLS1_3 -> 772.int32

pub fun int/mbedtls-ssl-protocol-version(i: int32): exn mbedtls-ssl-protocol-version
  match i.int
    0 -> MBEDTLS_SSL_VERSION_UNKNOWN
    771 -> MBEDTLS_SSL_VERSION_TLS1_2
    772 -> MBEDTLS_SSL_VERSION_TLS1_3

pub struct mbedtls-ssl-tls13-application-secrets
pub type mbedtls-ssl-tls13-application-secrets-c
pub alias mbedtls-ssl-tls13-application-secretsp = c-pointer<mbedtls-ssl-tls13-application-secrets-c>
pub alias mbedtls-ssl-tls13-application-secretsc<s::S> = owned-c<mbedtls-ssl-tls13-application-secrets-c>
pub alias mbedtls-ssl-tls13-application-secretscb<s::S> = borrowed-c<s,mbedtls-ssl-tls13-application-secrets-c>
pub alias mbedtls-ssl-tls13-application-secretsca<s::S> = owned-c<c-array<mbedtls-ssl-tls13-application-secrets-c>>

pub extern mbedtls-ssl-tls13-application-secrets/size-of(c: c-null<mbedtls-ssl-tls13-application-secrets-c>): int32
  c inline "sizeof(mbedtls_ssl_tls13_application_secrets)"

pub fun mbedtls-ssl-tls13-application-secretsc(): mbedtls-ssl-tls13-application-secretsc<s::S>
  malloc(?size-of=mbedtls-ssl-tls13-application-secrets/size-of)

pub fun mbedtls-ssl-tls13-application-secretsc-calloc(): mbedtls-ssl-tls13-application-secretsc<s::S>
  malloc-c(?size-of=mbedtls-ssl-tls13-application-secrets/size-of)

pub fun mbedtls-ssl-tls13-application-secretsc-array(n: int): mbedtls-ssl-tls13-application-secretsca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-tls13-application-secrets/size-of)

pub fun mbedtls-ssl-tls13-application-secretsc-array-calloc(n: int): mbedtls-ssl-tls13-application-secretsca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-tls13-application-secrets/size-of)

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/client-application-traffic-secret-n(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_ssl_tls13_application_secrets*)#1)->client_application_traffic_secret_N)"

pub inline fun mbedtls-ssl-tls13-application-secretsp/client-application-traffic-secret-n(s: mbedtls-ssl-tls13-application-secretsp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-tls13-application-secrets-ptrraw/client-application-traffic-secret-n.cextern/ptr/carray

pub inline fun mbedtls-ssl-tls13-application-secretsc/client-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretsc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/client-application-traffic-secret-n)

pub inline fun mbedtls-ssl-tls13-application-secretscb/client-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretscb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/client-application-traffic-secret-n)

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/set-client-application-traffic-secret-n(s: intptr_t, client-application-traffic-secret-n: c-pointer<int>): ()
  c inline "((mbedtls_ssl_tls13_application_secrets*)#1)->client_application_traffic_secret_N = (unsigned char*)#2"

pub inline fun mbedtls-ssl-tls13-application-secretsp/set-client-application-traffic-secret-n(s: mbedtls-ssl-tls13-application-secretsp, client-application-traffic-secret-n: c-array<int>): ()
  s.mbedtls-ssl-tls13-application-secrets-ptrraw/set-client-application-traffic-secret-n(client-application-traffic-secret-n.cextern/carray/ptr)

pub inline fun mbedtls-ssl-tls13-application-secretsc/set-client-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretsc<s::S>, client-application-traffic-secret-n: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-client-application-traffic-secret-n(client-application-traffic-secret-n))

pub inline fun mbedtls-ssl-tls13-application-secretscb/set-client-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretscb<s::S>, client-application-traffic-secret-n: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-client-application-traffic-secret-n(client-application-traffic-secret-n))

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/server-application-traffic-secret-n(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_ssl_tls13_application_secrets*)#1)->server_application_traffic_secret_N)"

pub inline fun mbedtls-ssl-tls13-application-secretsp/server-application-traffic-secret-n(s: mbedtls-ssl-tls13-application-secretsp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-tls13-application-secrets-ptrraw/server-application-traffic-secret-n.cextern/ptr/carray

pub inline fun mbedtls-ssl-tls13-application-secretsc/server-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretsc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/server-application-traffic-secret-n)

pub inline fun mbedtls-ssl-tls13-application-secretscb/server-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretscb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/server-application-traffic-secret-n)

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/set-server-application-traffic-secret-n(s: intptr_t, server-application-traffic-secret-n: c-pointer<int>): ()
  c inline "((mbedtls_ssl_tls13_application_secrets*)#1)->server_application_traffic_secret_N = (unsigned char*)#2"

pub inline fun mbedtls-ssl-tls13-application-secretsp/set-server-application-traffic-secret-n(s: mbedtls-ssl-tls13-application-secretsp, server-application-traffic-secret-n: c-array<int>): ()
  s.mbedtls-ssl-tls13-application-secrets-ptrraw/set-server-application-traffic-secret-n(server-application-traffic-secret-n.cextern/carray/ptr)

pub inline fun mbedtls-ssl-tls13-application-secretsc/set-server-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretsc<s::S>, server-application-traffic-secret-n: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-server-application-traffic-secret-n(server-application-traffic-secret-n))

pub inline fun mbedtls-ssl-tls13-application-secretscb/set-server-application-traffic-secret-n(^s: mbedtls-ssl-tls13-application-secretscb<s::S>, server-application-traffic-secret-n: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-server-application-traffic-secret-n(server-application-traffic-secret-n))

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/exporter-master-secret(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_ssl_tls13_application_secrets*)#1)->exporter_master_secret)"

pub inline fun mbedtls-ssl-tls13-application-secretsp/exporter-master-secret(s: mbedtls-ssl-tls13-application-secretsp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-tls13-application-secrets-ptrraw/exporter-master-secret.cextern/ptr/carray

pub inline fun mbedtls-ssl-tls13-application-secretsc/exporter-master-secret(^s: mbedtls-ssl-tls13-application-secretsc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/exporter-master-secret)

pub inline fun mbedtls-ssl-tls13-application-secretscb/exporter-master-secret(^s: mbedtls-ssl-tls13-application-secretscb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/exporter-master-secret)

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/set-exporter-master-secret(s: intptr_t, exporter-master-secret: c-pointer<int>): ()
  c inline "((mbedtls_ssl_tls13_application_secrets*)#1)->exporter_master_secret = (unsigned char*)#2"

pub inline fun mbedtls-ssl-tls13-application-secretsp/set-exporter-master-secret(s: mbedtls-ssl-tls13-application-secretsp, exporter-master-secret: c-array<int>): ()
  s.mbedtls-ssl-tls13-application-secrets-ptrraw/set-exporter-master-secret(exporter-master-secret.cextern/carray/ptr)

pub inline fun mbedtls-ssl-tls13-application-secretsc/set-exporter-master-secret(^s: mbedtls-ssl-tls13-application-secretsc<s::S>, exporter-master-secret: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-exporter-master-secret(exporter-master-secret))

pub inline fun mbedtls-ssl-tls13-application-secretscb/set-exporter-master-secret(^s: mbedtls-ssl-tls13-application-secretscb<s::S>, exporter-master-secret: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-exporter-master-secret(exporter-master-secret))

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/resumption-master-secret(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_ssl_tls13_application_secrets*)#1)->resumption_master_secret)"

pub inline fun mbedtls-ssl-tls13-application-secretsp/resumption-master-secret(s: mbedtls-ssl-tls13-application-secretsp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-tls13-application-secrets-ptrraw/resumption-master-secret.cextern/ptr/carray

pub inline fun mbedtls-ssl-tls13-application-secretsc/resumption-master-secret(^s: mbedtls-ssl-tls13-application-secretsc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/resumption-master-secret)

pub inline fun mbedtls-ssl-tls13-application-secretscb/resumption-master-secret(^s: mbedtls-ssl-tls13-application-secretscb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-tls13-application-secretsp/resumption-master-secret)

pub inline extern mbedtls-ssl-tls13-application-secrets-ptrraw/set-resumption-master-secret(s: intptr_t, resumption-master-secret: c-pointer<int>): ()
  c inline "((mbedtls_ssl_tls13_application_secrets*)#1)->resumption_master_secret = (unsigned char*)#2"

pub inline fun mbedtls-ssl-tls13-application-secretsp/set-resumption-master-secret(s: mbedtls-ssl-tls13-application-secretsp, resumption-master-secret: c-array<int>): ()
  s.mbedtls-ssl-tls13-application-secrets-ptrraw/set-resumption-master-secret(resumption-master-secret.cextern/carray/ptr)

pub inline fun mbedtls-ssl-tls13-application-secretsc/set-resumption-master-secret(^s: mbedtls-ssl-tls13-application-secretsc<s::S>, resumption-master-secret: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-resumption-master-secret(resumption-master-secret))

pub inline fun mbedtls-ssl-tls13-application-secretscb/set-resumption-master-secret(^s: mbedtls-ssl-tls13-application-secretscb<s::S>, resumption-master-secret: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-tls13-application-secretsp/set-resumption-master-secret(resumption-master-secret))

pub struct mbedtls-ssl-context
pub type mbedtls-ssl-context-c
pub alias mbedtls-ssl-contextp = c-pointer<mbedtls-ssl-context-c>
pub alias mbedtls-ssl-contextc<s::S> = owned-c<mbedtls-ssl-context-c>
pub alias mbedtls-ssl-contextcb<s::S> = borrowed-c<s,mbedtls-ssl-context-c>
pub alias mbedtls-ssl-contextca<s::S> = owned-c<c-array<mbedtls-ssl-context-c>>

pub extern mbedtls-ssl-context/size-of(c: c-null<mbedtls-ssl-context-c>): int32
  c inline "sizeof(struct mbedtls_ssl_context)"

pub fun mbedtls-ssl-contextc(): mbedtls-ssl-contextc<s::S>
  malloc(?size-of=mbedtls-ssl-context/size-of)

pub fun mbedtls-ssl-contextc-calloc(): mbedtls-ssl-contextc<s::S>
  malloc-c(?size-of=mbedtls-ssl-context/size-of)

pub fun mbedtls-ssl-contextc-array(n: int): mbedtls-ssl-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-context/size-of)

pub fun mbedtls-ssl-contextc-array-calloc(n: int): mbedtls-ssl-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-context/size-of)

pub inline extern mbedtls-ssl-context-ptrraw/private-conf(s: intptr_t): c-pointer<mbedtls-ssl-config-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_conf)"

pub inline fun mbedtls-ssl-contextp/private-conf(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-config-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-conf

pub inline fun mbedtls-ssl-contextc/private-conf(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-config-c>
  s.with-ptr(mbedtls-ssl-contextp/private-conf)

pub inline fun mbedtls-ssl-contextcb/private-conf(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-config-c>
  s.with-ptr(mbedtls-ssl-contextp/private-conf)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-conf(s: intptr_t, private-conf: c-pointer<mbedtls-ssl-config-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_conf = (struct mbedtls_ssl_config*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-conf(s: mbedtls-ssl-contextp, private-conf: c-pointer<mbedtls-ssl-config-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-conf(private-conf)

pub inline fun mbedtls-ssl-contextc/set-private-conf(^s: mbedtls-ssl-contextc<s::S>, private-conf: c-pointer<mbedtls-ssl-config-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-conf(private-conf))

pub inline fun mbedtls-ssl-contextcb/set-private-conf(^s: mbedtls-ssl-contextcb<s::S>, private-conf: c-pointer<mbedtls-ssl-config-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-conf(private-conf))

pub inline extern mbedtls-ssl-context-ptrraw/private-state(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_state)"

pub inline fun mbedtls-ssl-contextp/private-state(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-state.int

pub inline fun mbedtls-ssl-contextc/private-state(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-state)

pub inline fun mbedtls-ssl-contextcb/private-state(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-state)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-state(s: intptr_t, private-state: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_state = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-state(s: mbedtls-ssl-contextp, private-state: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-state(private-state.int32)

pub inline fun mbedtls-ssl-contextc/set-private-state(^s: mbedtls-ssl-contextc<s::S>, private-state: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-state(private-state))

pub inline fun mbedtls-ssl-contextcb/set-private-state(^s: mbedtls-ssl-contextcb<s::S>, private-state: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-state(private-state))

pub inline extern mbedtls-ssl-context-ptrraw/private-renego-status(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_renego_status)"

pub inline fun mbedtls-ssl-contextp/private-renego-status(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-renego-status.int

pub inline fun mbedtls-ssl-contextc/private-renego-status(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-renego-status)

pub inline fun mbedtls-ssl-contextcb/private-renego-status(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-renego-status)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-renego-status(s: intptr_t, private-renego-status: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_renego_status = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-renego-status(s: mbedtls-ssl-contextp, private-renego-status: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-renego-status(private-renego-status.int32)

pub inline fun mbedtls-ssl-contextc/set-private-renego-status(^s: mbedtls-ssl-contextc<s::S>, private-renego-status: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-renego-status(private-renego-status))

pub inline fun mbedtls-ssl-contextcb/set-private-renego-status(^s: mbedtls-ssl-contextcb<s::S>, private-renego-status: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-renego-status(private-renego-status))

pub inline extern mbedtls-ssl-context-ptrraw/private-renego-records-seen(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_renego_records_seen)"

pub inline fun mbedtls-ssl-contextp/private-renego-records-seen(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-renego-records-seen.int

pub inline fun mbedtls-ssl-contextc/private-renego-records-seen(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-renego-records-seen)

pub inline fun mbedtls-ssl-contextcb/private-renego-records-seen(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-renego-records-seen)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-renego-records-seen(s: intptr_t, private-renego-records-seen: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_renego_records_seen = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-renego-records-seen(s: mbedtls-ssl-contextp, private-renego-records-seen: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-renego-records-seen(private-renego-records-seen.int32)

pub inline fun mbedtls-ssl-contextc/set-private-renego-records-seen(^s: mbedtls-ssl-contextc<s::S>, private-renego-records-seen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-renego-records-seen(private-renego-records-seen))

pub inline fun mbedtls-ssl-contextcb/set-private-renego-records-seen(^s: mbedtls-ssl-contextcb<s::S>, private-renego-records-seen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-renego-records-seen(private-renego-records-seen))

pub inline extern mbedtls-ssl-context-ptrraw/private-tls-version(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_context*)#1)->private_tls_version)"

pub inline fun mbedtls-ssl-contextp/private-tls-version(s: mbedtls-ssl-contextp): <exn> mbedtls-ssl-protocol-version
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-tls-version.int/mbedtls-ssl-protocol-version

pub inline fun mbedtls-ssl-contextc/private-tls-version(^s: mbedtls-ssl-contextc<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-contextp/private-tls-version)

pub inline fun mbedtls-ssl-contextcb/private-tls-version(^s: mbedtls-ssl-contextcb<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-contextp/private-tls-version)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-tls-version(s: intptr_t, private-tls-version: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_tls_version = (int32_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-tls-version(s: mbedtls-ssl-contextp, private-tls-version: mbedtls-ssl-protocol-version): ()
  s.mbedtls-ssl-context-ptrraw/set-private-tls-version(private-tls-version.mbedtls-ssl-protocol-version/int)

pub inline fun mbedtls-ssl-contextc/set-private-tls-version(^s: mbedtls-ssl-contextc<s::S>, private-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-tls-version(private-tls-version))

pub inline fun mbedtls-ssl-contextcb/set-private-tls-version(^s: mbedtls-ssl-contextcb<s::S>, private-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-tls-version(private-tls-version))

pub inline extern mbedtls-ssl-context-ptrraw/private-badmac-seen(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_ssl_context*)#1)->private_badmac_seen)"

pub inline fun mbedtls-ssl-contextp/private-badmac-seen(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-badmac-seen.int

pub inline fun mbedtls-ssl-contextc/private-badmac-seen(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-badmac-seen)

pub inline fun mbedtls-ssl-contextcb/private-badmac-seen(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-badmac-seen)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-badmac-seen(s: intptr_t, private-badmac-seen: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_badmac_seen = (unsigned int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-badmac-seen(s: mbedtls-ssl-contextp, private-badmac-seen: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-badmac-seen(private-badmac-seen.int32)

pub inline fun mbedtls-ssl-contextc/set-private-badmac-seen(^s: mbedtls-ssl-contextc<s::S>, private-badmac-seen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-badmac-seen(private-badmac-seen))

pub inline fun mbedtls-ssl-contextcb/set-private-badmac-seen(^s: mbedtls-ssl-contextcb<s::S>, private-badmac-seen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-badmac-seen(private-badmac-seen))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-vrfy(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_vrfy)"

pub inline fun mbedtls-ssl-contextp/private-f-vrfy(s: mbedtls-ssl-contextp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-vrfy

pub inline fun mbedtls-ssl-contextc/private-f-vrfy(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-vrfy)

pub inline fun mbedtls-ssl-contextcb/private-f-vrfy(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-vrfy)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-vrfy(s: intptr_t, private-f-vrfy: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_vrfy = (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-vrfy(s: mbedtls-ssl-contextp, private-f-vrfy: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-vrfy(private-f-vrfy)

pub inline fun mbedtls-ssl-contextc/set-private-f-vrfy(^s: mbedtls-ssl-contextc<s::S>, private-f-vrfy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-vrfy(private-f-vrfy))

pub inline fun mbedtls-ssl-contextcb/set-private-f-vrfy(^s: mbedtls-ssl-contextcb<s::S>, private-f-vrfy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-vrfy(private-f-vrfy))

pub inline extern mbedtls-ssl-context-ptrraw/private-p-vrfy(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_p_vrfy)"

pub inline fun mbedtls-ssl-contextp/private-p-vrfy(s: mbedtls-ssl-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-p-vrfy

pub inline fun mbedtls-ssl-contextc/private-p-vrfy(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-vrfy)

pub inline fun mbedtls-ssl-contextcb/private-p-vrfy(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-vrfy)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-p-vrfy(s: intptr_t, private-p-vrfy: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_p_vrfy = (void*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-p-vrfy(s: mbedtls-ssl-contextp, private-p-vrfy: c-pointer<()>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-p-vrfy(private-p-vrfy)

pub inline fun mbedtls-ssl-contextc/set-private-p-vrfy(^s: mbedtls-ssl-contextc<s::S>, private-p-vrfy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-vrfy(private-p-vrfy))

pub inline fun mbedtls-ssl-contextcb/set-private-p-vrfy(^s: mbedtls-ssl-contextcb<s::S>, private-p-vrfy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-vrfy(private-p-vrfy))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-send(s: intptr_t): c-pointer<mbedtls-ssl-send-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_send)"

pub inline fun mbedtls-ssl-contextp/private-f-send(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-send-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-send

pub inline fun mbedtls-ssl-contextc/private-f-send(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-send-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-send)

pub inline fun mbedtls-ssl-contextcb/private-f-send(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-send-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-send)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-send(s: intptr_t, private-f-send: c-pointer<mbedtls-ssl-send-t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_send = (mbedtls_ssl_send_t*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-send(s: mbedtls-ssl-contextp, private-f-send: c-pointer<mbedtls-ssl-send-t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-send(private-f-send)

pub inline fun mbedtls-ssl-contextc/set-private-f-send(^s: mbedtls-ssl-contextc<s::S>, private-f-send: c-pointer<mbedtls-ssl-send-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-send(private-f-send))

pub inline fun mbedtls-ssl-contextcb/set-private-f-send(^s: mbedtls-ssl-contextcb<s::S>, private-f-send: c-pointer<mbedtls-ssl-send-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-send(private-f-send))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-recv(s: intptr_t): c-pointer<mbedtls-ssl-recv-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_recv)"

pub inline fun mbedtls-ssl-contextp/private-f-recv(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-recv-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-recv

pub inline fun mbedtls-ssl-contextc/private-f-recv(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-recv-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-recv)

pub inline fun mbedtls-ssl-contextcb/private-f-recv(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-recv-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-recv)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-recv(s: intptr_t, private-f-recv: c-pointer<mbedtls-ssl-recv-t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_recv = (mbedtls_ssl_recv_t*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-recv(s: mbedtls-ssl-contextp, private-f-recv: c-pointer<mbedtls-ssl-recv-t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-recv(private-f-recv)

pub inline fun mbedtls-ssl-contextc/set-private-f-recv(^s: mbedtls-ssl-contextc<s::S>, private-f-recv: c-pointer<mbedtls-ssl-recv-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-recv(private-f-recv))

pub inline fun mbedtls-ssl-contextcb/set-private-f-recv(^s: mbedtls-ssl-contextcb<s::S>, private-f-recv: c-pointer<mbedtls-ssl-recv-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-recv(private-f-recv))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-recv-timeout(s: intptr_t): c-pointer<mbedtls-ssl-recv-timeout-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_recv_timeout)"

pub inline fun mbedtls-ssl-contextp/private-f-recv-timeout(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-recv-timeout-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-recv-timeout

pub inline fun mbedtls-ssl-contextc/private-f-recv-timeout(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-recv-timeout-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-recv-timeout)

pub inline fun mbedtls-ssl-contextcb/private-f-recv-timeout(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-recv-timeout-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-recv-timeout)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-recv-timeout(s: intptr_t, private-f-recv-timeout: c-pointer<mbedtls-ssl-recv-timeout-t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_recv_timeout = (mbedtls_ssl_recv_timeout_t*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-recv-timeout(s: mbedtls-ssl-contextp, private-f-recv-timeout: c-pointer<mbedtls-ssl-recv-timeout-t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-recv-timeout(private-f-recv-timeout)

pub inline fun mbedtls-ssl-contextc/set-private-f-recv-timeout(^s: mbedtls-ssl-contextc<s::S>, private-f-recv-timeout: c-pointer<mbedtls-ssl-recv-timeout-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-recv-timeout(private-f-recv-timeout))

pub inline fun mbedtls-ssl-contextcb/set-private-f-recv-timeout(^s: mbedtls-ssl-contextcb<s::S>, private-f-recv-timeout: c-pointer<mbedtls-ssl-recv-timeout-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-recv-timeout(private-f-recv-timeout))

pub inline extern mbedtls-ssl-context-ptrraw/private-p-bio(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_p_bio)"

pub inline fun mbedtls-ssl-contextp/private-p-bio(s: mbedtls-ssl-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-p-bio

pub inline fun mbedtls-ssl-contextc/private-p-bio(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-bio)

pub inline fun mbedtls-ssl-contextcb/private-p-bio(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-bio)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-p-bio(s: intptr_t, private-p-bio: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_p_bio = (void*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-p-bio(s: mbedtls-ssl-contextp, private-p-bio: c-pointer<()>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-p-bio(private-p-bio)

pub inline fun mbedtls-ssl-contextc/set-private-p-bio(^s: mbedtls-ssl-contextc<s::S>, private-p-bio: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-bio(private-p-bio))

pub inline fun mbedtls-ssl-contextcb/set-private-p-bio(^s: mbedtls-ssl-contextcb<s::S>, private-p-bio: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-bio(private-p-bio))

pub inline extern mbedtls-ssl-context-ptrraw/private-session-in(s: intptr_t): c-pointer<mbedtls-ssl-session-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_session_in)"

pub inline fun mbedtls-ssl-contextp/private-session-in(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-session-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-session-in

pub inline fun mbedtls-ssl-contextc/private-session-in(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session-in)

pub inline fun mbedtls-ssl-contextcb/private-session-in(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session-in)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-session-in(s: intptr_t, private-session-in: c-pointer<mbedtls-ssl-session-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_session_in = (struct mbedtls_ssl_session*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-session-in(s: mbedtls-ssl-contextp, private-session-in: c-pointer<mbedtls-ssl-session-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-session-in(private-session-in)

pub inline fun mbedtls-ssl-contextc/set-private-session-in(^s: mbedtls-ssl-contextc<s::S>, private-session-in: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session-in(private-session-in))

pub inline fun mbedtls-ssl-contextcb/set-private-session-in(^s: mbedtls-ssl-contextcb<s::S>, private-session-in: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session-in(private-session-in))

pub inline extern mbedtls-ssl-context-ptrraw/private-session-out(s: intptr_t): c-pointer<mbedtls-ssl-session-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_session_out)"

pub inline fun mbedtls-ssl-contextp/private-session-out(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-session-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-session-out

pub inline fun mbedtls-ssl-contextc/private-session-out(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session-out)

pub inline fun mbedtls-ssl-contextcb/private-session-out(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session-out)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-session-out(s: intptr_t, private-session-out: c-pointer<mbedtls-ssl-session-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_session_out = (struct mbedtls_ssl_session*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-session-out(s: mbedtls-ssl-contextp, private-session-out: c-pointer<mbedtls-ssl-session-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-session-out(private-session-out)

pub inline fun mbedtls-ssl-contextc/set-private-session-out(^s: mbedtls-ssl-contextc<s::S>, private-session-out: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session-out(private-session-out))

pub inline fun mbedtls-ssl-contextcb/set-private-session-out(^s: mbedtls-ssl-contextcb<s::S>, private-session-out: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session-out(private-session-out))

pub inline extern mbedtls-ssl-context-ptrraw/private-session(s: intptr_t): c-pointer<mbedtls-ssl-session-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_session)"

pub inline fun mbedtls-ssl-contextp/private-session(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-session-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-session

pub inline fun mbedtls-ssl-contextc/private-session(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session)

pub inline fun mbedtls-ssl-contextcb/private-session(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-session(s: intptr_t, private-session: c-pointer<mbedtls-ssl-session-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_session = (struct mbedtls_ssl_session*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-session(s: mbedtls-ssl-contextp, private-session: c-pointer<mbedtls-ssl-session-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-session(private-session)

pub inline fun mbedtls-ssl-contextc/set-private-session(^s: mbedtls-ssl-contextc<s::S>, private-session: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session(private-session))

pub inline fun mbedtls-ssl-contextcb/set-private-session(^s: mbedtls-ssl-contextcb<s::S>, private-session: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session(private-session))

pub inline extern mbedtls-ssl-context-ptrraw/private-session-negotiate(s: intptr_t): c-pointer<mbedtls-ssl-session-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_session_negotiate)"

pub inline fun mbedtls-ssl-contextp/private-session-negotiate(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-session-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-session-negotiate

pub inline fun mbedtls-ssl-contextc/private-session-negotiate(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session-negotiate)

pub inline fun mbedtls-ssl-contextcb/private-session-negotiate(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-session-c>
  s.with-ptr(mbedtls-ssl-contextp/private-session-negotiate)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-session-negotiate(s: intptr_t, private-session-negotiate: c-pointer<mbedtls-ssl-session-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_session_negotiate = (struct mbedtls_ssl_session*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-session-negotiate(s: mbedtls-ssl-contextp, private-session-negotiate: c-pointer<mbedtls-ssl-session-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-session-negotiate(private-session-negotiate)

pub inline fun mbedtls-ssl-contextc/set-private-session-negotiate(^s: mbedtls-ssl-contextc<s::S>, private-session-negotiate: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session-negotiate(private-session-negotiate))

pub inline fun mbedtls-ssl-contextcb/set-private-session-negotiate(^s: mbedtls-ssl-contextcb<s::S>, private-session-negotiate: c-pointer<mbedtls-ssl-session-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-session-negotiate(private-session-negotiate))

pub inline extern mbedtls-ssl-context-ptrraw/private-handshake(s: intptr_t): c-pointer<mbedtls-ssl-handshake-params-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_handshake)"

pub inline fun mbedtls-ssl-contextp/private-handshake(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-handshake-params-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-handshake

pub inline fun mbedtls-ssl-contextc/private-handshake(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-handshake-params-c>
  s.with-ptr(mbedtls-ssl-contextp/private-handshake)

pub inline fun mbedtls-ssl-contextcb/private-handshake(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-handshake-params-c>
  s.with-ptr(mbedtls-ssl-contextp/private-handshake)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-handshake(s: intptr_t, private-handshake: c-pointer<mbedtls-ssl-handshake-params-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_handshake = (struct mbedtls_ssl_handshake_params*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-handshake(s: mbedtls-ssl-contextp, private-handshake: c-pointer<mbedtls-ssl-handshake-params-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-handshake(private-handshake)

pub inline fun mbedtls-ssl-contextc/set-private-handshake(^s: mbedtls-ssl-contextc<s::S>, private-handshake: c-pointer<mbedtls-ssl-handshake-params-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-handshake(private-handshake))

pub inline fun mbedtls-ssl-contextcb/set-private-handshake(^s: mbedtls-ssl-contextcb<s::S>, private-handshake: c-pointer<mbedtls-ssl-handshake-params-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-handshake(private-handshake))

pub inline extern mbedtls-ssl-context-ptrraw/private-transform-in(s: intptr_t): c-pointer<mbedtls-ssl-transform-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_transform_in)"

pub inline fun mbedtls-ssl-contextp/private-transform-in(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-transform-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-transform-in

pub inline fun mbedtls-ssl-contextc/private-transform-in(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-in)

pub inline fun mbedtls-ssl-contextcb/private-transform-in(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-in)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-transform-in(s: intptr_t, private-transform-in: c-pointer<mbedtls-ssl-transform-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_transform_in = (struct mbedtls_ssl_transform*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-transform-in(s: mbedtls-ssl-contextp, private-transform-in: c-pointer<mbedtls-ssl-transform-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-transform-in(private-transform-in)

pub inline fun mbedtls-ssl-contextc/set-private-transform-in(^s: mbedtls-ssl-contextc<s::S>, private-transform-in: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-in(private-transform-in))

pub inline fun mbedtls-ssl-contextcb/set-private-transform-in(^s: mbedtls-ssl-contextcb<s::S>, private-transform-in: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-in(private-transform-in))

pub inline extern mbedtls-ssl-context-ptrraw/private-transform-out(s: intptr_t): c-pointer<mbedtls-ssl-transform-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_transform_out)"

pub inline fun mbedtls-ssl-contextp/private-transform-out(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-transform-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-transform-out

pub inline fun mbedtls-ssl-contextc/private-transform-out(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-out)

pub inline fun mbedtls-ssl-contextcb/private-transform-out(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-out)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-transform-out(s: intptr_t, private-transform-out: c-pointer<mbedtls-ssl-transform-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_transform_out = (struct mbedtls_ssl_transform*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-transform-out(s: mbedtls-ssl-contextp, private-transform-out: c-pointer<mbedtls-ssl-transform-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-transform-out(private-transform-out)

pub inline fun mbedtls-ssl-contextc/set-private-transform-out(^s: mbedtls-ssl-contextc<s::S>, private-transform-out: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-out(private-transform-out))

pub inline fun mbedtls-ssl-contextcb/set-private-transform-out(^s: mbedtls-ssl-contextcb<s::S>, private-transform-out: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-out(private-transform-out))

pub inline extern mbedtls-ssl-context-ptrraw/private-transform(s: intptr_t): c-pointer<mbedtls-ssl-transform-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_transform)"

pub inline fun mbedtls-ssl-contextp/private-transform(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-transform-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-transform

pub inline fun mbedtls-ssl-contextc/private-transform(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform)

pub inline fun mbedtls-ssl-contextcb/private-transform(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-transform(s: intptr_t, private-transform: c-pointer<mbedtls-ssl-transform-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_transform = (struct mbedtls_ssl_transform*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-transform(s: mbedtls-ssl-contextp, private-transform: c-pointer<mbedtls-ssl-transform-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-transform(private-transform)

pub inline fun mbedtls-ssl-contextc/set-private-transform(^s: mbedtls-ssl-contextc<s::S>, private-transform: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform(private-transform))

pub inline fun mbedtls-ssl-contextcb/set-private-transform(^s: mbedtls-ssl-contextcb<s::S>, private-transform: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform(private-transform))

pub inline extern mbedtls-ssl-context-ptrraw/private-transform-negotiate(s: intptr_t): c-pointer<mbedtls-ssl-transform-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_transform_negotiate)"

pub inline fun mbedtls-ssl-contextp/private-transform-negotiate(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-transform-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-transform-negotiate

pub inline fun mbedtls-ssl-contextc/private-transform-negotiate(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-negotiate)

pub inline fun mbedtls-ssl-contextcb/private-transform-negotiate(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-negotiate)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-transform-negotiate(s: intptr_t, private-transform-negotiate: c-pointer<mbedtls-ssl-transform-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_transform_negotiate = (struct mbedtls_ssl_transform*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-transform-negotiate(s: mbedtls-ssl-contextp, private-transform-negotiate: c-pointer<mbedtls-ssl-transform-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-transform-negotiate(private-transform-negotiate)

pub inline fun mbedtls-ssl-contextc/set-private-transform-negotiate(^s: mbedtls-ssl-contextc<s::S>, private-transform-negotiate: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-negotiate(private-transform-negotiate))

pub inline fun mbedtls-ssl-contextcb/set-private-transform-negotiate(^s: mbedtls-ssl-contextcb<s::S>, private-transform-negotiate: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-negotiate(private-transform-negotiate))

pub inline extern mbedtls-ssl-context-ptrraw/private-transform-application(s: intptr_t): c-pointer<mbedtls-ssl-transform-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_transform_application)"

pub inline fun mbedtls-ssl-contextp/private-transform-application(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-transform-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-transform-application

pub inline fun mbedtls-ssl-contextc/private-transform-application(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-application)

pub inline fun mbedtls-ssl-contextcb/private-transform-application(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-transform-c>
  s.with-ptr(mbedtls-ssl-contextp/private-transform-application)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-transform-application(s: intptr_t, private-transform-application: c-pointer<mbedtls-ssl-transform-c>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_transform_application = (struct mbedtls_ssl_transform*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-transform-application(s: mbedtls-ssl-contextp, private-transform-application: c-pointer<mbedtls-ssl-transform-c>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-transform-application(private-transform-application)

pub inline fun mbedtls-ssl-contextc/set-private-transform-application(^s: mbedtls-ssl-contextc<s::S>, private-transform-application: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-application(private-transform-application))

pub inline fun mbedtls-ssl-contextcb/set-private-transform-application(^s: mbedtls-ssl-contextcb<s::S>, private-transform-application: c-pointer<mbedtls-ssl-transform-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-transform-application(private-transform-application))

pub inline extern mbedtls-ssl-context-ptrraw/private-p-timer(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_p_timer)"

pub inline fun mbedtls-ssl-contextp/private-p-timer(s: mbedtls-ssl-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-p-timer

pub inline fun mbedtls-ssl-contextc/private-p-timer(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-timer)

pub inline fun mbedtls-ssl-contextcb/private-p-timer(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-timer)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-p-timer(s: intptr_t, private-p-timer: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_p_timer = (void*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-p-timer(s: mbedtls-ssl-contextp, private-p-timer: c-pointer<()>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-p-timer(private-p-timer)

pub inline fun mbedtls-ssl-contextc/set-private-p-timer(^s: mbedtls-ssl-contextc<s::S>, private-p-timer: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-timer(private-p-timer))

pub inline fun mbedtls-ssl-contextcb/set-private-p-timer(^s: mbedtls-ssl-contextcb<s::S>, private-p-timer: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-timer(private-p-timer))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-set-timer(s: intptr_t): c-pointer<mbedtls-ssl-set-timer-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_set_timer)"

pub inline fun mbedtls-ssl-contextp/private-f-set-timer(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-set-timer-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-set-timer

pub inline fun mbedtls-ssl-contextc/private-f-set-timer(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-set-timer-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-set-timer)

pub inline fun mbedtls-ssl-contextcb/private-f-set-timer(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-set-timer-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-set-timer)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-set-timer(s: intptr_t, private-f-set-timer: c-pointer<mbedtls-ssl-set-timer-t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_set_timer = (mbedtls_ssl_set_timer_t*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-set-timer(s: mbedtls-ssl-contextp, private-f-set-timer: c-pointer<mbedtls-ssl-set-timer-t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-set-timer(private-f-set-timer)

pub inline fun mbedtls-ssl-contextc/set-private-f-set-timer(^s: mbedtls-ssl-contextc<s::S>, private-f-set-timer: c-pointer<mbedtls-ssl-set-timer-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-set-timer(private-f-set-timer))

pub inline fun mbedtls-ssl-contextcb/set-private-f-set-timer(^s: mbedtls-ssl-contextcb<s::S>, private-f-set-timer: c-pointer<mbedtls-ssl-set-timer-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-set-timer(private-f-set-timer))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-get-timer(s: intptr_t): c-pointer<mbedtls-ssl-get-timer-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_get_timer)"

pub inline fun mbedtls-ssl-contextp/private-f-get-timer(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-get-timer-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-get-timer

pub inline fun mbedtls-ssl-contextc/private-f-get-timer(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-get-timer-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-get-timer)

pub inline fun mbedtls-ssl-contextcb/private-f-get-timer(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-get-timer-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-get-timer)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-get-timer(s: intptr_t, private-f-get-timer: c-pointer<mbedtls-ssl-get-timer-t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_get_timer = (mbedtls_ssl_get_timer_t*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-get-timer(s: mbedtls-ssl-contextp, private-f-get-timer: c-pointer<mbedtls-ssl-get-timer-t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-get-timer(private-f-get-timer)

pub inline fun mbedtls-ssl-contextc/set-private-f-get-timer(^s: mbedtls-ssl-contextc<s::S>, private-f-get-timer: c-pointer<mbedtls-ssl-get-timer-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-get-timer(private-f-get-timer))

pub inline fun mbedtls-ssl-contextcb/set-private-f-get-timer(^s: mbedtls-ssl-contextcb<s::S>, private-f-get-timer: c-pointer<mbedtls-ssl-get-timer-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-get-timer(private-f-get-timer))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-buf(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_buf)"

pub inline fun mbedtls-ssl-contextp/private-in-buf(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-buf

pub inline fun mbedtls-ssl-contextc/private-in-buf(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-buf)

pub inline fun mbedtls-ssl-contextcb/private-in-buf(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-buf)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-buf(s: intptr_t, private-in-buf: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_buf = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-buf(s: mbedtls-ssl-contextp, private-in-buf: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-buf(private-in-buf)

pub inline fun mbedtls-ssl-contextc/set-private-in-buf(^s: mbedtls-ssl-contextc<s::S>, private-in-buf: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-buf(private-in-buf))

pub inline fun mbedtls-ssl-contextcb/set-private-in-buf(^s: mbedtls-ssl-contextcb<s::S>, private-in-buf: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-buf(private-in-buf))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-ctr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_ctr)"

pub inline fun mbedtls-ssl-contextp/private-in-ctr(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-ctr

pub inline fun mbedtls-ssl-contextc/private-in-ctr(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-ctr)

pub inline fun mbedtls-ssl-contextcb/private-in-ctr(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-ctr)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-ctr(s: intptr_t, private-in-ctr: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_ctr = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-ctr(s: mbedtls-ssl-contextp, private-in-ctr: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-ctr(private-in-ctr)

pub inline fun mbedtls-ssl-contextc/set-private-in-ctr(^s: mbedtls-ssl-contextc<s::S>, private-in-ctr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-ctr(private-in-ctr))

pub inline fun mbedtls-ssl-contextcb/set-private-in-ctr(^s: mbedtls-ssl-contextcb<s::S>, private-in-ctr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-ctr(private-in-ctr))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-hdr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_hdr)"

pub inline fun mbedtls-ssl-contextp/private-in-hdr(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-hdr

pub inline fun mbedtls-ssl-contextc/private-in-hdr(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-hdr)

pub inline fun mbedtls-ssl-contextcb/private-in-hdr(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-hdr)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-hdr(s: intptr_t, private-in-hdr: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_hdr = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-hdr(s: mbedtls-ssl-contextp, private-in-hdr: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-hdr(private-in-hdr)

pub inline fun mbedtls-ssl-contextc/set-private-in-hdr(^s: mbedtls-ssl-contextc<s::S>, private-in-hdr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-hdr(private-in-hdr))

pub inline fun mbedtls-ssl-contextcb/set-private-in-hdr(^s: mbedtls-ssl-contextcb<s::S>, private-in-hdr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-hdr(private-in-hdr))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-cid(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_cid)"

pub inline fun mbedtls-ssl-contextp/private-in-cid(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-cid

pub inline fun mbedtls-ssl-contextc/private-in-cid(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-cid)

pub inline fun mbedtls-ssl-contextcb/private-in-cid(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-cid)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-cid(s: intptr_t, private-in-cid: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_cid = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-cid(s: mbedtls-ssl-contextp, private-in-cid: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-cid(private-in-cid)

pub inline fun mbedtls-ssl-contextc/set-private-in-cid(^s: mbedtls-ssl-contextc<s::S>, private-in-cid: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-cid(private-in-cid))

pub inline fun mbedtls-ssl-contextcb/set-private-in-cid(^s: mbedtls-ssl-contextcb<s::S>, private-in-cid: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-cid(private-in-cid))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-len(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_len)"

pub inline fun mbedtls-ssl-contextp/private-in-len(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-len

pub inline fun mbedtls-ssl-contextc/private-in-len(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-len)

pub inline fun mbedtls-ssl-contextcb/private-in-len(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-len)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-len(s: intptr_t, private-in-len: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_len = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-len(s: mbedtls-ssl-contextp, private-in-len: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-len(private-in-len)

pub inline fun mbedtls-ssl-contextc/set-private-in-len(^s: mbedtls-ssl-contextc<s::S>, private-in-len: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-len(private-in-len))

pub inline fun mbedtls-ssl-contextcb/set-private-in-len(^s: mbedtls-ssl-contextcb<s::S>, private-in-len: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-len(private-in-len))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-iv(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_iv)"

pub inline fun mbedtls-ssl-contextp/private-in-iv(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-iv

pub inline fun mbedtls-ssl-contextc/private-in-iv(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-iv)

pub inline fun mbedtls-ssl-contextcb/private-in-iv(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-iv)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-iv(s: intptr_t, private-in-iv: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_iv = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-iv(s: mbedtls-ssl-contextp, private-in-iv: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-iv(private-in-iv)

pub inline fun mbedtls-ssl-contextc/set-private-in-iv(^s: mbedtls-ssl-contextc<s::S>, private-in-iv: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-iv(private-in-iv))

pub inline fun mbedtls-ssl-contextcb/set-private-in-iv(^s: mbedtls-ssl-contextcb<s::S>, private-in-iv: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-iv(private-in-iv))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-msg(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_msg)"

pub inline fun mbedtls-ssl-contextp/private-in-msg(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-msg

pub inline fun mbedtls-ssl-contextc/private-in-msg(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-msg)

pub inline fun mbedtls-ssl-contextcb/private-in-msg(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-msg)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-msg(s: intptr_t, private-in-msg: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_msg = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-msg(s: mbedtls-ssl-contextp, private-in-msg: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-msg(private-in-msg)

pub inline fun mbedtls-ssl-contextc/set-private-in-msg(^s: mbedtls-ssl-contextc<s::S>, private-in-msg: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-msg(private-in-msg))

pub inline fun mbedtls-ssl-contextcb/set-private-in-msg(^s: mbedtls-ssl-contextcb<s::S>, private-in-msg: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-msg(private-in-msg))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-offt(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_in_offt)"

pub inline fun mbedtls-ssl-contextp/private-in-offt(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-offt

pub inline fun mbedtls-ssl-contextc/private-in-offt(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-offt)

pub inline fun mbedtls-ssl-contextcb/private-in-offt(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-in-offt)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-offt(s: intptr_t, private-in-offt: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_offt = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-offt(s: mbedtls-ssl-contextp, private-in-offt: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-offt(private-in-offt)

pub inline fun mbedtls-ssl-contextc/set-private-in-offt(^s: mbedtls-ssl-contextc<s::S>, private-in-offt: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-offt(private-in-offt))

pub inline fun mbedtls-ssl-contextcb/set-private-in-offt(^s: mbedtls-ssl-contextcb<s::S>, private-in-offt: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-offt(private-in-offt))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-msgtype(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_in_msgtype)"

pub inline fun mbedtls-ssl-contextp/private-in-msgtype(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-msgtype.int

pub inline fun mbedtls-ssl-contextc/private-in-msgtype(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-msgtype)

pub inline fun mbedtls-ssl-contextcb/private-in-msgtype(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-msgtype)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-msgtype(s: intptr_t, private-in-msgtype: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_msgtype = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-msgtype(s: mbedtls-ssl-contextp, private-in-msgtype: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-msgtype(private-in-msgtype.int32)

pub inline fun mbedtls-ssl-contextc/set-private-in-msgtype(^s: mbedtls-ssl-contextc<s::S>, private-in-msgtype: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-msgtype(private-in-msgtype))

pub inline fun mbedtls-ssl-contextcb/set-private-in-msgtype(^s: mbedtls-ssl-contextcb<s::S>, private-in-msgtype: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-msgtype(private-in-msgtype))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-msglen(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_in_msglen)"

pub inline fun mbedtls-ssl-contextp/private-in-msglen(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-msglen.int

pub inline fun mbedtls-ssl-contextc/private-in-msglen(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-msglen)

pub inline fun mbedtls-ssl-contextcb/private-in-msglen(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-msglen)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-msglen(s: intptr_t, private-in-msglen: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_msglen = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-msglen(s: mbedtls-ssl-contextp, private-in-msglen: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-msglen(private-in-msglen.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-in-msglen(^s: mbedtls-ssl-contextc<s::S>, private-in-msglen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-msglen(private-in-msglen))

pub inline fun mbedtls-ssl-contextcb/set-private-in-msglen(^s: mbedtls-ssl-contextcb<s::S>, private-in-msglen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-msglen(private-in-msglen))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-left(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_in_left)"

pub inline fun mbedtls-ssl-contextp/private-in-left(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-left.int

pub inline fun mbedtls-ssl-contextc/private-in-left(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-left)

pub inline fun mbedtls-ssl-contextcb/private-in-left(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-left)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-left(s: intptr_t, private-in-left: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_left = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-left(s: mbedtls-ssl-contextp, private-in-left: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-left(private-in-left.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-in-left(^s: mbedtls-ssl-contextc<s::S>, private-in-left: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-left(private-in-left))

pub inline fun mbedtls-ssl-contextcb/set-private-in-left(^s: mbedtls-ssl-contextcb<s::S>, private-in-left: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-left(private-in-left))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-epoch(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ssl_context*)#1)->private_in_epoch)"

pub inline fun mbedtls-ssl-contextp/private-in-epoch(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-epoch.int

pub inline fun mbedtls-ssl-contextc/private-in-epoch(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-epoch)

pub inline fun mbedtls-ssl-contextcb/private-in-epoch(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-epoch)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-epoch(s: intptr_t, private-in-epoch: int16): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_epoch = (int16_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-epoch(s: mbedtls-ssl-contextp, private-in-epoch: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-epoch(private-in-epoch.int16)

pub inline fun mbedtls-ssl-contextc/set-private-in-epoch(^s: mbedtls-ssl-contextc<s::S>, private-in-epoch: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-epoch(private-in-epoch))

pub inline fun mbedtls-ssl-contextcb/set-private-in-epoch(^s: mbedtls-ssl-contextcb<s::S>, private-in-epoch: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-epoch(private-in-epoch))

pub inline extern mbedtls-ssl-context-ptrraw/private-next-record-offset(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_next_record_offset)"

pub inline fun mbedtls-ssl-contextp/private-next-record-offset(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-next-record-offset.int

pub inline fun mbedtls-ssl-contextc/private-next-record-offset(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-next-record-offset)

pub inline fun mbedtls-ssl-contextcb/private-next-record-offset(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-next-record-offset)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-next-record-offset(s: intptr_t, private-next-record-offset: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_next_record_offset = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-next-record-offset(s: mbedtls-ssl-contextp, private-next-record-offset: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-next-record-offset(private-next-record-offset.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-next-record-offset(^s: mbedtls-ssl-contextc<s::S>, private-next-record-offset: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-next-record-offset(private-next-record-offset))

pub inline fun mbedtls-ssl-contextcb/set-private-next-record-offset(^s: mbedtls-ssl-contextcb<s::S>, private-next-record-offset: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-next-record-offset(private-next-record-offset))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-window-top(s: intptr_t): int64
  c inline "(int64_t)(((struct mbedtls_ssl_context*)#1)->private_in_window_top)"

pub inline fun mbedtls-ssl-contextp/private-in-window-top(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-window-top.int

pub inline fun mbedtls-ssl-contextc/private-in-window-top(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-window-top)

pub inline fun mbedtls-ssl-contextcb/private-in-window-top(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-window-top)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-window-top(s: intptr_t, private-in-window-top: int64): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_window_top = (int64_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-window-top(s: mbedtls-ssl-contextp, private-in-window-top: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-window-top(private-in-window-top.int64)

pub inline fun mbedtls-ssl-contextc/set-private-in-window-top(^s: mbedtls-ssl-contextc<s::S>, private-in-window-top: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-window-top(private-in-window-top))

pub inline fun mbedtls-ssl-contextcb/set-private-in-window-top(^s: mbedtls-ssl-contextcb<s::S>, private-in-window-top: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-window-top(private-in-window-top))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-window(s: intptr_t): int64
  c inline "(int64_t)(((struct mbedtls_ssl_context*)#1)->private_in_window)"

pub inline fun mbedtls-ssl-contextp/private-in-window(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-window.int

pub inline fun mbedtls-ssl-contextc/private-in-window(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-window)

pub inline fun mbedtls-ssl-contextcb/private-in-window(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-window)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-window(s: intptr_t, private-in-window: int64): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_window = (int64_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-window(s: mbedtls-ssl-contextp, private-in-window: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-window(private-in-window.int64)

pub inline fun mbedtls-ssl-contextc/set-private-in-window(^s: mbedtls-ssl-contextc<s::S>, private-in-window: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-window(private-in-window))

pub inline fun mbedtls-ssl-contextcb/set-private-in-window(^s: mbedtls-ssl-contextcb<s::S>, private-in-window: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-window(private-in-window))

pub inline extern mbedtls-ssl-context-ptrraw/private-in-hslen(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_in_hslen)"

pub inline fun mbedtls-ssl-contextp/private-in-hslen(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-in-hslen.int

pub inline fun mbedtls-ssl-contextc/private-in-hslen(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-hslen)

pub inline fun mbedtls-ssl-contextcb/private-in-hslen(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-in-hslen)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-in-hslen(s: intptr_t, private-in-hslen: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_in_hslen = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-in-hslen(s: mbedtls-ssl-contextp, private-in-hslen: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-in-hslen(private-in-hslen.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-in-hslen(^s: mbedtls-ssl-contextc<s::S>, private-in-hslen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-hslen(private-in-hslen))

pub inline fun mbedtls-ssl-contextcb/set-private-in-hslen(^s: mbedtls-ssl-contextcb<s::S>, private-in-hslen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-in-hslen(private-in-hslen))

pub inline extern mbedtls-ssl-context-ptrraw/private-nb-zero(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_nb_zero)"

pub inline fun mbedtls-ssl-contextp/private-nb-zero(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-nb-zero.int

pub inline fun mbedtls-ssl-contextc/private-nb-zero(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-nb-zero)

pub inline fun mbedtls-ssl-contextcb/private-nb-zero(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-nb-zero)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-nb-zero(s: intptr_t, private-nb-zero: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_nb_zero = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-nb-zero(s: mbedtls-ssl-contextp, private-nb-zero: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-nb-zero(private-nb-zero.int32)

pub inline fun mbedtls-ssl-contextc/set-private-nb-zero(^s: mbedtls-ssl-contextc<s::S>, private-nb-zero: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-nb-zero(private-nb-zero))

pub inline fun mbedtls-ssl-contextcb/set-private-nb-zero(^s: mbedtls-ssl-contextcb<s::S>, private-nb-zero: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-nb-zero(private-nb-zero))

pub inline extern mbedtls-ssl-context-ptrraw/private-keep-current-message(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_keep_current_message)"

pub inline fun mbedtls-ssl-contextp/private-keep-current-message(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-keep-current-message.int

pub inline fun mbedtls-ssl-contextc/private-keep-current-message(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-keep-current-message)

pub inline fun mbedtls-ssl-contextcb/private-keep-current-message(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-keep-current-message)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-keep-current-message(s: intptr_t, private-keep-current-message: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_keep_current_message = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-keep-current-message(s: mbedtls-ssl-contextp, private-keep-current-message: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-keep-current-message(private-keep-current-message.int32)

pub inline fun mbedtls-ssl-contextc/set-private-keep-current-message(^s: mbedtls-ssl-contextc<s::S>, private-keep-current-message: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-keep-current-message(private-keep-current-message))

pub inline fun mbedtls-ssl-contextcb/set-private-keep-current-message(^s: mbedtls-ssl-contextcb<s::S>, private-keep-current-message: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-keep-current-message(private-keep-current-message))

pub inline extern mbedtls-ssl-context-ptrraw/private-send-alert(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_ssl_context*)#1)->private_send_alert)"

pub inline fun mbedtls-ssl-contextp/private-send-alert(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-send-alert.int

pub inline fun mbedtls-ssl-contextc/private-send-alert(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-send-alert)

pub inline fun mbedtls-ssl-contextcb/private-send-alert(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-send-alert)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-send-alert(s: intptr_t, private-send-alert: int8): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_send_alert = (unsigned char)#2"

pub inline fun mbedtls-ssl-contextp/set-private-send-alert(s: mbedtls-ssl-contextp, private-send-alert: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-send-alert(private-send-alert.int8)

pub inline fun mbedtls-ssl-contextc/set-private-send-alert(^s: mbedtls-ssl-contextc<s::S>, private-send-alert: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-send-alert(private-send-alert))

pub inline fun mbedtls-ssl-contextcb/set-private-send-alert(^s: mbedtls-ssl-contextcb<s::S>, private-send-alert: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-send-alert(private-send-alert))

pub inline extern mbedtls-ssl-context-ptrraw/private-alert-type(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_ssl_context*)#1)->private_alert_type)"

pub inline fun mbedtls-ssl-contextp/private-alert-type(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-alert-type.int

pub inline fun mbedtls-ssl-contextc/private-alert-type(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-alert-type)

pub inline fun mbedtls-ssl-contextcb/private-alert-type(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-alert-type)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-alert-type(s: intptr_t, private-alert-type: int8): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_alert_type = (unsigned char)#2"

pub inline fun mbedtls-ssl-contextp/set-private-alert-type(s: mbedtls-ssl-contextp, private-alert-type: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-alert-type(private-alert-type.int8)

pub inline fun mbedtls-ssl-contextc/set-private-alert-type(^s: mbedtls-ssl-contextc<s::S>, private-alert-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-alert-type(private-alert-type))

pub inline fun mbedtls-ssl-contextcb/set-private-alert-type(^s: mbedtls-ssl-contextcb<s::S>, private-alert-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-alert-type(private-alert-type))

pub inline extern mbedtls-ssl-context-ptrraw/private-alert-reason(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_alert_reason)"

pub inline fun mbedtls-ssl-contextp/private-alert-reason(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-alert-reason.int

pub inline fun mbedtls-ssl-contextc/private-alert-reason(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-alert-reason)

pub inline fun mbedtls-ssl-contextcb/private-alert-reason(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-alert-reason)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-alert-reason(s: intptr_t, private-alert-reason: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_alert_reason = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-alert-reason(s: mbedtls-ssl-contextp, private-alert-reason: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-alert-reason(private-alert-reason.int32)

pub inline fun mbedtls-ssl-contextc/set-private-alert-reason(^s: mbedtls-ssl-contextc<s::S>, private-alert-reason: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-alert-reason(private-alert-reason))

pub inline fun mbedtls-ssl-contextcb/set-private-alert-reason(^s: mbedtls-ssl-contextcb<s::S>, private-alert-reason: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-alert-reason(private-alert-reason))

pub inline extern mbedtls-ssl-context-ptrraw/private-disable-datagram-packing(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_context*)#1)->private_disable_datagram_packing)"

pub inline fun mbedtls-ssl-contextp/private-disable-datagram-packing(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-disable-datagram-packing.int

pub inline fun mbedtls-ssl-contextc/private-disable-datagram-packing(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-disable-datagram-packing)

pub inline fun mbedtls-ssl-contextcb/private-disable-datagram-packing(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-disable-datagram-packing)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-disable-datagram-packing(s: intptr_t, private-disable-datagram-packing: int8): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_disable_datagram_packing = (uint8_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-disable-datagram-packing(s: mbedtls-ssl-contextp, private-disable-datagram-packing: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-disable-datagram-packing(private-disable-datagram-packing.int8)

pub inline fun mbedtls-ssl-contextc/set-private-disable-datagram-packing(^s: mbedtls-ssl-contextc<s::S>, private-disable-datagram-packing: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-disable-datagram-packing(private-disable-datagram-packing))

pub inline fun mbedtls-ssl-contextcb/set-private-disable-datagram-packing(^s: mbedtls-ssl-contextcb<s::S>, private-disable-datagram-packing: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-disable-datagram-packing(private-disable-datagram-packing))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-buf(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_buf)"

pub inline fun mbedtls-ssl-contextp/private-out-buf(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-buf

pub inline fun mbedtls-ssl-contextc/private-out-buf(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-buf)

pub inline fun mbedtls-ssl-contextcb/private-out-buf(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-buf)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-buf(s: intptr_t, private-out-buf: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_buf = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-buf(s: mbedtls-ssl-contextp, private-out-buf: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-buf(private-out-buf)

pub inline fun mbedtls-ssl-contextc/set-private-out-buf(^s: mbedtls-ssl-contextc<s::S>, private-out-buf: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-buf(private-out-buf))

pub inline fun mbedtls-ssl-contextcb/set-private-out-buf(^s: mbedtls-ssl-contextcb<s::S>, private-out-buf: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-buf(private-out-buf))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-ctr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_ctr)"

pub inline fun mbedtls-ssl-contextp/private-out-ctr(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-ctr

pub inline fun mbedtls-ssl-contextc/private-out-ctr(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-ctr)

pub inline fun mbedtls-ssl-contextcb/private-out-ctr(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-ctr)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-ctr(s: intptr_t, private-out-ctr: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_ctr = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-ctr(s: mbedtls-ssl-contextp, private-out-ctr: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-ctr(private-out-ctr)

pub inline fun mbedtls-ssl-contextc/set-private-out-ctr(^s: mbedtls-ssl-contextc<s::S>, private-out-ctr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-ctr(private-out-ctr))

pub inline fun mbedtls-ssl-contextcb/set-private-out-ctr(^s: mbedtls-ssl-contextcb<s::S>, private-out-ctr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-ctr(private-out-ctr))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-hdr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_hdr)"

pub inline fun mbedtls-ssl-contextp/private-out-hdr(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-hdr

pub inline fun mbedtls-ssl-contextc/private-out-hdr(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-hdr)

pub inline fun mbedtls-ssl-contextcb/private-out-hdr(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-hdr)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-hdr(s: intptr_t, private-out-hdr: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_hdr = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-hdr(s: mbedtls-ssl-contextp, private-out-hdr: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-hdr(private-out-hdr)

pub inline fun mbedtls-ssl-contextc/set-private-out-hdr(^s: mbedtls-ssl-contextc<s::S>, private-out-hdr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-hdr(private-out-hdr))

pub inline fun mbedtls-ssl-contextcb/set-private-out-hdr(^s: mbedtls-ssl-contextcb<s::S>, private-out-hdr: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-hdr(private-out-hdr))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-cid(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_cid)"

pub inline fun mbedtls-ssl-contextp/private-out-cid(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-cid

pub inline fun mbedtls-ssl-contextc/private-out-cid(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-cid)

pub inline fun mbedtls-ssl-contextcb/private-out-cid(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-cid)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-cid(s: intptr_t, private-out-cid: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_cid = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-cid(s: mbedtls-ssl-contextp, private-out-cid: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-cid(private-out-cid)

pub inline fun mbedtls-ssl-contextc/set-private-out-cid(^s: mbedtls-ssl-contextc<s::S>, private-out-cid: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-cid(private-out-cid))

pub inline fun mbedtls-ssl-contextcb/set-private-out-cid(^s: mbedtls-ssl-contextcb<s::S>, private-out-cid: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-cid(private-out-cid))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-len(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_len)"

pub inline fun mbedtls-ssl-contextp/private-out-len(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-len

pub inline fun mbedtls-ssl-contextc/private-out-len(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-len)

pub inline fun mbedtls-ssl-contextcb/private-out-len(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-len)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-len(s: intptr_t, private-out-len: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_len = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-len(s: mbedtls-ssl-contextp, private-out-len: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-len(private-out-len)

pub inline fun mbedtls-ssl-contextc/set-private-out-len(^s: mbedtls-ssl-contextc<s::S>, private-out-len: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-len(private-out-len))

pub inline fun mbedtls-ssl-contextcb/set-private-out-len(^s: mbedtls-ssl-contextcb<s::S>, private-out-len: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-len(private-out-len))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-iv(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_iv)"

pub inline fun mbedtls-ssl-contextp/private-out-iv(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-iv

pub inline fun mbedtls-ssl-contextc/private-out-iv(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-iv)

pub inline fun mbedtls-ssl-contextcb/private-out-iv(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-iv)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-iv(s: intptr_t, private-out-iv: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_iv = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-iv(s: mbedtls-ssl-contextp, private-out-iv: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-iv(private-out-iv)

pub inline fun mbedtls-ssl-contextc/set-private-out-iv(^s: mbedtls-ssl-contextc<s::S>, private-out-iv: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-iv(private-out-iv))

pub inline fun mbedtls-ssl-contextcb/set-private-out-iv(^s: mbedtls-ssl-contextcb<s::S>, private-out-iv: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-iv(private-out-iv))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-msg(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_out_msg)"

pub inline fun mbedtls-ssl-contextp/private-out-msg(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-msg

pub inline fun mbedtls-ssl-contextc/private-out-msg(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-msg)

pub inline fun mbedtls-ssl-contextcb/private-out-msg(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-out-msg)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-msg(s: intptr_t, private-out-msg: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_msg = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-msg(s: mbedtls-ssl-contextp, private-out-msg: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-msg(private-out-msg)

pub inline fun mbedtls-ssl-contextc/set-private-out-msg(^s: mbedtls-ssl-contextc<s::S>, private-out-msg: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-msg(private-out-msg))

pub inline fun mbedtls-ssl-contextcb/set-private-out-msg(^s: mbedtls-ssl-contextcb<s::S>, private-out-msg: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-msg(private-out-msg))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-msgtype(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_out_msgtype)"

pub inline fun mbedtls-ssl-contextp/private-out-msgtype(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-msgtype.int

pub inline fun mbedtls-ssl-contextc/private-out-msgtype(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-out-msgtype)

pub inline fun mbedtls-ssl-contextcb/private-out-msgtype(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-out-msgtype)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-msgtype(s: intptr_t, private-out-msgtype: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_msgtype = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-msgtype(s: mbedtls-ssl-contextp, private-out-msgtype: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-msgtype(private-out-msgtype.int32)

pub inline fun mbedtls-ssl-contextc/set-private-out-msgtype(^s: mbedtls-ssl-contextc<s::S>, private-out-msgtype: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-msgtype(private-out-msgtype))

pub inline fun mbedtls-ssl-contextcb/set-private-out-msgtype(^s: mbedtls-ssl-contextcb<s::S>, private-out-msgtype: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-msgtype(private-out-msgtype))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-msglen(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_out_msglen)"

pub inline fun mbedtls-ssl-contextp/private-out-msglen(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-msglen.int

pub inline fun mbedtls-ssl-contextc/private-out-msglen(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-out-msglen)

pub inline fun mbedtls-ssl-contextcb/private-out-msglen(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-out-msglen)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-msglen(s: intptr_t, private-out-msglen: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_msglen = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-msglen(s: mbedtls-ssl-contextp, private-out-msglen: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-msglen(private-out-msglen.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-out-msglen(^s: mbedtls-ssl-contextc<s::S>, private-out-msglen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-msglen(private-out-msglen))

pub inline fun mbedtls-ssl-contextcb/set-private-out-msglen(^s: mbedtls-ssl-contextcb<s::S>, private-out-msglen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-msglen(private-out-msglen))

pub inline extern mbedtls-ssl-context-ptrraw/private-out-left(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_out_left)"

pub inline fun mbedtls-ssl-contextp/private-out-left(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-out-left.int

pub inline fun mbedtls-ssl-contextc/private-out-left(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-out-left)

pub inline fun mbedtls-ssl-contextcb/private-out-left(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-out-left)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-out-left(s: intptr_t, private-out-left: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_out_left = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-out-left(s: mbedtls-ssl-contextp, private-out-left: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-out-left(private-out-left.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-out-left(^s: mbedtls-ssl-contextc<s::S>, private-out-left: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-left(private-out-left))

pub inline fun mbedtls-ssl-contextcb/set-private-out-left(^s: mbedtls-ssl-contextcb<s::S>, private-out-left: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-out-left(private-out-left))

pub inline extern mbedtls-ssl-context-ptrraw/private-cur-out-ctr(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_cur_out_ctr)"

pub inline fun mbedtls-ssl-contextp/private-cur-out-ctr(s: mbedtls-ssl-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-cur-out-ctr.cextern/ptr/carray

pub inline fun mbedtls-ssl-contextc/private-cur-out-ctr(^s: mbedtls-ssl-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-cur-out-ctr)

pub inline fun mbedtls-ssl-contextcb/private-cur-out-ctr(^s: mbedtls-ssl-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-cur-out-ctr)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-cur-out-ctr(s: intptr_t, private-cur-out-ctr: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_cur_out_ctr = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-cur-out-ctr(s: mbedtls-ssl-contextp, private-cur-out-ctr: c-array<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-cur-out-ctr(private-cur-out-ctr.cextern/carray/ptr)

pub inline fun mbedtls-ssl-contextc/set-private-cur-out-ctr(^s: mbedtls-ssl-contextc<s::S>, private-cur-out-ctr: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-cur-out-ctr(private-cur-out-ctr))

pub inline fun mbedtls-ssl-contextcb/set-private-cur-out-ctr(^s: mbedtls-ssl-contextcb<s::S>, private-cur-out-ctr: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-cur-out-ctr(private-cur-out-ctr))

pub inline extern mbedtls-ssl-context-ptrraw/private-mtu(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ssl_context*)#1)->private_mtu)"

pub inline fun mbedtls-ssl-contextp/private-mtu(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-mtu.int

pub inline fun mbedtls-ssl-contextc/private-mtu(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-mtu)

pub inline fun mbedtls-ssl-contextcb/private-mtu(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-mtu)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-mtu(s: intptr_t, private-mtu: int16): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_mtu = (int16_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-mtu(s: mbedtls-ssl-contextp, private-mtu: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-mtu(private-mtu.int16)

pub inline fun mbedtls-ssl-contextc/set-private-mtu(^s: mbedtls-ssl-contextc<s::S>, private-mtu: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-mtu(private-mtu))

pub inline fun mbedtls-ssl-contextcb/set-private-mtu(^s: mbedtls-ssl-contextcb<s::S>, private-mtu: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-mtu(private-mtu))

pub inline extern mbedtls-ssl-context-ptrraw/private-hostname(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_hostname)"

pub inline fun mbedtls-ssl-contextp/private-hostname(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-hostname

pub inline fun mbedtls-ssl-contextc/private-hostname(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-hostname)

pub inline fun mbedtls-ssl-contextcb/private-hostname(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-hostname)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-hostname(s: intptr_t, private-hostname: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_hostname = (char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-hostname(s: mbedtls-ssl-contextp, private-hostname: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-hostname(private-hostname)

pub inline fun mbedtls-ssl-contextc/set-private-hostname(^s: mbedtls-ssl-contextc<s::S>, private-hostname: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-hostname(private-hostname))

pub inline fun mbedtls-ssl-contextcb/set-private-hostname(^s: mbedtls-ssl-contextcb<s::S>, private-hostname: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-hostname(private-hostname))

pub inline extern mbedtls-ssl-context-ptrraw/private-alpn-chosen(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_alpn_chosen)"

pub inline fun mbedtls-ssl-contextp/private-alpn-chosen(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-alpn-chosen

pub inline fun mbedtls-ssl-contextc/private-alpn-chosen(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-alpn-chosen)

pub inline fun mbedtls-ssl-contextcb/private-alpn-chosen(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-alpn-chosen)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-alpn-chosen(s: intptr_t, private-alpn-chosen: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_alpn_chosen = (char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-alpn-chosen(s: mbedtls-ssl-contextp, private-alpn-chosen: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-alpn-chosen(private-alpn-chosen)

pub inline fun mbedtls-ssl-contextc/set-private-alpn-chosen(^s: mbedtls-ssl-contextc<s::S>, private-alpn-chosen: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-alpn-chosen(private-alpn-chosen))

pub inline fun mbedtls-ssl-contextcb/set-private-alpn-chosen(^s: mbedtls-ssl-contextcb<s::S>, private-alpn-chosen: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-alpn-chosen(private-alpn-chosen))

pub inline extern mbedtls-ssl-context-ptrraw/private-cli-id(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_cli_id)"

pub inline fun mbedtls-ssl-contextp/private-cli-id(s: mbedtls-ssl-contextp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-cli-id

pub inline fun mbedtls-ssl-contextc/private-cli-id(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-cli-id)

pub inline fun mbedtls-ssl-contextcb/private-cli-id(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-contextp/private-cli-id)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-cli-id(s: intptr_t, private-cli-id: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_cli_id = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-cli-id(s: mbedtls-ssl-contextp, private-cli-id: c-pointer<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-cli-id(private-cli-id)

pub inline fun mbedtls-ssl-contextc/set-private-cli-id(^s: mbedtls-ssl-contextc<s::S>, private-cli-id: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-cli-id(private-cli-id))

pub inline fun mbedtls-ssl-contextcb/set-private-cli-id(^s: mbedtls-ssl-contextcb<s::S>, private-cli-id: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-cli-id(private-cli-id))

pub inline extern mbedtls-ssl-context-ptrraw/private-cli-id-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_cli_id_len)"

pub inline fun mbedtls-ssl-contextp/private-cli-id-len(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-cli-id-len.int

pub inline fun mbedtls-ssl-contextc/private-cli-id-len(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-cli-id-len)

pub inline fun mbedtls-ssl-contextcb/private-cli-id-len(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-cli-id-len)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-cli-id-len(s: intptr_t, private-cli-id-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_cli_id_len = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-cli-id-len(s: mbedtls-ssl-contextp, private-cli-id-len: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-cli-id-len(private-cli-id-len.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-cli-id-len(^s: mbedtls-ssl-contextc<s::S>, private-cli-id-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-cli-id-len(private-cli-id-len))

pub inline fun mbedtls-ssl-contextcb/set-private-cli-id-len(^s: mbedtls-ssl-contextcb<s::S>, private-cli-id-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-cli-id-len(private-cli-id-len))

pub inline extern mbedtls-ssl-context-ptrraw/private-secure-renegotiation(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_context*)#1)->private_secure_renegotiation)"

pub inline fun mbedtls-ssl-contextp/private-secure-renegotiation(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-secure-renegotiation.int

pub inline fun mbedtls-ssl-contextc/private-secure-renegotiation(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-secure-renegotiation)

pub inline fun mbedtls-ssl-contextcb/private-secure-renegotiation(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-secure-renegotiation)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-secure-renegotiation(s: intptr_t, private-secure-renegotiation: int32): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_secure_renegotiation = (int)#2"

pub inline fun mbedtls-ssl-contextp/set-private-secure-renegotiation(s: mbedtls-ssl-contextp, private-secure-renegotiation: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-secure-renegotiation(private-secure-renegotiation.int32)

pub inline fun mbedtls-ssl-contextc/set-private-secure-renegotiation(^s: mbedtls-ssl-contextc<s::S>, private-secure-renegotiation: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-secure-renegotiation(private-secure-renegotiation))

pub inline fun mbedtls-ssl-contextcb/set-private-secure-renegotiation(^s: mbedtls-ssl-contextcb<s::S>, private-secure-renegotiation: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-secure-renegotiation(private-secure-renegotiation))

pub inline extern mbedtls-ssl-context-ptrraw/private-verify-data-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_context*)#1)->private_verify_data_len)"

pub inline fun mbedtls-ssl-contextp/private-verify-data-len(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-verify-data-len.int

pub inline fun mbedtls-ssl-contextc/private-verify-data-len(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-verify-data-len)

pub inline fun mbedtls-ssl-contextcb/private-verify-data-len(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-verify-data-len)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-verify-data-len(s: intptr_t, private-verify-data-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_verify_data_len = (size_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-verify-data-len(s: mbedtls-ssl-contextp, private-verify-data-len: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-verify-data-len(private-verify-data-len.ssize_t)

pub inline fun mbedtls-ssl-contextc/set-private-verify-data-len(^s: mbedtls-ssl-contextc<s::S>, private-verify-data-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-verify-data-len(private-verify-data-len))

pub inline fun mbedtls-ssl-contextcb/set-private-verify-data-len(^s: mbedtls-ssl-contextcb<s::S>, private-verify-data-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-verify-data-len(private-verify-data-len))

pub inline extern mbedtls-ssl-context-ptrraw/private-own-verify-data(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_own_verify_data)"

pub inline fun mbedtls-ssl-contextp/private-own-verify-data(s: mbedtls-ssl-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-own-verify-data.cextern/ptr/carray

pub inline fun mbedtls-ssl-contextc/private-own-verify-data(^s: mbedtls-ssl-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-own-verify-data)

pub inline fun mbedtls-ssl-contextcb/private-own-verify-data(^s: mbedtls-ssl-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-own-verify-data)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-own-verify-data(s: intptr_t, private-own-verify-data: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_own_verify_data = (char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-own-verify-data(s: mbedtls-ssl-contextp, private-own-verify-data: c-array<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-own-verify-data(private-own-verify-data.cextern/carray/ptr)

pub inline fun mbedtls-ssl-contextc/set-private-own-verify-data(^s: mbedtls-ssl-contextc<s::S>, private-own-verify-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-own-verify-data(private-own-verify-data))

pub inline fun mbedtls-ssl-contextcb/set-private-own-verify-data(^s: mbedtls-ssl-contextcb<s::S>, private-own-verify-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-own-verify-data(private-own-verify-data))

pub inline extern mbedtls-ssl-context-ptrraw/private-peer-verify-data(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_peer_verify_data)"

pub inline fun mbedtls-ssl-contextp/private-peer-verify-data(s: mbedtls-ssl-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-peer-verify-data.cextern/ptr/carray

pub inline fun mbedtls-ssl-contextc/private-peer-verify-data(^s: mbedtls-ssl-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-peer-verify-data)

pub inline fun mbedtls-ssl-contextcb/private-peer-verify-data(^s: mbedtls-ssl-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-peer-verify-data)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-peer-verify-data(s: intptr_t, private-peer-verify-data: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_peer_verify_data = (char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-peer-verify-data(s: mbedtls-ssl-contextp, private-peer-verify-data: c-array<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-peer-verify-data(private-peer-verify-data.cextern/carray/ptr)

pub inline fun mbedtls-ssl-contextc/set-private-peer-verify-data(^s: mbedtls-ssl-contextc<s::S>, private-peer-verify-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-peer-verify-data(private-peer-verify-data))

pub inline fun mbedtls-ssl-contextcb/set-private-peer-verify-data(^s: mbedtls-ssl-contextcb<s::S>, private-peer-verify-data: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-peer-verify-data(private-peer-verify-data))

pub inline extern mbedtls-ssl-context-ptrraw/private-own-cid(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_own_cid)"

pub inline fun mbedtls-ssl-contextp/private-own-cid(s: mbedtls-ssl-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-own-cid.cextern/ptr/carray

pub inline fun mbedtls-ssl-contextc/private-own-cid(^s: mbedtls-ssl-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-own-cid)

pub inline fun mbedtls-ssl-contextcb/private-own-cid(^s: mbedtls-ssl-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-contextp/private-own-cid)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-own-cid(s: intptr_t, private-own-cid: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_own_cid = (unsigned char*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-own-cid(s: mbedtls-ssl-contextp, private-own-cid: c-array<int>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-own-cid(private-own-cid.cextern/carray/ptr)

pub inline fun mbedtls-ssl-contextc/set-private-own-cid(^s: mbedtls-ssl-contextc<s::S>, private-own-cid: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-own-cid(private-own-cid))

pub inline fun mbedtls-ssl-contextcb/set-private-own-cid(^s: mbedtls-ssl-contextcb<s::S>, private-own-cid: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-own-cid(private-own-cid))

pub inline extern mbedtls-ssl-context-ptrraw/private-own-cid-len(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_context*)#1)->private_own_cid_len)"

pub inline fun mbedtls-ssl-contextp/private-own-cid-len(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-own-cid-len.int

pub inline fun mbedtls-ssl-contextc/private-own-cid-len(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-own-cid-len)

pub inline fun mbedtls-ssl-contextcb/private-own-cid-len(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-own-cid-len)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-own-cid-len(s: intptr_t, private-own-cid-len: int8): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_own_cid_len = (uint8_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-own-cid-len(s: mbedtls-ssl-contextp, private-own-cid-len: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-own-cid-len(private-own-cid-len.int8)

pub inline fun mbedtls-ssl-contextc/set-private-own-cid-len(^s: mbedtls-ssl-contextc<s::S>, private-own-cid-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-own-cid-len(private-own-cid-len))

pub inline fun mbedtls-ssl-contextcb/set-private-own-cid-len(^s: mbedtls-ssl-contextcb<s::S>, private-own-cid-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-own-cid-len(private-own-cid-len))

pub inline extern mbedtls-ssl-context-ptrraw/private-negotiate-cid(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_context*)#1)->private_negotiate_cid)"

pub inline fun mbedtls-ssl-contextp/private-negotiate-cid(s: mbedtls-ssl-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-negotiate-cid.int

pub inline fun mbedtls-ssl-contextc/private-negotiate-cid(^s: mbedtls-ssl-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-negotiate-cid)

pub inline fun mbedtls-ssl-contextcb/private-negotiate-cid(^s: mbedtls-ssl-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-contextp/private-negotiate-cid)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-negotiate-cid(s: intptr_t, private-negotiate-cid: int8): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_negotiate_cid = (uint8_t)#2"

pub inline fun mbedtls-ssl-contextp/set-private-negotiate-cid(s: mbedtls-ssl-contextp, private-negotiate-cid: int): ()
  s.mbedtls-ssl-context-ptrraw/set-private-negotiate-cid(private-negotiate-cid.int8)

pub inline fun mbedtls-ssl-contextc/set-private-negotiate-cid(^s: mbedtls-ssl-contextc<s::S>, private-negotiate-cid: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-negotiate-cid(private-negotiate-cid))

pub inline fun mbedtls-ssl-contextcb/set-private-negotiate-cid(^s: mbedtls-ssl-contextcb<s::S>, private-negotiate-cid: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-negotiate-cid(private-negotiate-cid))

pub inline extern mbedtls-ssl-context-ptrraw/private-f-export-keys(s: intptr_t): c-pointer<mbedtls-ssl-export-keys-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_f_export_keys)"

pub inline fun mbedtls-ssl-contextp/private-f-export-keys(s: mbedtls-ssl-contextp): <> c-pointer<mbedtls-ssl-export-keys-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-f-export-keys

pub inline fun mbedtls-ssl-contextc/private-f-export-keys(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<mbedtls-ssl-export-keys-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-export-keys)

pub inline fun mbedtls-ssl-contextcb/private-f-export-keys(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<mbedtls-ssl-export-keys-t>
  s.with-ptr(mbedtls-ssl-contextp/private-f-export-keys)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-f-export-keys(s: intptr_t, private-f-export-keys: c-pointer<mbedtls-ssl-export-keys-t>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_f_export_keys = (mbedtls_ssl_export_keys_t*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-f-export-keys(s: mbedtls-ssl-contextp, private-f-export-keys: c-pointer<mbedtls-ssl-export-keys-t>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-f-export-keys(private-f-export-keys)

pub inline fun mbedtls-ssl-contextc/set-private-f-export-keys(^s: mbedtls-ssl-contextc<s::S>, private-f-export-keys: c-pointer<mbedtls-ssl-export-keys-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-export-keys(private-f-export-keys))

pub inline fun mbedtls-ssl-contextcb/set-private-f-export-keys(^s: mbedtls-ssl-contextcb<s::S>, private-f-export-keys: c-pointer<mbedtls-ssl-export-keys-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-f-export-keys(private-f-export-keys))

pub inline extern mbedtls-ssl-context-ptrraw/private-p-export-keys(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_context*)#1)->private_p_export_keys)"

pub inline fun mbedtls-ssl-contextp/private-p-export-keys(s: mbedtls-ssl-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-context-ptrraw/private-p-export-keys

pub inline fun mbedtls-ssl-contextc/private-p-export-keys(^s: mbedtls-ssl-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-export-keys)

pub inline fun mbedtls-ssl-contextcb/private-p-export-keys(^s: mbedtls-ssl-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-contextp/private-p-export-keys)

pub inline extern mbedtls-ssl-context-ptrraw/set-private-p-export-keys(s: intptr_t, private-p-export-keys: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_context*)#1)->private_p_export_keys = (void*)#2"

pub inline fun mbedtls-ssl-contextp/set-private-p-export-keys(s: mbedtls-ssl-contextp, private-p-export-keys: c-pointer<()>): ()
  s.mbedtls-ssl-context-ptrraw/set-private-p-export-keys(private-p-export-keys)

pub inline fun mbedtls-ssl-contextc/set-private-p-export-keys(^s: mbedtls-ssl-contextc<s::S>, private-p-export-keys: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-export-keys(private-p-export-keys))

pub inline fun mbedtls-ssl-contextcb/set-private-p-export-keys(^s: mbedtls-ssl-contextcb<s::S>, private-p-export-keys: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-contextp/set-private-p-export-keys(private-p-export-keys))

// SSL/TLS configuration to be shared between mbedtls_ssl_context structures.
pub struct mbedtls-ssl-config
pub type mbedtls-ssl-config-c
pub alias mbedtls-ssl-configp = c-pointer<mbedtls-ssl-config-c>
pub alias mbedtls-ssl-configc<s::S> = owned-c<mbedtls-ssl-config-c>
pub alias mbedtls-ssl-configcb<s::S> = borrowed-c<s,mbedtls-ssl-config-c>
pub alias mbedtls-ssl-configca<s::S> = owned-c<c-array<mbedtls-ssl-config-c>>

pub extern mbedtls-ssl-config/size-of(c: c-null<mbedtls-ssl-config-c>): int32
  c inline "sizeof(struct mbedtls_ssl_config)"

pub fun mbedtls-ssl-configc(): mbedtls-ssl-configc<s::S>
  malloc(?size-of=mbedtls-ssl-config/size-of)

pub fun mbedtls-ssl-configc-calloc(): mbedtls-ssl-configc<s::S>
  malloc-c(?size-of=mbedtls-ssl-config/size-of)

pub fun mbedtls-ssl-configc-array(n: int): mbedtls-ssl-configca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-config/size-of)

pub fun mbedtls-ssl-configc-array-calloc(n: int): mbedtls-ssl-configca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-config/size-of)

pub inline extern mbedtls-ssl-config-ptrraw/private-max-tls-version(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_config*)#1)->private_max_tls_version)"

pub inline fun mbedtls-ssl-configp/private-max-tls-version(s: mbedtls-ssl-configp): <exn> mbedtls-ssl-protocol-version
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-max-tls-version.int/mbedtls-ssl-protocol-version

pub inline fun mbedtls-ssl-configc/private-max-tls-version(^s: mbedtls-ssl-configc<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-configp/private-max-tls-version)

pub inline fun mbedtls-ssl-configcb/private-max-tls-version(^s: mbedtls-ssl-configcb<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-configp/private-max-tls-version)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-max-tls-version(s: intptr_t, private-max-tls-version: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_max_tls_version = (int32_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-max-tls-version(s: mbedtls-ssl-configp, private-max-tls-version: mbedtls-ssl-protocol-version): ()
  s.mbedtls-ssl-config-ptrraw/set-private-max-tls-version(private-max-tls-version.mbedtls-ssl-protocol-version/int)

pub inline fun mbedtls-ssl-configc/set-private-max-tls-version(^s: mbedtls-ssl-configc<s::S>, private-max-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-max-tls-version(private-max-tls-version))

pub inline fun mbedtls-ssl-configcb/set-private-max-tls-version(^s: mbedtls-ssl-configcb<s::S>, private-max-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-max-tls-version(private-max-tls-version))

pub inline extern mbedtls-ssl-config-ptrraw/private-min-tls-version(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_config*)#1)->private_min_tls_version)"

pub inline fun mbedtls-ssl-configp/private-min-tls-version(s: mbedtls-ssl-configp): <exn> mbedtls-ssl-protocol-version
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-min-tls-version.int/mbedtls-ssl-protocol-version

pub inline fun mbedtls-ssl-configc/private-min-tls-version(^s: mbedtls-ssl-configc<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-configp/private-min-tls-version)

pub inline fun mbedtls-ssl-configcb/private-min-tls-version(^s: mbedtls-ssl-configcb<s::S>): <exn> mbedtls-ssl-protocol-version
  s.with-ptr(mbedtls-ssl-configp/private-min-tls-version)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-min-tls-version(s: intptr_t, private-min-tls-version: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_min_tls_version = (int32_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-min-tls-version(s: mbedtls-ssl-configp, private-min-tls-version: mbedtls-ssl-protocol-version): ()
  s.mbedtls-ssl-config-ptrraw/set-private-min-tls-version(private-min-tls-version.mbedtls-ssl-protocol-version/int)

pub inline fun mbedtls-ssl-configc/set-private-min-tls-version(^s: mbedtls-ssl-configc<s::S>, private-min-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-min-tls-version(private-min-tls-version))

pub inline fun mbedtls-ssl-configcb/set-private-min-tls-version(^s: mbedtls-ssl-configcb<s::S>, private-min-tls-version: mbedtls-ssl-protocol-version): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-min-tls-version(private-min-tls-version))

pub inline extern mbedtls-ssl-config-ptrraw/private-endpoint(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_endpoint)"

pub inline fun mbedtls-ssl-configp/private-endpoint(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-endpoint.int

pub inline fun mbedtls-ssl-configc/private-endpoint(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-endpoint)

pub inline fun mbedtls-ssl-configcb/private-endpoint(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-endpoint)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-endpoint(s: intptr_t, private-endpoint: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_endpoint = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-endpoint(s: mbedtls-ssl-configp, private-endpoint: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-endpoint(private-endpoint.int8)

pub inline fun mbedtls-ssl-configc/set-private-endpoint(^s: mbedtls-ssl-configc<s::S>, private-endpoint: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-endpoint(private-endpoint))

pub inline fun mbedtls-ssl-configcb/set-private-endpoint(^s: mbedtls-ssl-configcb<s::S>, private-endpoint: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-endpoint(private-endpoint))

pub inline extern mbedtls-ssl-config-ptrraw/private-transport(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_transport)"

pub inline fun mbedtls-ssl-configp/private-transport(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-transport.int

pub inline fun mbedtls-ssl-configc/private-transport(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-transport)

pub inline fun mbedtls-ssl-configcb/private-transport(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-transport)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-transport(s: intptr_t, private-transport: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_transport = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-transport(s: mbedtls-ssl-configp, private-transport: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-transport(private-transport.int8)

pub inline fun mbedtls-ssl-configc/set-private-transport(^s: mbedtls-ssl-configc<s::S>, private-transport: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-transport(private-transport))

pub inline fun mbedtls-ssl-configcb/set-private-transport(^s: mbedtls-ssl-configcb<s::S>, private-transport: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-transport(private-transport))

pub inline extern mbedtls-ssl-config-ptrraw/private-authmode(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_authmode)"

pub inline fun mbedtls-ssl-configp/private-authmode(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-authmode.int

pub inline fun mbedtls-ssl-configc/private-authmode(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-authmode)

pub inline fun mbedtls-ssl-configcb/private-authmode(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-authmode)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-authmode(s: intptr_t, private-authmode: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_authmode = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-authmode(s: mbedtls-ssl-configp, private-authmode: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-authmode(private-authmode.int8)

pub inline fun mbedtls-ssl-configc/set-private-authmode(^s: mbedtls-ssl-configc<s::S>, private-authmode: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-authmode(private-authmode))

pub inline fun mbedtls-ssl-configcb/set-private-authmode(^s: mbedtls-ssl-configcb<s::S>, private-authmode: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-authmode(private-authmode))

pub inline extern mbedtls-ssl-config-ptrraw/private-allow-legacy-renegotiation(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_allow_legacy_renegotiation)"

pub inline fun mbedtls-ssl-configp/private-allow-legacy-renegotiation(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-allow-legacy-renegotiation.int

pub inline fun mbedtls-ssl-configc/private-allow-legacy-renegotiation(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-allow-legacy-renegotiation)

pub inline fun mbedtls-ssl-configcb/private-allow-legacy-renegotiation(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-allow-legacy-renegotiation)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-allow-legacy-renegotiation(s: intptr_t, private-allow-legacy-renegotiation: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_allow_legacy_renegotiation = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-allow-legacy-renegotiation(s: mbedtls-ssl-configp, private-allow-legacy-renegotiation: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-allow-legacy-renegotiation(private-allow-legacy-renegotiation.int8)

pub inline fun mbedtls-ssl-configc/set-private-allow-legacy-renegotiation(^s: mbedtls-ssl-configc<s::S>, private-allow-legacy-renegotiation: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-allow-legacy-renegotiation(private-allow-legacy-renegotiation))

pub inline fun mbedtls-ssl-configcb/set-private-allow-legacy-renegotiation(^s: mbedtls-ssl-configcb<s::S>, private-allow-legacy-renegotiation: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-allow-legacy-renegotiation(private-allow-legacy-renegotiation))

pub inline extern mbedtls-ssl-config-ptrraw/private-mfl-code(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_mfl_code)"

pub inline fun mbedtls-ssl-configp/private-mfl-code(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-mfl-code.int

pub inline fun mbedtls-ssl-configc/private-mfl-code(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-mfl-code)

pub inline fun mbedtls-ssl-configcb/private-mfl-code(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-mfl-code)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-mfl-code(s: intptr_t, private-mfl-code: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_mfl_code = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-mfl-code(s: mbedtls-ssl-configp, private-mfl-code: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-mfl-code(private-mfl-code.int8)

pub inline fun mbedtls-ssl-configc/set-private-mfl-code(^s: mbedtls-ssl-configc<s::S>, private-mfl-code: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-mfl-code(private-mfl-code))

pub inline fun mbedtls-ssl-configcb/set-private-mfl-code(^s: mbedtls-ssl-configcb<s::S>, private-mfl-code: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-mfl-code(private-mfl-code))

pub inline extern mbedtls-ssl-config-ptrraw/private-encrypt-then-mac(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_encrypt_then_mac)"

pub inline fun mbedtls-ssl-configp/private-encrypt-then-mac(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-encrypt-then-mac.int

pub inline fun mbedtls-ssl-configc/private-encrypt-then-mac(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-encrypt-then-mac)

pub inline fun mbedtls-ssl-configcb/private-encrypt-then-mac(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-encrypt-then-mac)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-encrypt-then-mac(s: intptr_t, private-encrypt-then-mac: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_encrypt_then_mac = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-encrypt-then-mac(s: mbedtls-ssl-configp, private-encrypt-then-mac: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-encrypt-then-mac(private-encrypt-then-mac.int8)

pub inline fun mbedtls-ssl-configc/set-private-encrypt-then-mac(^s: mbedtls-ssl-configc<s::S>, private-encrypt-then-mac: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-encrypt-then-mac(private-encrypt-then-mac))

pub inline fun mbedtls-ssl-configcb/set-private-encrypt-then-mac(^s: mbedtls-ssl-configcb<s::S>, private-encrypt-then-mac: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-encrypt-then-mac(private-encrypt-then-mac))

pub inline extern mbedtls-ssl-config-ptrraw/private-extended-ms(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_extended_ms)"

pub inline fun mbedtls-ssl-configp/private-extended-ms(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-extended-ms.int

pub inline fun mbedtls-ssl-configc/private-extended-ms(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-extended-ms)

pub inline fun mbedtls-ssl-configcb/private-extended-ms(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-extended-ms)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-extended-ms(s: intptr_t, private-extended-ms: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_extended_ms = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-extended-ms(s: mbedtls-ssl-configp, private-extended-ms: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-extended-ms(private-extended-ms.int8)

pub inline fun mbedtls-ssl-configc/set-private-extended-ms(^s: mbedtls-ssl-configc<s::S>, private-extended-ms: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-extended-ms(private-extended-ms))

pub inline fun mbedtls-ssl-configcb/set-private-extended-ms(^s: mbedtls-ssl-configcb<s::S>, private-extended-ms: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-extended-ms(private-extended-ms))

pub inline extern mbedtls-ssl-config-ptrraw/private-anti-replay(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_anti_replay)"

pub inline fun mbedtls-ssl-configp/private-anti-replay(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-anti-replay.int

pub inline fun mbedtls-ssl-configc/private-anti-replay(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-anti-replay)

pub inline fun mbedtls-ssl-configcb/private-anti-replay(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-anti-replay)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-anti-replay(s: intptr_t, private-anti-replay: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_anti_replay = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-anti-replay(s: mbedtls-ssl-configp, private-anti-replay: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-anti-replay(private-anti-replay.int8)

pub inline fun mbedtls-ssl-configc/set-private-anti-replay(^s: mbedtls-ssl-configc<s::S>, private-anti-replay: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-anti-replay(private-anti-replay))

pub inline fun mbedtls-ssl-configcb/set-private-anti-replay(^s: mbedtls-ssl-configcb<s::S>, private-anti-replay: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-anti-replay(private-anti-replay))

pub inline extern mbedtls-ssl-config-ptrraw/private-disable-renegotiation(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_disable_renegotiation)"

pub inline fun mbedtls-ssl-configp/private-disable-renegotiation(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-disable-renegotiation.int

pub inline fun mbedtls-ssl-configc/private-disable-renegotiation(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-disable-renegotiation)

pub inline fun mbedtls-ssl-configcb/private-disable-renegotiation(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-disable-renegotiation)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-disable-renegotiation(s: intptr_t, private-disable-renegotiation: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_disable_renegotiation = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-disable-renegotiation(s: mbedtls-ssl-configp, private-disable-renegotiation: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-disable-renegotiation(private-disable-renegotiation.int8)

pub inline fun mbedtls-ssl-configc/set-private-disable-renegotiation(^s: mbedtls-ssl-configc<s::S>, private-disable-renegotiation: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-disable-renegotiation(private-disable-renegotiation))

pub inline fun mbedtls-ssl-configcb/set-private-disable-renegotiation(^s: mbedtls-ssl-configcb<s::S>, private-disable-renegotiation: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-disable-renegotiation(private-disable-renegotiation))

pub inline extern mbedtls-ssl-config-ptrraw/private-session-tickets(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_session_tickets)"

pub inline fun mbedtls-ssl-configp/private-session-tickets(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-session-tickets.int

pub inline fun mbedtls-ssl-configc/private-session-tickets(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-session-tickets)

pub inline fun mbedtls-ssl-configcb/private-session-tickets(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-session-tickets)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-session-tickets(s: intptr_t, private-session-tickets: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_session_tickets = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-session-tickets(s: mbedtls-ssl-configp, private-session-tickets: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-session-tickets(private-session-tickets.int8)

pub inline fun mbedtls-ssl-configc/set-private-session-tickets(^s: mbedtls-ssl-configc<s::S>, private-session-tickets: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-session-tickets(private-session-tickets))

pub inline fun mbedtls-ssl-configcb/set-private-session-tickets(^s: mbedtls-ssl-configcb<s::S>, private-session-tickets: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-session-tickets(private-session-tickets))

pub inline extern mbedtls-ssl-config-ptrraw/private-new-session-tickets-count(s: intptr_t): int16
  c inline "(int16_t)(((struct mbedtls_ssl_config*)#1)->private_new_session_tickets_count)"

pub inline fun mbedtls-ssl-configp/private-new-session-tickets-count(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-new-session-tickets-count.int

pub inline fun mbedtls-ssl-configc/private-new-session-tickets-count(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-new-session-tickets-count)

pub inline fun mbedtls-ssl-configcb/private-new-session-tickets-count(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-new-session-tickets-count)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-new-session-tickets-count(s: intptr_t, private-new-session-tickets-count: int16): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_new_session_tickets_count = (int16_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-new-session-tickets-count(s: mbedtls-ssl-configp, private-new-session-tickets-count: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-new-session-tickets-count(private-new-session-tickets-count.int16)

pub inline fun mbedtls-ssl-configc/set-private-new-session-tickets-count(^s: mbedtls-ssl-configc<s::S>, private-new-session-tickets-count: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-new-session-tickets-count(private-new-session-tickets-count))

pub inline fun mbedtls-ssl-configcb/set-private-new-session-tickets-count(^s: mbedtls-ssl-configcb<s::S>, private-new-session-tickets-count: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-new-session-tickets-count(private-new-session-tickets-count))

pub inline extern mbedtls-ssl-config-ptrraw/private-cert-req-ca-list(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_cert_req_ca_list)"

pub inline fun mbedtls-ssl-configp/private-cert-req-ca-list(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-cert-req-ca-list.int

pub inline fun mbedtls-ssl-configc/private-cert-req-ca-list(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-cert-req-ca-list)

pub inline fun mbedtls-ssl-configcb/private-cert-req-ca-list(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-cert-req-ca-list)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-cert-req-ca-list(s: intptr_t, private-cert-req-ca-list: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_cert_req_ca_list = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-cert-req-ca-list(s: mbedtls-ssl-configp, private-cert-req-ca-list: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-cert-req-ca-list(private-cert-req-ca-list.int8)

pub inline fun mbedtls-ssl-configc/set-private-cert-req-ca-list(^s: mbedtls-ssl-configc<s::S>, private-cert-req-ca-list: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-cert-req-ca-list(private-cert-req-ca-list))

pub inline fun mbedtls-ssl-configcb/set-private-cert-req-ca-list(^s: mbedtls-ssl-configcb<s::S>, private-cert-req-ca-list: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-cert-req-ca-list(private-cert-req-ca-list))

pub inline extern mbedtls-ssl-config-ptrraw/private-respect-cli-pref(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_respect_cli_pref)"

pub inline fun mbedtls-ssl-configp/private-respect-cli-pref(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-respect-cli-pref.int

pub inline fun mbedtls-ssl-configc/private-respect-cli-pref(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-respect-cli-pref)

pub inline fun mbedtls-ssl-configcb/private-respect-cli-pref(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-respect-cli-pref)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-respect-cli-pref(s: intptr_t, private-respect-cli-pref: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_respect_cli_pref = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-respect-cli-pref(s: mbedtls-ssl-configp, private-respect-cli-pref: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-respect-cli-pref(private-respect-cli-pref.int8)

pub inline fun mbedtls-ssl-configc/set-private-respect-cli-pref(^s: mbedtls-ssl-configc<s::S>, private-respect-cli-pref: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-respect-cli-pref(private-respect-cli-pref))

pub inline fun mbedtls-ssl-configcb/set-private-respect-cli-pref(^s: mbedtls-ssl-configcb<s::S>, private-respect-cli-pref: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-respect-cli-pref(private-respect-cli-pref))

pub inline extern mbedtls-ssl-config-ptrraw/private-ignore-unexpected-cid(s: intptr_t): int8
  c inline "(uint8_t)(((struct mbedtls_ssl_config*)#1)->private_ignore_unexpected_cid)"

pub inline fun mbedtls-ssl-configp/private-ignore-unexpected-cid(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-ignore-unexpected-cid.int

pub inline fun mbedtls-ssl-configc/private-ignore-unexpected-cid(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-ignore-unexpected-cid)

pub inline fun mbedtls-ssl-configcb/private-ignore-unexpected-cid(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-ignore-unexpected-cid)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-ignore-unexpected-cid(s: intptr_t, private-ignore-unexpected-cid: int8): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_ignore_unexpected_cid = (uint8_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-ignore-unexpected-cid(s: mbedtls-ssl-configp, private-ignore-unexpected-cid: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-ignore-unexpected-cid(private-ignore-unexpected-cid.int8)

pub inline fun mbedtls-ssl-configc/set-private-ignore-unexpected-cid(^s: mbedtls-ssl-configc<s::S>, private-ignore-unexpected-cid: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ignore-unexpected-cid(private-ignore-unexpected-cid))

pub inline fun mbedtls-ssl-configcb/set-private-ignore-unexpected-cid(^s: mbedtls-ssl-configcb<s::S>, private-ignore-unexpected-cid: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ignore-unexpected-cid(private-ignore-unexpected-cid))

pub inline extern mbedtls-ssl-config-ptrraw/private-ciphersuite-list(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_ciphersuite_list)"

pub inline fun mbedtls-ssl-configp/private-ciphersuite-list(s: mbedtls-ssl-configp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-ciphersuite-list

pub inline fun mbedtls-ssl-configc/private-ciphersuite-list(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-ciphersuite-list)

pub inline fun mbedtls-ssl-configcb/private-ciphersuite-list(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-ciphersuite-list)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-ciphersuite-list(s: intptr_t, private-ciphersuite-list: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_ciphersuite_list = (int*)#2"

pub inline fun mbedtls-ssl-configp/set-private-ciphersuite-list(s: mbedtls-ssl-configp, private-ciphersuite-list: c-pointer<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-ciphersuite-list(private-ciphersuite-list)

pub inline fun mbedtls-ssl-configc/set-private-ciphersuite-list(^s: mbedtls-ssl-configc<s::S>, private-ciphersuite-list: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ciphersuite-list(private-ciphersuite-list))

pub inline fun mbedtls-ssl-configcb/set-private-ciphersuite-list(^s: mbedtls-ssl-configcb<s::S>, private-ciphersuite-list: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ciphersuite-list(private-ciphersuite-list))

pub inline extern mbedtls-ssl-config-ptrraw/private-tls13-kex-modes(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_config*)#1)->private_tls13_kex_modes)"

pub inline fun mbedtls-ssl-configp/private-tls13-kex-modes(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-tls13-kex-modes.int

pub inline fun mbedtls-ssl-configc/private-tls13-kex-modes(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-tls13-kex-modes)

pub inline fun mbedtls-ssl-configcb/private-tls13-kex-modes(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-tls13-kex-modes)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-tls13-kex-modes(s: intptr_t, private-tls13-kex-modes: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_tls13_kex_modes = (int)#2"

pub inline fun mbedtls-ssl-configp/set-private-tls13-kex-modes(s: mbedtls-ssl-configp, private-tls13-kex-modes: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-tls13-kex-modes(private-tls13-kex-modes.int32)

pub inline fun mbedtls-ssl-configc/set-private-tls13-kex-modes(^s: mbedtls-ssl-configc<s::S>, private-tls13-kex-modes: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-tls13-kex-modes(private-tls13-kex-modes))

pub inline fun mbedtls-ssl-configcb/set-private-tls13-kex-modes(^s: mbedtls-ssl-configcb<s::S>, private-tls13-kex-modes: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-tls13-kex-modes(private-tls13-kex-modes))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-dbg(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_dbg)"

pub inline fun mbedtls-ssl-configp/private-f-dbg(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-dbg

pub inline fun mbedtls-ssl-configc/private-f-dbg(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-dbg)

pub inline fun mbedtls-ssl-configcb/private-f-dbg(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-dbg)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-dbg(s: intptr_t, private-f-dbg: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_dbg = (void (*)(void*, int, char*, int, char*))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-dbg(s: mbedtls-ssl-configp, private-f-dbg: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-dbg(private-f-dbg)

pub inline fun mbedtls-ssl-configc/set-private-f-dbg(^s: mbedtls-ssl-configc<s::S>, private-f-dbg: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-dbg(private-f-dbg))

pub inline fun mbedtls-ssl-configcb/set-private-f-dbg(^s: mbedtls-ssl-configcb<s::S>, private-f-dbg: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-dbg(private-f-dbg))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-dbg(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_dbg)"

pub inline fun mbedtls-ssl-configp/private-p-dbg(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-dbg

pub inline fun mbedtls-ssl-configc/private-p-dbg(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-dbg)

pub inline fun mbedtls-ssl-configcb/private-p-dbg(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-dbg)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-dbg(s: intptr_t, private-p-dbg: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_dbg = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-dbg(s: mbedtls-ssl-configp, private-p-dbg: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-dbg(private-p-dbg)

pub inline fun mbedtls-ssl-configc/set-private-p-dbg(^s: mbedtls-ssl-configc<s::S>, private-p-dbg: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-dbg(private-p-dbg))

pub inline fun mbedtls-ssl-configcb/set-private-p-dbg(^s: mbedtls-ssl-configcb<s::S>, private-p-dbg: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-dbg(private-p-dbg))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-rng(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_rng)"

pub inline fun mbedtls-ssl-configp/private-f-rng(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-rng

pub inline fun mbedtls-ssl-configc/private-f-rng(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-rng)

pub inline fun mbedtls-ssl-configcb/private-f-rng(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-rng)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-rng(s: intptr_t, private-f-rng: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_rng = (int (*)(void*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-rng(s: mbedtls-ssl-configp, private-f-rng: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-rng(private-f-rng)

pub inline fun mbedtls-ssl-configc/set-private-f-rng(^s: mbedtls-ssl-configc<s::S>, private-f-rng: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-rng(private-f-rng))

pub inline fun mbedtls-ssl-configcb/set-private-f-rng(^s: mbedtls-ssl-configcb<s::S>, private-f-rng: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-rng(private-f-rng))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-rng(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_rng)"

pub inline fun mbedtls-ssl-configp/private-p-rng(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-rng

pub inline fun mbedtls-ssl-configc/private-p-rng(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-rng)

pub inline fun mbedtls-ssl-configcb/private-p-rng(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-rng)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-rng(s: intptr_t, private-p-rng: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_rng = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-rng(s: mbedtls-ssl-configp, private-p-rng: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-rng(private-p-rng)

pub inline fun mbedtls-ssl-configc/set-private-p-rng(^s: mbedtls-ssl-configc<s::S>, private-p-rng: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-rng(private-p-rng))

pub inline fun mbedtls-ssl-configcb/set-private-p-rng(^s: mbedtls-ssl-configcb<s::S>, private-p-rng: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-rng(private-p-rng))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-get-cache(s: intptr_t): c-pointer<mbedtls-ssl-cache-get-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_get_cache)"

pub inline fun mbedtls-ssl-configp/private-f-get-cache(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-ssl-cache-get-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-get-cache

pub inline fun mbedtls-ssl-configc/private-f-get-cache(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-ssl-cache-get-t>
  s.with-ptr(mbedtls-ssl-configp/private-f-get-cache)

pub inline fun mbedtls-ssl-configcb/private-f-get-cache(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-ssl-cache-get-t>
  s.with-ptr(mbedtls-ssl-configp/private-f-get-cache)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-get-cache(s: intptr_t, private-f-get-cache: c-pointer<mbedtls-ssl-cache-get-t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_get_cache = (mbedtls_ssl_cache_get_t*)#2"

pub inline fun mbedtls-ssl-configp/set-private-f-get-cache(s: mbedtls-ssl-configp, private-f-get-cache: c-pointer<mbedtls-ssl-cache-get-t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-get-cache(private-f-get-cache)

pub inline fun mbedtls-ssl-configc/set-private-f-get-cache(^s: mbedtls-ssl-configc<s::S>, private-f-get-cache: c-pointer<mbedtls-ssl-cache-get-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-get-cache(private-f-get-cache))

pub inline fun mbedtls-ssl-configcb/set-private-f-get-cache(^s: mbedtls-ssl-configcb<s::S>, private-f-get-cache: c-pointer<mbedtls-ssl-cache-get-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-get-cache(private-f-get-cache))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-set-cache(s: intptr_t): c-pointer<mbedtls-ssl-cache-set-t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_set_cache)"

pub inline fun mbedtls-ssl-configp/private-f-set-cache(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-ssl-cache-set-t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-set-cache

pub inline fun mbedtls-ssl-configc/private-f-set-cache(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-ssl-cache-set-t>
  s.with-ptr(mbedtls-ssl-configp/private-f-set-cache)

pub inline fun mbedtls-ssl-configcb/private-f-set-cache(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-ssl-cache-set-t>
  s.with-ptr(mbedtls-ssl-configp/private-f-set-cache)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-set-cache(s: intptr_t, private-f-set-cache: c-pointer<mbedtls-ssl-cache-set-t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_set_cache = (mbedtls_ssl_cache_set_t*)#2"

pub inline fun mbedtls-ssl-configp/set-private-f-set-cache(s: mbedtls-ssl-configp, private-f-set-cache: c-pointer<mbedtls-ssl-cache-set-t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-set-cache(private-f-set-cache)

pub inline fun mbedtls-ssl-configc/set-private-f-set-cache(^s: mbedtls-ssl-configc<s::S>, private-f-set-cache: c-pointer<mbedtls-ssl-cache-set-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-set-cache(private-f-set-cache))

pub inline fun mbedtls-ssl-configcb/set-private-f-set-cache(^s: mbedtls-ssl-configcb<s::S>, private-f-set-cache: c-pointer<mbedtls-ssl-cache-set-t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-set-cache(private-f-set-cache))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-cache(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_cache)"

pub inline fun mbedtls-ssl-configp/private-p-cache(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-cache

pub inline fun mbedtls-ssl-configc/private-p-cache(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-cache)

pub inline fun mbedtls-ssl-configcb/private-p-cache(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-cache)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-cache(s: intptr_t, private-p-cache: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_cache = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-cache(s: mbedtls-ssl-configp, private-p-cache: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-cache(private-p-cache)

pub inline fun mbedtls-ssl-configc/set-private-p-cache(^s: mbedtls-ssl-configc<s::S>, private-p-cache: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-cache(private-p-cache))

pub inline fun mbedtls-ssl-configcb/set-private-p-cache(^s: mbedtls-ssl-configcb<s::S>, private-p-cache: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-cache(private-p-cache))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-sni(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_sni)"

pub inline fun mbedtls-ssl-configp/private-f-sni(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-sni

pub inline fun mbedtls-ssl-configc/private-f-sni(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-sni)

pub inline fun mbedtls-ssl-configcb/private-f-sni(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-sni)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-sni(s: intptr_t, private-f-sni: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_sni = (int (*)(void*, struct mbedtls_ssl_context*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-sni(s: mbedtls-ssl-configp, private-f-sni: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-sni(private-f-sni)

pub inline fun mbedtls-ssl-configc/set-private-f-sni(^s: mbedtls-ssl-configc<s::S>, private-f-sni: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-sni(private-f-sni))

pub inline fun mbedtls-ssl-configcb/set-private-f-sni(^s: mbedtls-ssl-configcb<s::S>, private-f-sni: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-sni(private-f-sni))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-sni(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_sni)"

pub inline fun mbedtls-ssl-configp/private-p-sni(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-sni

pub inline fun mbedtls-ssl-configc/private-p-sni(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-sni)

pub inline fun mbedtls-ssl-configcb/private-p-sni(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-sni)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-sni(s: intptr_t, private-p-sni: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_sni = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-sni(s: mbedtls-ssl-configp, private-p-sni: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-sni(private-p-sni)

pub inline fun mbedtls-ssl-configc/set-private-p-sni(^s: mbedtls-ssl-configc<s::S>, private-p-sni: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-sni(private-p-sni))

pub inline fun mbedtls-ssl-configcb/set-private-p-sni(^s: mbedtls-ssl-configcb<s::S>, private-p-sni: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-sni(private-p-sni))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-vrfy(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_vrfy)"

pub inline fun mbedtls-ssl-configp/private-f-vrfy(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-vrfy

pub inline fun mbedtls-ssl-configc/private-f-vrfy(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-vrfy)

pub inline fun mbedtls-ssl-configcb/private-f-vrfy(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-vrfy)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-vrfy(s: intptr_t, private-f-vrfy: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_vrfy = (int (*)(void*, struct mbedtls_x509_crt*, int, int32_t*))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-vrfy(s: mbedtls-ssl-configp, private-f-vrfy: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-vrfy(private-f-vrfy)

pub inline fun mbedtls-ssl-configc/set-private-f-vrfy(^s: mbedtls-ssl-configc<s::S>, private-f-vrfy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-vrfy(private-f-vrfy))

pub inline fun mbedtls-ssl-configcb/set-private-f-vrfy(^s: mbedtls-ssl-configcb<s::S>, private-f-vrfy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-vrfy(private-f-vrfy))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-vrfy(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_vrfy)"

pub inline fun mbedtls-ssl-configp/private-p-vrfy(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-vrfy

pub inline fun mbedtls-ssl-configc/private-p-vrfy(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-vrfy)

pub inline fun mbedtls-ssl-configcb/private-p-vrfy(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-vrfy)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-vrfy(s: intptr_t, private-p-vrfy: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_vrfy = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-vrfy(s: mbedtls-ssl-configp, private-p-vrfy: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-vrfy(private-p-vrfy)

pub inline fun mbedtls-ssl-configc/set-private-p-vrfy(^s: mbedtls-ssl-configc<s::S>, private-p-vrfy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-vrfy(private-p-vrfy))

pub inline fun mbedtls-ssl-configcb/set-private-p-vrfy(^s: mbedtls-ssl-configcb<s::S>, private-p-vrfy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-vrfy(private-p-vrfy))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-psk(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_psk)"

pub inline fun mbedtls-ssl-configp/private-f-psk(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-psk

pub inline fun mbedtls-ssl-configc/private-f-psk(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-psk)

pub inline fun mbedtls-ssl-configcb/private-f-psk(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-psk)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-psk(s: intptr_t, private-f-psk: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_psk = (int (*)(void*, struct mbedtls_ssl_context*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-psk(s: mbedtls-ssl-configp, private-f-psk: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-psk(private-f-psk)

pub inline fun mbedtls-ssl-configc/set-private-f-psk(^s: mbedtls-ssl-configc<s::S>, private-f-psk: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-psk(private-f-psk))

pub inline fun mbedtls-ssl-configcb/set-private-f-psk(^s: mbedtls-ssl-configcb<s::S>, private-f-psk: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-psk(private-f-psk))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-psk(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_psk)"

pub inline fun mbedtls-ssl-configp/private-p-psk(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-psk

pub inline fun mbedtls-ssl-configc/private-p-psk(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-psk)

pub inline fun mbedtls-ssl-configcb/private-p-psk(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-psk)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-psk(s: intptr_t, private-p-psk: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_psk = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-psk(s: mbedtls-ssl-configp, private-p-psk: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-psk(private-p-psk)

pub inline fun mbedtls-ssl-configc/set-private-p-psk(^s: mbedtls-ssl-configc<s::S>, private-p-psk: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-psk(private-p-psk))

pub inline fun mbedtls-ssl-configcb/set-private-p-psk(^s: mbedtls-ssl-configcb<s::S>, private-p-psk: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-psk(private-p-psk))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-cookie-write(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_cookie_write)"

pub inline fun mbedtls-ssl-configp/private-f-cookie-write(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-cookie-write

pub inline fun mbedtls-ssl-configc/private-f-cookie-write(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-cookie-write)

pub inline fun mbedtls-ssl-configcb/private-f-cookie-write(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-cookie-write)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-cookie-write(s: intptr_t, private-f-cookie-write: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_cookie_write = (int (*)(void*, unsigned char**, unsigned char*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-cookie-write(s: mbedtls-ssl-configp, private-f-cookie-write: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-cookie-write(private-f-cookie-write)

pub inline fun mbedtls-ssl-configc/set-private-f-cookie-write(^s: mbedtls-ssl-configc<s::S>, private-f-cookie-write: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-cookie-write(private-f-cookie-write))

pub inline fun mbedtls-ssl-configcb/set-private-f-cookie-write(^s: mbedtls-ssl-configcb<s::S>, private-f-cookie-write: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-cookie-write(private-f-cookie-write))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-cookie-check(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_cookie_check)"

pub inline fun mbedtls-ssl-configp/private-f-cookie-check(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-cookie-check

pub inline fun mbedtls-ssl-configc/private-f-cookie-check(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-cookie-check)

pub inline fun mbedtls-ssl-configcb/private-f-cookie-check(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-cookie-check)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-cookie-check(s: intptr_t, private-f-cookie-check: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_cookie_check = (int (*)(void*, unsigned char*, size_t, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-cookie-check(s: mbedtls-ssl-configp, private-f-cookie-check: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-cookie-check(private-f-cookie-check)

pub inline fun mbedtls-ssl-configc/set-private-f-cookie-check(^s: mbedtls-ssl-configc<s::S>, private-f-cookie-check: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-cookie-check(private-f-cookie-check))

pub inline fun mbedtls-ssl-configcb/set-private-f-cookie-check(^s: mbedtls-ssl-configcb<s::S>, private-f-cookie-check: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-cookie-check(private-f-cookie-check))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-cookie(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_cookie)"

pub inline fun mbedtls-ssl-configp/private-p-cookie(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-cookie

pub inline fun mbedtls-ssl-configc/private-p-cookie(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-cookie)

pub inline fun mbedtls-ssl-configcb/private-p-cookie(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-cookie)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-cookie(s: intptr_t, private-p-cookie: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_cookie = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-cookie(s: mbedtls-ssl-configp, private-p-cookie: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-cookie(private-p-cookie)

pub inline fun mbedtls-ssl-configc/set-private-p-cookie(^s: mbedtls-ssl-configc<s::S>, private-p-cookie: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-cookie(private-p-cookie))

pub inline fun mbedtls-ssl-configcb/set-private-p-cookie(^s: mbedtls-ssl-configcb<s::S>, private-p-cookie: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-cookie(private-p-cookie))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-ticket-write(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_ticket_write)"

pub inline fun mbedtls-ssl-configp/private-f-ticket-write(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-ticket-write

pub inline fun mbedtls-ssl-configc/private-f-ticket-write(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-ticket-write)

pub inline fun mbedtls-ssl-configcb/private-f-ticket-write(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-ticket-write)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-ticket-write(s: intptr_t, private-f-ticket-write: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_ticket_write = (int (*)(void*, struct mbedtls_ssl_session*, unsigned char*, unsigned char*, size_t*, int32_t*))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-ticket-write(s: mbedtls-ssl-configp, private-f-ticket-write: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-ticket-write(private-f-ticket-write)

pub inline fun mbedtls-ssl-configc/set-private-f-ticket-write(^s: mbedtls-ssl-configc<s::S>, private-f-ticket-write: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-ticket-write(private-f-ticket-write))

pub inline fun mbedtls-ssl-configcb/set-private-f-ticket-write(^s: mbedtls-ssl-configcb<s::S>, private-f-ticket-write: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-ticket-write(private-f-ticket-write))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-ticket-parse(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_ticket_parse)"

pub inline fun mbedtls-ssl-configp/private-f-ticket-parse(s: mbedtls-ssl-configp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-ticket-parse

pub inline fun mbedtls-ssl-configc/private-f-ticket-parse(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-ticket-parse)

pub inline fun mbedtls-ssl-configcb/private-f-ticket-parse(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-configp/private-f-ticket-parse)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-ticket-parse(s: intptr_t, private-f-ticket-parse: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_ticket_parse = (int (*)(void*, struct mbedtls_ssl_session*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-configp/set-private-f-ticket-parse(s: mbedtls-ssl-configp, private-f-ticket-parse: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-ticket-parse(private-f-ticket-parse)

pub inline fun mbedtls-ssl-configc/set-private-f-ticket-parse(^s: mbedtls-ssl-configc<s::S>, private-f-ticket-parse: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-ticket-parse(private-f-ticket-parse))

pub inline fun mbedtls-ssl-configcb/set-private-f-ticket-parse(^s: mbedtls-ssl-configcb<s::S>, private-f-ticket-parse: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-ticket-parse(private-f-ticket-parse))

pub inline extern mbedtls-ssl-config-ptrraw/private-p-ticket(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_p_ticket)"

pub inline fun mbedtls-ssl-configp/private-p-ticket(s: mbedtls-ssl-configp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-p-ticket

pub inline fun mbedtls-ssl-configc/private-p-ticket(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-ticket)

pub inline fun mbedtls-ssl-configcb/private-p-ticket(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-configp/private-p-ticket)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-p-ticket(s: intptr_t, private-p-ticket: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_p_ticket = (void*)#2"

pub inline fun mbedtls-ssl-configp/set-private-p-ticket(s: mbedtls-ssl-configp, private-p-ticket: c-pointer<()>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-p-ticket(private-p-ticket)

pub inline fun mbedtls-ssl-configc/set-private-p-ticket(^s: mbedtls-ssl-configc<s::S>, private-p-ticket: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-ticket(private-p-ticket))

pub inline fun mbedtls-ssl-configcb/set-private-p-ticket(^s: mbedtls-ssl-configcb<s::S>, private-p-ticket: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-p-ticket(private-p-ticket))

pub inline extern mbedtls-ssl-config-ptrraw/private-cid-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_config*)#1)->private_cid_len)"

pub inline fun mbedtls-ssl-configp/private-cid-len(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-cid-len.int

pub inline fun mbedtls-ssl-configc/private-cid-len(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-cid-len)

pub inline fun mbedtls-ssl-configcb/private-cid-len(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-cid-len)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-cid-len(s: intptr_t, private-cid-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_cid_len = (size_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-cid-len(s: mbedtls-ssl-configp, private-cid-len: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-cid-len(private-cid-len.ssize_t)

pub inline fun mbedtls-ssl-configc/set-private-cid-len(^s: mbedtls-ssl-configc<s::S>, private-cid-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-cid-len(private-cid-len))

pub inline fun mbedtls-ssl-configcb/set-private-cid-len(^s: mbedtls-ssl-configcb<s::S>, private-cid-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-cid-len(private-cid-len))

pub inline extern mbedtls-ssl-config-ptrraw/private-cert-profile(s: intptr_t): c-pointer<mbedtls-x509-crt-profile-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_cert_profile)"

pub inline fun mbedtls-ssl-configp/private-cert-profile(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-x509-crt-profile-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-cert-profile

pub inline fun mbedtls-ssl-configc/private-cert-profile(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-x509-crt-profile-c>
  s.with-ptr(mbedtls-ssl-configp/private-cert-profile)

pub inline fun mbedtls-ssl-configcb/private-cert-profile(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-x509-crt-profile-c>
  s.with-ptr(mbedtls-ssl-configp/private-cert-profile)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-cert-profile(s: intptr_t, private-cert-profile: c-pointer<mbedtls-x509-crt-profile-c>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_cert_profile = (struct mbedtls_x509_crt_profile*)#2"

pub inline fun mbedtls-ssl-configp/set-private-cert-profile(s: mbedtls-ssl-configp, private-cert-profile: c-pointer<mbedtls-x509-crt-profile-c>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-cert-profile(private-cert-profile)

pub inline fun mbedtls-ssl-configc/set-private-cert-profile(^s: mbedtls-ssl-configc<s::S>, private-cert-profile: c-pointer<mbedtls-x509-crt-profile-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-cert-profile(private-cert-profile))

pub inline fun mbedtls-ssl-configcb/set-private-cert-profile(^s: mbedtls-ssl-configcb<s::S>, private-cert-profile: c-pointer<mbedtls-x509-crt-profile-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-cert-profile(private-cert-profile))

pub inline extern mbedtls-ssl-config-ptrraw/private-key-cert(s: intptr_t): c-pointer<mbedtls-ssl-key-cert-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_key_cert)"

pub inline fun mbedtls-ssl-configp/private-key-cert(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-ssl-key-cert-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-key-cert

pub inline fun mbedtls-ssl-configc/private-key-cert(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-ssl-key-cert-c>
  s.with-ptr(mbedtls-ssl-configp/private-key-cert)

pub inline fun mbedtls-ssl-configcb/private-key-cert(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-ssl-key-cert-c>
  s.with-ptr(mbedtls-ssl-configp/private-key-cert)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-key-cert(s: intptr_t, private-key-cert: c-pointer<mbedtls-ssl-key-cert-c>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_key_cert = (struct mbedtls_ssl_key_cert*)#2"

pub inline fun mbedtls-ssl-configp/set-private-key-cert(s: mbedtls-ssl-configp, private-key-cert: c-pointer<mbedtls-ssl-key-cert-c>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-key-cert(private-key-cert)

pub inline fun mbedtls-ssl-configc/set-private-key-cert(^s: mbedtls-ssl-configc<s::S>, private-key-cert: c-pointer<mbedtls-ssl-key-cert-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-key-cert(private-key-cert))

pub inline fun mbedtls-ssl-configcb/set-private-key-cert(^s: mbedtls-ssl-configcb<s::S>, private-key-cert: c-pointer<mbedtls-ssl-key-cert-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-key-cert(private-key-cert))

pub inline extern mbedtls-ssl-config-ptrraw/private-ca-chain(s: intptr_t): c-pointer<mbedtls-x509-crt-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_ca_chain)"

pub inline fun mbedtls-ssl-configp/private-ca-chain(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-x509-crt-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-ca-chain

pub inline fun mbedtls-ssl-configc/private-ca-chain(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-ssl-configp/private-ca-chain)

pub inline fun mbedtls-ssl-configcb/private-ca-chain(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-ssl-configp/private-ca-chain)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-ca-chain(s: intptr_t, private-ca-chain: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_ca_chain = (struct mbedtls_x509_crt*)#2"

pub inline fun mbedtls-ssl-configp/set-private-ca-chain(s: mbedtls-ssl-configp, private-ca-chain: c-pointer<mbedtls-x509-crt-c>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-ca-chain(private-ca-chain)

pub inline fun mbedtls-ssl-configc/set-private-ca-chain(^s: mbedtls-ssl-configc<s::S>, private-ca-chain: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ca-chain(private-ca-chain))

pub inline fun mbedtls-ssl-configcb/set-private-ca-chain(^s: mbedtls-ssl-configcb<s::S>, private-ca-chain: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ca-chain(private-ca-chain))

pub inline extern mbedtls-ssl-config-ptrraw/private-ca-crl(s: intptr_t): c-pointer<mbedtls-x509-crl-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_ca_crl)"

pub inline fun mbedtls-ssl-configp/private-ca-crl(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-x509-crl-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-ca-crl

pub inline fun mbedtls-ssl-configc/private-ca-crl(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-x509-crl-c>
  s.with-ptr(mbedtls-ssl-configp/private-ca-crl)

pub inline fun mbedtls-ssl-configcb/private-ca-crl(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-x509-crl-c>
  s.with-ptr(mbedtls-ssl-configp/private-ca-crl)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-ca-crl(s: intptr_t, private-ca-crl: c-pointer<mbedtls-x509-crl-c>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_ca_crl = (struct mbedtls_x509_crl*)#2"

pub inline fun mbedtls-ssl-configp/set-private-ca-crl(s: mbedtls-ssl-configp, private-ca-crl: c-pointer<mbedtls-x509-crl-c>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-ca-crl(private-ca-crl)

pub inline fun mbedtls-ssl-configc/set-private-ca-crl(^s: mbedtls-ssl-configc<s::S>, private-ca-crl: c-pointer<mbedtls-x509-crl-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ca-crl(private-ca-crl))

pub inline fun mbedtls-ssl-configcb/set-private-ca-crl(^s: mbedtls-ssl-configcb<s::S>, private-ca-crl: c-pointer<mbedtls-x509-crl-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-ca-crl(private-ca-crl))

pub inline extern mbedtls-ssl-config-ptrraw/private-sig-hashes(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_sig_hashes)"

pub inline fun mbedtls-ssl-configp/private-sig-hashes(s: mbedtls-ssl-configp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-sig-hashes

pub inline fun mbedtls-ssl-configc/private-sig-hashes(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-sig-hashes)

pub inline fun mbedtls-ssl-configcb/private-sig-hashes(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-sig-hashes)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-sig-hashes(s: intptr_t, private-sig-hashes: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_sig_hashes = (int*)#2"

pub inline fun mbedtls-ssl-configp/set-private-sig-hashes(s: mbedtls-ssl-configp, private-sig-hashes: c-pointer<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-sig-hashes(private-sig-hashes)

pub inline fun mbedtls-ssl-configc/set-private-sig-hashes(^s: mbedtls-ssl-configc<s::S>, private-sig-hashes: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-sig-hashes(private-sig-hashes))

pub inline fun mbedtls-ssl-configcb/set-private-sig-hashes(^s: mbedtls-ssl-configcb<s::S>, private-sig-hashes: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-sig-hashes(private-sig-hashes))

pub inline extern mbedtls-ssl-config-ptrraw/private-sig-algs(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_sig_algs)"

pub inline fun mbedtls-ssl-configp/private-sig-algs(s: mbedtls-ssl-configp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-sig-algs

pub inline fun mbedtls-ssl-configc/private-sig-algs(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-sig-algs)

pub inline fun mbedtls-ssl-configcb/private-sig-algs(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-sig-algs)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-sig-algs(s: intptr_t, private-sig-algs: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_sig_algs = (int16_t*)#2"

pub inline fun mbedtls-ssl-configp/set-private-sig-algs(s: mbedtls-ssl-configp, private-sig-algs: c-pointer<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-sig-algs(private-sig-algs)

pub inline fun mbedtls-ssl-configc/set-private-sig-algs(^s: mbedtls-ssl-configc<s::S>, private-sig-algs: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-sig-algs(private-sig-algs))

pub inline fun mbedtls-ssl-configcb/set-private-sig-algs(^s: mbedtls-ssl-configcb<s::S>, private-sig-algs: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-sig-algs(private-sig-algs))

pub inline extern mbedtls-ssl-config-ptrraw/private-curve-list(s: intptr_t): c-pointer<mbedtls-ecp-group-id>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_curve_list)"

pub inline fun mbedtls-ssl-configp/private-curve-list(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-ecp-group-id>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-curve-list

pub inline fun mbedtls-ssl-configc/private-curve-list(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-ecp-group-id>
  s.with-ptr(mbedtls-ssl-configp/private-curve-list)

pub inline fun mbedtls-ssl-configcb/private-curve-list(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-ecp-group-id>
  s.with-ptr(mbedtls-ssl-configp/private-curve-list)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-curve-list(s: intptr_t, private-curve-list: c-pointer<mbedtls-ecp-group-id>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_curve_list = (int32_t*)#2"

pub inline fun mbedtls-ssl-configp/set-private-curve-list(s: mbedtls-ssl-configp, private-curve-list: c-pointer<mbedtls-ecp-group-id>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-curve-list(private-curve-list)

pub inline fun mbedtls-ssl-configc/set-private-curve-list(^s: mbedtls-ssl-configc<s::S>, private-curve-list: c-pointer<mbedtls-ecp-group-id>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-curve-list(private-curve-list))

pub inline fun mbedtls-ssl-configcb/set-private-curve-list(^s: mbedtls-ssl-configcb<s::S>, private-curve-list: c-pointer<mbedtls-ecp-group-id>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-curve-list(private-curve-list))

pub inline extern mbedtls-ssl-config-ptrraw/private-group-list(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_group_list)"

pub inline fun mbedtls-ssl-configp/private-group-list(s: mbedtls-ssl-configp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-group-list

pub inline fun mbedtls-ssl-configc/private-group-list(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-group-list)

pub inline fun mbedtls-ssl-configcb/private-group-list(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-group-list)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-group-list(s: intptr_t, private-group-list: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_group_list = (int16_t*)#2"

pub inline fun mbedtls-ssl-configp/set-private-group-list(s: mbedtls-ssl-configp, private-group-list: c-pointer<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-group-list(private-group-list)

pub inline fun mbedtls-ssl-configc/set-private-group-list(^s: mbedtls-ssl-configc<s::S>, private-group-list: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-group-list(private-group-list))

pub inline fun mbedtls-ssl-configcb/set-private-group-list(^s: mbedtls-ssl-configcb<s::S>, private-group-list: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-group-list(private-group-list))

pub inline extern mbedtls-ssl-config-ptrraw/private-psk(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_psk)"

pub inline fun mbedtls-ssl-configp/private-psk(s: mbedtls-ssl-configp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-psk

pub inline fun mbedtls-ssl-configc/private-psk(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-psk)

pub inline fun mbedtls-ssl-configcb/private-psk(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-psk)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-psk(s: intptr_t, private-psk: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_psk = (unsigned char*)#2"

pub inline fun mbedtls-ssl-configp/set-private-psk(s: mbedtls-ssl-configp, private-psk: c-pointer<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-psk(private-psk)

pub inline fun mbedtls-ssl-configc/set-private-psk(^s: mbedtls-ssl-configc<s::S>, private-psk: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk(private-psk))

pub inline fun mbedtls-ssl-configcb/set-private-psk(^s: mbedtls-ssl-configcb<s::S>, private-psk: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk(private-psk))

pub inline extern mbedtls-ssl-config-ptrraw/private-psk-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_config*)#1)->private_psk_len)"

pub inline fun mbedtls-ssl-configp/private-psk-len(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-psk-len.int

pub inline fun mbedtls-ssl-configc/private-psk-len(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-psk-len)

pub inline fun mbedtls-ssl-configcb/private-psk-len(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-psk-len)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-psk-len(s: intptr_t, private-psk-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_psk_len = (size_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-psk-len(s: mbedtls-ssl-configp, private-psk-len: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-psk-len(private-psk-len.ssize_t)

pub inline fun mbedtls-ssl-configc/set-private-psk-len(^s: mbedtls-ssl-configc<s::S>, private-psk-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk-len(private-psk-len))

pub inline fun mbedtls-ssl-configcb/set-private-psk-len(^s: mbedtls-ssl-configcb<s::S>, private-psk-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk-len(private-psk-len))

pub inline extern mbedtls-ssl-config-ptrraw/private-psk-identity(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_psk_identity)"

pub inline fun mbedtls-ssl-configp/private-psk-identity(s: mbedtls-ssl-configp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-psk-identity

pub inline fun mbedtls-ssl-configc/private-psk-identity(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-psk-identity)

pub inline fun mbedtls-ssl-configcb/private-psk-identity(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-configp/private-psk-identity)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-psk-identity(s: intptr_t, private-psk-identity: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_psk_identity = (unsigned char*)#2"

pub inline fun mbedtls-ssl-configp/set-private-psk-identity(s: mbedtls-ssl-configp, private-psk-identity: c-pointer<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-psk-identity(private-psk-identity)

pub inline fun mbedtls-ssl-configc/set-private-psk-identity(^s: mbedtls-ssl-configc<s::S>, private-psk-identity: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk-identity(private-psk-identity))

pub inline fun mbedtls-ssl-configcb/set-private-psk-identity(^s: mbedtls-ssl-configcb<s::S>, private-psk-identity: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk-identity(private-psk-identity))

pub inline extern mbedtls-ssl-config-ptrraw/private-psk-identity-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_config*)#1)->private_psk_identity_len)"

pub inline fun mbedtls-ssl-configp/private-psk-identity-len(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-psk-identity-len.int

pub inline fun mbedtls-ssl-configc/private-psk-identity-len(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-psk-identity-len)

pub inline fun mbedtls-ssl-configcb/private-psk-identity-len(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-psk-identity-len)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-psk-identity-len(s: intptr_t, private-psk-identity-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_psk_identity_len = (size_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-psk-identity-len(s: mbedtls-ssl-configp, private-psk-identity-len: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-psk-identity-len(private-psk-identity-len.ssize_t)

pub inline fun mbedtls-ssl-configc/set-private-psk-identity-len(^s: mbedtls-ssl-configc<s::S>, private-psk-identity-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk-identity-len(private-psk-identity-len))

pub inline fun mbedtls-ssl-configcb/set-private-psk-identity-len(^s: mbedtls-ssl-configcb<s::S>, private-psk-identity-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-psk-identity-len(private-psk-identity-len))

pub inline extern mbedtls-ssl-config-ptrraw/private-alpn-list(s: intptr_t): c-pointer<c-pointer<int>>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_alpn_list)"

pub inline fun mbedtls-ssl-configp/private-alpn-list(s: mbedtls-ssl-configp): <> c-pointer<c-pointer<int>>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-alpn-list

pub inline fun mbedtls-ssl-configc/private-alpn-list(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<c-pointer<int>>
  s.with-ptr(mbedtls-ssl-configp/private-alpn-list)

pub inline fun mbedtls-ssl-configcb/private-alpn-list(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<c-pointer<int>>
  s.with-ptr(mbedtls-ssl-configp/private-alpn-list)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-alpn-list(s: intptr_t, private-alpn-list: c-pointer<c-pointer<int>>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_alpn_list = (char**)#2"

pub inline fun mbedtls-ssl-configp/set-private-alpn-list(s: mbedtls-ssl-configp, private-alpn-list: c-pointer<c-pointer<int>>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-alpn-list(private-alpn-list)

pub inline fun mbedtls-ssl-configc/set-private-alpn-list(^s: mbedtls-ssl-configc<s::S>, private-alpn-list: c-pointer<c-pointer<int>>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-alpn-list(private-alpn-list))

pub inline fun mbedtls-ssl-configcb/set-private-alpn-list(^s: mbedtls-ssl-configcb<s::S>, private-alpn-list: c-pointer<c-pointer<int>>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-alpn-list(private-alpn-list))

pub inline extern mbedtls-ssl-config-ptrraw/private-read-timeout(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_config*)#1)->private_read_timeout)"

pub inline fun mbedtls-ssl-configp/private-read-timeout(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-read-timeout.int

pub inline fun mbedtls-ssl-configc/private-read-timeout(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-read-timeout)

pub inline fun mbedtls-ssl-configcb/private-read-timeout(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-read-timeout)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-read-timeout(s: intptr_t, private-read-timeout: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_read_timeout = (int32_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-read-timeout(s: mbedtls-ssl-configp, private-read-timeout: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-read-timeout(private-read-timeout.int32)

pub inline fun mbedtls-ssl-configc/set-private-read-timeout(^s: mbedtls-ssl-configc<s::S>, private-read-timeout: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-read-timeout(private-read-timeout))

pub inline fun mbedtls-ssl-configcb/set-private-read-timeout(^s: mbedtls-ssl-configcb<s::S>, private-read-timeout: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-read-timeout(private-read-timeout))

pub inline extern mbedtls-ssl-config-ptrraw/private-hs-timeout-min(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_config*)#1)->private_hs_timeout_min)"

pub inline fun mbedtls-ssl-configp/private-hs-timeout-min(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-hs-timeout-min.int

pub inline fun mbedtls-ssl-configc/private-hs-timeout-min(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-hs-timeout-min)

pub inline fun mbedtls-ssl-configcb/private-hs-timeout-min(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-hs-timeout-min)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-hs-timeout-min(s: intptr_t, private-hs-timeout-min: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_hs_timeout_min = (int32_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-hs-timeout-min(s: mbedtls-ssl-configp, private-hs-timeout-min: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-hs-timeout-min(private-hs-timeout-min.int32)

pub inline fun mbedtls-ssl-configc/set-private-hs-timeout-min(^s: mbedtls-ssl-configc<s::S>, private-hs-timeout-min: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-hs-timeout-min(private-hs-timeout-min))

pub inline fun mbedtls-ssl-configcb/set-private-hs-timeout-min(^s: mbedtls-ssl-configcb<s::S>, private-hs-timeout-min: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-hs-timeout-min(private-hs-timeout-min))

pub inline extern mbedtls-ssl-config-ptrraw/private-hs-timeout-max(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_config*)#1)->private_hs_timeout_max)"

pub inline fun mbedtls-ssl-configp/private-hs-timeout-max(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-hs-timeout-max.int

pub inline fun mbedtls-ssl-configc/private-hs-timeout-max(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-hs-timeout-max)

pub inline fun mbedtls-ssl-configcb/private-hs-timeout-max(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-hs-timeout-max)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-hs-timeout-max(s: intptr_t, private-hs-timeout-max: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_hs_timeout_max = (int32_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-hs-timeout-max(s: mbedtls-ssl-configp, private-hs-timeout-max: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-hs-timeout-max(private-hs-timeout-max.int32)

pub inline fun mbedtls-ssl-configc/set-private-hs-timeout-max(^s: mbedtls-ssl-configc<s::S>, private-hs-timeout-max: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-hs-timeout-max(private-hs-timeout-max))

pub inline fun mbedtls-ssl-configcb/set-private-hs-timeout-max(^s: mbedtls-ssl-configcb<s::S>, private-hs-timeout-max: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-hs-timeout-max(private-hs-timeout-max))

pub inline extern mbedtls-ssl-config-ptrraw/private-renego-max-records(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_config*)#1)->private_renego_max_records)"

pub inline fun mbedtls-ssl-configp/private-renego-max-records(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-renego-max-records.int

pub inline fun mbedtls-ssl-configc/private-renego-max-records(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-renego-max-records)

pub inline fun mbedtls-ssl-configcb/private-renego-max-records(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-renego-max-records)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-renego-max-records(s: intptr_t, private-renego-max-records: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_renego_max_records = (int)#2"

pub inline fun mbedtls-ssl-configp/set-private-renego-max-records(s: mbedtls-ssl-configp, private-renego-max-records: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-renego-max-records(private-renego-max-records.int32)

pub inline fun mbedtls-ssl-configc/set-private-renego-max-records(^s: mbedtls-ssl-configc<s::S>, private-renego-max-records: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-renego-max-records(private-renego-max-records))

pub inline fun mbedtls-ssl-configcb/set-private-renego-max-records(^s: mbedtls-ssl-configcb<s::S>, private-renego-max-records: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-renego-max-records(private-renego-max-records))

pub inline extern mbedtls-ssl-config-ptrraw/private-renego-period(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_renego_period)"

pub inline fun mbedtls-ssl-configp/private-renego-period(s: mbedtls-ssl-configp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-renego-period.cextern/ptr/carray

pub inline fun mbedtls-ssl-configc/private-renego-period(^s: mbedtls-ssl-configc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-configp/private-renego-period)

pub inline fun mbedtls-ssl-configcb/private-renego-period(^s: mbedtls-ssl-configcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-configp/private-renego-period)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-renego-period(s: intptr_t, private-renego-period: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_renego_period = (unsigned char*)#2"

pub inline fun mbedtls-ssl-configp/set-private-renego-period(s: mbedtls-ssl-configp, private-renego-period: c-array<int>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-renego-period(private-renego-period.cextern/carray/ptr)

pub inline fun mbedtls-ssl-configc/set-private-renego-period(^s: mbedtls-ssl-configc<s::S>, private-renego-period: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-renego-period(private-renego-period))

pub inline fun mbedtls-ssl-configcb/set-private-renego-period(^s: mbedtls-ssl-configcb<s::S>, private-renego-period: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-renego-period(private-renego-period))

pub inline extern mbedtls-ssl-config-ptrraw/private-badmac-limit(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_ssl_config*)#1)->private_badmac_limit)"

pub inline fun mbedtls-ssl-configp/private-badmac-limit(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-badmac-limit.int

pub inline fun mbedtls-ssl-configc/private-badmac-limit(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-badmac-limit)

pub inline fun mbedtls-ssl-configcb/private-badmac-limit(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-badmac-limit)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-badmac-limit(s: intptr_t, private-badmac-limit: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_badmac_limit = (unsigned int)#2"

pub inline fun mbedtls-ssl-configp/set-private-badmac-limit(s: mbedtls-ssl-configp, private-badmac-limit: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-badmac-limit(private-badmac-limit.int32)

pub inline fun mbedtls-ssl-configc/set-private-badmac-limit(^s: mbedtls-ssl-configc<s::S>, private-badmac-limit: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-badmac-limit(private-badmac-limit))

pub inline fun mbedtls-ssl-configcb/set-private-badmac-limit(^s: mbedtls-ssl-configcb<s::S>, private-badmac-limit: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-badmac-limit(private-badmac-limit))

pub inline extern mbedtls-ssl-config-ptrraw/private-dhm-min-bitlen(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_ssl_config*)#1)->private_dhm_min_bitlen)"

pub inline fun mbedtls-ssl-configp/private-dhm-min-bitlen(s: mbedtls-ssl-configp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-dhm-min-bitlen.int

pub inline fun mbedtls-ssl-configc/private-dhm-min-bitlen(^s: mbedtls-ssl-configc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-dhm-min-bitlen)

pub inline fun mbedtls-ssl-configcb/private-dhm-min-bitlen(^s: mbedtls-ssl-configcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-configp/private-dhm-min-bitlen)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-dhm-min-bitlen(s: intptr_t, private-dhm-min-bitlen: int32): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_dhm_min_bitlen = (unsigned int)#2"

pub inline fun mbedtls-ssl-configp/set-private-dhm-min-bitlen(s: mbedtls-ssl-configp, private-dhm-min-bitlen: int): ()
  s.mbedtls-ssl-config-ptrraw/set-private-dhm-min-bitlen(private-dhm-min-bitlen.int32)

pub inline fun mbedtls-ssl-configc/set-private-dhm-min-bitlen(^s: mbedtls-ssl-configc<s::S>, private-dhm-min-bitlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-dhm-min-bitlen(private-dhm-min-bitlen))

pub inline fun mbedtls-ssl-configcb/set-private-dhm-min-bitlen(^s: mbedtls-ssl-configcb<s::S>, private-dhm-min-bitlen: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-dhm-min-bitlen(private-dhm-min-bitlen))

pub inline extern mbedtls-ssl-config-ptrraw/private-f-cert-cb(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_f_cert_cb)"

pub inline fun mbedtls-ssl-configp/private-f-cert-cb(s: mbedtls-ssl-configp): <> mbedtls-ssl-hs-cb-t
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-f-cert-cb

pub inline fun mbedtls-ssl-configc/private-f-cert-cb(^s: mbedtls-ssl-configc<s::S>): <> mbedtls-ssl-hs-cb-t
  s.with-ptr(mbedtls-ssl-configp/private-f-cert-cb)

pub inline fun mbedtls-ssl-configcb/private-f-cert-cb(^s: mbedtls-ssl-configcb<s::S>): <> mbedtls-ssl-hs-cb-t
  s.with-ptr(mbedtls-ssl-configp/private-f-cert-cb)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-f-cert-cb(s: intptr_t, private-f-cert-cb: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_f_cert_cb = (mbedtls_ssl_hs_cb_t)#2"

pub inline fun mbedtls-ssl-configp/set-private-f-cert-cb(s: mbedtls-ssl-configp, private-f-cert-cb: mbedtls-ssl-hs-cb-t): ()
  s.mbedtls-ssl-config-ptrraw/set-private-f-cert-cb(private-f-cert-cb)

pub inline fun mbedtls-ssl-configc/set-private-f-cert-cb(^s: mbedtls-ssl-configc<s::S>, private-f-cert-cb: mbedtls-ssl-hs-cb-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-cert-cb(private-f-cert-cb))

pub inline fun mbedtls-ssl-configcb/set-private-f-cert-cb(^s: mbedtls-ssl-configcb<s::S>, private-f-cert-cb: mbedtls-ssl-hs-cb-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-f-cert-cb(private-f-cert-cb))

pub inline extern mbedtls-ssl-config-ptrraw/private-dn-hints(s: intptr_t): c-pointer<mbedtls-x509-crt-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_config*)#1)->private_dn_hints)"

pub inline fun mbedtls-ssl-configp/private-dn-hints(s: mbedtls-ssl-configp): <> c-pointer<mbedtls-x509-crt-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-config-ptrraw/private-dn-hints

pub inline fun mbedtls-ssl-configc/private-dn-hints(^s: mbedtls-ssl-configc<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-ssl-configp/private-dn-hints)

pub inline fun mbedtls-ssl-configcb/private-dn-hints(^s: mbedtls-ssl-configcb<s::S>): <> c-pointer<mbedtls-x509-crt-c>
  s.with-ptr(mbedtls-ssl-configp/private-dn-hints)

pub inline extern mbedtls-ssl-config-ptrraw/set-private-dn-hints(s: intptr_t, private-dn-hints: c-pointer<mbedtls-x509-crt-c>): ()
  c inline "((struct mbedtls_ssl_config*)#1)->private_dn_hints = (struct mbedtls_x509_crt*)#2"

pub inline fun mbedtls-ssl-configp/set-private-dn-hints(s: mbedtls-ssl-configp, private-dn-hints: c-pointer<mbedtls-x509-crt-c>): ()
  s.mbedtls-ssl-config-ptrraw/set-private-dn-hints(private-dn-hints)

pub inline fun mbedtls-ssl-configc/set-private-dn-hints(^s: mbedtls-ssl-configc<s::S>, private-dn-hints: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-dn-hints(private-dn-hints))

pub inline fun mbedtls-ssl-configcb/set-private-dn-hints(^s: mbedtls-ssl-configcb<s::S>, private-dn-hints: c-pointer<mbedtls-x509-crt-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-configp/set-private-dn-hints(private-dn-hints))

// \brief          Callback type: server-side session cache getter
// 
// The session cache is logically a key value store, with
// keys being session IDs and values being instances of
// mbedtls_ssl_session.
// 
// This callback retrieves an entry in this key-value store.
// 
// \param data            The address of the session cache structure to query.
// \param session_id      The buffer holding the session ID to query.
// \param session_id_len  The length of \p session_id in Bytes.
// \param session         The address of the session structure to populate.
// It is initialized with mbdtls_ssl_session_init(),
// and the callback must always leave it in a state
// where it can safely be freed via
// mbedtls_ssl_session_free() independent of the
// return code of this function.
// 
// \return                \c 0 on success
// \return                A non-zero return value on failure.
alias mbedtls-ssl-cache-get-t = intptr_t
// \brief          Callback type: server-side session cache setter
// 
// The session cache is logically a key value store, with
// keys being session IDs and values being instances of
// mbedtls_ssl_session.
// 
// This callback sets an entry in this key-value store.
// 
// \param data            The address of the session cache structure to modify.
// \param session_id      The buffer holding the session ID to query.
// \param session_id_len  The length of \p session_id in Bytes.
// \param session         The address of the session to be stored in the
// session cache.
// 
// \return                \c 0 on success
// \return                A non-zero return value on failure.
alias mbedtls-ssl-cache-set-t = intptr_t
pub struct mbedtls-ssl-key-cert
pub type mbedtls-ssl-key-cert-c
pub alias mbedtls-ssl-key-certp = c-pointer<mbedtls-ssl-key-cert-c>
pub alias mbedtls-ssl-key-certc = owned-c<mbedtls-ssl-key-cert-c>
pub alias mbedtls-ssl-key-certcb<s::S> = borrowed-c<s,mbedtls-ssl-key-cert-c>
pub alias mbedtls-ssl-key-certca = owned-c<c-array<mbedtls-ssl-key-cert-c>>

pub struct mbedtls-ssl-user-data-t
pub type mbedtls-ssl-user-data-t-c
pub alias mbedtls-ssl-user-data-tp = c-pointer<mbedtls-ssl-user-data-t-c>
pub alias mbedtls-ssl-user-data-tc = owned-c<mbedtls-ssl-user-data-t-c>
pub alias mbedtls-ssl-user-data-tcb<s::S> = borrowed-c<s,mbedtls-ssl-user-data-t-c>
pub alias mbedtls-ssl-user-data-tca = owned-c<c-array<mbedtls-ssl-user-data-t-c>>

// \brief           Callback type: generic handshake callback
// 
// \note            Callbacks may use user_data funcs to set/get app user data.
// See \c mbedtls_ssl_get_user_data_p()
// \c mbedtls_ssl_get_user_data_n()
// \c mbedtls_ssl_conf_get_user_data_p()
// \c mbedtls_ssl_conf_get_user_data_n()
// 
// \param ssl       \c mbedtls_ssl_context on which the callback is run
// 
// \return          The return value of the callback is 0 if successful,
// or a specific MBEDTLS_ERR_XXX code, which will cause
// the handshake to be aborted.
alias mbedtls-ssl-hs-cb-t = c-pointer<intptr_t>
alias mbedtls-ssl-hs-cb-tfn = ((ssl : c-pointer<mbedtls-ssl-context-c>) -> int)
// \brief          Callback type: send data on the network.
// 
// \note           That callback may be either blocking or non-blocking.
// 
// \param ctx      Context for the send callback (typically a file descriptor)
// \param buf      Buffer holding the data to send
// \param len      Length of the data to send
// 
// \return         The callback must return the number of bytes sent if any,
// or a non-zero error code.
// If performing non-blocking I/O, \c MBEDTLS_ERR_SSL_WANT_WRITE
// must be returned when the operation would block.
// 
// \note           The callback is allowed to send fewer bytes than requested.
// It must always return the number of bytes actually sent.
alias mbedtls-ssl-send-t = intptr_t
// \brief          Callback type: receive data from the network.
// 
// \note           That callback may be either blocking or non-blocking.
// 
// \param ctx      Context for the receive callback (typically a file
// descriptor)
// \param buf      Buffer to write the received data to
// \param len      Length of the receive buffer
// 
// \returns        If data has been received, the positive number of bytes received.
// \returns        \c 0 if the connection has been closed.
// \returns        If performing non-blocking I/O, \c MBEDTLS_ERR_SSL_WANT_READ
// must be returned when the operation would block.
// \returns        Another negative error code on other kinds of failures.
// 
// \note           The callback may receive fewer bytes than the length of the
// buffer. It must always return the number of bytes actually
// received and written to the buffer.
alias mbedtls-ssl-recv-t = intptr_t
// \brief          Callback type: receive data from the network, with timeout
// 
// \note           That callback must block until data is received, or the
// timeout delay expires, or the operation is interrupted by a
// signal.
// 
// \param ctx      Context for the receive callback (typically a file descriptor)
// \param buf      Buffer to write the received data to
// \param len      Length of the receive buffer
// \param timeout  Maximum number of milliseconds to wait for data
// 0 means no timeout (potentially waiting forever)
// 
// \return         The callback must return the number of bytes received,
// or a non-zero error code:
// \c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,
// \c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.
// 
// \note           The callback may receive fewer bytes than the length of the
// buffer. It must always return the number of bytes actually
// received and written to the buffer.
alias mbedtls-ssl-recv-timeout-t = intptr_t
pub struct mbedtls-ssl-handshake-params
pub type mbedtls-ssl-handshake-params-c
pub alias mbedtls-ssl-handshake-paramsp = c-pointer<mbedtls-ssl-handshake-params-c>
pub alias mbedtls-ssl-handshake-paramsc = owned-c<mbedtls-ssl-handshake-params-c>
pub alias mbedtls-ssl-handshake-paramscb<s::S> = borrowed-c<s,mbedtls-ssl-handshake-params-c>
pub alias mbedtls-ssl-handshake-paramsca = owned-c<c-array<mbedtls-ssl-handshake-params-c>>

pub struct mbedtls-ssl-transform
pub type mbedtls-ssl-transform-c
pub alias mbedtls-ssl-transformp = c-pointer<mbedtls-ssl-transform-c>
pub alias mbedtls-ssl-transformc = owned-c<mbedtls-ssl-transform-c>
pub alias mbedtls-ssl-transformcb<s::S> = borrowed-c<s,mbedtls-ssl-transform-c>
pub alias mbedtls-ssl-transformca = owned-c<c-array<mbedtls-ssl-transform-c>>

// \brief          Callback type: set a pair of timers/delays to watch
// 
// \param ctx      Context pointer
// \param int_ms   Intermediate delay in milliseconds
// \param fin_ms   Final delay in milliseconds
// 0 cancels the current timer.
// 
// \note           This callback must at least store the necessary information
// for the associated \c mbedtls_ssl_get_timer_t callback to
// return correct information.
// 
// \note           If using an event-driven style of programming, an event must
// be generated when the final delay is passed. The event must
// cause a call to \c mbedtls_ssl_handshake() with the proper
// SSL context to be scheduled. Care must be taken to ensure
// that at most one such call happens at a time.
// 
// \note           Only one timer at a time must be running. Calling this
// function while a timer is running must cancel it. Cancelled
// timers must not generate any event.
alias mbedtls-ssl-set-timer-t = intptr_t
// \brief          Callback type: get status of timers/delays
// 
// \param ctx      Context pointer
// 
// \return         This callback must return:
// -1 if cancelled (fin_ms == 0),
// 0 if none of the delays have passed,
// 1 if only the intermediate delay has passed,
// 2 if the final delay has passed.
alias mbedtls-ssl-get-timer-t = intptr_t
// \brief           Callback type: Export key alongside random values for
// session identification, and PRF for
// implementation of TLS key exporters.
// 
// \param p_expkey   Context for the callback.
// \param type       The type of the key that is being exported.
// \param secret     The address of the buffer holding the secret
// that's being exporterd.
// \param secret_len The length of \p secret in bytes.
// \param client_random The client random bytes.
// \param server_random The server random bytes.
// \param tls_prf_type The identifier for the PRF used in the handshake
// to which the key belongs.
alias mbedtls-ssl-export-keys-t = intptr_t
type mbedtls-ssl-key-export-type
  MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET
  MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_EARLY_SECRET
  MBEDTLS_SSL_KEY_EXPORT_TLS1_3_EARLY_EXPORTER_SECRET
  MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_HANDSHAKE_TRAFFIC_SECRET
  MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_HANDSHAKE_TRAFFIC_SECRET
  MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_APPLICATION_TRAFFIC_SECRET
  MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_APPLICATION_TRAFFIC_SECRET

pub fun mbedtls-ssl-key-export-type/int(i: mbedtls-ssl-key-export-type): int32
  match i
    MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET -> 0.int32
    MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_EARLY_SECRET -> 1.int32
    MBEDTLS_SSL_KEY_EXPORT_TLS1_3_EARLY_EXPORTER_SECRET -> 2.int32
    MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_HANDSHAKE_TRAFFIC_SECRET -> 3.int32
    MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_HANDSHAKE_TRAFFIC_SECRET -> 4.int32
    MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_APPLICATION_TRAFFIC_SECRET -> 5.int32
    MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_APPLICATION_TRAFFIC_SECRET -> 6.int32

pub fun int/mbedtls-ssl-key-export-type(i: int32): exn mbedtls-ssl-key-export-type
  match i.int
    0 -> MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET
    1 -> MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_EARLY_SECRET
    2 -> MBEDTLS_SSL_KEY_EXPORT_TLS1_3_EARLY_EXPORTER_SECRET
    3 -> MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_HANDSHAKE_TRAFFIC_SECRET
    4 -> MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_HANDSHAKE_TRAFFIC_SECRET
    5 -> MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_APPLICATION_TRAFFIC_SECRET
    6 -> MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_APPLICATION_TRAFFIC_SECRET

type mbedtls-tls-prf-types
  MBEDTLS_SSL_TLS_PRF_NONE
  MBEDTLS_SSL_TLS_PRF_SHA384
  MBEDTLS_SSL_TLS_PRF_SHA256
  MBEDTLS_SSL_HKDF_EXPAND_SHA384
  MBEDTLS_SSL_HKDF_EXPAND_SHA256

pub fun mbedtls-tls-prf-types/int(i: mbedtls-tls-prf-types): int32
  match i
    MBEDTLS_SSL_TLS_PRF_NONE -> 0.int32
    MBEDTLS_SSL_TLS_PRF_SHA384 -> 1.int32
    MBEDTLS_SSL_TLS_PRF_SHA256 -> 2.int32
    MBEDTLS_SSL_HKDF_EXPAND_SHA384 -> 3.int32
    MBEDTLS_SSL_HKDF_EXPAND_SHA256 -> 4.int32

pub fun int/mbedtls-tls-prf-types(i: int32): exn mbedtls-tls-prf-types
  match i.int
    0 -> MBEDTLS_SSL_TLS_PRF_NONE
    1 -> MBEDTLS_SSL_TLS_PRF_SHA384
    2 -> MBEDTLS_SSL_TLS_PRF_SHA256
    3 -> MBEDTLS_SSL_HKDF_EXPAND_SHA384
    4 -> MBEDTLS_SSL_HKDF_EXPAND_SHA256

pub struct mbedtls-ssl-sig-hash-set-t
pub type mbedtls-ssl-sig-hash-set-t-c
pub alias mbedtls-ssl-sig-hash-set-tp = c-pointer<mbedtls-ssl-sig-hash-set-t-c>
pub alias mbedtls-ssl-sig-hash-set-tc = owned-c<mbedtls-ssl-sig-hash-set-t-c>
pub alias mbedtls-ssl-sig-hash-set-tcb<s::S> = borrowed-c<s,mbedtls-ssl-sig-hash-set-t-c>
pub alias mbedtls-ssl-sig-hash-set-tca = owned-c<c-array<mbedtls-ssl-sig-hash-set-t-c>>

pub struct mbedtls-ssl-flight-item
pub type mbedtls-ssl-flight-item-c
pub alias mbedtls-ssl-flight-itemp = c-pointer<mbedtls-ssl-flight-item-c>
pub alias mbedtls-ssl-flight-itemc = owned-c<mbedtls-ssl-flight-item-c>
pub alias mbedtls-ssl-flight-itemcb<s::S> = borrowed-c<s,mbedtls-ssl-flight-item-c>
pub alias mbedtls-ssl-flight-itemca = owned-c<c-array<mbedtls-ssl-flight-item-c>>

// \brief           Callback type: generate and write session ticket
// 
// \note            This describes what a callback implementation should do.
// This callback should generate an encrypted and
// authenticated ticket for the session and write it to the
// output buffer. Here, ticket means the opaque ticket part
// of the NewSessionTicket structure of RFC 5077.
// 
// \param p_ticket  Context for the callback
// \param session   SSL session to be written in the ticket
// \param start     Start of the output buffer
// \param end       End of the output buffer
// \param tlen      On exit, holds the length written
// \param lifetime  On exit, holds the lifetime of the ticket in seconds
// 
// \return          0 if successful, or
// a specific MBEDTLS_ERR_XXX code.
alias mbedtls-ssl-ticket-write-t = intptr_t
// \brief           Callback type: parse and load session ticket
// 
// \note            This describes what a callback implementation should do.
// This callback should parse a session ticket as generated
// by the corresponding mbedtls_ssl_ticket_write_t function,
// and, if the ticket is authentic and valid, load the
// session.
// 
// \note            The implementation is allowed to modify the first len
// bytes of the input buffer, eg to use it as a temporary
// area for the decrypted ticket contents.
// 
// \param p_ticket  Context for the callback
// \param session   SSL session to be loaded
// \param buf       Start of the buffer containing the ticket
// \param len       Length of the ticket.
// 
// \return          0 if successful, or
// MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or
// MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or
// any other non-zero code for other failures.
alias mbedtls-ssl-ticket-parse-t = intptr_t
// \brief          Callback type: generate a cookie
// 
// \param ctx      Context for the callback
// \param p        Buffer to write to,
// must be updated to point right after the cookie
// \param end      Pointer to one past the end of the output buffer
// \param info     Client ID info that was passed to
// \c mbedtls_ssl_set_client_transport_id()
// \param ilen     Length of info in bytes
// 
// \return         The callback must return 0 on success,
// or a negative error code.
alias mbedtls-ssl-cookie-write-t = intptr_t
// \brief          Callback type: verify a cookie
// 
// \param ctx      Context for the callback
// \param cookie   Cookie to verify
// \param clen     Length of cookie
// \param info     Client ID info that was passed to
// \c mbedtls_ssl_set_client_transport_id()
// \param ilen     Length of info in bytes
// 
// \return         The callback must return 0 if cookie is valid,
// or a negative error code.
alias mbedtls-ssl-cookie-check-t = intptr_t
// Certificate Signing Request (CSR) structure.
// 
// Some fields of this structure are publicly readable. Do not modify
// them except via Mbed TLS library functions: the effect of modifying
// those fields or the data that those fields point to is unspecified.
pub struct mbedtls-x509-csr
  // < The raw CSR data (DER).
  raw: koka-mbedtls-x509-buf
  // < The raw CertificateRequestInfo body (DER).
  cri: koka-mbedtls-x509-buf
  // < CSR version (1=v1).
  version: int
  // < The raw subject data (DER).
  subject-raw: koka-mbedtls-x509-buf
  // < The parsed subject data (named information object).
  subject: koka-mbedtls-x509-name
  // < Container for the public key context.
  pk: mbedtls-pk-context-c
  // < Optional key usage extension value: See the values in x509.h
  key-usage: int
  // < Optional Netscape certificate type extension value: See the values in x509.h
  ns-cert-type: int
  // < Optional list of raw entries of Subject Alternative Names extension. These can be later parsed by mbedtls_x509_parse_subject_alt_name.
  subject-alt-names: koka-mbedtls-x509-sequence
  // < Bit string containing detected and parsed extensions
  private-ext-types: int
  sig-oid: koka-mbedtls-x509-buf
  private-sig: koka-mbedtls-x509-buf
  // < Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256
  private-sig-md: int
  // < Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA
  private-sig-pk: int
  // < Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS
  private-sig-opts: c-pointer<()>

pub type mbedtls-x509-csr-c
pub alias mbedtls-x509-csrp = c-pointer<mbedtls-x509-csr-c>
pub alias mbedtls-x509-csrc = owned-c<mbedtls-x509-csr-c>
pub alias mbedtls-x509-csrcb<s::S> = borrowed-c<s,mbedtls-x509-csr-c>
pub alias mbedtls-x509-csrca = owned-c<c-array<mbedtls-x509-csr-c>>

pub extern mbedtls-x509-csr/size-of(c: c-null<mbedtls-x509-csr-c>): int32
  c inline "sizeof(struct mbedtls_x509_csr)"

pub fun mbedtls-x509-csrc(): mbedtls-x509-csrc
  malloc(?size-of=mbedtls-x509-csr/size-of)

pub fun mbedtls-x509-csrc-calloc(): mbedtls-x509-csrc
  malloc-c(?size-of=mbedtls-x509-csr/size-of)

pub fun mbedtls-x509-csrc-array(n: int): mbedtls-x509-csrca
  malloc(n.int32, ?size-of=mbedtls-x509-csr/size-of)

pub fun mbedtls-x509-csrc-array-calloc(n: int): mbedtls-x509-csrca
  malloc-c(n.int32, ?size-of=mbedtls-x509-csr/size-of)

pub inline extern mbedtls-x509-csr-ptrraw/version(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_csr*)#1)->version)"

pub inline fun mbedtls-x509-csrp/version(s: mbedtls-x509-csrp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/version.int

pub inline fun mbedtls-x509-csrc/version(^s: mbedtls-x509-csrc): <> int
  s.with-ptr(mbedtls-x509-csrp/version)

pub inline fun mbedtls-x509-csrcb/version(^s: mbedtls-x509-csrcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-csrp/version)

pub inline extern mbedtls-x509-csr-ptrraw/set-version(s: intptr_t, version: int32): ()
  c inline "((struct mbedtls_x509_csr*)#1)->version = (int)#2"

pub inline fun mbedtls-x509-csrp/set-version(s: mbedtls-x509-csrp, version: int): ()
  s.mbedtls-x509-csr-ptrraw/set-version(version.int32)

pub inline fun mbedtls-x509-csrc/set-version(^s: mbedtls-x509-csrc, version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-version(version))

pub inline fun mbedtls-x509-csrcb/set-version(^s: mbedtls-x509-csrcb<s::S>, version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-version(version))

pub inline extern mbedtls-x509-csr-ptrraw/key-usage(s: intptr_t): int32
  c inline "(unsigned int)(((struct mbedtls_x509_csr*)#1)->key_usage)"

pub inline fun mbedtls-x509-csrp/key-usage(s: mbedtls-x509-csrp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/key-usage.int

pub inline fun mbedtls-x509-csrc/key-usage(^s: mbedtls-x509-csrc): <> int
  s.with-ptr(mbedtls-x509-csrp/key-usage)

pub inline fun mbedtls-x509-csrcb/key-usage(^s: mbedtls-x509-csrcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-csrp/key-usage)

pub inline extern mbedtls-x509-csr-ptrraw/set-key-usage(s: intptr_t, key-usage: int32): ()
  c inline "((struct mbedtls_x509_csr*)#1)->key_usage = (unsigned int)#2"

pub inline fun mbedtls-x509-csrp/set-key-usage(s: mbedtls-x509-csrp, key-usage: int): ()
  s.mbedtls-x509-csr-ptrraw/set-key-usage(key-usage.int32)

pub inline fun mbedtls-x509-csrc/set-key-usage(^s: mbedtls-x509-csrc, key-usage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-key-usage(key-usage))

pub inline fun mbedtls-x509-csrcb/set-key-usage(^s: mbedtls-x509-csrcb<s::S>, key-usage: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-key-usage(key-usage))

pub inline extern mbedtls-x509-csr-ptrraw/ns-cert-type(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_x509_csr*)#1)->ns_cert_type)"

pub inline fun mbedtls-x509-csrp/ns-cert-type(s: mbedtls-x509-csrp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/ns-cert-type.int

pub inline fun mbedtls-x509-csrc/ns-cert-type(^s: mbedtls-x509-csrc): <> int
  s.with-ptr(mbedtls-x509-csrp/ns-cert-type)

pub inline fun mbedtls-x509-csrcb/ns-cert-type(^s: mbedtls-x509-csrcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-csrp/ns-cert-type)

pub inline extern mbedtls-x509-csr-ptrraw/set-ns-cert-type(s: intptr_t, ns-cert-type: int8): ()
  c inline "((struct mbedtls_x509_csr*)#1)->ns_cert_type = (unsigned char)#2"

pub inline fun mbedtls-x509-csrp/set-ns-cert-type(s: mbedtls-x509-csrp, ns-cert-type: int): ()
  s.mbedtls-x509-csr-ptrraw/set-ns-cert-type(ns-cert-type.int8)

pub inline fun mbedtls-x509-csrc/set-ns-cert-type(^s: mbedtls-x509-csrc, ns-cert-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-ns-cert-type(ns-cert-type))

pub inline fun mbedtls-x509-csrcb/set-ns-cert-type(^s: mbedtls-x509-csrcb<s::S>, ns-cert-type: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-ns-cert-type(ns-cert-type))

pub inline extern mbedtls-x509-csr-ptrraw/private-ext-types(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_x509_csr*)#1)->private_ext_types)"

pub inline fun mbedtls-x509-csrp/private-ext-types(s: mbedtls-x509-csrp): <> int
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/private-ext-types.int

pub inline fun mbedtls-x509-csrc/private-ext-types(^s: mbedtls-x509-csrc): <> int
  s.with-ptr(mbedtls-x509-csrp/private-ext-types)

pub inline fun mbedtls-x509-csrcb/private-ext-types(^s: mbedtls-x509-csrcb<s::S>): <> int
  s.with-ptr(mbedtls-x509-csrp/private-ext-types)

pub inline extern mbedtls-x509-csr-ptrraw/set-private-ext-types(s: intptr_t, private-ext-types: int32): ()
  c inline "((struct mbedtls_x509_csr*)#1)->private_ext_types = (int)#2"

pub inline fun mbedtls-x509-csrp/set-private-ext-types(s: mbedtls-x509-csrp, private-ext-types: int): ()
  s.mbedtls-x509-csr-ptrraw/set-private-ext-types(private-ext-types.int32)

pub inline fun mbedtls-x509-csrc/set-private-ext-types(^s: mbedtls-x509-csrc, private-ext-types: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-ext-types(private-ext-types))

pub inline fun mbedtls-x509-csrcb/set-private-ext-types(^s: mbedtls-x509-csrcb<s::S>, private-ext-types: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-ext-types(private-ext-types))

pub inline extern mbedtls-x509-csr-ptrraw/private-sig-md(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_csr*)#1)->private_sig_md)"

pub inline fun mbedtls-x509-csrp/private-sig-md(s: mbedtls-x509-csrp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/private-sig-md.int/mbedtls-md-type-t

pub inline fun mbedtls-x509-csrc/private-sig-md(^s: mbedtls-x509-csrc): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509-csrp/private-sig-md)

pub inline fun mbedtls-x509-csrcb/private-sig-md(^s: mbedtls-x509-csrcb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509-csrp/private-sig-md)

pub inline extern mbedtls-x509-csr-ptrraw/set-private-sig-md(s: intptr_t, private-sig-md: int32): ()
  c inline "((struct mbedtls_x509_csr*)#1)->private_sig_md = (int32_t)#2"

pub inline fun mbedtls-x509-csrp/set-private-sig-md(s: mbedtls-x509-csrp, private-sig-md: mbedtls-md-type-t): ()
  s.mbedtls-x509-csr-ptrraw/set-private-sig-md(private-sig-md.mbedtls-md-type-t/int)

pub inline fun mbedtls-x509-csrc/set-private-sig-md(^s: mbedtls-x509-csrc, private-sig-md: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-sig-md(private-sig-md))

pub inline fun mbedtls-x509-csrcb/set-private-sig-md(^s: mbedtls-x509-csrcb<s::S>, private-sig-md: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-sig-md(private-sig-md))

pub inline extern mbedtls-x509-csr-ptrraw/private-sig-pk(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509_csr*)#1)->private_sig_pk)"

pub inline fun mbedtls-x509-csrp/private-sig-pk(s: mbedtls-x509-csrp): <exn> mbedtls-pk-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/private-sig-pk.int/mbedtls-pk-type-t

pub inline fun mbedtls-x509-csrc/private-sig-pk(^s: mbedtls-x509-csrc): <exn> mbedtls-pk-type-t
  s.with-ptr(mbedtls-x509-csrp/private-sig-pk)

pub inline fun mbedtls-x509-csrcb/private-sig-pk(^s: mbedtls-x509-csrcb<s::S>): <exn> mbedtls-pk-type-t
  s.with-ptr(mbedtls-x509-csrp/private-sig-pk)

pub inline extern mbedtls-x509-csr-ptrraw/set-private-sig-pk(s: intptr_t, private-sig-pk: int32): ()
  c inline "((struct mbedtls_x509_csr*)#1)->private_sig_pk = (int32_t)#2"

pub inline fun mbedtls-x509-csrp/set-private-sig-pk(s: mbedtls-x509-csrp, private-sig-pk: mbedtls-pk-type-t): ()
  s.mbedtls-x509-csr-ptrraw/set-private-sig-pk(private-sig-pk.mbedtls-pk-type-t/int)

pub inline fun mbedtls-x509-csrc/set-private-sig-pk(^s: mbedtls-x509-csrc, private-sig-pk: mbedtls-pk-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-sig-pk(private-sig-pk))

pub inline fun mbedtls-x509-csrcb/set-private-sig-pk(^s: mbedtls-x509-csrcb<s::S>, private-sig-pk: mbedtls-pk-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-sig-pk(private-sig-pk))

pub inline extern mbedtls-x509-csr-ptrraw/private-sig-opts(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_x509_csr*)#1)->private_sig_opts)"

pub inline fun mbedtls-x509-csrp/private-sig-opts(s: mbedtls-x509-csrp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-x509-csr-ptrraw/private-sig-opts

pub inline fun mbedtls-x509-csrc/private-sig-opts(^s: mbedtls-x509-csrc): <> c-pointer<()>
  s.with-ptr(mbedtls-x509-csrp/private-sig-opts)

pub inline fun mbedtls-x509-csrcb/private-sig-opts(^s: mbedtls-x509-csrcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-x509-csrp/private-sig-opts)

pub inline extern mbedtls-x509-csr-ptrraw/set-private-sig-opts(s: intptr_t, private-sig-opts: c-pointer<()>): ()
  c inline "((struct mbedtls_x509_csr*)#1)->private_sig_opts = (void*)#2"

pub inline fun mbedtls-x509-csrp/set-private-sig-opts(s: mbedtls-x509-csrp, private-sig-opts: c-pointer<()>): ()
  s.mbedtls-x509-csr-ptrraw/set-private-sig-opts(private-sig-opts)

pub inline fun mbedtls-x509-csrc/set-private-sig-opts(^s: mbedtls-x509-csrc, private-sig-opts: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-sig-opts(private-sig-opts))

pub inline fun mbedtls-x509-csrcb/set-private-sig-opts(^s: mbedtls-x509-csrcb<s::S>, private-sig-opts: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509-csrp/set-private-sig-opts(private-sig-opts))

// Container for writing a CSR
pub struct mbedtls-x509write-csr
  private-key: mbedtls-pk-context-c
  private-subject: mbedtls-asn1-named-data-c
  private-md-alg: int
  private-extensions: mbedtls-asn1-named-data-c

pub type mbedtls-x509write-csr-c
pub alias mbedtls-x509write-csrp = c-pointer<mbedtls-x509write-csr-c>
pub alias mbedtls-x509write-csrc = owned-c<mbedtls-x509write-csr-c>
pub alias mbedtls-x509write-csrcb<s::S> = borrowed-c<s,mbedtls-x509write-csr-c>
pub alias mbedtls-x509write-csrca = owned-c<c-array<mbedtls-x509write-csr-c>>

pub extern mbedtls-x509write-csr/size-of(c: c-null<mbedtls-x509write-csr-c>): int32
  c inline "sizeof(struct mbedtls_x509write_csr)"

pub fun mbedtls-x509write-csrc(): mbedtls-x509write-csrc
  malloc(?size-of=mbedtls-x509write-csr/size-of)

pub fun mbedtls-x509write-csrc-calloc(): mbedtls-x509write-csrc
  malloc-c(?size-of=mbedtls-x509write-csr/size-of)

pub fun mbedtls-x509write-csrc-array(n: int): mbedtls-x509write-csrca
  malloc(n.int32, ?size-of=mbedtls-x509write-csr/size-of)

pub fun mbedtls-x509write-csrc-array-calloc(n: int): mbedtls-x509write-csrca
  malloc-c(n.int32, ?size-of=mbedtls-x509write-csr/size-of)

pub inline extern mbedtls-x509write-csr-ptrraw/private-key(s: intptr_t): c-pointer<mbedtls-pk-context-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_csr*)#1)->private_key)"

pub inline fun mbedtls-x509write-csrp/private-key(s: mbedtls-x509write-csrp): <> c-pointer<mbedtls-pk-context-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-csr-ptrraw/private-key

pub inline fun mbedtls-x509write-csrc/private-key(^s: mbedtls-x509write-csrc): <> c-pointer<mbedtls-pk-context-c>
  s.with-ptr(mbedtls-x509write-csrp/private-key)

pub inline fun mbedtls-x509write-csrcb/private-key(^s: mbedtls-x509write-csrcb<s::S>): <> c-pointer<mbedtls-pk-context-c>
  s.with-ptr(mbedtls-x509write-csrp/private-key)

pub inline extern mbedtls-x509write-csr-ptrraw/set-private-key(s: intptr_t, private-key: c-pointer<mbedtls-pk-context-c>): ()
  c inline "((struct mbedtls_x509write_csr*)#1)->private_key = (struct mbedtls_pk_context*)#2"

pub inline fun mbedtls-x509write-csrp/set-private-key(s: mbedtls-x509write-csrp, private-key: c-pointer<mbedtls-pk-context-c>): ()
  s.mbedtls-x509write-csr-ptrraw/set-private-key(private-key)

pub inline fun mbedtls-x509write-csrc/set-private-key(^s: mbedtls-x509write-csrc, private-key: c-pointer<mbedtls-pk-context-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-key(private-key))

pub inline fun mbedtls-x509write-csrcb/set-private-key(^s: mbedtls-x509write-csrcb<s::S>, private-key: c-pointer<mbedtls-pk-context-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-key(private-key))

pub inline extern mbedtls-x509write-csr-ptrraw/private-subject(s: intptr_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_csr*)#1)->private_subject)"

pub inline fun mbedtls-x509write-csrp/private-subject(s: mbedtls-x509write-csrp): <> c-pointer<mbedtls-asn1-named-data-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-csr-ptrraw/private-subject

pub inline fun mbedtls-x509write-csrc/private-subject(^s: mbedtls-x509write-csrc): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-csrp/private-subject)

pub inline fun mbedtls-x509write-csrcb/private-subject(^s: mbedtls-x509write-csrcb<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-csrp/private-subject)

pub inline extern mbedtls-x509write-csr-ptrraw/set-private-subject(s: intptr_t, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "((struct mbedtls_x509write_csr*)#1)->private_subject = (struct mbedtls_asn1_named_data*)#2"

pub inline fun mbedtls-x509write-csrp/set-private-subject(s: mbedtls-x509write-csrp, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.mbedtls-x509write-csr-ptrraw/set-private-subject(private-subject)

pub inline fun mbedtls-x509write-csrc/set-private-subject(^s: mbedtls-x509write-csrc, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-subject(private-subject))

pub inline fun mbedtls-x509write-csrcb/set-private-subject(^s: mbedtls-x509write-csrcb<s::S>, private-subject: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-subject(private-subject))

pub inline extern mbedtls-x509write-csr-ptrraw/private-md-alg(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_x509write_csr*)#1)->private_md_alg)"

pub inline fun mbedtls-x509write-csrp/private-md-alg(s: mbedtls-x509write-csrp): <exn> mbedtls-md-type-t
  s.cextern/c-pointer/ptr.mbedtls-x509write-csr-ptrraw/private-md-alg.int/mbedtls-md-type-t

pub inline fun mbedtls-x509write-csrc/private-md-alg(^s: mbedtls-x509write-csrc): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509write-csrp/private-md-alg)

pub inline fun mbedtls-x509write-csrcb/private-md-alg(^s: mbedtls-x509write-csrcb<s::S>): <exn> mbedtls-md-type-t
  s.with-ptr(mbedtls-x509write-csrp/private-md-alg)

pub inline extern mbedtls-x509write-csr-ptrraw/set-private-md-alg(s: intptr_t, private-md-alg: int32): ()
  c inline "((struct mbedtls_x509write_csr*)#1)->private_md_alg = (int32_t)#2"

pub inline fun mbedtls-x509write-csrp/set-private-md-alg(s: mbedtls-x509write-csrp, private-md-alg: mbedtls-md-type-t): ()
  s.mbedtls-x509write-csr-ptrraw/set-private-md-alg(private-md-alg.mbedtls-md-type-t/int)

pub inline fun mbedtls-x509write-csrc/set-private-md-alg(^s: mbedtls-x509write-csrc, private-md-alg: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-md-alg(private-md-alg))

pub inline fun mbedtls-x509write-csrcb/set-private-md-alg(^s: mbedtls-x509write-csrcb<s::S>, private-md-alg: mbedtls-md-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-md-alg(private-md-alg))

pub inline extern mbedtls-x509write-csr-ptrraw/private-extensions(s: intptr_t): c-pointer<mbedtls-asn1-named-data-c>
  c inline "(intptr_t)(((struct mbedtls_x509write_csr*)#1)->private_extensions)"

pub inline fun mbedtls-x509write-csrp/private-extensions(s: mbedtls-x509write-csrp): <> c-pointer<mbedtls-asn1-named-data-c>
  s.cextern/c-pointer/ptr.mbedtls-x509write-csr-ptrraw/private-extensions

pub inline fun mbedtls-x509write-csrc/private-extensions(^s: mbedtls-x509write-csrc): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-csrp/private-extensions)

pub inline fun mbedtls-x509write-csrcb/private-extensions(^s: mbedtls-x509write-csrcb<s::S>): <> c-pointer<mbedtls-asn1-named-data-c>
  s.with-ptr(mbedtls-x509write-csrp/private-extensions)

pub inline extern mbedtls-x509write-csr-ptrraw/set-private-extensions(s: intptr_t, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  c inline "((struct mbedtls_x509write_csr*)#1)->private_extensions = (struct mbedtls_asn1_named_data*)#2"

pub inline fun mbedtls-x509write-csrp/set-private-extensions(s: mbedtls-x509write-csrp, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.mbedtls-x509write-csr-ptrraw/set-private-extensions(private-extensions)

pub inline fun mbedtls-x509write-csrc/set-private-extensions(^s: mbedtls-x509write-csrc, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-extensions(private-extensions))

pub inline fun mbedtls-x509write-csrcb/set-private-extensions(^s: mbedtls-x509write-csrcb<s::S>, private-extensions: c-pointer<mbedtls-asn1-named-data-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-x509write-csrp/set-private-extensions(private-extensions))

// \brief          The type of certificate extension callbacks.
// 
// Callbacks of this type are passed to and used by the
// mbedtls_x509_csr_parse_der_with_ext_cb() routine when
// it encounters either an unsupported extension.
// Future versions of the library may invoke the callback
// in other cases, if and when the need arises.
// 
// \param p_ctx    An opaque context passed to the callback.
// \param csr      The CSR being parsed.
// \param oid      The OID of the extension.
// \param critical Whether the extension is critical.
// \param p        Pointer to the start of the extension value
// (the content of the OCTET STRING).
// \param end      End of extension value.
// 
// \note           The callback must fail and return a negative error code
// if it can not parse or does not support the extension.
// When the callback fails to parse a critical extension
// mbedtls_x509_csr_parse_der_with_ext_cb() also fails.
// When the callback fails to parse a non critical extension
// mbedtls_x509_csr_parse_der_with_ext_cb() simply skips
// the extension and continues parsing.
// 
// \return         \c 0 on success.
// \return         A negative error code on failure.
alias mbedtls-x509-csr-ext-cb-t = c-pointer<intptr_t>
alias mbedtls-x509-csr-ext-cb-tfn = ((p_ctx : c-pointer<()>, csr : c-pointer<mbedtls-x509-csr-c>, oid : c-pointer<mbedtls-asn1-buf-c>, critical : int, p : c-pointer<int>, end : c-pointer<int>) -> int)
// \brief          timer structure
pub struct mbedtls-timing-hr-time
pub type mbedtls-timing-hr-time-c
pub alias mbedtls-timing-hr-timep = c-pointer<mbedtls-timing-hr-time-c>
pub alias mbedtls-timing-hr-timec<s::S> = owned-c<mbedtls-timing-hr-time-c>
pub alias mbedtls-timing-hr-timecb<s::S> = borrowed-c<s,mbedtls-timing-hr-time-c>
pub alias mbedtls-timing-hr-timeca<s::S> = owned-c<c-array<mbedtls-timing-hr-time-c>>

pub extern mbedtls-timing-hr-time/size-of(c: c-null<mbedtls-timing-hr-time-c>): int32
  c inline "sizeof(struct mbedtls_timing_hr_time)"

pub fun mbedtls-timing-hr-timec(): mbedtls-timing-hr-timec<s::S>
  malloc(?size-of=mbedtls-timing-hr-time/size-of)

pub fun mbedtls-timing-hr-timec-calloc(): mbedtls-timing-hr-timec<s::S>
  malloc-c(?size-of=mbedtls-timing-hr-time/size-of)

pub fun mbedtls-timing-hr-timec-array(n: int): mbedtls-timing-hr-timeca<s::S>
  malloc(n.int32, ?size-of=mbedtls-timing-hr-time/size-of)

pub fun mbedtls-timing-hr-timec-array-calloc(n: int): mbedtls-timing-hr-timeca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-timing-hr-time/size-of)

pub inline extern mbedtls-timing-hr-time-ptrraw/private-opaque(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_timing_hr_time*)#1)->private_opaque)"

pub inline fun mbedtls-timing-hr-timep/private-opaque(s: mbedtls-timing-hr-timep): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-timing-hr-time-ptrraw/private-opaque.cextern/ptr/carray

pub inline fun mbedtls-timing-hr-timec/private-opaque(^s: mbedtls-timing-hr-timec<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-timing-hr-timep/private-opaque)

pub inline fun mbedtls-timing-hr-timecb/private-opaque(^s: mbedtls-timing-hr-timecb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-timing-hr-timep/private-opaque)

pub inline extern mbedtls-timing-hr-time-ptrraw/set-private-opaque(s: intptr_t, private-opaque: c-pointer<int>): ()
  c inline "((struct mbedtls_timing_hr_time*)#1)->private_opaque = (int64_t*)#2"

pub inline fun mbedtls-timing-hr-timep/set-private-opaque(s: mbedtls-timing-hr-timep, private-opaque: c-array<int>): ()
  s.mbedtls-timing-hr-time-ptrraw/set-private-opaque(private-opaque.cextern/carray/ptr)

pub inline fun mbedtls-timing-hr-timec/set-private-opaque(^s: mbedtls-timing-hr-timec<s::S>, private-opaque: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-timing-hr-timep/set-private-opaque(private-opaque))

pub inline fun mbedtls-timing-hr-timecb/set-private-opaque(^s: mbedtls-timing-hr-timecb<s::S>, private-opaque: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-timing-hr-timep/set-private-opaque(private-opaque))

// \brief          Context for mbedtls_timing_set/get_delay()
pub value struct mbedtls-timing-delay-context
  private-timer: mbedtls-timing-hr-time-c
  private-int-ms: int
  private-fin-ms: int

pub type mbedtls-timing-delay-context-c
pub alias mbedtls-timing-delay-contextp = c-pointer<mbedtls-timing-delay-context-c>
pub alias mbedtls-timing-delay-contextc = owned-c<mbedtls-timing-delay-context-c>
pub alias mbedtls-timing-delay-contextcb<s::S> = borrowed-c<s,mbedtls-timing-delay-context-c>
pub alias mbedtls-timing-delay-contextca = owned-c<c-array<mbedtls-timing-delay-context-c>>

pub extern mbedtls-timing-delay-context/size-of(c: c-null<mbedtls-timing-delay-context-c>): int32
  c inline "sizeof(struct mbedtls_timing_delay_context)"

pub fun mbedtls-timing-delay-contextc(): mbedtls-timing-delay-contextc
  malloc(?size-of=mbedtls-timing-delay-context/size-of)

pub fun mbedtls-timing-delay-contextc-calloc(): mbedtls-timing-delay-contextc
  malloc-c(?size-of=mbedtls-timing-delay-context/size-of)

pub fun mbedtls-timing-delay-contextc-array(n: int): mbedtls-timing-delay-contextca
  malloc(n.int32, ?size-of=mbedtls-timing-delay-context/size-of)

pub fun mbedtls-timing-delay-contextc-array-calloc(n: int): mbedtls-timing-delay-contextca
  malloc-c(n.int32, ?size-of=mbedtls-timing-delay-context/size-of)

pub inline extern mbedtls-timing-delay-context-ptrraw/private-int-ms(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_timing_delay_context*)#1)->private_int_ms)"

pub inline fun mbedtls-timing-delay-contextp/private-int-ms(s: mbedtls-timing-delay-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-timing-delay-context-ptrraw/private-int-ms.int

pub inline fun mbedtls-timing-delay-contextc/private-int-ms(^s: mbedtls-timing-delay-contextc): <> int
  s.with-ptr(mbedtls-timing-delay-contextp/private-int-ms)

pub inline fun mbedtls-timing-delay-contextcb/private-int-ms(^s: mbedtls-timing-delay-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-timing-delay-contextp/private-int-ms)

pub inline extern mbedtls-timing-delay-context-ptrraw/set-private-int-ms(s: intptr_t, private-int-ms: int32): ()
  c inline "((struct mbedtls_timing_delay_context*)#1)->private_int_ms = (int32_t)#2"

pub inline fun mbedtls-timing-delay-contextp/set-private-int-ms(s: mbedtls-timing-delay-contextp, private-int-ms: int): ()
  s.mbedtls-timing-delay-context-ptrraw/set-private-int-ms(private-int-ms.int32)

pub inline fun mbedtls-timing-delay-contextc/set-private-int-ms(^s: mbedtls-timing-delay-contextc, private-int-ms: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-timing-delay-contextp/set-private-int-ms(private-int-ms))

pub inline fun mbedtls-timing-delay-contextcb/set-private-int-ms(^s: mbedtls-timing-delay-contextcb<s::S>, private-int-ms: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-timing-delay-contextp/set-private-int-ms(private-int-ms))

pub inline extern mbedtls-timing-delay-context-ptrraw/private-fin-ms(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_timing_delay_context*)#1)->private_fin_ms)"

pub inline fun mbedtls-timing-delay-contextp/private-fin-ms(s: mbedtls-timing-delay-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-timing-delay-context-ptrraw/private-fin-ms.int

pub inline fun mbedtls-timing-delay-contextc/private-fin-ms(^s: mbedtls-timing-delay-contextc): <> int
  s.with-ptr(mbedtls-timing-delay-contextp/private-fin-ms)

pub inline fun mbedtls-timing-delay-contextcb/private-fin-ms(^s: mbedtls-timing-delay-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-timing-delay-contextp/private-fin-ms)

pub inline extern mbedtls-timing-delay-context-ptrraw/set-private-fin-ms(s: intptr_t, private-fin-ms: int32): ()
  c inline "((struct mbedtls_timing_delay_context*)#1)->private_fin_ms = (int32_t)#2"

pub inline fun mbedtls-timing-delay-contextp/set-private-fin-ms(s: mbedtls-timing-delay-contextp, private-fin-ms: int): ()
  s.mbedtls-timing-delay-context-ptrraw/set-private-fin-ms(private-fin-ms.int32)

pub inline fun mbedtls-timing-delay-contextc/set-private-fin-ms(^s: mbedtls-timing-delay-contextc, private-fin-ms: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-timing-delay-contextp/set-private-fin-ms(private-fin-ms))

pub inline fun mbedtls-timing-delay-contextcb/set-private-fin-ms(^s: mbedtls-timing-delay-contextcb<s::S>, private-fin-ms: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-timing-delay-contextp/set-private-fin-ms(private-fin-ms))

type mbedtls-nist-kw-mode-t
  MBEDTLS_KW_MODE_KW
  MBEDTLS_KW_MODE_KWP

pub fun mbedtls-nist-kw-mode-t/int(i: mbedtls-nist-kw-mode-t): int32
  match i
    MBEDTLS_KW_MODE_KW -> 0.int32
    MBEDTLS_KW_MODE_KWP -> 1.int32

pub fun int/mbedtls-nist-kw-mode-t(i: int32): exn mbedtls-nist-kw-mode-t
  match i.int
    0 -> MBEDTLS_KW_MODE_KW
    1 -> MBEDTLS_KW_MODE_KWP

// \brief    The key wrapping context-type definition. The key wrapping context is passed
// to the APIs called.
// 
// \note     The definition of this type may change in future library versions.
// Don't make any assumptions on this context!
pub value struct mbedtls-nist-kw-context
  // !< The cipher context used.
  private-cipher-ctx: mbedtls-cipher-context-t-c

pub type mbedtls-nist-kw-context-c
pub alias mbedtls-nist-kw-contextp = c-pointer<mbedtls-nist-kw-context-c>
pub alias mbedtls-nist-kw-contextc = owned-c<mbedtls-nist-kw-context-c>
pub alias mbedtls-nist-kw-contextcb<s::S> = borrowed-c<s,mbedtls-nist-kw-context-c>
pub alias mbedtls-nist-kw-contextca = owned-c<c-array<mbedtls-nist-kw-context-c>>

pub extern mbedtls-nist-kw-context/size-of(c: c-null<mbedtls-nist-kw-context-c>): int32
  c inline "sizeof(mbedtls_nist_kw_context)"

pub fun mbedtls-nist-kw-contextc(): mbedtls-nist-kw-contextc
  malloc(?size-of=mbedtls-nist-kw-context/size-of)

pub fun mbedtls-nist-kw-contextc-calloc(): mbedtls-nist-kw-contextc
  malloc-c(?size-of=mbedtls-nist-kw-context/size-of)

pub fun mbedtls-nist-kw-contextc-array(n: int): mbedtls-nist-kw-contextca
  malloc(n.int32, ?size-of=mbedtls-nist-kw-context/size-of)

pub fun mbedtls-nist-kw-contextc-array-calloc(n: int): mbedtls-nist-kw-contextca
  malloc-c(n.int32, ?size-of=mbedtls-nist-kw-context/size-of)

// Wrapper type for sockets.
// 
// Currently backed by just a file descriptor, but might be more in the future
// (eg two file descriptors for combined IPv4 + IPv6 support, or additional
// structures for hand-made UDP demultiplexing).
pub value struct mbedtls-net-context
  // The underlying file descriptor.
  // 
  // This field is only guaranteed to be present on POSIX/Unix-like platforms.
  // On other platforms, it may have a different type, have a different
  // meaning, or be absent altogether.
  fd: int

pub type mbedtls-net-context-c
pub alias mbedtls-net-contextp = c-pointer<mbedtls-net-context-c>
pub alias mbedtls-net-contextc = owned-c<mbedtls-net-context-c>
pub alias mbedtls-net-contextcb<s::S> = borrowed-c<s,mbedtls-net-context-c>
pub alias mbedtls-net-contextca = owned-c<c-array<mbedtls-net-context-c>>

pub extern mbedtls-net-context/size-of(c: c-null<mbedtls-net-context-c>): int32
  c inline "sizeof(struct mbedtls_net_context)"

pub fun mbedtls-net-contextc(): mbedtls-net-contextc
  malloc(?size-of=mbedtls-net-context/size-of)

pub fun mbedtls-net-contextc-calloc(): mbedtls-net-contextc
  malloc-c(?size-of=mbedtls-net-context/size-of)

pub fun mbedtls-net-contextc-array(n: int): mbedtls-net-contextca
  malloc(n.int32, ?size-of=mbedtls-net-context/size-of)

pub fun mbedtls-net-contextc-array-calloc(n: int): mbedtls-net-contextca
  malloc-c(n.int32, ?size-of=mbedtls-net-context/size-of)

pub inline extern mbedtls-net-context-ptrraw/fd(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_net_context*)#1)->fd)"

pub inline fun mbedtls-net-contextp/fd(s: mbedtls-net-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-net-context-ptrraw/fd.int

pub inline fun mbedtls-net-contextc/fd(^s: mbedtls-net-contextc): <> int
  s.with-ptr(mbedtls-net-contextp/fd)

pub inline fun mbedtls-net-contextcb/fd(^s: mbedtls-net-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-net-contextp/fd)

pub inline extern mbedtls-net-context-ptrraw/set-fd(s: intptr_t, fd: int32): ()
  c inline "((struct mbedtls_net_context*)#1)->fd = (int)#2"

pub inline fun mbedtls-net-contextp/set-fd(s: mbedtls-net-contextp, fd: int): ()
  s.mbedtls-net-context-ptrraw/set-fd(fd.int32)

pub inline fun mbedtls-net-contextc/set-fd(^s: mbedtls-net-contextc, fd: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-net-contextp/set-fd(fd))

pub inline fun mbedtls-net-contextcb/set-fd(^s: mbedtls-net-contextcb<s::S>, fd: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-net-contextp/set-fd(fd))

// \brief           Entropy source state
pub struct mbedtls-entropy-source-state
  // < The entropy source callback
  private-f-source: mbedtls-entropy-f-source-ptr
  // < The callback data pointer
  private-p-source: c-pointer<()>
  // < Amount received in bytes
  private-size: int
  // < Minimum bytes required before release
  private-threshold: int
  // < Is the source strong?
  private-strong: int

pub type mbedtls-entropy-source-state-c
pub alias mbedtls-entropy-source-statep = c-pointer<mbedtls-entropy-source-state-c>
pub alias mbedtls-entropy-source-statec = owned-c<mbedtls-entropy-source-state-c>
pub alias mbedtls-entropy-source-statecb<s::S> = borrowed-c<s,mbedtls-entropy-source-state-c>
pub alias mbedtls-entropy-source-stateca = owned-c<c-array<mbedtls-entropy-source-state-c>>

pub extern mbedtls-entropy-source-state/size-of(c: c-null<mbedtls-entropy-source-state-c>): int32
  c inline "sizeof(struct mbedtls_entropy_source_state)"

pub fun mbedtls-entropy-source-statec(): mbedtls-entropy-source-statec
  malloc(?size-of=mbedtls-entropy-source-state/size-of)

pub fun mbedtls-entropy-source-statec-calloc(): mbedtls-entropy-source-statec
  malloc-c(?size-of=mbedtls-entropy-source-state/size-of)

pub fun mbedtls-entropy-source-statec-array(n: int): mbedtls-entropy-source-stateca
  malloc(n.int32, ?size-of=mbedtls-entropy-source-state/size-of)

pub fun mbedtls-entropy-source-statec-array-calloc(n: int): mbedtls-entropy-source-stateca
  malloc-c(n.int32, ?size-of=mbedtls-entropy-source-state/size-of)

pub inline extern mbedtls-entropy-source-state-ptrraw/private-f-source(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_entropy_source_state*)#1)->private_f_source)"

pub inline fun mbedtls-entropy-source-statep/private-f-source(s: mbedtls-entropy-source-statep): <> mbedtls-entropy-f-source-ptr
  s.cextern/c-pointer/ptr.mbedtls-entropy-source-state-ptrraw/private-f-source

pub inline fun mbedtls-entropy-source-statec/private-f-source(^s: mbedtls-entropy-source-statec): <> mbedtls-entropy-f-source-ptr
  s.with-ptr(mbedtls-entropy-source-statep/private-f-source)

pub inline fun mbedtls-entropy-source-statecb/private-f-source(^s: mbedtls-entropy-source-statecb<s::S>): <> mbedtls-entropy-f-source-ptr
  s.with-ptr(mbedtls-entropy-source-statep/private-f-source)

pub inline extern mbedtls-entropy-source-state-ptrraw/set-private-f-source(s: intptr_t, private-f-source: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_entropy_source_state*)#1)->private_f_source = (mbedtls_entropy_f_source_ptr)#2"

pub inline fun mbedtls-entropy-source-statep/set-private-f-source(s: mbedtls-entropy-source-statep, private-f-source: mbedtls-entropy-f-source-ptr): ()
  s.mbedtls-entropy-source-state-ptrraw/set-private-f-source(private-f-source)

pub inline fun mbedtls-entropy-source-statec/set-private-f-source(^s: mbedtls-entropy-source-statec, private-f-source: mbedtls-entropy-f-source-ptr): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-f-source(private-f-source))

pub inline fun mbedtls-entropy-source-statecb/set-private-f-source(^s: mbedtls-entropy-source-statecb<s::S>, private-f-source: mbedtls-entropy-f-source-ptr): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-f-source(private-f-source))

pub inline extern mbedtls-entropy-source-state-ptrraw/private-p-source(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_entropy_source_state*)#1)->private_p_source)"

pub inline fun mbedtls-entropy-source-statep/private-p-source(s: mbedtls-entropy-source-statep): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-entropy-source-state-ptrraw/private-p-source

pub inline fun mbedtls-entropy-source-statec/private-p-source(^s: mbedtls-entropy-source-statec): <> c-pointer<()>
  s.with-ptr(mbedtls-entropy-source-statep/private-p-source)

pub inline fun mbedtls-entropy-source-statecb/private-p-source(^s: mbedtls-entropy-source-statecb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-entropy-source-statep/private-p-source)

pub inline extern mbedtls-entropy-source-state-ptrraw/set-private-p-source(s: intptr_t, private-p-source: c-pointer<()>): ()
  c inline "((struct mbedtls_entropy_source_state*)#1)->private_p_source = (void*)#2"

pub inline fun mbedtls-entropy-source-statep/set-private-p-source(s: mbedtls-entropy-source-statep, private-p-source: c-pointer<()>): ()
  s.mbedtls-entropy-source-state-ptrraw/set-private-p-source(private-p-source)

pub inline fun mbedtls-entropy-source-statec/set-private-p-source(^s: mbedtls-entropy-source-statec, private-p-source: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-p-source(private-p-source))

pub inline fun mbedtls-entropy-source-statecb/set-private-p-source(^s: mbedtls-entropy-source-statecb<s::S>, private-p-source: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-p-source(private-p-source))

pub inline extern mbedtls-entropy-source-state-ptrraw/private-size(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_entropy_source_state*)#1)->private_size)"

pub inline fun mbedtls-entropy-source-statep/private-size(s: mbedtls-entropy-source-statep): <> int
  s.cextern/c-pointer/ptr.mbedtls-entropy-source-state-ptrraw/private-size.int

pub inline fun mbedtls-entropy-source-statec/private-size(^s: mbedtls-entropy-source-statec): <> int
  s.with-ptr(mbedtls-entropy-source-statep/private-size)

pub inline fun mbedtls-entropy-source-statecb/private-size(^s: mbedtls-entropy-source-statecb<s::S>): <> int
  s.with-ptr(mbedtls-entropy-source-statep/private-size)

pub inline extern mbedtls-entropy-source-state-ptrraw/set-private-size(s: intptr_t, private-size: ssize_t): ()
  c inline "((struct mbedtls_entropy_source_state*)#1)->private_size = (size_t)#2"

pub inline fun mbedtls-entropy-source-statep/set-private-size(s: mbedtls-entropy-source-statep, private-size: int): ()
  s.mbedtls-entropy-source-state-ptrraw/set-private-size(private-size.ssize_t)

pub inline fun mbedtls-entropy-source-statec/set-private-size(^s: mbedtls-entropy-source-statec, private-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-size(private-size))

pub inline fun mbedtls-entropy-source-statecb/set-private-size(^s: mbedtls-entropy-source-statecb<s::S>, private-size: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-size(private-size))

pub inline extern mbedtls-entropy-source-state-ptrraw/private-threshold(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_entropy_source_state*)#1)->private_threshold)"

pub inline fun mbedtls-entropy-source-statep/private-threshold(s: mbedtls-entropy-source-statep): <> int
  s.cextern/c-pointer/ptr.mbedtls-entropy-source-state-ptrraw/private-threshold.int

pub inline fun mbedtls-entropy-source-statec/private-threshold(^s: mbedtls-entropy-source-statec): <> int
  s.with-ptr(mbedtls-entropy-source-statep/private-threshold)

pub inline fun mbedtls-entropy-source-statecb/private-threshold(^s: mbedtls-entropy-source-statecb<s::S>): <> int
  s.with-ptr(mbedtls-entropy-source-statep/private-threshold)

pub inline extern mbedtls-entropy-source-state-ptrraw/set-private-threshold(s: intptr_t, private-threshold: ssize_t): ()
  c inline "((struct mbedtls_entropy_source_state*)#1)->private_threshold = (size_t)#2"

pub inline fun mbedtls-entropy-source-statep/set-private-threshold(s: mbedtls-entropy-source-statep, private-threshold: int): ()
  s.mbedtls-entropy-source-state-ptrraw/set-private-threshold(private-threshold.ssize_t)

pub inline fun mbedtls-entropy-source-statec/set-private-threshold(^s: mbedtls-entropy-source-statec, private-threshold: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-threshold(private-threshold))

pub inline fun mbedtls-entropy-source-statecb/set-private-threshold(^s: mbedtls-entropy-source-statecb<s::S>, private-threshold: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-threshold(private-threshold))

pub inline extern mbedtls-entropy-source-state-ptrraw/private-strong(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_entropy_source_state*)#1)->private_strong)"

pub inline fun mbedtls-entropy-source-statep/private-strong(s: mbedtls-entropy-source-statep): <> int
  s.cextern/c-pointer/ptr.mbedtls-entropy-source-state-ptrraw/private-strong.int

pub inline fun mbedtls-entropy-source-statec/private-strong(^s: mbedtls-entropy-source-statec): <> int
  s.with-ptr(mbedtls-entropy-source-statep/private-strong)

pub inline fun mbedtls-entropy-source-statecb/private-strong(^s: mbedtls-entropy-source-statecb<s::S>): <> int
  s.with-ptr(mbedtls-entropy-source-statep/private-strong)

pub inline extern mbedtls-entropy-source-state-ptrraw/set-private-strong(s: intptr_t, private-strong: int32): ()
  c inline "((struct mbedtls_entropy_source_state*)#1)->private_strong = (int)#2"

pub inline fun mbedtls-entropy-source-statep/set-private-strong(s: mbedtls-entropy-source-statep, private-strong: int): ()
  s.mbedtls-entropy-source-state-ptrraw/set-private-strong(private-strong.int32)

pub inline fun mbedtls-entropy-source-statec/set-private-strong(^s: mbedtls-entropy-source-statec, private-strong: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-strong(private-strong))

pub inline fun mbedtls-entropy-source-statecb/set-private-strong(^s: mbedtls-entropy-source-statecb<s::S>, private-strong: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-source-statep/set-private-strong(private-strong))

// \brief           Entropy poll callback pointer
// 
// \param data      Callback-specific data pointer
// \param output    Data to fill
// \param len       Maximum size to provide
// \param olen      The actual amount of bytes put into the buffer (Can be 0)
// 
// \return          0 if no critical failures occurred,
// MBEDTLS_ERR_ENTROPY_SOURCE_FAILED otherwise
alias mbedtls-entropy-f-source-ptr = c-pointer<intptr_t>
alias mbedtls-entropy-f-source-ptrfn = ((data : c-pointer<()>, output : c-pointer<int>, len : int, olen : c-pointer<int>) -> int)
// \brief           Entropy context structure
pub struct mbedtls-entropy-context
pub type mbedtls-entropy-context-c
pub alias mbedtls-entropy-contextp = c-pointer<mbedtls-entropy-context-c>
pub alias mbedtls-entropy-contextc<s::S> = owned-c<mbedtls-entropy-context-c>
pub alias mbedtls-entropy-contextcb<s::S> = borrowed-c<s,mbedtls-entropy-context-c>
pub alias mbedtls-entropy-contextca<s::S> = owned-c<c-array<mbedtls-entropy-context-c>>

pub extern mbedtls-entropy-context/size-of(c: c-null<mbedtls-entropy-context-c>): int32
  c inline "sizeof(struct mbedtls_entropy_context)"

pub fun mbedtls-entropy-contextc(): mbedtls-entropy-contextc<s::S>
  malloc(?size-of=mbedtls-entropy-context/size-of)

pub fun mbedtls-entropy-contextc-calloc(): mbedtls-entropy-contextc<s::S>
  malloc-c(?size-of=mbedtls-entropy-context/size-of)

pub fun mbedtls-entropy-contextc-array(n: int): mbedtls-entropy-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-entropy-context/size-of)

pub fun mbedtls-entropy-contextc-array-calloc(n: int): mbedtls-entropy-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-entropy-context/size-of)

pub inline extern mbedtls-entropy-context-ptrraw/private-accumulator-started(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_entropy_context*)#1)->private_accumulator_started)"

pub inline fun mbedtls-entropy-contextp/private-accumulator-started(s: mbedtls-entropy-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-entropy-context-ptrraw/private-accumulator-started.int

pub inline fun mbedtls-entropy-contextc/private-accumulator-started(^s: mbedtls-entropy-contextc<s::S>): <> int
  s.with-ptr(mbedtls-entropy-contextp/private-accumulator-started)

pub inline fun mbedtls-entropy-contextcb/private-accumulator-started(^s: mbedtls-entropy-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-entropy-contextp/private-accumulator-started)

pub inline extern mbedtls-entropy-context-ptrraw/set-private-accumulator-started(s: intptr_t, private-accumulator-started: int32): ()
  c inline "((struct mbedtls_entropy_context*)#1)->private_accumulator_started = (int)#2"

pub inline fun mbedtls-entropy-contextp/set-private-accumulator-started(s: mbedtls-entropy-contextp, private-accumulator-started: int): ()
  s.mbedtls-entropy-context-ptrraw/set-private-accumulator-started(private-accumulator-started.int32)

pub inline fun mbedtls-entropy-contextc/set-private-accumulator-started(^s: mbedtls-entropy-contextc<s::S>, private-accumulator-started: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-contextp/set-private-accumulator-started(private-accumulator-started))

pub inline fun mbedtls-entropy-contextcb/set-private-accumulator-started(^s: mbedtls-entropy-contextcb<s::S>, private-accumulator-started: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-contextp/set-private-accumulator-started(private-accumulator-started))

pub inline extern mbedtls-entropy-context-ptrraw/private-source-count(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_entropy_context*)#1)->private_source_count)"

pub inline fun mbedtls-entropy-contextp/private-source-count(s: mbedtls-entropy-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-entropy-context-ptrraw/private-source-count.int

pub inline fun mbedtls-entropy-contextc/private-source-count(^s: mbedtls-entropy-contextc<s::S>): <> int
  s.with-ptr(mbedtls-entropy-contextp/private-source-count)

pub inline fun mbedtls-entropy-contextcb/private-source-count(^s: mbedtls-entropy-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-entropy-contextp/private-source-count)

pub inline extern mbedtls-entropy-context-ptrraw/set-private-source-count(s: intptr_t, private-source-count: int32): ()
  c inline "((struct mbedtls_entropy_context*)#1)->private_source_count = (int)#2"

pub inline fun mbedtls-entropy-contextp/set-private-source-count(s: mbedtls-entropy-contextp, private-source-count: int): ()
  s.mbedtls-entropy-context-ptrraw/set-private-source-count(private-source-count.int32)

pub inline fun mbedtls-entropy-contextc/set-private-source-count(^s: mbedtls-entropy-contextc<s::S>, private-source-count: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-contextp/set-private-source-count(private-source-count))

pub inline fun mbedtls-entropy-contextcb/set-private-source-count(^s: mbedtls-entropy-contextcb<s::S>, private-source-count: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-contextp/set-private-source-count(private-source-count))

pub inline extern mbedtls-entropy-context-ptrraw/private-source(s: intptr_t): c-pointer<mbedtls-entropy-source-state-c>
  c inline "(intptr_t)(((struct mbedtls_entropy_context*)#1)->private_source)"

pub inline fun mbedtls-entropy-contextp/private-source(s: mbedtls-entropy-contextp): <> c-array<mbedtls-entropy-source-state-c>
  s.cextern/c-pointer/ptr.mbedtls-entropy-context-ptrraw/private-source.cextern/ptr/carray

pub inline fun mbedtls-entropy-contextc/private-source(^s: mbedtls-entropy-contextc<s::S>): <> c-array<mbedtls-entropy-source-state-c>
  s.with-ptr(mbedtls-entropy-contextp/private-source)

pub inline fun mbedtls-entropy-contextcb/private-source(^s: mbedtls-entropy-contextcb<s::S>): <> c-array<mbedtls-entropy-source-state-c>
  s.with-ptr(mbedtls-entropy-contextp/private-source)

pub inline extern mbedtls-entropy-context-ptrraw/set-private-source(s: intptr_t, private-source: c-pointer<mbedtls-entropy-source-state-c>): ()
  c inline "((struct mbedtls_entropy_context*)#1)->private_source = (struct mbedtls_entropy_source_state*)#2"

pub inline fun mbedtls-entropy-contextp/set-private-source(s: mbedtls-entropy-contextp, private-source: c-array<mbedtls-entropy-source-state-c>): ()
  s.mbedtls-entropy-context-ptrraw/set-private-source(private-source.cextern/carray/ptr)

pub inline fun mbedtls-entropy-contextc/set-private-source(^s: mbedtls-entropy-contextc<s::S>, private-source: c-array<mbedtls-entropy-source-state-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-contextp/set-private-source(private-source))

pub inline fun mbedtls-entropy-contextcb/set-private-source(^s: mbedtls-entropy-contextcb<s::S>, private-source: c-array<mbedtls-entropy-source-state-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-entropy-contextp/set-private-source(private-source))

// PKCS #7 types
type mbedtls-pkcs7-type
  MBEDTLS_PKCS7_NONE
  MBEDTLS_PKCS7_DATA
  MBEDTLS_PKCS7_SIGNED_DATA
  MBEDTLS_PKCS7_ENVELOPED_DATA
  MBEDTLS_PKCS7_SIGNED_AND_ENVELOPED_DATA
  MBEDTLS_PKCS7_DIGESTED_DATA
  MBEDTLS_PKCS7_ENCRYPTED_DATA

pub fun mbedtls-pkcs7-type/int(i: mbedtls-pkcs7-type): int32
  match i
    MBEDTLS_PKCS7_NONE -> 0.int32
    MBEDTLS_PKCS7_DATA -> 1.int32
    MBEDTLS_PKCS7_SIGNED_DATA -> 2.int32
    MBEDTLS_PKCS7_ENVELOPED_DATA -> 3.int32
    MBEDTLS_PKCS7_SIGNED_AND_ENVELOPED_DATA -> 4.int32
    MBEDTLS_PKCS7_DIGESTED_DATA -> 5.int32
    MBEDTLS_PKCS7_ENCRYPTED_DATA -> 6.int32

pub fun int/mbedtls-pkcs7-type(i: int32): exn mbedtls-pkcs7-type
  match i.int
    0 -> MBEDTLS_PKCS7_NONE
    1 -> MBEDTLS_PKCS7_DATA
    2 -> MBEDTLS_PKCS7_SIGNED_DATA
    3 -> MBEDTLS_PKCS7_ENVELOPED_DATA
    4 -> MBEDTLS_PKCS7_SIGNED_AND_ENVELOPED_DATA
    5 -> MBEDTLS_PKCS7_DIGESTED_DATA
    6 -> MBEDTLS_PKCS7_ENCRYPTED_DATA

// Structure holding PKCS #7 signer info
pub struct mbedtls-pkcs7-signer-info
  private-version: int
  private-serial: koka-mbedtls-x509-buf
  private-issuer: koka-mbedtls-x509-name
  private-issuer-raw: koka-mbedtls-x509-buf
  private-alg-identifier: koka-mbedtls-x509-buf
  private-sig-alg-identifier: koka-mbedtls-x509-buf
  private-sig: koka-mbedtls-x509-buf
  private-next: mbedtls-pkcs7-signer-info-c

pub type mbedtls-pkcs7-signer-info-c
pub alias mbedtls-pkcs7-signer-infop = c-pointer<mbedtls-pkcs7-signer-info-c>
pub alias mbedtls-pkcs7-signer-infoc = owned-c<mbedtls-pkcs7-signer-info-c>
pub alias mbedtls-pkcs7-signer-infocb<s::S> = borrowed-c<s,mbedtls-pkcs7-signer-info-c>
pub alias mbedtls-pkcs7-signer-infoca = owned-c<c-array<mbedtls-pkcs7-signer-info-c>>

pub extern mbedtls-pkcs7-signer-info/size-of(c: c-null<mbedtls-pkcs7-signer-info-c>): int32
  c inline "sizeof(struct mbedtls_pkcs7_signer_info)"

pub fun mbedtls-pkcs7-signer-infoc(): mbedtls-pkcs7-signer-infoc
  malloc(?size-of=mbedtls-pkcs7-signer-info/size-of)

pub fun mbedtls-pkcs7-signer-infoc-calloc(): mbedtls-pkcs7-signer-infoc
  malloc-c(?size-of=mbedtls-pkcs7-signer-info/size-of)

pub fun mbedtls-pkcs7-signer-infoc-array(n: int): mbedtls-pkcs7-signer-infoca
  malloc(n.int32, ?size-of=mbedtls-pkcs7-signer-info/size-of)

pub fun mbedtls-pkcs7-signer-infoc-array-calloc(n: int): mbedtls-pkcs7-signer-infoca
  malloc-c(n.int32, ?size-of=mbedtls-pkcs7-signer-info/size-of)

pub inline extern mbedtls-pkcs7-signer-info-ptrraw/private-version(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_pkcs7_signer_info*)#1)->private_version)"

pub inline fun mbedtls-pkcs7-signer-infop/private-version(s: mbedtls-pkcs7-signer-infop): <> int
  s.cextern/c-pointer/ptr.mbedtls-pkcs7-signer-info-ptrraw/private-version.int

pub inline fun mbedtls-pkcs7-signer-infoc/private-version(^s: mbedtls-pkcs7-signer-infoc): <> int
  s.with-ptr(mbedtls-pkcs7-signer-infop/private-version)

pub inline fun mbedtls-pkcs7-signer-infocb/private-version(^s: mbedtls-pkcs7-signer-infocb<s::S>): <> int
  s.with-ptr(mbedtls-pkcs7-signer-infop/private-version)

pub inline extern mbedtls-pkcs7-signer-info-ptrraw/set-private-version(s: intptr_t, private-version: int32): ()
  c inline "((struct mbedtls_pkcs7_signer_info*)#1)->private_version = (int)#2"

pub inline fun mbedtls-pkcs7-signer-infop/set-private-version(s: mbedtls-pkcs7-signer-infop, private-version: int): ()
  s.mbedtls-pkcs7-signer-info-ptrraw/set-private-version(private-version.int32)

pub inline fun mbedtls-pkcs7-signer-infoc/set-private-version(^s: mbedtls-pkcs7-signer-infoc, private-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signer-infop/set-private-version(private-version))

pub inline fun mbedtls-pkcs7-signer-infocb/set-private-version(^s: mbedtls-pkcs7-signer-infocb<s::S>, private-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signer-infop/set-private-version(private-version))

pub inline extern mbedtls-pkcs7-signer-info-ptrraw/private-next(s: intptr_t): c-pointer<mbedtls-pkcs7-signer-info-c>
  c inline "(intptr_t)(((struct mbedtls_pkcs7_signer_info*)#1)->private_next)"

pub inline fun mbedtls-pkcs7-signer-infop/private-next(s: mbedtls-pkcs7-signer-infop): <> c-pointer<mbedtls-pkcs7-signer-info-c>
  s.cextern/c-pointer/ptr.mbedtls-pkcs7-signer-info-ptrraw/private-next

pub inline fun mbedtls-pkcs7-signer-infoc/private-next(^s: mbedtls-pkcs7-signer-infoc): <> c-pointer<mbedtls-pkcs7-signer-info-c>
  s.with-ptr(mbedtls-pkcs7-signer-infop/private-next)

pub inline fun mbedtls-pkcs7-signer-infocb/private-next(^s: mbedtls-pkcs7-signer-infocb<s::S>): <> c-pointer<mbedtls-pkcs7-signer-info-c>
  s.with-ptr(mbedtls-pkcs7-signer-infop/private-next)

pub inline extern mbedtls-pkcs7-signer-info-ptrraw/set-private-next(s: intptr_t, private-next: c-pointer<mbedtls-pkcs7-signer-info-c>): ()
  c inline "((struct mbedtls_pkcs7_signer_info*)#1)->private_next = (struct mbedtls_pkcs7_signer_info*)#2"

pub inline fun mbedtls-pkcs7-signer-infop/set-private-next(s: mbedtls-pkcs7-signer-infop, private-next: c-pointer<mbedtls-pkcs7-signer-info-c>): ()
  s.mbedtls-pkcs7-signer-info-ptrraw/set-private-next(private-next)

pub inline fun mbedtls-pkcs7-signer-infoc/set-private-next(^s: mbedtls-pkcs7-signer-infoc, private-next: c-pointer<mbedtls-pkcs7-signer-info-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signer-infop/set-private-next(private-next))

pub inline fun mbedtls-pkcs7-signer-infocb/set-private-next(^s: mbedtls-pkcs7-signer-infocb<s::S>, private-next: c-pointer<mbedtls-pkcs7-signer-info-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signer-infop/set-private-next(private-next))

// Structure holding the signed data section
pub struct mbedtls-pkcs7-signed-data
  private-version: int
  private-digest-alg-identifiers: koka-mbedtls-pkcs7-buf
  private-no-of-certs: int
  private-certs: mbedtls-x509-crt-c
  private-no-of-crls: int
  private-crl: mbedtls-x509-crl-c
  private-no-of-signers: int
  private-signers: mbedtls-pkcs7-signer-info-c

pub type mbedtls-pkcs7-signed-data-c
pub alias mbedtls-pkcs7-signed-datap = c-pointer<mbedtls-pkcs7-signed-data-c>
pub alias mbedtls-pkcs7-signed-datac = owned-c<mbedtls-pkcs7-signed-data-c>
pub alias mbedtls-pkcs7-signed-datacb<s::S> = borrowed-c<s,mbedtls-pkcs7-signed-data-c>
pub alias mbedtls-pkcs7-signed-dataca = owned-c<c-array<mbedtls-pkcs7-signed-data-c>>

pub extern mbedtls-pkcs7-signed-data/size-of(c: c-null<mbedtls-pkcs7-signed-data-c>): int32
  c inline "sizeof(struct mbedtls_pkcs7_signed_data)"

pub fun mbedtls-pkcs7-signed-datac(): mbedtls-pkcs7-signed-datac
  malloc(?size-of=mbedtls-pkcs7-signed-data/size-of)

pub fun mbedtls-pkcs7-signed-datac-calloc(): mbedtls-pkcs7-signed-datac
  malloc-c(?size-of=mbedtls-pkcs7-signed-data/size-of)

pub fun mbedtls-pkcs7-signed-datac-array(n: int): mbedtls-pkcs7-signed-dataca
  malloc(n.int32, ?size-of=mbedtls-pkcs7-signed-data/size-of)

pub fun mbedtls-pkcs7-signed-datac-array-calloc(n: int): mbedtls-pkcs7-signed-dataca
  malloc-c(n.int32, ?size-of=mbedtls-pkcs7-signed-data/size-of)

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/private-version(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_pkcs7_signed_data*)#1)->private_version)"

pub inline fun mbedtls-pkcs7-signed-datap/private-version(s: mbedtls-pkcs7-signed-datap): <> int
  s.cextern/c-pointer/ptr.mbedtls-pkcs7-signed-data-ptrraw/private-version.int

pub inline fun mbedtls-pkcs7-signed-datac/private-version(^s: mbedtls-pkcs7-signed-datac): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-version)

pub inline fun mbedtls-pkcs7-signed-datacb/private-version(^s: mbedtls-pkcs7-signed-datacb<s::S>): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-version)

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/set-private-version(s: intptr_t, private-version: int32): ()
  c inline "((struct mbedtls_pkcs7_signed_data*)#1)->private_version = (int)#2"

pub inline fun mbedtls-pkcs7-signed-datap/set-private-version(s: mbedtls-pkcs7-signed-datap, private-version: int): ()
  s.mbedtls-pkcs7-signed-data-ptrraw/set-private-version(private-version.int32)

pub inline fun mbedtls-pkcs7-signed-datac/set-private-version(^s: mbedtls-pkcs7-signed-datac, private-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-version(private-version))

pub inline fun mbedtls-pkcs7-signed-datacb/set-private-version(^s: mbedtls-pkcs7-signed-datacb<s::S>, private-version: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-version(private-version))

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/private-no-of-certs(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_pkcs7_signed_data*)#1)->private_no_of_certs)"

pub inline fun mbedtls-pkcs7-signed-datap/private-no-of-certs(s: mbedtls-pkcs7-signed-datap): <> int
  s.cextern/c-pointer/ptr.mbedtls-pkcs7-signed-data-ptrraw/private-no-of-certs.int

pub inline fun mbedtls-pkcs7-signed-datac/private-no-of-certs(^s: mbedtls-pkcs7-signed-datac): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-no-of-certs)

pub inline fun mbedtls-pkcs7-signed-datacb/private-no-of-certs(^s: mbedtls-pkcs7-signed-datacb<s::S>): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-no-of-certs)

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/set-private-no-of-certs(s: intptr_t, private-no-of-certs: int32): ()
  c inline "((struct mbedtls_pkcs7_signed_data*)#1)->private_no_of_certs = (int)#2"

pub inline fun mbedtls-pkcs7-signed-datap/set-private-no-of-certs(s: mbedtls-pkcs7-signed-datap, private-no-of-certs: int): ()
  s.mbedtls-pkcs7-signed-data-ptrraw/set-private-no-of-certs(private-no-of-certs.int32)

pub inline fun mbedtls-pkcs7-signed-datac/set-private-no-of-certs(^s: mbedtls-pkcs7-signed-datac, private-no-of-certs: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-no-of-certs(private-no-of-certs))

pub inline fun mbedtls-pkcs7-signed-datacb/set-private-no-of-certs(^s: mbedtls-pkcs7-signed-datacb<s::S>, private-no-of-certs: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-no-of-certs(private-no-of-certs))

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/private-no-of-crls(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_pkcs7_signed_data*)#1)->private_no_of_crls)"

pub inline fun mbedtls-pkcs7-signed-datap/private-no-of-crls(s: mbedtls-pkcs7-signed-datap): <> int
  s.cextern/c-pointer/ptr.mbedtls-pkcs7-signed-data-ptrraw/private-no-of-crls.int

pub inline fun mbedtls-pkcs7-signed-datac/private-no-of-crls(^s: mbedtls-pkcs7-signed-datac): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-no-of-crls)

pub inline fun mbedtls-pkcs7-signed-datacb/private-no-of-crls(^s: mbedtls-pkcs7-signed-datacb<s::S>): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-no-of-crls)

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/set-private-no-of-crls(s: intptr_t, private-no-of-crls: int32): ()
  c inline "((struct mbedtls_pkcs7_signed_data*)#1)->private_no_of_crls = (int)#2"

pub inline fun mbedtls-pkcs7-signed-datap/set-private-no-of-crls(s: mbedtls-pkcs7-signed-datap, private-no-of-crls: int): ()
  s.mbedtls-pkcs7-signed-data-ptrraw/set-private-no-of-crls(private-no-of-crls.int32)

pub inline fun mbedtls-pkcs7-signed-datac/set-private-no-of-crls(^s: mbedtls-pkcs7-signed-datac, private-no-of-crls: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-no-of-crls(private-no-of-crls))

pub inline fun mbedtls-pkcs7-signed-datacb/set-private-no-of-crls(^s: mbedtls-pkcs7-signed-datacb<s::S>, private-no-of-crls: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-no-of-crls(private-no-of-crls))

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/private-no-of-signers(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_pkcs7_signed_data*)#1)->private_no_of_signers)"

pub inline fun mbedtls-pkcs7-signed-datap/private-no-of-signers(s: mbedtls-pkcs7-signed-datap): <> int
  s.cextern/c-pointer/ptr.mbedtls-pkcs7-signed-data-ptrraw/private-no-of-signers.int

pub inline fun mbedtls-pkcs7-signed-datac/private-no-of-signers(^s: mbedtls-pkcs7-signed-datac): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-no-of-signers)

pub inline fun mbedtls-pkcs7-signed-datacb/private-no-of-signers(^s: mbedtls-pkcs7-signed-datacb<s::S>): <> int
  s.with-ptr(mbedtls-pkcs7-signed-datap/private-no-of-signers)

pub inline extern mbedtls-pkcs7-signed-data-ptrraw/set-private-no-of-signers(s: intptr_t, private-no-of-signers: int32): ()
  c inline "((struct mbedtls_pkcs7_signed_data*)#1)->private_no_of_signers = (int)#2"

pub inline fun mbedtls-pkcs7-signed-datap/set-private-no-of-signers(s: mbedtls-pkcs7-signed-datap, private-no-of-signers: int): ()
  s.mbedtls-pkcs7-signed-data-ptrraw/set-private-no-of-signers(private-no-of-signers.int32)

pub inline fun mbedtls-pkcs7-signed-datac/set-private-no-of-signers(^s: mbedtls-pkcs7-signed-datac, private-no-of-signers: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-no-of-signers(private-no-of-signers))

pub inline fun mbedtls-pkcs7-signed-datacb/set-private-no-of-signers(^s: mbedtls-pkcs7-signed-datacb<s::S>, private-no-of-signers: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-pkcs7-signed-datap/set-private-no-of-signers(private-no-of-signers))

// Type-length-value structure that allows for ASN.1 using DER.
alias mbedtls-pkcs7-buf = mbedtls-asn1-buf-c
alias koka-mbedtls-pkcs7-buf = mbedtls-asn1-buf
// Structure holding PKCS #7 structure, only signed data for now
pub value struct mbedtls-pkcs7
  private-raw: koka-mbedtls-pkcs7-buf
  private-signed-data: mbedtls-pkcs7-signed-data-c

pub type mbedtls-pkcs7-c
pub alias mbedtls-pkcs7p = c-pointer<mbedtls-pkcs7-c>
pub alias mbedtls-pkcs7c = owned-c<mbedtls-pkcs7-c>
pub alias mbedtls-pkcs7cb<s::S> = borrowed-c<s,mbedtls-pkcs7-c>
pub alias mbedtls-pkcs7ca = owned-c<c-array<mbedtls-pkcs7-c>>

pub extern mbedtls-pkcs7/size-of(c: c-null<mbedtls-pkcs7-c>): int32
  c inline "sizeof(struct mbedtls_pkcs7)"

pub fun mbedtls-pkcs7c(): mbedtls-pkcs7c
  malloc(?size-of=mbedtls-pkcs7/size-of)

pub fun mbedtls-pkcs7c-calloc(): mbedtls-pkcs7c
  malloc-c(?size-of=mbedtls-pkcs7/size-of)

pub fun mbedtls-pkcs7c-array(n: int): mbedtls-pkcs7ca
  malloc(n.int32, ?size-of=mbedtls-pkcs7/size-of)

pub fun mbedtls-pkcs7c-array-calloc(n: int): mbedtls-pkcs7ca
  malloc-c(n.int32, ?size-of=mbedtls-pkcs7/size-of)

// \brief The AES context-type definition.
pub struct mbedtls-aes-context
pub type mbedtls-aes-context-c
pub alias mbedtls-aes-contextp = c-pointer<mbedtls-aes-context-c>
pub alias mbedtls-aes-contextc<s::S> = owned-c<mbedtls-aes-context-c>
pub alias mbedtls-aes-contextcb<s::S> = borrowed-c<s,mbedtls-aes-context-c>
pub alias mbedtls-aes-contextca<s::S> = owned-c<c-array<mbedtls-aes-context-c>>

pub extern mbedtls-aes-context/size-of(c: c-null<mbedtls-aes-context-c>): int32
  c inline "sizeof(struct mbedtls_aes_context)"

pub fun mbedtls-aes-contextc(): mbedtls-aes-contextc<s::S>
  malloc(?size-of=mbedtls-aes-context/size-of)

pub fun mbedtls-aes-contextc-calloc(): mbedtls-aes-contextc<s::S>
  malloc-c(?size-of=mbedtls-aes-context/size-of)

pub fun mbedtls-aes-contextc-array(n: int): mbedtls-aes-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-aes-context/size-of)

pub fun mbedtls-aes-contextc-array-calloc(n: int): mbedtls-aes-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-aes-context/size-of)

pub inline extern mbedtls-aes-context-ptrraw/private-nr(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_aes_context*)#1)->private_nr)"

pub inline fun mbedtls-aes-contextp/private-nr(s: mbedtls-aes-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-aes-context-ptrraw/private-nr.int

pub inline fun mbedtls-aes-contextc/private-nr(^s: mbedtls-aes-contextc<s::S>): <> int
  s.with-ptr(mbedtls-aes-contextp/private-nr)

pub inline fun mbedtls-aes-contextcb/private-nr(^s: mbedtls-aes-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-aes-contextp/private-nr)

pub inline extern mbedtls-aes-context-ptrraw/set-private-nr(s: intptr_t, private-nr: int32): ()
  c inline "((struct mbedtls_aes_context*)#1)->private_nr = (int)#2"

pub inline fun mbedtls-aes-contextp/set-private-nr(s: mbedtls-aes-contextp, private-nr: int): ()
  s.mbedtls-aes-context-ptrraw/set-private-nr(private-nr.int32)

pub inline fun mbedtls-aes-contextc/set-private-nr(^s: mbedtls-aes-contextc<s::S>, private-nr: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aes-contextp/set-private-nr(private-nr))

pub inline fun mbedtls-aes-contextcb/set-private-nr(^s: mbedtls-aes-contextcb<s::S>, private-nr: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aes-contextp/set-private-nr(private-nr))

pub inline extern mbedtls-aes-context-ptrraw/private-rk-offset(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_aes_context*)#1)->private_rk_offset)"

pub inline fun mbedtls-aes-contextp/private-rk-offset(s: mbedtls-aes-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-aes-context-ptrraw/private-rk-offset.int

pub inline fun mbedtls-aes-contextc/private-rk-offset(^s: mbedtls-aes-contextc<s::S>): <> int
  s.with-ptr(mbedtls-aes-contextp/private-rk-offset)

pub inline fun mbedtls-aes-contextcb/private-rk-offset(^s: mbedtls-aes-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-aes-contextp/private-rk-offset)

pub inline extern mbedtls-aes-context-ptrraw/set-private-rk-offset(s: intptr_t, private-rk-offset: ssize_t): ()
  c inline "((struct mbedtls_aes_context*)#1)->private_rk_offset = (size_t)#2"

pub inline fun mbedtls-aes-contextp/set-private-rk-offset(s: mbedtls-aes-contextp, private-rk-offset: int): ()
  s.mbedtls-aes-context-ptrraw/set-private-rk-offset(private-rk-offset.ssize_t)

pub inline fun mbedtls-aes-contextc/set-private-rk-offset(^s: mbedtls-aes-contextc<s::S>, private-rk-offset: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aes-contextp/set-private-rk-offset(private-rk-offset))

pub inline fun mbedtls-aes-contextcb/set-private-rk-offset(^s: mbedtls-aes-contextcb<s::S>, private-rk-offset: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aes-contextp/set-private-rk-offset(private-rk-offset))

pub inline extern mbedtls-aes-context-ptrraw/private-buf(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_aes_context*)#1)->private_buf)"

pub inline fun mbedtls-aes-contextp/private-buf(s: mbedtls-aes-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-aes-context-ptrraw/private-buf.cextern/ptr/carray

pub inline fun mbedtls-aes-contextc/private-buf(^s: mbedtls-aes-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-aes-contextp/private-buf)

pub inline fun mbedtls-aes-contextcb/private-buf(^s: mbedtls-aes-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-aes-contextp/private-buf)

pub inline extern mbedtls-aes-context-ptrraw/set-private-buf(s: intptr_t, private-buf: c-pointer<int>): ()
  c inline "((struct mbedtls_aes_context*)#1)->private_buf = (int32_t*)#2"

pub inline fun mbedtls-aes-contextp/set-private-buf(s: mbedtls-aes-contextp, private-buf: c-array<int>): ()
  s.mbedtls-aes-context-ptrraw/set-private-buf(private-buf.cextern/carray/ptr)

pub inline fun mbedtls-aes-contextc/set-private-buf(^s: mbedtls-aes-contextc<s::S>, private-buf: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aes-contextp/set-private-buf(private-buf))

pub inline fun mbedtls-aes-contextcb/set-private-buf(^s: mbedtls-aes-contextcb<s::S>, private-buf: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aes-contextp/set-private-buf(private-buf))

// \brief The AES XTS context-type definition.
pub value struct mbedtls-aes-xts-context
  // !< The AES context to use for AES block
  // encryption or decryption.
  private-crypt: mbedtls-aes-context-c
  // !< The AES context used for tweak
  // computation.
  private-tweak: mbedtls-aes-context-c

pub type mbedtls-aes-xts-context-c
pub alias mbedtls-aes-xts-contextp = c-pointer<mbedtls-aes-xts-context-c>
pub alias mbedtls-aes-xts-contextc = owned-c<mbedtls-aes-xts-context-c>
pub alias mbedtls-aes-xts-contextcb<s::S> = borrowed-c<s,mbedtls-aes-xts-context-c>
pub alias mbedtls-aes-xts-contextca = owned-c<c-array<mbedtls-aes-xts-context-c>>

pub extern mbedtls-aes-xts-context/size-of(c: c-null<mbedtls-aes-xts-context-c>): int32
  c inline "sizeof(struct mbedtls_aes_xts_context)"

pub fun mbedtls-aes-xts-contextc(): mbedtls-aes-xts-contextc
  malloc(?size-of=mbedtls-aes-xts-context/size-of)

pub fun mbedtls-aes-xts-contextc-calloc(): mbedtls-aes-xts-contextc
  malloc-c(?size-of=mbedtls-aes-xts-context/size-of)

pub fun mbedtls-aes-xts-contextc-array(n: int): mbedtls-aes-xts-contextca
  malloc(n.int32, ?size-of=mbedtls-aes-xts-context/size-of)

pub fun mbedtls-aes-xts-contextc-array-calloc(n: int): mbedtls-aes-xts-contextca
  malloc-c(n.int32, ?size-of=mbedtls-aes-xts-context/size-of)

// \brief The ARIA context-type definition.
pub struct mbedtls-aria-context
pub type mbedtls-aria-context-c
pub alias mbedtls-aria-contextp = c-pointer<mbedtls-aria-context-c>
pub alias mbedtls-aria-contextc<s::S> = owned-c<mbedtls-aria-context-c>
pub alias mbedtls-aria-contextcb<s::S> = borrowed-c<s,mbedtls-aria-context-c>
pub alias mbedtls-aria-contextca<s::S> = owned-c<c-array<mbedtls-aria-context-c>>

pub extern mbedtls-aria-context/size-of(c: c-null<mbedtls-aria-context-c>): int32
  c inline "sizeof(struct mbedtls_aria_context)"

pub fun mbedtls-aria-contextc(): mbedtls-aria-contextc<s::S>
  malloc(?size-of=mbedtls-aria-context/size-of)

pub fun mbedtls-aria-contextc-calloc(): mbedtls-aria-contextc<s::S>
  malloc-c(?size-of=mbedtls-aria-context/size-of)

pub fun mbedtls-aria-contextc-array(n: int): mbedtls-aria-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-aria-context/size-of)

pub fun mbedtls-aria-contextc-array-calloc(n: int): mbedtls-aria-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-aria-context/size-of)

pub inline extern mbedtls-aria-context-ptrraw/private-nr(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_aria_context*)#1)->private_nr)"

pub inline fun mbedtls-aria-contextp/private-nr(s: mbedtls-aria-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-aria-context-ptrraw/private-nr.int

pub inline fun mbedtls-aria-contextc/private-nr(^s: mbedtls-aria-contextc<s::S>): <> int
  s.with-ptr(mbedtls-aria-contextp/private-nr)

pub inline fun mbedtls-aria-contextcb/private-nr(^s: mbedtls-aria-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-aria-contextp/private-nr)

pub inline extern mbedtls-aria-context-ptrraw/set-private-nr(s: intptr_t, private-nr: int8): ()
  c inline "((struct mbedtls_aria_context*)#1)->private_nr = (unsigned char)#2"

pub inline fun mbedtls-aria-contextp/set-private-nr(s: mbedtls-aria-contextp, private-nr: int): ()
  s.mbedtls-aria-context-ptrraw/set-private-nr(private-nr.int8)

pub inline fun mbedtls-aria-contextc/set-private-nr(^s: mbedtls-aria-contextc<s::S>, private-nr: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aria-contextp/set-private-nr(private-nr))

pub inline fun mbedtls-aria-contextcb/set-private-nr(^s: mbedtls-aria-contextcb<s::S>, private-nr: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aria-contextp/set-private-nr(private-nr))

pub inline extern mbedtls-aria-context-ptrraw/private-rk(s: intptr_t): c-pointer<c-array<int>>
  c inline "(intptr_t)(((struct mbedtls_aria_context*)#1)->private_rk)"

pub inline fun mbedtls-aria-contextp/private-rk(s: mbedtls-aria-contextp): <> c-array<c-array<int>>
  s.cextern/c-pointer/ptr.mbedtls-aria-context-ptrraw/private-rk.cextern/ptr/carray

pub inline fun mbedtls-aria-contextc/private-rk(^s: mbedtls-aria-contextc<s::S>): <> c-array<c-array<int>>
  s.with-ptr(mbedtls-aria-contextp/private-rk)

pub inline fun mbedtls-aria-contextcb/private-rk(^s: mbedtls-aria-contextcb<s::S>): <> c-array<c-array<int>>
  s.with-ptr(mbedtls-aria-contextp/private-rk)

pub inline extern mbedtls-aria-context-ptrraw/set-private-rk(s: intptr_t, private-rk: c-pointer<c-array<int>>): ()
  c inline "((struct mbedtls_aria_context*)#1)->private_rk = (int32_t**)#2"

pub inline fun mbedtls-aria-contextp/set-private-rk(s: mbedtls-aria-contextp, private-rk: c-array<c-array<int>>): ()
  s.mbedtls-aria-context-ptrraw/set-private-rk(private-rk.cextern/carray/ptr)

pub inline fun mbedtls-aria-contextc/set-private-rk(^s: mbedtls-aria-contextc<s::S>, private-rk: c-array<c-array<int>>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aria-contextp/set-private-rk(private-rk))

pub inline fun mbedtls-aria-contextcb/set-private-rk(^s: mbedtls-aria-contextcb<s::S>, private-rk: c-array<c-array<int>>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-aria-contextp/set-private-rk(private-rk))

// \brief          CAMELLIA context structure
pub struct mbedtls-camellia-context
pub type mbedtls-camellia-context-c
pub alias mbedtls-camellia-contextp = c-pointer<mbedtls-camellia-context-c>
pub alias mbedtls-camellia-contextc<s::S> = owned-c<mbedtls-camellia-context-c>
pub alias mbedtls-camellia-contextcb<s::S> = borrowed-c<s,mbedtls-camellia-context-c>
pub alias mbedtls-camellia-contextca<s::S> = owned-c<c-array<mbedtls-camellia-context-c>>

pub extern mbedtls-camellia-context/size-of(c: c-null<mbedtls-camellia-context-c>): int32
  c inline "sizeof(struct mbedtls_camellia_context)"

pub fun mbedtls-camellia-contextc(): mbedtls-camellia-contextc<s::S>
  malloc(?size-of=mbedtls-camellia-context/size-of)

pub fun mbedtls-camellia-contextc-calloc(): mbedtls-camellia-contextc<s::S>
  malloc-c(?size-of=mbedtls-camellia-context/size-of)

pub fun mbedtls-camellia-contextc-array(n: int): mbedtls-camellia-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-camellia-context/size-of)

pub fun mbedtls-camellia-contextc-array-calloc(n: int): mbedtls-camellia-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-camellia-context/size-of)

pub inline extern mbedtls-camellia-context-ptrraw/private-nr(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_camellia_context*)#1)->private_nr)"

pub inline fun mbedtls-camellia-contextp/private-nr(s: mbedtls-camellia-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-camellia-context-ptrraw/private-nr.int

pub inline fun mbedtls-camellia-contextc/private-nr(^s: mbedtls-camellia-contextc<s::S>): <> int
  s.with-ptr(mbedtls-camellia-contextp/private-nr)

pub inline fun mbedtls-camellia-contextcb/private-nr(^s: mbedtls-camellia-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-camellia-contextp/private-nr)

pub inline extern mbedtls-camellia-context-ptrraw/set-private-nr(s: intptr_t, private-nr: int32): ()
  c inline "((struct mbedtls_camellia_context*)#1)->private_nr = (int)#2"

pub inline fun mbedtls-camellia-contextp/set-private-nr(s: mbedtls-camellia-contextp, private-nr: int): ()
  s.mbedtls-camellia-context-ptrraw/set-private-nr(private-nr.int32)

pub inline fun mbedtls-camellia-contextc/set-private-nr(^s: mbedtls-camellia-contextc<s::S>, private-nr: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-camellia-contextp/set-private-nr(private-nr))

pub inline fun mbedtls-camellia-contextcb/set-private-nr(^s: mbedtls-camellia-contextcb<s::S>, private-nr: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-camellia-contextp/set-private-nr(private-nr))

pub inline extern mbedtls-camellia-context-ptrraw/private-rk(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_camellia_context*)#1)->private_rk)"

pub inline fun mbedtls-camellia-contextp/private-rk(s: mbedtls-camellia-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-camellia-context-ptrraw/private-rk.cextern/ptr/carray

pub inline fun mbedtls-camellia-contextc/private-rk(^s: mbedtls-camellia-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-camellia-contextp/private-rk)

pub inline fun mbedtls-camellia-contextcb/private-rk(^s: mbedtls-camellia-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-camellia-contextp/private-rk)

pub inline extern mbedtls-camellia-context-ptrraw/set-private-rk(s: intptr_t, private-rk: c-pointer<int>): ()
  c inline "((struct mbedtls_camellia_context*)#1)->private_rk = (int32_t*)#2"

pub inline fun mbedtls-camellia-contextp/set-private-rk(s: mbedtls-camellia-contextp, private-rk: c-array<int>): ()
  s.mbedtls-camellia-context-ptrraw/set-private-rk(private-rk.cextern/carray/ptr)

pub inline fun mbedtls-camellia-contextc/set-private-rk(^s: mbedtls-camellia-contextc<s::S>, private-rk: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-camellia-contextp/set-private-rk(private-rk))

pub inline fun mbedtls-camellia-contextcb/set-private-rk(^s: mbedtls-camellia-contextcb<s::S>, private-rk: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-camellia-contextp/set-private-rk(private-rk))

type mbedtls-block-cipher-id-t
  // < Unset.
  MBEDTLS_BLOCK_CIPHER_ID_NONE
  // < The AES cipher.
  MBEDTLS_BLOCK_CIPHER_ID_AES
  // < The Camellia cipher.
  MBEDTLS_BLOCK_CIPHER_ID_CAMELLIA
  // < The Aria cipher.
  MBEDTLS_BLOCK_CIPHER_ID_ARIA

pub fun mbedtls-block-cipher-id-t/int(i: mbedtls-block-cipher-id-t): int32
  match i
    MBEDTLS_BLOCK_CIPHER_ID_NONE -> 0.int32
    MBEDTLS_BLOCK_CIPHER_ID_AES -> 1.int32
    MBEDTLS_BLOCK_CIPHER_ID_CAMELLIA -> 2.int32
    MBEDTLS_BLOCK_CIPHER_ID_ARIA -> 3.int32

pub fun int/mbedtls-block-cipher-id-t(i: int32): exn mbedtls-block-cipher-id-t
  match i.int
    0 -> MBEDTLS_BLOCK_CIPHER_ID_NONE
    1 -> MBEDTLS_BLOCK_CIPHER_ID_AES
    2 -> MBEDTLS_BLOCK_CIPHER_ID_CAMELLIA
    3 -> MBEDTLS_BLOCK_CIPHER_ID_ARIA

// Used internally to indicate whether a context uses legacy or PSA.
// 
// Internal use only.
type mbedtls-block-cipher-engine-t
  MBEDTLS_BLOCK_CIPHER_ENGINE_LEGACY
  MBEDTLS_BLOCK_CIPHER_ENGINE_PSA

pub fun mbedtls-block-cipher-engine-t/int(i: mbedtls-block-cipher-engine-t): int32
  match i
    MBEDTLS_BLOCK_CIPHER_ENGINE_LEGACY -> 0.int32
    MBEDTLS_BLOCK_CIPHER_ENGINE_PSA -> 1.int32

pub fun int/mbedtls-block-cipher-engine-t(i: int32): exn mbedtls-block-cipher-engine-t
  match i.int
    0 -> MBEDTLS_BLOCK_CIPHER_ENGINE_LEGACY
    1 -> MBEDTLS_BLOCK_CIPHER_ENGINE_PSA

pub value struct mbedtls-block-cipher-context-t
  private-id: int
  private-ctx: unnamed-union11-c

pub type mbedtls-block-cipher-context-t-c
pub alias mbedtls-block-cipher-context-tp = c-pointer<mbedtls-block-cipher-context-t-c>
pub alias mbedtls-block-cipher-context-tc = owned-c<mbedtls-block-cipher-context-t-c>
pub alias mbedtls-block-cipher-context-tcb<s::S> = borrowed-c<s,mbedtls-block-cipher-context-t-c>
pub alias mbedtls-block-cipher-context-tca = owned-c<c-array<mbedtls-block-cipher-context-t-c>>

pub extern mbedtls-block-cipher-context-t/size-of(c: c-null<mbedtls-block-cipher-context-t-c>): int32
  c inline "sizeof(mbedtls_block_cipher_context_t)"

pub fun mbedtls-block-cipher-context-tc(): mbedtls-block-cipher-context-tc
  malloc(?size-of=mbedtls-block-cipher-context-t/size-of)

pub fun mbedtls-block-cipher-context-tc-calloc(): mbedtls-block-cipher-context-tc
  malloc-c(?size-of=mbedtls-block-cipher-context-t/size-of)

pub fun mbedtls-block-cipher-context-tc-array(n: int): mbedtls-block-cipher-context-tca
  malloc(n.int32, ?size-of=mbedtls-block-cipher-context-t/size-of)

pub fun mbedtls-block-cipher-context-tc-array-calloc(n: int): mbedtls-block-cipher-context-tca
  malloc-c(n.int32, ?size-of=mbedtls-block-cipher-context-t/size-of)

pub inline extern mbedtls-block-cipher-context-t-ptrraw/private-id(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_block_cipher_context_t*)#1)->private_id)"

pub inline fun mbedtls-block-cipher-context-tp/private-id(s: mbedtls-block-cipher-context-tp): <exn> mbedtls-block-cipher-id-t
  s.cextern/c-pointer/ptr.mbedtls-block-cipher-context-t-ptrraw/private-id.int/mbedtls-block-cipher-id-t

pub inline fun mbedtls-block-cipher-context-tc/private-id(^s: mbedtls-block-cipher-context-tc): <exn> mbedtls-block-cipher-id-t
  s.with-ptr(mbedtls-block-cipher-context-tp/private-id)

pub inline fun mbedtls-block-cipher-context-tcb/private-id(^s: mbedtls-block-cipher-context-tcb<s::S>): <exn> mbedtls-block-cipher-id-t
  s.with-ptr(mbedtls-block-cipher-context-tp/private-id)

pub inline extern mbedtls-block-cipher-context-t-ptrraw/set-private-id(s: intptr_t, private-id: int32): ()
  c inline "((mbedtls_block_cipher_context_t*)#1)->private_id = (int32_t)#2"

pub inline fun mbedtls-block-cipher-context-tp/set-private-id(s: mbedtls-block-cipher-context-tp, private-id: mbedtls-block-cipher-id-t): ()
  s.mbedtls-block-cipher-context-t-ptrraw/set-private-id(private-id.mbedtls-block-cipher-id-t/int)

pub inline fun mbedtls-block-cipher-context-tc/set-private-id(^s: mbedtls-block-cipher-context-tc, private-id: mbedtls-block-cipher-id-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-block-cipher-context-tp/set-private-id(private-id))

pub inline fun mbedtls-block-cipher-context-tcb/set-private-id(^s: mbedtls-block-cipher-context-tcb<s::S>, private-id: mbedtls-block-cipher-id-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-block-cipher-context-tp/set-private-id(private-id))

pub struct unnamed-union11
pub type unnamed-union11-c
pub alias unnamed-union11p = c-pointer<unnamed-union11-c>
pub alias unnamed-union11c = owned-c<unnamed-union11-c>
pub alias unnamed-union11cb<s::S> = borrowed-c<s,unnamed-union11-c>
pub alias unnamed-union11ca = owned-c<c-array<unnamed-union11-c>>

// \brief          Context for the default cookie functions.
pub value struct mbedtls-ssl-cookie-ctx
  // !< context for the HMAC portion
  private-hmac-ctx: mbedtls-md-context-t-c
  // !< timeout delay, in seconds if HAVE_TIME,
  // or in number of tickets issued
  private-timeout: int

pub type mbedtls-ssl-cookie-ctx-c
pub alias mbedtls-ssl-cookie-ctxp = c-pointer<mbedtls-ssl-cookie-ctx-c>
pub alias mbedtls-ssl-cookie-ctxc = owned-c<mbedtls-ssl-cookie-ctx-c>
pub alias mbedtls-ssl-cookie-ctxcb<s::S> = borrowed-c<s,mbedtls-ssl-cookie-ctx-c>
pub alias mbedtls-ssl-cookie-ctxca = owned-c<c-array<mbedtls-ssl-cookie-ctx-c>>

pub extern mbedtls-ssl-cookie-ctx/size-of(c: c-null<mbedtls-ssl-cookie-ctx-c>): int32
  c inline "sizeof(struct mbedtls_ssl_cookie_ctx)"

pub fun mbedtls-ssl-cookie-ctxc(): mbedtls-ssl-cookie-ctxc
  malloc(?size-of=mbedtls-ssl-cookie-ctx/size-of)

pub fun mbedtls-ssl-cookie-ctxc-calloc(): mbedtls-ssl-cookie-ctxc
  malloc-c(?size-of=mbedtls-ssl-cookie-ctx/size-of)

pub fun mbedtls-ssl-cookie-ctxc-array(n: int): mbedtls-ssl-cookie-ctxca
  malloc(n.int32, ?size-of=mbedtls-ssl-cookie-ctx/size-of)

pub fun mbedtls-ssl-cookie-ctxc-array-calloc(n: int): mbedtls-ssl-cookie-ctxca
  malloc-c(n.int32, ?size-of=mbedtls-ssl-cookie-ctx/size-of)

pub inline extern mbedtls-ssl-cookie-ctx-ptrraw/private-timeout(s: intptr_t): int64
  c inline "(unsigned long)(((struct mbedtls_ssl_cookie_ctx*)#1)->private_timeout)"

pub inline fun mbedtls-ssl-cookie-ctxp/private-timeout(s: mbedtls-ssl-cookie-ctxp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-cookie-ctx-ptrraw/private-timeout.int

pub inline fun mbedtls-ssl-cookie-ctxc/private-timeout(^s: mbedtls-ssl-cookie-ctxc): <> int
  s.with-ptr(mbedtls-ssl-cookie-ctxp/private-timeout)

pub inline fun mbedtls-ssl-cookie-ctxcb/private-timeout(^s: mbedtls-ssl-cookie-ctxcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cookie-ctxp/private-timeout)

pub inline extern mbedtls-ssl-cookie-ctx-ptrraw/set-private-timeout(s: intptr_t, private-timeout: int64): ()
  c inline "((struct mbedtls_ssl_cookie_ctx*)#1)->private_timeout = (unsigned long)#2"

pub inline fun mbedtls-ssl-cookie-ctxp/set-private-timeout(s: mbedtls-ssl-cookie-ctxp, private-timeout: int): ()
  s.mbedtls-ssl-cookie-ctx-ptrraw/set-private-timeout(private-timeout.int64)

pub inline fun mbedtls-ssl-cookie-ctxc/set-private-timeout(^s: mbedtls-ssl-cookie-ctxc, private-timeout: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cookie-ctxp/set-private-timeout(private-timeout))

pub inline fun mbedtls-ssl-cookie-ctxcb/set-private-timeout(^s: mbedtls-ssl-cookie-ctxcb<s::S>, private-timeout: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cookie-ctxp/set-private-timeout(private-timeout))

// \brief          The CTR_DRBG context structure.
pub struct mbedtls-ctr-drbg-context
pub type mbedtls-ctr-drbg-context-c
pub alias mbedtls-ctr-drbg-contextp = c-pointer<mbedtls-ctr-drbg-context-c>
pub alias mbedtls-ctr-drbg-contextc<s::S> = owned-c<mbedtls-ctr-drbg-context-c>
pub alias mbedtls-ctr-drbg-contextcb<s::S> = borrowed-c<s,mbedtls-ctr-drbg-context-c>
pub alias mbedtls-ctr-drbg-contextca<s::S> = owned-c<c-array<mbedtls-ctr-drbg-context-c>>

pub extern mbedtls-ctr-drbg-context/size-of(c: c-null<mbedtls-ctr-drbg-context-c>): int32
  c inline "sizeof(struct mbedtls_ctr_drbg_context)"

pub fun mbedtls-ctr-drbg-contextc(): mbedtls-ctr-drbg-contextc<s::S>
  malloc(?size-of=mbedtls-ctr-drbg-context/size-of)

pub fun mbedtls-ctr-drbg-contextc-calloc(): mbedtls-ctr-drbg-contextc<s::S>
  malloc-c(?size-of=mbedtls-ctr-drbg-context/size-of)

pub fun mbedtls-ctr-drbg-contextc-array(n: int): mbedtls-ctr-drbg-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ctr-drbg-context/size-of)

pub fun mbedtls-ctr-drbg-contextc-array-calloc(n: int): mbedtls-ctr-drbg-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ctr-drbg-context/size-of)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-counter(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ctr_drbg_context*)#1)->private_counter)"

pub inline fun mbedtls-ctr-drbg-contextp/private-counter(s: mbedtls-ctr-drbg-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-counter.cextern/ptr/carray

pub inline fun mbedtls-ctr-drbg-contextc/private-counter(^s: mbedtls-ctr-drbg-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-counter)

pub inline fun mbedtls-ctr-drbg-contextcb/private-counter(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-counter)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-counter(s: intptr_t, private-counter: c-pointer<int>): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_counter = (unsigned char*)#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-counter(s: mbedtls-ctr-drbg-contextp, private-counter: c-array<int>): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-counter(private-counter.cextern/carray/ptr)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-counter(^s: mbedtls-ctr-drbg-contextc<s::S>, private-counter: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-counter(private-counter))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-counter(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-counter: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-counter(private-counter))

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-reseed-counter(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ctr_drbg_context*)#1)->private_reseed_counter)"

pub inline fun mbedtls-ctr-drbg-contextp/private-reseed-counter(s: mbedtls-ctr-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-reseed-counter.int

pub inline fun mbedtls-ctr-drbg-contextc/private-reseed-counter(^s: mbedtls-ctr-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-reseed-counter)

pub inline fun mbedtls-ctr-drbg-contextcb/private-reseed-counter(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-reseed-counter)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-reseed-counter(s: intptr_t, private-reseed-counter: int32): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_reseed_counter = (int)#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-reseed-counter(s: mbedtls-ctr-drbg-contextp, private-reseed-counter: int): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-reseed-counter(private-reseed-counter.int32)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-reseed-counter(^s: mbedtls-ctr-drbg-contextc<s::S>, private-reseed-counter: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-reseed-counter(private-reseed-counter))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-reseed-counter(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-reseed-counter: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-reseed-counter(private-reseed-counter))

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-prediction-resistance(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ctr_drbg_context*)#1)->private_prediction_resistance)"

pub inline fun mbedtls-ctr-drbg-contextp/private-prediction-resistance(s: mbedtls-ctr-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-prediction-resistance.int

pub inline fun mbedtls-ctr-drbg-contextc/private-prediction-resistance(^s: mbedtls-ctr-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-prediction-resistance)

pub inline fun mbedtls-ctr-drbg-contextcb/private-prediction-resistance(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-prediction-resistance)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-prediction-resistance(s: intptr_t, private-prediction-resistance: int32): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_prediction_resistance = (int)#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-prediction-resistance(s: mbedtls-ctr-drbg-contextp, private-prediction-resistance: int): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-prediction-resistance(private-prediction-resistance.int32)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-prediction-resistance(^s: mbedtls-ctr-drbg-contextc<s::S>, private-prediction-resistance: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-prediction-resistance(private-prediction-resistance))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-prediction-resistance(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-prediction-resistance: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-prediction-resistance(private-prediction-resistance))

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-entropy-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ctr_drbg_context*)#1)->private_entropy_len)"

pub inline fun mbedtls-ctr-drbg-contextp/private-entropy-len(s: mbedtls-ctr-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-entropy-len.int

pub inline fun mbedtls-ctr-drbg-contextc/private-entropy-len(^s: mbedtls-ctr-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-entropy-len)

pub inline fun mbedtls-ctr-drbg-contextcb/private-entropy-len(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-entropy-len)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-entropy-len(s: intptr_t, private-entropy-len: ssize_t): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_entropy_len = (size_t)#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-entropy-len(s: mbedtls-ctr-drbg-contextp, private-entropy-len: int): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-entropy-len(private-entropy-len.ssize_t)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-entropy-len(^s: mbedtls-ctr-drbg-contextc<s::S>, private-entropy-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-entropy-len(private-entropy-len))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-entropy-len(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-entropy-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-entropy-len(private-entropy-len))

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-reseed-interval(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ctr_drbg_context*)#1)->private_reseed_interval)"

pub inline fun mbedtls-ctr-drbg-contextp/private-reseed-interval(s: mbedtls-ctr-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-reseed-interval.int

pub inline fun mbedtls-ctr-drbg-contextc/private-reseed-interval(^s: mbedtls-ctr-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-reseed-interval)

pub inline fun mbedtls-ctr-drbg-contextcb/private-reseed-interval(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-reseed-interval)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-reseed-interval(s: intptr_t, private-reseed-interval: int32): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_reseed_interval = (int)#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-reseed-interval(s: mbedtls-ctr-drbg-contextp, private-reseed-interval: int): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-reseed-interval(private-reseed-interval.int32)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-reseed-interval(^s: mbedtls-ctr-drbg-contextc<s::S>, private-reseed-interval: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-reseed-interval(private-reseed-interval))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-reseed-interval(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-reseed-interval: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-reseed-interval(private-reseed-interval))

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-f-entropy(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ctr_drbg_context*)#1)->private_f_entropy)"

pub inline fun mbedtls-ctr-drbg-contextp/private-f-entropy(s: mbedtls-ctr-drbg-contextp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-f-entropy

pub inline fun mbedtls-ctr-drbg-contextc/private-f-entropy(^s: mbedtls-ctr-drbg-contextc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-f-entropy)

pub inline fun mbedtls-ctr-drbg-contextcb/private-f-entropy(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-f-entropy)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-f-entropy(s: intptr_t, private-f-entropy: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_f_entropy = (int (*)(void*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-f-entropy(s: mbedtls-ctr-drbg-contextp, private-f-entropy: c-pointer<intptr_t>): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-f-entropy(private-f-entropy)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-f-entropy(^s: mbedtls-ctr-drbg-contextc<s::S>, private-f-entropy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-f-entropy(private-f-entropy))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-f-entropy(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-f-entropy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-f-entropy(private-f-entropy))

pub inline extern mbedtls-ctr-drbg-context-ptrraw/private-p-entropy(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ctr_drbg_context*)#1)->private_p_entropy)"

pub inline fun mbedtls-ctr-drbg-contextp/private-p-entropy(s: mbedtls-ctr-drbg-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ctr-drbg-context-ptrraw/private-p-entropy

pub inline fun mbedtls-ctr-drbg-contextc/private-p-entropy(^s: mbedtls-ctr-drbg-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-p-entropy)

pub inline fun mbedtls-ctr-drbg-contextcb/private-p-entropy(^s: mbedtls-ctr-drbg-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ctr-drbg-contextp/private-p-entropy)

pub inline extern mbedtls-ctr-drbg-context-ptrraw/set-private-p-entropy(s: intptr_t, private-p-entropy: c-pointer<()>): ()
  c inline "((struct mbedtls_ctr_drbg_context*)#1)->private_p_entropy = (void*)#2"

pub inline fun mbedtls-ctr-drbg-contextp/set-private-p-entropy(s: mbedtls-ctr-drbg-contextp, private-p-entropy: c-pointer<()>): ()
  s.mbedtls-ctr-drbg-context-ptrraw/set-private-p-entropy(private-p-entropy)

pub inline fun mbedtls-ctr-drbg-contextc/set-private-p-entropy(^s: mbedtls-ctr-drbg-contextc<s::S>, private-p-entropy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-p-entropy(private-p-entropy))

pub inline fun mbedtls-ctr-drbg-contextcb/set-private-p-entropy(^s: mbedtls-ctr-drbg-contextcb<s::S>, private-p-entropy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ctr-drbg-contextp/set-private-p-entropy(private-p-entropy))

// \brief          DES context structure
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub struct mbedtls-des-context
pub type mbedtls-des-context-c
pub alias mbedtls-des-contextp = c-pointer<mbedtls-des-context-c>
pub alias mbedtls-des-contextc<s::S> = owned-c<mbedtls-des-context-c>
pub alias mbedtls-des-contextcb<s::S> = borrowed-c<s,mbedtls-des-context-c>
pub alias mbedtls-des-contextca<s::S> = owned-c<c-array<mbedtls-des-context-c>>

pub extern mbedtls-des-context/size-of(c: c-null<mbedtls-des-context-c>): int32
  c inline "sizeof(struct mbedtls_des_context)"

pub fun mbedtls-des-contextc(): mbedtls-des-contextc<s::S>
  malloc(?size-of=mbedtls-des-context/size-of)

pub fun mbedtls-des-contextc-calloc(): mbedtls-des-contextc<s::S>
  malloc-c(?size-of=mbedtls-des-context/size-of)

pub fun mbedtls-des-contextc-array(n: int): mbedtls-des-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-des-context/size-of)

pub fun mbedtls-des-contextc-array-calloc(n: int): mbedtls-des-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-des-context/size-of)

pub inline extern mbedtls-des-context-ptrraw/private-sk(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_des_context*)#1)->private_sk)"

pub inline fun mbedtls-des-contextp/private-sk(s: mbedtls-des-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-des-context-ptrraw/private-sk.cextern/ptr/carray

pub inline fun mbedtls-des-contextc/private-sk(^s: mbedtls-des-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-des-contextp/private-sk)

pub inline fun mbedtls-des-contextcb/private-sk(^s: mbedtls-des-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-des-contextp/private-sk)

pub inline extern mbedtls-des-context-ptrraw/set-private-sk(s: intptr_t, private-sk: c-pointer<int>): ()
  c inline "((struct mbedtls_des_context*)#1)->private_sk = (int32_t*)#2"

pub inline fun mbedtls-des-contextp/set-private-sk(s: mbedtls-des-contextp, private-sk: c-array<int>): ()
  s.mbedtls-des-context-ptrraw/set-private-sk(private-sk.cextern/carray/ptr)

pub inline fun mbedtls-des-contextc/set-private-sk(^s: mbedtls-des-contextc<s::S>, private-sk: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-des-contextp/set-private-sk(private-sk))

pub inline fun mbedtls-des-contextcb/set-private-sk(^s: mbedtls-des-contextcb<s::S>, private-sk: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-des-contextp/set-private-sk(private-sk))

// \brief          Triple-DES context structure
// 
// \warning        DES/3DES are considered weak ciphers and their use constitutes a
// security risk. We recommend considering stronger ciphers
// instead.
pub struct mbedtls-des3-context
pub type mbedtls-des3-context-c
pub alias mbedtls-des3-contextp = c-pointer<mbedtls-des3-context-c>
pub alias mbedtls-des3-contextc<s::S> = owned-c<mbedtls-des3-context-c>
pub alias mbedtls-des3-contextcb<s::S> = borrowed-c<s,mbedtls-des3-context-c>
pub alias mbedtls-des3-contextca<s::S> = owned-c<c-array<mbedtls-des3-context-c>>

pub extern mbedtls-des3-context/size-of(c: c-null<mbedtls-des3-context-c>): int32
  c inline "sizeof(struct mbedtls_des3_context)"

pub fun mbedtls-des3-contextc(): mbedtls-des3-contextc<s::S>
  malloc(?size-of=mbedtls-des3-context/size-of)

pub fun mbedtls-des3-contextc-calloc(): mbedtls-des3-contextc<s::S>
  malloc-c(?size-of=mbedtls-des3-context/size-of)

pub fun mbedtls-des3-contextc-array(n: int): mbedtls-des3-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-des3-context/size-of)

pub fun mbedtls-des3-contextc-array-calloc(n: int): mbedtls-des3-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-des3-context/size-of)

pub inline extern mbedtls-des3-context-ptrraw/private-sk(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_des3_context*)#1)->private_sk)"

pub inline fun mbedtls-des3-contextp/private-sk(s: mbedtls-des3-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-des3-context-ptrraw/private-sk.cextern/ptr/carray

pub inline fun mbedtls-des3-contextc/private-sk(^s: mbedtls-des3-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-des3-contextp/private-sk)

pub inline fun mbedtls-des3-contextcb/private-sk(^s: mbedtls-des3-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-des3-contextp/private-sk)

pub inline extern mbedtls-des3-context-ptrraw/set-private-sk(s: intptr_t, private-sk: c-pointer<int>): ()
  c inline "((struct mbedtls_des3_context*)#1)->private_sk = (int32_t*)#2"

pub inline fun mbedtls-des3-contextp/set-private-sk(s: mbedtls-des3-contextp, private-sk: c-array<int>): ()
  s.mbedtls-des3-context-ptrraw/set-private-sk(private-sk.cextern/carray/ptr)

pub inline fun mbedtls-des3-contextc/set-private-sk(^s: mbedtls-des3-contextc<s::S>, private-sk: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-des3-contextp/set-private-sk(private-sk))

pub inline fun mbedtls-des3-contextcb/set-private-sk(^s: mbedtls-des3-contextcb<s::S>, private-sk: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-des3-contextp/set-private-sk(private-sk))

// The type of PSA elliptic curve family identifiers.
// 
// Values of this type are generally constructed by macros called
// `PSA_ECC_FAMILY_xxx`.
// 
// The curve identifier is required to create an ECC key using the
// PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()
// macros.
// 
// Values defined by this standard will never be in the range 0x80-0xff.
// Vendors who define additional families must use an encoding in this range.
// 
// \note Values of this type are encoded in the persistent key store.
// Any changes to existing values will require bumping the storage
// format version and providing a translation when reading the old
// format.
alias psa-ecc-family-t = int
// HMAC_DRBG context.
pub struct mbedtls-hmac-drbg-context
pub type mbedtls-hmac-drbg-context-c
pub alias mbedtls-hmac-drbg-contextp = c-pointer<mbedtls-hmac-drbg-context-c>
pub alias mbedtls-hmac-drbg-contextc<s::S> = owned-c<mbedtls-hmac-drbg-context-c>
pub alias mbedtls-hmac-drbg-contextcb<s::S> = borrowed-c<s,mbedtls-hmac-drbg-context-c>
pub alias mbedtls-hmac-drbg-contextca<s::S> = owned-c<c-array<mbedtls-hmac-drbg-context-c>>

pub extern mbedtls-hmac-drbg-context/size-of(c: c-null<mbedtls-hmac-drbg-context-c>): int32
  c inline "sizeof(struct mbedtls_hmac_drbg_context)"

pub fun mbedtls-hmac-drbg-contextc(): mbedtls-hmac-drbg-contextc<s::S>
  malloc(?size-of=mbedtls-hmac-drbg-context/size-of)

pub fun mbedtls-hmac-drbg-contextc-calloc(): mbedtls-hmac-drbg-contextc<s::S>
  malloc-c(?size-of=mbedtls-hmac-drbg-context/size-of)

pub fun mbedtls-hmac-drbg-contextc-array(n: int): mbedtls-hmac-drbg-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-hmac-drbg-context/size-of)

pub fun mbedtls-hmac-drbg-contextc-array-calloc(n: int): mbedtls-hmac-drbg-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-hmac-drbg-context/size-of)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-v(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_hmac_drbg_context*)#1)->private_V)"

pub inline fun mbedtls-hmac-drbg-contextp/private-v(s: mbedtls-hmac-drbg-contextp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-v.cextern/ptr/carray

pub inline fun mbedtls-hmac-drbg-contextc/private-v(^s: mbedtls-hmac-drbg-contextc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-v)

pub inline fun mbedtls-hmac-drbg-contextcb/private-v(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-v)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-v(s: intptr_t, private-v: c-pointer<int>): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_V = (unsigned char*)#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-v(s: mbedtls-hmac-drbg-contextp, private-v: c-array<int>): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-v(private-v.cextern/carray/ptr)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-v(^s: mbedtls-hmac-drbg-contextc<s::S>, private-v: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-v(private-v))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-v(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-v: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-v(private-v))

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-reseed-counter(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_hmac_drbg_context*)#1)->private_reseed_counter)"

pub inline fun mbedtls-hmac-drbg-contextp/private-reseed-counter(s: mbedtls-hmac-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-reseed-counter.int

pub inline fun mbedtls-hmac-drbg-contextc/private-reseed-counter(^s: mbedtls-hmac-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-reseed-counter)

pub inline fun mbedtls-hmac-drbg-contextcb/private-reseed-counter(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-reseed-counter)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-reseed-counter(s: intptr_t, private-reseed-counter: int32): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_reseed_counter = (int)#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-reseed-counter(s: mbedtls-hmac-drbg-contextp, private-reseed-counter: int): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-reseed-counter(private-reseed-counter.int32)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-reseed-counter(^s: mbedtls-hmac-drbg-contextc<s::S>, private-reseed-counter: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-reseed-counter(private-reseed-counter))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-reseed-counter(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-reseed-counter: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-reseed-counter(private-reseed-counter))

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-entropy-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_hmac_drbg_context*)#1)->private_entropy_len)"

pub inline fun mbedtls-hmac-drbg-contextp/private-entropy-len(s: mbedtls-hmac-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-entropy-len.int

pub inline fun mbedtls-hmac-drbg-contextc/private-entropy-len(^s: mbedtls-hmac-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-entropy-len)

pub inline fun mbedtls-hmac-drbg-contextcb/private-entropy-len(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-entropy-len)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-entropy-len(s: intptr_t, private-entropy-len: ssize_t): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_entropy_len = (size_t)#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-entropy-len(s: mbedtls-hmac-drbg-contextp, private-entropy-len: int): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-entropy-len(private-entropy-len.ssize_t)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-entropy-len(^s: mbedtls-hmac-drbg-contextc<s::S>, private-entropy-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-entropy-len(private-entropy-len))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-entropy-len(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-entropy-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-entropy-len(private-entropy-len))

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-prediction-resistance(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_hmac_drbg_context*)#1)->private_prediction_resistance)"

pub inline fun mbedtls-hmac-drbg-contextp/private-prediction-resistance(s: mbedtls-hmac-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-prediction-resistance.int

pub inline fun mbedtls-hmac-drbg-contextc/private-prediction-resistance(^s: mbedtls-hmac-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-prediction-resistance)

pub inline fun mbedtls-hmac-drbg-contextcb/private-prediction-resistance(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-prediction-resistance)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-prediction-resistance(s: intptr_t, private-prediction-resistance: int32): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_prediction_resistance = (int)#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-prediction-resistance(s: mbedtls-hmac-drbg-contextp, private-prediction-resistance: int): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-prediction-resistance(private-prediction-resistance.int32)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-prediction-resistance(^s: mbedtls-hmac-drbg-contextc<s::S>, private-prediction-resistance: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-prediction-resistance(private-prediction-resistance))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-prediction-resistance(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-prediction-resistance: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-prediction-resistance(private-prediction-resistance))

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-reseed-interval(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_hmac_drbg_context*)#1)->private_reseed_interval)"

pub inline fun mbedtls-hmac-drbg-contextp/private-reseed-interval(s: mbedtls-hmac-drbg-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-reseed-interval.int

pub inline fun mbedtls-hmac-drbg-contextc/private-reseed-interval(^s: mbedtls-hmac-drbg-contextc<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-reseed-interval)

pub inline fun mbedtls-hmac-drbg-contextcb/private-reseed-interval(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-reseed-interval)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-reseed-interval(s: intptr_t, private-reseed-interval: int32): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_reseed_interval = (int)#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-reseed-interval(s: mbedtls-hmac-drbg-contextp, private-reseed-interval: int): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-reseed-interval(private-reseed-interval.int32)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-reseed-interval(^s: mbedtls-hmac-drbg-contextc<s::S>, private-reseed-interval: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-reseed-interval(private-reseed-interval))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-reseed-interval(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-reseed-interval: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-reseed-interval(private-reseed-interval))

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-f-entropy(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_hmac_drbg_context*)#1)->private_f_entropy)"

pub inline fun mbedtls-hmac-drbg-contextp/private-f-entropy(s: mbedtls-hmac-drbg-contextp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-f-entropy

pub inline fun mbedtls-hmac-drbg-contextc/private-f-entropy(^s: mbedtls-hmac-drbg-contextc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-f-entropy)

pub inline fun mbedtls-hmac-drbg-contextcb/private-f-entropy(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-f-entropy)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-f-entropy(s: intptr_t, private-f-entropy: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_f_entropy = (int (*)(void*, unsigned char*, size_t))#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-f-entropy(s: mbedtls-hmac-drbg-contextp, private-f-entropy: c-pointer<intptr_t>): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-f-entropy(private-f-entropy)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-f-entropy(^s: mbedtls-hmac-drbg-contextc<s::S>, private-f-entropy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-f-entropy(private-f-entropy))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-f-entropy(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-f-entropy: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-f-entropy(private-f-entropy))

pub inline extern mbedtls-hmac-drbg-context-ptrraw/private-p-entropy(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_hmac_drbg_context*)#1)->private_p_entropy)"

pub inline fun mbedtls-hmac-drbg-contextp/private-p-entropy(s: mbedtls-hmac-drbg-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-hmac-drbg-context-ptrraw/private-p-entropy

pub inline fun mbedtls-hmac-drbg-contextc/private-p-entropy(^s: mbedtls-hmac-drbg-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-p-entropy)

pub inline fun mbedtls-hmac-drbg-contextcb/private-p-entropy(^s: mbedtls-hmac-drbg-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-hmac-drbg-contextp/private-p-entropy)

pub inline extern mbedtls-hmac-drbg-context-ptrraw/set-private-p-entropy(s: intptr_t, private-p-entropy: c-pointer<()>): ()
  c inline "((struct mbedtls_hmac_drbg_context*)#1)->private_p_entropy = (void*)#2"

pub inline fun mbedtls-hmac-drbg-contextp/set-private-p-entropy(s: mbedtls-hmac-drbg-contextp, private-p-entropy: c-pointer<()>): ()
  s.mbedtls-hmac-drbg-context-ptrraw/set-private-p-entropy(private-p-entropy)

pub inline fun mbedtls-hmac-drbg-contextc/set-private-p-entropy(^s: mbedtls-hmac-drbg-contextc<s::S>, private-p-entropy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-p-entropy(private-p-entropy))

pub inline fun mbedtls-hmac-drbg-contextcb/set-private-p-entropy(^s: mbedtls-hmac-drbg-contextcb<s::S>, private-p-entropy: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-hmac-drbg-contextp/set-private-p-entropy(private-p-entropy))

// \brief   Information for session ticket protection
pub struct mbedtls-ssl-ticket-key
pub type mbedtls-ssl-ticket-key-c
pub alias mbedtls-ssl-ticket-keyp = c-pointer<mbedtls-ssl-ticket-key-c>
pub alias mbedtls-ssl-ticket-keyc<s::S> = owned-c<mbedtls-ssl-ticket-key-c>
pub alias mbedtls-ssl-ticket-keycb<s::S> = borrowed-c<s,mbedtls-ssl-ticket-key-c>
pub alias mbedtls-ssl-ticket-keyca<s::S> = owned-c<c-array<mbedtls-ssl-ticket-key-c>>

pub extern mbedtls-ssl-ticket-key/size-of(c: c-null<mbedtls-ssl-ticket-key-c>): int32
  c inline "sizeof(struct mbedtls_ssl_ticket_key)"

pub fun mbedtls-ssl-ticket-keyc(): mbedtls-ssl-ticket-keyc<s::S>
  malloc(?size-of=mbedtls-ssl-ticket-key/size-of)

pub fun mbedtls-ssl-ticket-keyc-calloc(): mbedtls-ssl-ticket-keyc<s::S>
  malloc-c(?size-of=mbedtls-ssl-ticket-key/size-of)

pub fun mbedtls-ssl-ticket-keyc-array(n: int): mbedtls-ssl-ticket-keyca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-ticket-key/size-of)

pub fun mbedtls-ssl-ticket-keyc-array-calloc(n: int): mbedtls-ssl-ticket-keyca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-ticket-key/size-of)

pub inline extern mbedtls-ssl-ticket-key-ptrraw/private-name(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_ticket_key*)#1)->private_name)"

pub inline fun mbedtls-ssl-ticket-keyp/private-name(s: mbedtls-ssl-ticket-keyp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-key-ptrraw/private-name.cextern/ptr/carray

pub inline fun mbedtls-ssl-ticket-keyc/private-name(^s: mbedtls-ssl-ticket-keyc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-ticket-keyp/private-name)

pub inline fun mbedtls-ssl-ticket-keycb/private-name(^s: mbedtls-ssl-ticket-keycb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-ticket-keyp/private-name)

pub inline extern mbedtls-ssl-ticket-key-ptrraw/set-private-name(s: intptr_t, private-name: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_ticket_key*)#1)->private_name = (unsigned char*)#2"

pub inline fun mbedtls-ssl-ticket-keyp/set-private-name(s: mbedtls-ssl-ticket-keyp, private-name: c-array<int>): ()
  s.mbedtls-ssl-ticket-key-ptrraw/set-private-name(private-name.cextern/carray/ptr)

pub inline fun mbedtls-ssl-ticket-keyc/set-private-name(^s: mbedtls-ssl-ticket-keyc<s::S>, private-name: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-keyp/set-private-name(private-name))

pub inline fun mbedtls-ssl-ticket-keycb/set-private-name(^s: mbedtls-ssl-ticket-keycb<s::S>, private-name: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-keyp/set-private-name(private-name))

pub inline extern mbedtls-ssl-ticket-key-ptrraw/private-generation-time(s: intptr_t): int64
  c inline "(mbedtls_time_t)(((struct mbedtls_ssl_ticket_key*)#1)->private_generation_time)"

pub inline fun mbedtls-ssl-ticket-keyp/private-generation-time(s: mbedtls-ssl-ticket-keyp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-key-ptrraw/private-generation-time.int

pub inline fun mbedtls-ssl-ticket-keyc/private-generation-time(^s: mbedtls-ssl-ticket-keyc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-keyp/private-generation-time)

pub inline fun mbedtls-ssl-ticket-keycb/private-generation-time(^s: mbedtls-ssl-ticket-keycb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-keyp/private-generation-time)

pub inline extern mbedtls-ssl-ticket-key-ptrraw/set-private-generation-time(s: intptr_t, private-generation-time: int64): ()
  c inline "((struct mbedtls_ssl_ticket_key*)#1)->private_generation_time = (mbedtls_time_t)#2"

pub inline fun mbedtls-ssl-ticket-keyp/set-private-generation-time(s: mbedtls-ssl-ticket-keyp, private-generation-time: int): ()
  s.mbedtls-ssl-ticket-key-ptrraw/set-private-generation-time(private-generation-time.int64)

pub inline fun mbedtls-ssl-ticket-keyc/set-private-generation-time(^s: mbedtls-ssl-ticket-keyc<s::S>, private-generation-time: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-keyp/set-private-generation-time(private-generation-time))

pub inline fun mbedtls-ssl-ticket-keycb/set-private-generation-time(^s: mbedtls-ssl-ticket-keycb<s::S>, private-generation-time: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-keyp/set-private-generation-time(private-generation-time))

pub inline extern mbedtls-ssl-ticket-key-ptrraw/private-lifetime(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_ticket_key*)#1)->private_lifetime)"

pub inline fun mbedtls-ssl-ticket-keyp/private-lifetime(s: mbedtls-ssl-ticket-keyp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-key-ptrraw/private-lifetime.int

pub inline fun mbedtls-ssl-ticket-keyc/private-lifetime(^s: mbedtls-ssl-ticket-keyc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-keyp/private-lifetime)

pub inline fun mbedtls-ssl-ticket-keycb/private-lifetime(^s: mbedtls-ssl-ticket-keycb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-keyp/private-lifetime)

pub inline extern mbedtls-ssl-ticket-key-ptrraw/set-private-lifetime(s: intptr_t, private-lifetime: int32): ()
  c inline "((struct mbedtls_ssl_ticket_key*)#1)->private_lifetime = (int32_t)#2"

pub inline fun mbedtls-ssl-ticket-keyp/set-private-lifetime(s: mbedtls-ssl-ticket-keyp, private-lifetime: int): ()
  s.mbedtls-ssl-ticket-key-ptrraw/set-private-lifetime(private-lifetime.int32)

pub inline fun mbedtls-ssl-ticket-keyc/set-private-lifetime(^s: mbedtls-ssl-ticket-keyc<s::S>, private-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-keyp/set-private-lifetime(private-lifetime))

pub inline fun mbedtls-ssl-ticket-keycb/set-private-lifetime(^s: mbedtls-ssl-ticket-keycb<s::S>, private-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-keyp/set-private-lifetime(private-lifetime))

// \brief   Context for session ticket handling functions
pub struct mbedtls-ssl-ticket-context
pub type mbedtls-ssl-ticket-context-c
pub alias mbedtls-ssl-ticket-contextp = c-pointer<mbedtls-ssl-ticket-context-c>
pub alias mbedtls-ssl-ticket-contextc<s::S> = owned-c<mbedtls-ssl-ticket-context-c>
pub alias mbedtls-ssl-ticket-contextcb<s::S> = borrowed-c<s,mbedtls-ssl-ticket-context-c>
pub alias mbedtls-ssl-ticket-contextca<s::S> = owned-c<c-array<mbedtls-ssl-ticket-context-c>>

pub extern mbedtls-ssl-ticket-context/size-of(c: c-null<mbedtls-ssl-ticket-context-c>): int32
  c inline "sizeof(struct mbedtls_ssl_ticket_context)"

pub fun mbedtls-ssl-ticket-contextc(): mbedtls-ssl-ticket-contextc<s::S>
  malloc(?size-of=mbedtls-ssl-ticket-context/size-of)

pub fun mbedtls-ssl-ticket-contextc-calloc(): mbedtls-ssl-ticket-contextc<s::S>
  malloc-c(?size-of=mbedtls-ssl-ticket-context/size-of)

pub fun mbedtls-ssl-ticket-contextc-array(n: int): mbedtls-ssl-ticket-contextca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-ticket-context/size-of)

pub fun mbedtls-ssl-ticket-contextc-array-calloc(n: int): mbedtls-ssl-ticket-contextca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-ticket-context/size-of)

pub inline extern mbedtls-ssl-ticket-context-ptrraw/private-keys(s: intptr_t): c-pointer<mbedtls-ssl-ticket-key-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_ticket_context*)#1)->private_keys)"

pub inline fun mbedtls-ssl-ticket-contextp/private-keys(s: mbedtls-ssl-ticket-contextp): <> c-array<mbedtls-ssl-ticket-key-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-context-ptrraw/private-keys.cextern/ptr/carray

pub inline fun mbedtls-ssl-ticket-contextc/private-keys(^s: mbedtls-ssl-ticket-contextc<s::S>): <> c-array<mbedtls-ssl-ticket-key-c>
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-keys)

pub inline fun mbedtls-ssl-ticket-contextcb/private-keys(^s: mbedtls-ssl-ticket-contextcb<s::S>): <> c-array<mbedtls-ssl-ticket-key-c>
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-keys)

pub inline extern mbedtls-ssl-ticket-context-ptrraw/set-private-keys(s: intptr_t, private-keys: c-pointer<mbedtls-ssl-ticket-key-c>): ()
  c inline "((struct mbedtls_ssl_ticket_context*)#1)->private_keys = (struct mbedtls_ssl_ticket_key*)#2"

pub inline fun mbedtls-ssl-ticket-contextp/set-private-keys(s: mbedtls-ssl-ticket-contextp, private-keys: c-array<mbedtls-ssl-ticket-key-c>): ()
  s.mbedtls-ssl-ticket-context-ptrraw/set-private-keys(private-keys.cextern/carray/ptr)

pub inline fun mbedtls-ssl-ticket-contextc/set-private-keys(^s: mbedtls-ssl-ticket-contextc<s::S>, private-keys: c-array<mbedtls-ssl-ticket-key-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-keys(private-keys))

pub inline fun mbedtls-ssl-ticket-contextcb/set-private-keys(^s: mbedtls-ssl-ticket-contextcb<s::S>, private-keys: c-array<mbedtls-ssl-ticket-key-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-keys(private-keys))

pub inline extern mbedtls-ssl-ticket-context-ptrraw/private-active(s: intptr_t): int8
  c inline "(unsigned char)(((struct mbedtls_ssl_ticket_context*)#1)->private_active)"

pub inline fun mbedtls-ssl-ticket-contextp/private-active(s: mbedtls-ssl-ticket-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-context-ptrraw/private-active.int

pub inline fun mbedtls-ssl-ticket-contextc/private-active(^s: mbedtls-ssl-ticket-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-active)

pub inline fun mbedtls-ssl-ticket-contextcb/private-active(^s: mbedtls-ssl-ticket-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-active)

pub inline extern mbedtls-ssl-ticket-context-ptrraw/set-private-active(s: intptr_t, private-active: int8): ()
  c inline "((struct mbedtls_ssl_ticket_context*)#1)->private_active = (unsigned char)#2"

pub inline fun mbedtls-ssl-ticket-contextp/set-private-active(s: mbedtls-ssl-ticket-contextp, private-active: int): ()
  s.mbedtls-ssl-ticket-context-ptrraw/set-private-active(private-active.int8)

pub inline fun mbedtls-ssl-ticket-contextc/set-private-active(^s: mbedtls-ssl-ticket-contextc<s::S>, private-active: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-active(private-active))

pub inline fun mbedtls-ssl-ticket-contextcb/set-private-active(^s: mbedtls-ssl-ticket-contextcb<s::S>, private-active: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-active(private-active))

pub inline extern mbedtls-ssl-ticket-context-ptrraw/private-ticket-lifetime(s: intptr_t): int32
  c inline "(int32_t)(((struct mbedtls_ssl_ticket_context*)#1)->private_ticket_lifetime)"

pub inline fun mbedtls-ssl-ticket-contextp/private-ticket-lifetime(s: mbedtls-ssl-ticket-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-context-ptrraw/private-ticket-lifetime.int

pub inline fun mbedtls-ssl-ticket-contextc/private-ticket-lifetime(^s: mbedtls-ssl-ticket-contextc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-ticket-lifetime)

pub inline fun mbedtls-ssl-ticket-contextcb/private-ticket-lifetime(^s: mbedtls-ssl-ticket-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-ticket-lifetime)

pub inline extern mbedtls-ssl-ticket-context-ptrraw/set-private-ticket-lifetime(s: intptr_t, private-ticket-lifetime: int32): ()
  c inline "((struct mbedtls_ssl_ticket_context*)#1)->private_ticket_lifetime = (int32_t)#2"

pub inline fun mbedtls-ssl-ticket-contextp/set-private-ticket-lifetime(s: mbedtls-ssl-ticket-contextp, private-ticket-lifetime: int): ()
  s.mbedtls-ssl-ticket-context-ptrraw/set-private-ticket-lifetime(private-ticket-lifetime.int32)

pub inline fun mbedtls-ssl-ticket-contextc/set-private-ticket-lifetime(^s: mbedtls-ssl-ticket-contextc<s::S>, private-ticket-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-ticket-lifetime(private-ticket-lifetime))

pub inline fun mbedtls-ssl-ticket-contextcb/set-private-ticket-lifetime(^s: mbedtls-ssl-ticket-contextcb<s::S>, private-ticket-lifetime: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-ticket-lifetime(private-ticket-lifetime))

pub inline extern mbedtls-ssl-ticket-context-ptrraw/private-f-rng(s: intptr_t): c-pointer<intptr_t>
  c inline "(intptr_t)(((struct mbedtls_ssl_ticket_context*)#1)->private_f_rng)"

pub inline fun mbedtls-ssl-ticket-contextp/private-f-rng(s: mbedtls-ssl-ticket-contextp): <> c-pointer<intptr_t>
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-context-ptrraw/private-f-rng

pub inline fun mbedtls-ssl-ticket-contextc/private-f-rng(^s: mbedtls-ssl-ticket-contextc<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-f-rng)

pub inline fun mbedtls-ssl-ticket-contextcb/private-f-rng(^s: mbedtls-ssl-ticket-contextcb<s::S>): <> c-pointer<intptr_t>
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-f-rng)

pub inline extern mbedtls-ssl-ticket-context-ptrraw/set-private-f-rng(s: intptr_t, private-f-rng: c-pointer<intptr_t>): ()
  c inline "((struct mbedtls_ssl_ticket_context*)#1)->private_f_rng = (int (*)(void*, unsigned char*, size_t))#2"

pub inline fun mbedtls-ssl-ticket-contextp/set-private-f-rng(s: mbedtls-ssl-ticket-contextp, private-f-rng: c-pointer<intptr_t>): ()
  s.mbedtls-ssl-ticket-context-ptrraw/set-private-f-rng(private-f-rng)

pub inline fun mbedtls-ssl-ticket-contextc/set-private-f-rng(^s: mbedtls-ssl-ticket-contextc<s::S>, private-f-rng: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-f-rng(private-f-rng))

pub inline fun mbedtls-ssl-ticket-contextcb/set-private-f-rng(^s: mbedtls-ssl-ticket-contextcb<s::S>, private-f-rng: c-pointer<intptr_t>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-f-rng(private-f-rng))

pub inline extern mbedtls-ssl-ticket-context-ptrraw/private-p-rng(s: intptr_t): c-pointer<()>
  c inline "(intptr_t)(((struct mbedtls_ssl_ticket_context*)#1)->private_p_rng)"

pub inline fun mbedtls-ssl-ticket-contextp/private-p-rng(s: mbedtls-ssl-ticket-contextp): <> c-pointer<()>
  s.cextern/c-pointer/ptr.mbedtls-ssl-ticket-context-ptrraw/private-p-rng

pub inline fun mbedtls-ssl-ticket-contextc/private-p-rng(^s: mbedtls-ssl-ticket-contextc<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-p-rng)

pub inline fun mbedtls-ssl-ticket-contextcb/private-p-rng(^s: mbedtls-ssl-ticket-contextcb<s::S>): <> c-pointer<()>
  s.with-ptr(mbedtls-ssl-ticket-contextp/private-p-rng)

pub inline extern mbedtls-ssl-ticket-context-ptrraw/set-private-p-rng(s: intptr_t, private-p-rng: c-pointer<()>): ()
  c inline "((struct mbedtls_ssl_ticket_context*)#1)->private_p_rng = (void*)#2"

pub inline fun mbedtls-ssl-ticket-contextp/set-private-p-rng(s: mbedtls-ssl-ticket-contextp, private-p-rng: c-pointer<()>): ()
  s.mbedtls-ssl-ticket-context-ptrraw/set-private-p-rng(private-p-rng)

pub inline fun mbedtls-ssl-ticket-contextc/set-private-p-rng(^s: mbedtls-ssl-ticket-contextc<s::S>, private-p-rng: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-p-rng(private-p-rng))

pub inline fun mbedtls-ssl-ticket-contextcb/set-private-p-rng(^s: mbedtls-ssl-ticket-contextcb<s::S>, private-p-rng: c-pointer<()>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-ticket-contextp/set-private-p-rng(private-p-rng))

// \brief Cache context
pub value struct mbedtls-ssl-cache-context
  // !< start of the chain
  private-chain: mbedtls-ssl-cache-entry-c
  // !< cache entry timeout
  private-timeout: int
  // !< maximum entries
  private-max-entries: int

pub type mbedtls-ssl-cache-context-c
pub alias mbedtls-ssl-cache-contextp = c-pointer<mbedtls-ssl-cache-context-c>
pub alias mbedtls-ssl-cache-contextc = owned-c<mbedtls-ssl-cache-context-c>
pub alias mbedtls-ssl-cache-contextcb<s::S> = borrowed-c<s,mbedtls-ssl-cache-context-c>
pub alias mbedtls-ssl-cache-contextca = owned-c<c-array<mbedtls-ssl-cache-context-c>>

pub extern mbedtls-ssl-cache-context/size-of(c: c-null<mbedtls-ssl-cache-context-c>): int32
  c inline "sizeof(struct mbedtls_ssl_cache_context)"

pub fun mbedtls-ssl-cache-contextc(): mbedtls-ssl-cache-contextc
  malloc(?size-of=mbedtls-ssl-cache-context/size-of)

pub fun mbedtls-ssl-cache-contextc-calloc(): mbedtls-ssl-cache-contextc
  malloc-c(?size-of=mbedtls-ssl-cache-context/size-of)

pub fun mbedtls-ssl-cache-contextc-array(n: int): mbedtls-ssl-cache-contextca
  malloc(n.int32, ?size-of=mbedtls-ssl-cache-context/size-of)

pub fun mbedtls-ssl-cache-contextc-array-calloc(n: int): mbedtls-ssl-cache-contextca
  malloc-c(n.int32, ?size-of=mbedtls-ssl-cache-context/size-of)

pub inline extern mbedtls-ssl-cache-context-ptrraw/private-chain(s: intptr_t): c-pointer<mbedtls-ssl-cache-entry-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_cache_context*)#1)->private_chain)"

pub inline fun mbedtls-ssl-cache-contextp/private-chain(s: mbedtls-ssl-cache-contextp): <> c-pointer<mbedtls-ssl-cache-entry-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-context-ptrraw/private-chain

pub inline fun mbedtls-ssl-cache-contextc/private-chain(^s: mbedtls-ssl-cache-contextc): <> c-pointer<mbedtls-ssl-cache-entry-c>
  s.with-ptr(mbedtls-ssl-cache-contextp/private-chain)

pub inline fun mbedtls-ssl-cache-contextcb/private-chain(^s: mbedtls-ssl-cache-contextcb<s::S>): <> c-pointer<mbedtls-ssl-cache-entry-c>
  s.with-ptr(mbedtls-ssl-cache-contextp/private-chain)

pub inline extern mbedtls-ssl-cache-context-ptrraw/set-private-chain(s: intptr_t, private-chain: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  c inline "((struct mbedtls_ssl_cache_context*)#1)->private_chain = (struct mbedtls_ssl_cache_entry*)#2"

pub inline fun mbedtls-ssl-cache-contextp/set-private-chain(s: mbedtls-ssl-cache-contextp, private-chain: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  s.mbedtls-ssl-cache-context-ptrraw/set-private-chain(private-chain)

pub inline fun mbedtls-ssl-cache-contextc/set-private-chain(^s: mbedtls-ssl-cache-contextc, private-chain: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-contextp/set-private-chain(private-chain))

pub inline fun mbedtls-ssl-cache-contextcb/set-private-chain(^s: mbedtls-ssl-cache-contextcb<s::S>, private-chain: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-contextp/set-private-chain(private-chain))

pub inline extern mbedtls-ssl-cache-context-ptrraw/private-timeout(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_cache_context*)#1)->private_timeout)"

pub inline fun mbedtls-ssl-cache-contextp/private-timeout(s: mbedtls-ssl-cache-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-context-ptrraw/private-timeout.int

pub inline fun mbedtls-ssl-cache-contextc/private-timeout(^s: mbedtls-ssl-cache-contextc): <> int
  s.with-ptr(mbedtls-ssl-cache-contextp/private-timeout)

pub inline fun mbedtls-ssl-cache-contextcb/private-timeout(^s: mbedtls-ssl-cache-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-contextp/private-timeout)

pub inline extern mbedtls-ssl-cache-context-ptrraw/set-private-timeout(s: intptr_t, private-timeout: int32): ()
  c inline "((struct mbedtls_ssl_cache_context*)#1)->private_timeout = (int)#2"

pub inline fun mbedtls-ssl-cache-contextp/set-private-timeout(s: mbedtls-ssl-cache-contextp, private-timeout: int): ()
  s.mbedtls-ssl-cache-context-ptrraw/set-private-timeout(private-timeout.int32)

pub inline fun mbedtls-ssl-cache-contextc/set-private-timeout(^s: mbedtls-ssl-cache-contextc, private-timeout: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-contextp/set-private-timeout(private-timeout))

pub inline fun mbedtls-ssl-cache-contextcb/set-private-timeout(^s: mbedtls-ssl-cache-contextcb<s::S>, private-timeout: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-contextp/set-private-timeout(private-timeout))

pub inline extern mbedtls-ssl-cache-context-ptrraw/private-max-entries(s: intptr_t): int32
  c inline "(int)(((struct mbedtls_ssl_cache_context*)#1)->private_max_entries)"

pub inline fun mbedtls-ssl-cache-contextp/private-max-entries(s: mbedtls-ssl-cache-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-context-ptrraw/private-max-entries.int

pub inline fun mbedtls-ssl-cache-contextc/private-max-entries(^s: mbedtls-ssl-cache-contextc): <> int
  s.with-ptr(mbedtls-ssl-cache-contextp/private-max-entries)

pub inline fun mbedtls-ssl-cache-contextcb/private-max-entries(^s: mbedtls-ssl-cache-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-contextp/private-max-entries)

pub inline extern mbedtls-ssl-cache-context-ptrraw/set-private-max-entries(s: intptr_t, private-max-entries: int32): ()
  c inline "((struct mbedtls_ssl_cache_context*)#1)->private_max_entries = (int)#2"

pub inline fun mbedtls-ssl-cache-contextp/set-private-max-entries(s: mbedtls-ssl-cache-contextp, private-max-entries: int): ()
  s.mbedtls-ssl-cache-context-ptrraw/set-private-max-entries(private-max-entries.int32)

pub inline fun mbedtls-ssl-cache-contextc/set-private-max-entries(^s: mbedtls-ssl-cache-contextc, private-max-entries: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-contextp/set-private-max-entries(private-max-entries))

pub inline fun mbedtls-ssl-cache-contextcb/set-private-max-entries(^s: mbedtls-ssl-cache-contextcb<s::S>, private-max-entries: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-contextp/set-private-max-entries(private-max-entries))

// \brief   This structure is used for storing cache entries
pub struct mbedtls-ssl-cache-entry
pub type mbedtls-ssl-cache-entry-c
pub alias mbedtls-ssl-cache-entryp = c-pointer<mbedtls-ssl-cache-entry-c>
pub alias mbedtls-ssl-cache-entryc<s::S> = owned-c<mbedtls-ssl-cache-entry-c>
pub alias mbedtls-ssl-cache-entrycb<s::S> = borrowed-c<s,mbedtls-ssl-cache-entry-c>
pub alias mbedtls-ssl-cache-entryca<s::S> = owned-c<c-array<mbedtls-ssl-cache-entry-c>>

pub extern mbedtls-ssl-cache-entry/size-of(c: c-null<mbedtls-ssl-cache-entry-c>): int32
  c inline "sizeof(struct mbedtls_ssl_cache_entry)"

pub fun mbedtls-ssl-cache-entryc(): mbedtls-ssl-cache-entryc<s::S>
  malloc(?size-of=mbedtls-ssl-cache-entry/size-of)

pub fun mbedtls-ssl-cache-entryc-calloc(): mbedtls-ssl-cache-entryc<s::S>
  malloc-c(?size-of=mbedtls-ssl-cache-entry/size-of)

pub fun mbedtls-ssl-cache-entryc-array(n: int): mbedtls-ssl-cache-entryca<s::S>
  malloc(n.int32, ?size-of=mbedtls-ssl-cache-entry/size-of)

pub fun mbedtls-ssl-cache-entryc-array-calloc(n: int): mbedtls-ssl-cache-entryca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-ssl-cache-entry/size-of)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/private-timestamp(s: intptr_t): int64
  c inline "(mbedtls_time_t)(((struct mbedtls_ssl_cache_entry*)#1)->private_timestamp)"

pub inline fun mbedtls-ssl-cache-entryp/private-timestamp(s: mbedtls-ssl-cache-entryp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-entry-ptrraw/private-timestamp.int

pub inline fun mbedtls-ssl-cache-entryc/private-timestamp(^s: mbedtls-ssl-cache-entryc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-entryp/private-timestamp)

pub inline fun mbedtls-ssl-cache-entrycb/private-timestamp(^s: mbedtls-ssl-cache-entrycb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-entryp/private-timestamp)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/set-private-timestamp(s: intptr_t, private-timestamp: int64): ()
  c inline "((struct mbedtls_ssl_cache_entry*)#1)->private_timestamp = (mbedtls_time_t)#2"

pub inline fun mbedtls-ssl-cache-entryp/set-private-timestamp(s: mbedtls-ssl-cache-entryp, private-timestamp: int): ()
  s.mbedtls-ssl-cache-entry-ptrraw/set-private-timestamp(private-timestamp.int64)

pub inline fun mbedtls-ssl-cache-entryc/set-private-timestamp(^s: mbedtls-ssl-cache-entryc<s::S>, private-timestamp: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-timestamp(private-timestamp))

pub inline fun mbedtls-ssl-cache-entrycb/set-private-timestamp(^s: mbedtls-ssl-cache-entrycb<s::S>, private-timestamp: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-timestamp(private-timestamp))

pub inline extern mbedtls-ssl-cache-entry-ptrraw/private-session-id(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_cache_entry*)#1)->private_session_id)"

pub inline fun mbedtls-ssl-cache-entryp/private-session-id(s: mbedtls-ssl-cache-entryp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-entry-ptrraw/private-session-id.cextern/ptr/carray

pub inline fun mbedtls-ssl-cache-entryc/private-session-id(^s: mbedtls-ssl-cache-entryc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session-id)

pub inline fun mbedtls-ssl-cache-entrycb/private-session-id(^s: mbedtls-ssl-cache-entrycb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session-id)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/set-private-session-id(s: intptr_t, private-session-id: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_cache_entry*)#1)->private_session_id = (unsigned char*)#2"

pub inline fun mbedtls-ssl-cache-entryp/set-private-session-id(s: mbedtls-ssl-cache-entryp, private-session-id: c-array<int>): ()
  s.mbedtls-ssl-cache-entry-ptrraw/set-private-session-id(private-session-id.cextern/carray/ptr)

pub inline fun mbedtls-ssl-cache-entryc/set-private-session-id(^s: mbedtls-ssl-cache-entryc<s::S>, private-session-id: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session-id(private-session-id))

pub inline fun mbedtls-ssl-cache-entrycb/set-private-session-id(^s: mbedtls-ssl-cache-entrycb<s::S>, private-session-id: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session-id(private-session-id))

pub inline extern mbedtls-ssl-cache-entry-ptrraw/private-session-id-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_cache_entry*)#1)->private_session_id_len)"

pub inline fun mbedtls-ssl-cache-entryp/private-session-id-len(s: mbedtls-ssl-cache-entryp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-entry-ptrraw/private-session-id-len.int

pub inline fun mbedtls-ssl-cache-entryc/private-session-id-len(^s: mbedtls-ssl-cache-entryc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session-id-len)

pub inline fun mbedtls-ssl-cache-entrycb/private-session-id-len(^s: mbedtls-ssl-cache-entrycb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session-id-len)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/set-private-session-id-len(s: intptr_t, private-session-id-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_cache_entry*)#1)->private_session_id_len = (size_t)#2"

pub inline fun mbedtls-ssl-cache-entryp/set-private-session-id-len(s: mbedtls-ssl-cache-entryp, private-session-id-len: int): ()
  s.mbedtls-ssl-cache-entry-ptrraw/set-private-session-id-len(private-session-id-len.ssize_t)

pub inline fun mbedtls-ssl-cache-entryc/set-private-session-id-len(^s: mbedtls-ssl-cache-entryc<s::S>, private-session-id-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session-id-len(private-session-id-len))

pub inline fun mbedtls-ssl-cache-entrycb/set-private-session-id-len(^s: mbedtls-ssl-cache-entrycb<s::S>, private-session-id-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session-id-len(private-session-id-len))

pub inline extern mbedtls-ssl-cache-entry-ptrraw/private-session(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((struct mbedtls_ssl_cache_entry*)#1)->private_session)"

pub inline fun mbedtls-ssl-cache-entryp/private-session(s: mbedtls-ssl-cache-entryp): <> c-pointer<int>
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-entry-ptrraw/private-session

pub inline fun mbedtls-ssl-cache-entryc/private-session(^s: mbedtls-ssl-cache-entryc<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session)

pub inline fun mbedtls-ssl-cache-entrycb/private-session(^s: mbedtls-ssl-cache-entrycb<s::S>): <> c-pointer<int>
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/set-private-session(s: intptr_t, private-session: c-pointer<int>): ()
  c inline "((struct mbedtls_ssl_cache_entry*)#1)->private_session = (unsigned char*)#2"

pub inline fun mbedtls-ssl-cache-entryp/set-private-session(s: mbedtls-ssl-cache-entryp, private-session: c-pointer<int>): ()
  s.mbedtls-ssl-cache-entry-ptrraw/set-private-session(private-session)

pub inline fun mbedtls-ssl-cache-entryc/set-private-session(^s: mbedtls-ssl-cache-entryc<s::S>, private-session: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session(private-session))

pub inline fun mbedtls-ssl-cache-entrycb/set-private-session(^s: mbedtls-ssl-cache-entrycb<s::S>, private-session: c-pointer<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session(private-session))

pub inline extern mbedtls-ssl-cache-entry-ptrraw/private-session-len(s: intptr_t): ssize_t
  c inline "(size_t)(((struct mbedtls_ssl_cache_entry*)#1)->private_session_len)"

pub inline fun mbedtls-ssl-cache-entryp/private-session-len(s: mbedtls-ssl-cache-entryp): <> int
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-entry-ptrraw/private-session-len.int

pub inline fun mbedtls-ssl-cache-entryc/private-session-len(^s: mbedtls-ssl-cache-entryc<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session-len)

pub inline fun mbedtls-ssl-cache-entrycb/private-session-len(^s: mbedtls-ssl-cache-entrycb<s::S>): <> int
  s.with-ptr(mbedtls-ssl-cache-entryp/private-session-len)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/set-private-session-len(s: intptr_t, private-session-len: ssize_t): ()
  c inline "((struct mbedtls_ssl_cache_entry*)#1)->private_session_len = (size_t)#2"

pub inline fun mbedtls-ssl-cache-entryp/set-private-session-len(s: mbedtls-ssl-cache-entryp, private-session-len: int): ()
  s.mbedtls-ssl-cache-entry-ptrraw/set-private-session-len(private-session-len.ssize_t)

pub inline fun mbedtls-ssl-cache-entryc/set-private-session-len(^s: mbedtls-ssl-cache-entryc<s::S>, private-session-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session-len(private-session-len))

pub inline fun mbedtls-ssl-cache-entrycb/set-private-session-len(^s: mbedtls-ssl-cache-entrycb<s::S>, private-session-len: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-session-len(private-session-len))

pub inline extern mbedtls-ssl-cache-entry-ptrraw/private-next(s: intptr_t): c-pointer<mbedtls-ssl-cache-entry-c>
  c inline "(intptr_t)(((struct mbedtls_ssl_cache_entry*)#1)->private_next)"

pub inline fun mbedtls-ssl-cache-entryp/private-next(s: mbedtls-ssl-cache-entryp): <> c-pointer<mbedtls-ssl-cache-entry-c>
  s.cextern/c-pointer/ptr.mbedtls-ssl-cache-entry-ptrraw/private-next

pub inline fun mbedtls-ssl-cache-entryc/private-next(^s: mbedtls-ssl-cache-entryc<s::S>): <> c-pointer<mbedtls-ssl-cache-entry-c>
  s.with-ptr(mbedtls-ssl-cache-entryp/private-next)

pub inline fun mbedtls-ssl-cache-entrycb/private-next(^s: mbedtls-ssl-cache-entrycb<s::S>): <> c-pointer<mbedtls-ssl-cache-entry-c>
  s.with-ptr(mbedtls-ssl-cache-entryp/private-next)

pub inline extern mbedtls-ssl-cache-entry-ptrraw/set-private-next(s: intptr_t, private-next: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  c inline "((struct mbedtls_ssl_cache_entry*)#1)->private_next = (struct mbedtls_ssl_cache_entry*)#2"

pub inline fun mbedtls-ssl-cache-entryp/set-private-next(s: mbedtls-ssl-cache-entryp, private-next: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  s.mbedtls-ssl-cache-entry-ptrraw/set-private-next(private-next)

pub inline fun mbedtls-ssl-cache-entryc/set-private-next(^s: mbedtls-ssl-cache-entryc<s::S>, private-next: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-next(private-next))

pub inline fun mbedtls-ssl-cache-entrycb/set-private-next(^s: mbedtls-ssl-cache-entrycb<s::S>, private-next: c-pointer<mbedtls-ssl-cache-entry-c>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-ssl-cache-entryp/set-private-next(private-next))

// \brief   The platform context structure.
// 
// \note    This structure may be used to assist platform-specific
// setup or teardown operations.
pub value struct mbedtls-platform-context
  // < A placeholder member, as empty structs are not portable.
  private-dummy: int

pub type mbedtls-platform-context-c
pub alias mbedtls-platform-contextp = c-pointer<mbedtls-platform-context-c>
pub alias mbedtls-platform-contextc = owned-c<mbedtls-platform-context-c>
pub alias mbedtls-platform-contextcb<s::S> = borrowed-c<s,mbedtls-platform-context-c>
pub alias mbedtls-platform-contextca = owned-c<c-array<mbedtls-platform-context-c>>

pub extern mbedtls-platform-context/size-of(c: c-null<mbedtls-platform-context-c>): int32
  c inline "sizeof(struct mbedtls_platform_context)"

pub fun mbedtls-platform-contextc(): mbedtls-platform-contextc
  malloc(?size-of=mbedtls-platform-context/size-of)

pub fun mbedtls-platform-contextc-calloc(): mbedtls-platform-contextc
  malloc-c(?size-of=mbedtls-platform-context/size-of)

pub fun mbedtls-platform-contextc-array(n: int): mbedtls-platform-contextca
  malloc(n.int32, ?size-of=mbedtls-platform-context/size-of)

pub fun mbedtls-platform-contextc-array-calloc(n: int): mbedtls-platform-contextca
  malloc-c(n.int32, ?size-of=mbedtls-platform-context/size-of)

pub inline extern mbedtls-platform-context-ptrraw/private-dummy(s: intptr_t): int8
  c inline "(char)(((struct mbedtls_platform_context*)#1)->private_dummy)"

pub inline fun mbedtls-platform-contextp/private-dummy(s: mbedtls-platform-contextp): <> int
  s.cextern/c-pointer/ptr.mbedtls-platform-context-ptrraw/private-dummy.int

pub inline fun mbedtls-platform-contextc/private-dummy(^s: mbedtls-platform-contextc): <> int
  s.with-ptr(mbedtls-platform-contextp/private-dummy)

pub inline fun mbedtls-platform-contextcb/private-dummy(^s: mbedtls-platform-contextcb<s::S>): <> int
  s.with-ptr(mbedtls-platform-contextp/private-dummy)

pub inline extern mbedtls-platform-context-ptrraw/set-private-dummy(s: intptr_t, private-dummy: int8): ()
  c inline "((struct mbedtls_platform_context*)#1)->private_dummy = (char)#2"

pub inline fun mbedtls-platform-contextp/set-private-dummy(s: mbedtls-platform-contextp, private-dummy: int): ()
  s.mbedtls-platform-context-ptrraw/set-private-dummy(private-dummy.int8)

pub inline fun mbedtls-platform-contextc/set-private-dummy(^s: mbedtls-platform-contextc, private-dummy: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-platform-contextp/set-private-dummy(private-dummy))

pub inline fun mbedtls-platform-contextcb/set-private-dummy(^s: mbedtls-platform-contextcb<s::S>, private-dummy: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-platform-contextp/set-private-dummy(private-dummy))

// The Identifier of the LMS parameter set, as per
// https://www.iana.org/assignments/leighton-micali-signatures/leighton-micali-signatures.xhtml
// We are only implementing a subset of the types, particularly H10, for the sake of simplicity.
type mbedtls-lms-algorithm-type-t
  MBEDTLS_LMS_SHA256_M32_H10

pub fun mbedtls-lms-algorithm-type-t/int(i: mbedtls-lms-algorithm-type-t): int32
  match i
    MBEDTLS_LMS_SHA256_M32_H10 -> 6.int32

pub fun int/mbedtls-lms-algorithm-type-t(i: int32): exn mbedtls-lms-algorithm-type-t
  match i.int
    6 -> MBEDTLS_LMS_SHA256_M32_H10

// The Identifier of the LMOTS parameter set, as per
// https://www.iana.org/assignments/leighton-micali-signatures/leighton-micali-signatures.xhtml.
// We are only implementing a subset of the types, particularly N32_W8, for the sake of simplicity.
type mbedtls-lmots-algorithm-type-t
  MBEDTLS_LMOTS_SHA256_N32_W8

pub fun mbedtls-lmots-algorithm-type-t/int(i: mbedtls-lmots-algorithm-type-t): int32
  match i
    MBEDTLS_LMOTS_SHA256_N32_W8 -> 4.int32

pub fun int/mbedtls-lmots-algorithm-type-t(i: int32): exn mbedtls-lmots-algorithm-type-t
  match i.int
    4 -> MBEDTLS_LMOTS_SHA256_N32_W8

// LMOTS parameters structure.
// 
// This contains the metadata associated with an LMOTS key, detailing the
// algorithm type, the key ID, and the leaf identifier should be key be part of
// a LMS key.
pub struct mbedtls-lmots-parameters-t
pub type mbedtls-lmots-parameters-t-c
pub alias mbedtls-lmots-parameters-tp = c-pointer<mbedtls-lmots-parameters-t-c>
pub alias mbedtls-lmots-parameters-tc<s::S> = owned-c<mbedtls-lmots-parameters-t-c>
pub alias mbedtls-lmots-parameters-tcb<s::S> = borrowed-c<s,mbedtls-lmots-parameters-t-c>
pub alias mbedtls-lmots-parameters-tca<s::S> = owned-c<c-array<mbedtls-lmots-parameters-t-c>>

pub extern mbedtls-lmots-parameters-t/size-of(c: c-null<mbedtls-lmots-parameters-t-c>): int32
  c inline "sizeof(mbedtls_lmots_parameters_t)"

pub fun mbedtls-lmots-parameters-tc(): mbedtls-lmots-parameters-tc<s::S>
  malloc(?size-of=mbedtls-lmots-parameters-t/size-of)

pub fun mbedtls-lmots-parameters-tc-calloc(): mbedtls-lmots-parameters-tc<s::S>
  malloc-c(?size-of=mbedtls-lmots-parameters-t/size-of)

pub fun mbedtls-lmots-parameters-tc-array(n: int): mbedtls-lmots-parameters-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-lmots-parameters-t/size-of)

pub fun mbedtls-lmots-parameters-tc-array-calloc(n: int): mbedtls-lmots-parameters-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-lmots-parameters-t/size-of)

pub inline extern mbedtls-lmots-parameters-t-ptrraw/private-i-key-identifier(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_lmots_parameters_t*)#1)->private_I_key_identifier)"

pub inline fun mbedtls-lmots-parameters-tp/private-i-key-identifier(s: mbedtls-lmots-parameters-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-lmots-parameters-t-ptrraw/private-i-key-identifier.cextern/ptr/carray

pub inline fun mbedtls-lmots-parameters-tc/private-i-key-identifier(^s: mbedtls-lmots-parameters-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lmots-parameters-tp/private-i-key-identifier)

pub inline fun mbedtls-lmots-parameters-tcb/private-i-key-identifier(^s: mbedtls-lmots-parameters-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lmots-parameters-tp/private-i-key-identifier)

pub inline extern mbedtls-lmots-parameters-t-ptrraw/set-private-i-key-identifier(s: intptr_t, private-i-key-identifier: c-pointer<int>): ()
  c inline "((mbedtls_lmots_parameters_t*)#1)->private_I_key_identifier = (unsigned char*)#2"

pub inline fun mbedtls-lmots-parameters-tp/set-private-i-key-identifier(s: mbedtls-lmots-parameters-tp, private-i-key-identifier: c-array<int>): ()
  s.mbedtls-lmots-parameters-t-ptrraw/set-private-i-key-identifier(private-i-key-identifier.cextern/carray/ptr)

pub inline fun mbedtls-lmots-parameters-tc/set-private-i-key-identifier(^s: mbedtls-lmots-parameters-tc<s::S>, private-i-key-identifier: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-parameters-tp/set-private-i-key-identifier(private-i-key-identifier))

pub inline fun mbedtls-lmots-parameters-tcb/set-private-i-key-identifier(^s: mbedtls-lmots-parameters-tcb<s::S>, private-i-key-identifier: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-parameters-tp/set-private-i-key-identifier(private-i-key-identifier))

pub inline extern mbedtls-lmots-parameters-t-ptrraw/private-q-leaf-identifier(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_lmots_parameters_t*)#1)->private_q_leaf_identifier)"

pub inline fun mbedtls-lmots-parameters-tp/private-q-leaf-identifier(s: mbedtls-lmots-parameters-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-lmots-parameters-t-ptrraw/private-q-leaf-identifier.cextern/ptr/carray

pub inline fun mbedtls-lmots-parameters-tc/private-q-leaf-identifier(^s: mbedtls-lmots-parameters-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lmots-parameters-tp/private-q-leaf-identifier)

pub inline fun mbedtls-lmots-parameters-tcb/private-q-leaf-identifier(^s: mbedtls-lmots-parameters-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lmots-parameters-tp/private-q-leaf-identifier)

pub inline extern mbedtls-lmots-parameters-t-ptrraw/set-private-q-leaf-identifier(s: intptr_t, private-q-leaf-identifier: c-pointer<int>): ()
  c inline "((mbedtls_lmots_parameters_t*)#1)->private_q_leaf_identifier = (unsigned char*)#2"

pub inline fun mbedtls-lmots-parameters-tp/set-private-q-leaf-identifier(s: mbedtls-lmots-parameters-tp, private-q-leaf-identifier: c-array<int>): ()
  s.mbedtls-lmots-parameters-t-ptrraw/set-private-q-leaf-identifier(private-q-leaf-identifier.cextern/carray/ptr)

pub inline fun mbedtls-lmots-parameters-tc/set-private-q-leaf-identifier(^s: mbedtls-lmots-parameters-tc<s::S>, private-q-leaf-identifier: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-parameters-tp/set-private-q-leaf-identifier(private-q-leaf-identifier))

pub inline fun mbedtls-lmots-parameters-tcb/set-private-q-leaf-identifier(^s: mbedtls-lmots-parameters-tcb<s::S>, private-q-leaf-identifier: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-parameters-tp/set-private-q-leaf-identifier(private-q-leaf-identifier))

pub inline extern mbedtls-lmots-parameters-t-ptrraw/private-type(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_lmots_parameters_t*)#1)->private_type)"

pub inline fun mbedtls-lmots-parameters-tp/private-type(s: mbedtls-lmots-parameters-tp): <exn> mbedtls-lmots-algorithm-type-t
  s.cextern/c-pointer/ptr.mbedtls-lmots-parameters-t-ptrraw/private-type.int/mbedtls-lmots-algorithm-type-t

pub inline fun mbedtls-lmots-parameters-tc/private-type(^s: mbedtls-lmots-parameters-tc<s::S>): <exn> mbedtls-lmots-algorithm-type-t
  s.with-ptr(mbedtls-lmots-parameters-tp/private-type)

pub inline fun mbedtls-lmots-parameters-tcb/private-type(^s: mbedtls-lmots-parameters-tcb<s::S>): <exn> mbedtls-lmots-algorithm-type-t
  s.with-ptr(mbedtls-lmots-parameters-tp/private-type)

pub inline extern mbedtls-lmots-parameters-t-ptrraw/set-private-type(s: intptr_t, private-type: int32): ()
  c inline "((mbedtls_lmots_parameters_t*)#1)->private_type = (int32_t)#2"

pub inline fun mbedtls-lmots-parameters-tp/set-private-type(s: mbedtls-lmots-parameters-tp, private-type: mbedtls-lmots-algorithm-type-t): ()
  s.mbedtls-lmots-parameters-t-ptrraw/set-private-type(private-type.mbedtls-lmots-algorithm-type-t/int)

pub inline fun mbedtls-lmots-parameters-tc/set-private-type(^s: mbedtls-lmots-parameters-tc<s::S>, private-type: mbedtls-lmots-algorithm-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-parameters-tp/set-private-type(private-type))

pub inline fun mbedtls-lmots-parameters-tcb/set-private-type(^s: mbedtls-lmots-parameters-tcb<s::S>, private-type: mbedtls-lmots-algorithm-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-parameters-tp/set-private-type(private-type))

// LMOTS public context structure.
// 
// A LMOTS public key is a hash output, and the applicable parameter set.
// 
// The context must be initialized before it is used. A public key must either
// be imported or generated from a private context.
// 
// \dot
// digraph lmots_public_t {
// UNINITIALIZED -> INIT [label="init"];
// HAVE_PUBLIC_KEY -> INIT [label="free"];
// INIT -> HAVE_PUBLIC_KEY [label="import_public_key"];
// INIT -> HAVE_PUBLIC_KEY [label="calculate_public_key from private key"];
// HAVE_PUBLIC_KEY -> HAVE_PUBLIC_KEY [label="export_public_key"];
// }
// \enddot
pub struct mbedtls-lmots-public-t
pub type mbedtls-lmots-public-t-c
pub alias mbedtls-lmots-public-tp = c-pointer<mbedtls-lmots-public-t-c>
pub alias mbedtls-lmots-public-tc<s::S> = owned-c<mbedtls-lmots-public-t-c>
pub alias mbedtls-lmots-public-tcb<s::S> = borrowed-c<s,mbedtls-lmots-public-t-c>
pub alias mbedtls-lmots-public-tca<s::S> = owned-c<c-array<mbedtls-lmots-public-t-c>>

pub extern mbedtls-lmots-public-t/size-of(c: c-null<mbedtls-lmots-public-t-c>): int32
  c inline "sizeof(mbedtls_lmots_public_t)"

pub fun mbedtls-lmots-public-tc(): mbedtls-lmots-public-tc<s::S>
  malloc(?size-of=mbedtls-lmots-public-t/size-of)

pub fun mbedtls-lmots-public-tc-calloc(): mbedtls-lmots-public-tc<s::S>
  malloc-c(?size-of=mbedtls-lmots-public-t/size-of)

pub fun mbedtls-lmots-public-tc-array(n: int): mbedtls-lmots-public-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-lmots-public-t/size-of)

pub fun mbedtls-lmots-public-tc-array-calloc(n: int): mbedtls-lmots-public-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-lmots-public-t/size-of)

pub inline extern mbedtls-lmots-public-t-ptrraw/private-public-key(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_lmots_public_t*)#1)->private_public_key)"

pub inline fun mbedtls-lmots-public-tp/private-public-key(s: mbedtls-lmots-public-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-lmots-public-t-ptrraw/private-public-key.cextern/ptr/carray

pub inline fun mbedtls-lmots-public-tc/private-public-key(^s: mbedtls-lmots-public-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lmots-public-tp/private-public-key)

pub inline fun mbedtls-lmots-public-tcb/private-public-key(^s: mbedtls-lmots-public-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lmots-public-tp/private-public-key)

pub inline extern mbedtls-lmots-public-t-ptrraw/set-private-public-key(s: intptr_t, private-public-key: c-pointer<int>): ()
  c inline "((mbedtls_lmots_public_t*)#1)->private_public_key = (unsigned char*)#2"

pub inline fun mbedtls-lmots-public-tp/set-private-public-key(s: mbedtls-lmots-public-tp, private-public-key: c-array<int>): ()
  s.mbedtls-lmots-public-t-ptrraw/set-private-public-key(private-public-key.cextern/carray/ptr)

pub inline fun mbedtls-lmots-public-tc/set-private-public-key(^s: mbedtls-lmots-public-tc<s::S>, private-public-key: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-public-tp/set-private-public-key(private-public-key))

pub inline fun mbedtls-lmots-public-tcb/set-private-public-key(^s: mbedtls-lmots-public-tcb<s::S>, private-public-key: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-public-tp/set-private-public-key(private-public-key))

pub inline extern mbedtls-lmots-public-t-ptrraw/private-have-public-key(s: intptr_t): int8
  c inline "(unsigned char)(((mbedtls_lmots_public_t*)#1)->private_have_public_key)"

pub inline fun mbedtls-lmots-public-tp/private-have-public-key(s: mbedtls-lmots-public-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-lmots-public-t-ptrraw/private-have-public-key.int

pub inline fun mbedtls-lmots-public-tc/private-have-public-key(^s: mbedtls-lmots-public-tc<s::S>): <> int
  s.with-ptr(mbedtls-lmots-public-tp/private-have-public-key)

pub inline fun mbedtls-lmots-public-tcb/private-have-public-key(^s: mbedtls-lmots-public-tcb<s::S>): <> int
  s.with-ptr(mbedtls-lmots-public-tp/private-have-public-key)

pub inline extern mbedtls-lmots-public-t-ptrraw/set-private-have-public-key(s: intptr_t, private-have-public-key: int8): ()
  c inline "((mbedtls_lmots_public_t*)#1)->private_have_public_key = (unsigned char)#2"

pub inline fun mbedtls-lmots-public-tp/set-private-have-public-key(s: mbedtls-lmots-public-tp, private-have-public-key: int): ()
  s.mbedtls-lmots-public-t-ptrraw/set-private-have-public-key(private-have-public-key.int8)

pub inline fun mbedtls-lmots-public-tc/set-private-have-public-key(^s: mbedtls-lmots-public-tc<s::S>, private-have-public-key: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-public-tp/set-private-have-public-key(private-have-public-key))

pub inline fun mbedtls-lmots-public-tcb/set-private-have-public-key(^s: mbedtls-lmots-public-tcb<s::S>, private-have-public-key: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lmots-public-tp/set-private-have-public-key(private-have-public-key))

// LMS parameters structure.
// 
// This contains the metadata associated with an LMS key, detailing the
// algorithm type, the type of the underlying OTS algorithm, and the key ID.
pub struct mbedtls-lms-parameters-t
pub type mbedtls-lms-parameters-t-c
pub alias mbedtls-lms-parameters-tp = c-pointer<mbedtls-lms-parameters-t-c>
pub alias mbedtls-lms-parameters-tc<s::S> = owned-c<mbedtls-lms-parameters-t-c>
pub alias mbedtls-lms-parameters-tcb<s::S> = borrowed-c<s,mbedtls-lms-parameters-t-c>
pub alias mbedtls-lms-parameters-tca<s::S> = owned-c<c-array<mbedtls-lms-parameters-t-c>>

pub extern mbedtls-lms-parameters-t/size-of(c: c-null<mbedtls-lms-parameters-t-c>): int32
  c inline "sizeof(mbedtls_lms_parameters_t)"

pub fun mbedtls-lms-parameters-tc(): mbedtls-lms-parameters-tc<s::S>
  malloc(?size-of=mbedtls-lms-parameters-t/size-of)

pub fun mbedtls-lms-parameters-tc-calloc(): mbedtls-lms-parameters-tc<s::S>
  malloc-c(?size-of=mbedtls-lms-parameters-t/size-of)

pub fun mbedtls-lms-parameters-tc-array(n: int): mbedtls-lms-parameters-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-lms-parameters-t/size-of)

pub fun mbedtls-lms-parameters-tc-array-calloc(n: int): mbedtls-lms-parameters-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-lms-parameters-t/size-of)

pub inline extern mbedtls-lms-parameters-t-ptrraw/private-i-key-identifier(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_lms_parameters_t*)#1)->private_I_key_identifier)"

pub inline fun mbedtls-lms-parameters-tp/private-i-key-identifier(s: mbedtls-lms-parameters-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-lms-parameters-t-ptrraw/private-i-key-identifier.cextern/ptr/carray

pub inline fun mbedtls-lms-parameters-tc/private-i-key-identifier(^s: mbedtls-lms-parameters-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lms-parameters-tp/private-i-key-identifier)

pub inline fun mbedtls-lms-parameters-tcb/private-i-key-identifier(^s: mbedtls-lms-parameters-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lms-parameters-tp/private-i-key-identifier)

pub inline extern mbedtls-lms-parameters-t-ptrraw/set-private-i-key-identifier(s: intptr_t, private-i-key-identifier: c-pointer<int>): ()
  c inline "((mbedtls_lms_parameters_t*)#1)->private_I_key_identifier = (unsigned char*)#2"

pub inline fun mbedtls-lms-parameters-tp/set-private-i-key-identifier(s: mbedtls-lms-parameters-tp, private-i-key-identifier: c-array<int>): ()
  s.mbedtls-lms-parameters-t-ptrraw/set-private-i-key-identifier(private-i-key-identifier.cextern/carray/ptr)

pub inline fun mbedtls-lms-parameters-tc/set-private-i-key-identifier(^s: mbedtls-lms-parameters-tc<s::S>, private-i-key-identifier: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-parameters-tp/set-private-i-key-identifier(private-i-key-identifier))

pub inline fun mbedtls-lms-parameters-tcb/set-private-i-key-identifier(^s: mbedtls-lms-parameters-tcb<s::S>, private-i-key-identifier: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-parameters-tp/set-private-i-key-identifier(private-i-key-identifier))

pub inline extern mbedtls-lms-parameters-t-ptrraw/private-otstype(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_lms_parameters_t*)#1)->private_otstype)"

pub inline fun mbedtls-lms-parameters-tp/private-otstype(s: mbedtls-lms-parameters-tp): <exn> mbedtls-lmots-algorithm-type-t
  s.cextern/c-pointer/ptr.mbedtls-lms-parameters-t-ptrraw/private-otstype.int/mbedtls-lmots-algorithm-type-t

pub inline fun mbedtls-lms-parameters-tc/private-otstype(^s: mbedtls-lms-parameters-tc<s::S>): <exn> mbedtls-lmots-algorithm-type-t
  s.with-ptr(mbedtls-lms-parameters-tp/private-otstype)

pub inline fun mbedtls-lms-parameters-tcb/private-otstype(^s: mbedtls-lms-parameters-tcb<s::S>): <exn> mbedtls-lmots-algorithm-type-t
  s.with-ptr(mbedtls-lms-parameters-tp/private-otstype)

pub inline extern mbedtls-lms-parameters-t-ptrraw/set-private-otstype(s: intptr_t, private-otstype: int32): ()
  c inline "((mbedtls_lms_parameters_t*)#1)->private_otstype = (int32_t)#2"

pub inline fun mbedtls-lms-parameters-tp/set-private-otstype(s: mbedtls-lms-parameters-tp, private-otstype: mbedtls-lmots-algorithm-type-t): ()
  s.mbedtls-lms-parameters-t-ptrraw/set-private-otstype(private-otstype.mbedtls-lmots-algorithm-type-t/int)

pub inline fun mbedtls-lms-parameters-tc/set-private-otstype(^s: mbedtls-lms-parameters-tc<s::S>, private-otstype: mbedtls-lmots-algorithm-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-parameters-tp/set-private-otstype(private-otstype))

pub inline fun mbedtls-lms-parameters-tcb/set-private-otstype(^s: mbedtls-lms-parameters-tcb<s::S>, private-otstype: mbedtls-lmots-algorithm-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-parameters-tp/set-private-otstype(private-otstype))

pub inline extern mbedtls-lms-parameters-t-ptrraw/private-type(s: intptr_t): int32
  c inline "(int32_t)(((mbedtls_lms_parameters_t*)#1)->private_type)"

pub inline fun mbedtls-lms-parameters-tp/private-type(s: mbedtls-lms-parameters-tp): <exn> mbedtls-lms-algorithm-type-t
  s.cextern/c-pointer/ptr.mbedtls-lms-parameters-t-ptrraw/private-type.int/mbedtls-lms-algorithm-type-t

pub inline fun mbedtls-lms-parameters-tc/private-type(^s: mbedtls-lms-parameters-tc<s::S>): <exn> mbedtls-lms-algorithm-type-t
  s.with-ptr(mbedtls-lms-parameters-tp/private-type)

pub inline fun mbedtls-lms-parameters-tcb/private-type(^s: mbedtls-lms-parameters-tcb<s::S>): <exn> mbedtls-lms-algorithm-type-t
  s.with-ptr(mbedtls-lms-parameters-tp/private-type)

pub inline extern mbedtls-lms-parameters-t-ptrraw/set-private-type(s: intptr_t, private-type: int32): ()
  c inline "((mbedtls_lms_parameters_t*)#1)->private_type = (int32_t)#2"

pub inline fun mbedtls-lms-parameters-tp/set-private-type(s: mbedtls-lms-parameters-tp, private-type: mbedtls-lms-algorithm-type-t): ()
  s.mbedtls-lms-parameters-t-ptrraw/set-private-type(private-type.mbedtls-lms-algorithm-type-t/int)

pub inline fun mbedtls-lms-parameters-tc/set-private-type(^s: mbedtls-lms-parameters-tc<s::S>, private-type: mbedtls-lms-algorithm-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-parameters-tp/set-private-type(private-type))

pub inline fun mbedtls-lms-parameters-tcb/set-private-type(^s: mbedtls-lms-parameters-tcb<s::S>, private-type: mbedtls-lms-algorithm-type-t): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-parameters-tp/set-private-type(private-type))

// LMS public context structure.
// 
// A LMS public key is the hash output that is the root of the Merkle tree, and
// the applicable parameter set
// 
// The context must be initialized before it is used. A public key must either
// be imported or generated from a private context.
// 
// \dot
// digraph lms_public_t {
// UNINITIALIZED -> INIT [label="init"];
// HAVE_PUBLIC_KEY -> INIT [label="free"];
// INIT -> HAVE_PUBLIC_KEY [label="import_public_key"];
// INIT -> HAVE_PUBLIC_KEY [label="calculate_public_key from private key"];
// HAVE_PUBLIC_KEY -> HAVE_PUBLIC_KEY [label="export_public_key"];
// }
// \enddot
pub struct mbedtls-lms-public-t
pub type mbedtls-lms-public-t-c
pub alias mbedtls-lms-public-tp = c-pointer<mbedtls-lms-public-t-c>
pub alias mbedtls-lms-public-tc<s::S> = owned-c<mbedtls-lms-public-t-c>
pub alias mbedtls-lms-public-tcb<s::S> = borrowed-c<s,mbedtls-lms-public-t-c>
pub alias mbedtls-lms-public-tca<s::S> = owned-c<c-array<mbedtls-lms-public-t-c>>

pub extern mbedtls-lms-public-t/size-of(c: c-null<mbedtls-lms-public-t-c>): int32
  c inline "sizeof(mbedtls_lms_public_t)"

pub fun mbedtls-lms-public-tc(): mbedtls-lms-public-tc<s::S>
  malloc(?size-of=mbedtls-lms-public-t/size-of)

pub fun mbedtls-lms-public-tc-calloc(): mbedtls-lms-public-tc<s::S>
  malloc-c(?size-of=mbedtls-lms-public-t/size-of)

pub fun mbedtls-lms-public-tc-array(n: int): mbedtls-lms-public-tca<s::S>
  malloc(n.int32, ?size-of=mbedtls-lms-public-t/size-of)

pub fun mbedtls-lms-public-tc-array-calloc(n: int): mbedtls-lms-public-tca<s::S>
  malloc-c(n.int32, ?size-of=mbedtls-lms-public-t/size-of)

pub inline extern mbedtls-lms-public-t-ptrraw/private-t-1-pub-key(s: intptr_t): c-pointer<int>
  c inline "(intptr_t)(((mbedtls_lms_public_t*)#1)->private_T_1_pub_key)"

pub inline fun mbedtls-lms-public-tp/private-t-1-pub-key(s: mbedtls-lms-public-tp): <> c-array<int>
  s.cextern/c-pointer/ptr.mbedtls-lms-public-t-ptrraw/private-t-1-pub-key.cextern/ptr/carray

pub inline fun mbedtls-lms-public-tc/private-t-1-pub-key(^s: mbedtls-lms-public-tc<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lms-public-tp/private-t-1-pub-key)

pub inline fun mbedtls-lms-public-tcb/private-t-1-pub-key(^s: mbedtls-lms-public-tcb<s::S>): <> c-array<int>
  s.with-ptr(mbedtls-lms-public-tp/private-t-1-pub-key)

pub inline extern mbedtls-lms-public-t-ptrraw/set-private-t-1-pub-key(s: intptr_t, private-t-1-pub-key: c-pointer<int>): ()
  c inline "((mbedtls_lms_public_t*)#1)->private_T_1_pub_key = (unsigned char*)#2"

pub inline fun mbedtls-lms-public-tp/set-private-t-1-pub-key(s: mbedtls-lms-public-tp, private-t-1-pub-key: c-array<int>): ()
  s.mbedtls-lms-public-t-ptrraw/set-private-t-1-pub-key(private-t-1-pub-key.cextern/carray/ptr)

pub inline fun mbedtls-lms-public-tc/set-private-t-1-pub-key(^s: mbedtls-lms-public-tc<s::S>, private-t-1-pub-key: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-public-tp/set-private-t-1-pub-key(private-t-1-pub-key))

pub inline fun mbedtls-lms-public-tcb/set-private-t-1-pub-key(^s: mbedtls-lms-public-tcb<s::S>, private-t-1-pub-key: c-array<int>): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-public-tp/set-private-t-1-pub-key(private-t-1-pub-key))

pub inline extern mbedtls-lms-public-t-ptrraw/private-have-public-key(s: intptr_t): int8
  c inline "(unsigned char)(((mbedtls_lms_public_t*)#1)->private_have_public_key)"

pub inline fun mbedtls-lms-public-tp/private-have-public-key(s: mbedtls-lms-public-tp): <> int
  s.cextern/c-pointer/ptr.mbedtls-lms-public-t-ptrraw/private-have-public-key.int

pub inline fun mbedtls-lms-public-tc/private-have-public-key(^s: mbedtls-lms-public-tc<s::S>): <> int
  s.with-ptr(mbedtls-lms-public-tp/private-have-public-key)

pub inline fun mbedtls-lms-public-tcb/private-have-public-key(^s: mbedtls-lms-public-tcb<s::S>): <> int
  s.with-ptr(mbedtls-lms-public-tp/private-have-public-key)

pub inline extern mbedtls-lms-public-t-ptrraw/set-private-have-public-key(s: intptr_t, private-have-public-key: int8): ()
  c inline "((mbedtls_lms_public_t*)#1)->private_have_public_key = (unsigned char)#2"

pub inline fun mbedtls-lms-public-tp/set-private-have-public-key(s: mbedtls-lms-public-tp, private-have-public-key: int): ()
  s.mbedtls-lms-public-t-ptrraw/set-private-have-public-key(private-have-public-key.int8)

pub inline fun mbedtls-lms-public-tc/set-private-have-public-key(^s: mbedtls-lms-public-tc<s::S>, private-have-public-key: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-public-tp/set-private-have-public-key(private-have-public-key))

pub inline fun mbedtls-lms-public-tcb/set-private-have-public-key(^s: mbedtls-lms-public-tcb<s::S>, private-have-public-key: int): ()
  s.with-ptr(fn(kk-internal-ptr) kk-internal-ptr.mbedtls-lms-public-tp/set-private-have-public-key(private-have-public-key))

pub val kmbedtls-key-length-none: int = 0

pub val kmbedtls-key-length-des: int = 64

pub val kmbedtls-key-length-des-ede: int = 128

pub val kmbedtls-key-length-des-ede3: int = 192

